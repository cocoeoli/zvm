
zephyr.elf:     file format elf64-littleaarch64


Disassembly of section text:

0000000040000000 <__text_region_start>:
#define HEADER_FLAGS	(HEADER_PGSIZE << 1)

_ASM_FILE_PROLOGUE

SECTION_SUBSEC_FUNC(image_header,_image_header_section,_image_header)
	b	__start				// branch to kernel start
    40000000:	14000431 	b	400010c4 <__reset>
	...
    40000010:	4006fdc8 	.word	0x4006fdc8
    40000014:	00000000 	.word	0x00000000
    40000018:	00000002 	.word	0x00000002
	...
    40000038:	644d5241 	.word	0x644d5241
    4000003c:	00000000 	.word	0x00000000

0000000040000040 <_vector_start>:
	...

0000000040000800 <_vector_table>:
	/* The whole table must be 2K aligned */
	.align 11

	/* Current EL with SP0 / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000800:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000810:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000820:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000830:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000840:	927ff800 8b010000 d51bd060 94002eb9     ........`.......
	b	z_arm64_sync_exc
    40000850:	14002e70 d503201f d503201f d503201f     p.... ... ... ..
    40000860:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000870:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SP0 / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000880:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000890:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    400008a0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    400008b0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    400008c0:	927ff800 8b010000 d51bd060 94002e99     ........`.......
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    400008d0:	1400021e d503201f d503201f d503201f     ..... ... ... ..
    400008e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    400008f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Current EL with SP0 / FIQ */
	.align 7
	b 	.
    40000900:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000910:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000920:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000930:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000940:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000950:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000960:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000970:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SP0 / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000980:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000990:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    400009a0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    400009b0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    400009c0:	927ff800 8b010000 d51bd060 94002e59     ........`...Y...
	b	z_arm64_serror
    400009d0:	14002e3d d503201f d503201f d503201f     =.... ... ... ..
    400009e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    400009f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000a00:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000a10:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000a20:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000a30:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000a40:	927ff800 8b010000 d51bd060 94002e39     ........`...9...
	b	z_arm64_sync_exc
    40000a50:	14002df0 d503201f d503201f d503201f     .-... ... ... ..
    40000a60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000a70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000a80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000a90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000aa0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000ab0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000ac0:	927ff800 8b010000 d51bd060 94002e19     ........`.......
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    40000ad0:	1400019e d503201f d503201f d503201f     ..... ... ... ..
    40000ae0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000af0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Current EL with SPx / FIQ */
	.align 7
	b	.
    40000b00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000b10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000b80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000b90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000ba0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000bb0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000bc0:	927ff800 8b010000 d51bd060 94002dd9     ........`....-..
	b	z_arm64_serror
    40000bd0:	14002dbd d503201f d503201f d503201f     .-... ... ... ..
    40000be0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000bf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000c00:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000c10:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000c20:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000c30:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000c40:	927ff800 8b010000 d51bd060 94002db9     ........`....-..
	b	z_arm64_sync_exc
    40000c50:	14002d70 d503201f d503201f d503201f     p-... ... ... ..
    40000c60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000c70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000c80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000c90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000ca0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000cb0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000cc0:	927ff800 8b010000 d51bd060 94002d99     ........`....-..
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    40000cd0:	1400011e d503201f d503201f d503201f     ..... ... ... ..
    40000ce0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000cf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Lower EL using AArch64 / FIQ */
	.align 7
	b	.
    40000d00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000d10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000d80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000d90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000da0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000db0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000dc0:	927ff800 8b010000 d51bd060 94002d59     ........`...Y-..
	b	z_arm64_serror
    40000dd0:	14002d3d d503201f d503201f d503201f     =-... ... ... ..
    40000de0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000df0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / Synchronous */
	.align 7
	b	.
    40000e00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000e10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / IRQ */
	.align 7
	b	.
    40000e80:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000e90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ea0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000eb0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ec0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ed0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ee0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ef0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / FIQ */
	.align 7
	b	.
    40000f00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000f10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / SError */
	.align 7
	b	.
    40000f80:	14000000                                ....

0000000040000f84 <_vector_end>:
	...

0000000040000f90 <__aarch64_swp8_acq_rel>:
    40000f90:	d503245f 	bti	c
    40000f94:	f00000b0 	adrp	x16, 40017000 <__aarch64_have_lse_atomics>
    40000f98:	39400210 	ldrb	w16, [x16]
    40000f9c:	34000070 	cbz	w16, 40000fa8 <__aarch64_swp8_acq_rel+0x18>
    40000fa0:	f8e08020 	swpal	x0, x0, [x1]
    40000fa4:	d65f03c0 	ret
    40000fa8:	aa0003f0 	mov	x16, x0
    40000fac:	c85ffc20 	ldaxr	x0, [x1]
    40000fb0:	c811fc30 	stlxr	w17, x16, [x1]
    40000fb4:	35ffffd1 	cbnz	w17, 40000fac <__aarch64_swp8_acq_rel+0x1c>
    40000fb8:	d65f03c0 	ret
    40000fbc:	00000000 	udf	#0

0000000040000fc0 <__aarch64_ldadd8_acq_rel>:
    40000fc0:	d503245f 	bti	c
    40000fc4:	f00000b0 	adrp	x16, 40017000 <__aarch64_have_lse_atomics>
    40000fc8:	39400210 	ldrb	w16, [x16]
    40000fcc:	34000070 	cbz	w16, 40000fd8 <__aarch64_ldadd8_acq_rel+0x18>
    40000fd0:	f8e00020 	ldaddal	x0, x0, [x1]
    40000fd4:	d65f03c0 	ret
    40000fd8:	aa0003f0 	mov	x16, x0
    40000fdc:	c85ffc20 	ldaxr	x0, [x1]
    40000fe0:	8b100011 	add	x17, x0, x16
    40000fe4:	c80ffc31 	stlxr	w15, x17, [x1]
    40000fe8:	35ffffaf 	cbnz	w15, 40000fdc <__aarch64_ldadd8_acq_rel+0x1c>
    40000fec:	d65f03c0 	ret

0000000040000ff0 <__aarch64_ldclr8_acq_rel>:
    40000ff0:	d503245f 	bti	c
    40000ff4:	f00000b0 	adrp	x16, 40017000 <__aarch64_have_lse_atomics>
    40000ff8:	39400210 	ldrb	w16, [x16]
    40000ffc:	34000070 	cbz	w16, 40001008 <__aarch64_ldclr8_acq_rel+0x18>
    40001000:	f8e01020 	ldclral	x0, x0, [x1]
    40001004:	d65f03c0 	ret
    40001008:	aa0003f0 	mov	x16, x0
    4000100c:	c85ffc20 	ldaxr	x0, [x1]
    40001010:	8a300011 	bic	x17, x0, x16
    40001014:	c80ffc31 	stlxr	w15, x17, [x1]
    40001018:	35ffffaf 	cbnz	w15, 4000100c <__aarch64_ldclr8_acq_rel+0x1c>
    4000101c:	d65f03c0 	ret

0000000040001020 <__aarch64_ldset8_acq_rel>:
    40001020:	d503245f 	bti	c
    40001024:	d00000b0 	adrp	x16, 40017000 <__aarch64_have_lse_atomics>
    40001028:	39400210 	ldrb	w16, [x16]
    4000102c:	34000070 	cbz	w16, 40001038 <__aarch64_ldset8_acq_rel+0x18>
    40001030:	f8e03020 	ldsetal	x0, x0, [x1]
    40001034:	d65f03c0 	ret
    40001038:	aa0003f0 	mov	x16, x0
    4000103c:	c85ffc20 	ldaxr	x0, [x1]
    40001040:	aa100011 	orr	x17, x0, x16
    40001044:	c80ffc31 	stlxr	w15, x17, [x1]
    40001048:	35ffffaf 	cbnz	w15, 4000103c <__aarch64_ldset8_acq_rel+0x1c>
    4000104c:	d65f03c0 	ret

0000000040001050 <__reset_prep_c>:
 */

GTEXT(__reset_prep_c)
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__reset_prep_c)
	/* return address: x23 */
	mov	x23, x30
    40001050:	aa1e03f7 	mov	x23, x30

	switch_el x0, 3f, 2f, 1f
    40001054:	d5384240 	mrs	x0, currentel
    40001058:	f100301f 	cmp	x0, #0xc
    4000105c:	540000a0 	b.eq	40001070 <__reset_prep_c+0x20>  // b.none
    40001060:	f100201f 	cmp	x0, #0x8
    40001064:	54000100 	b.eq	40001084 <__reset_prep_c+0x34>  // b.none
    40001068:	f100101f 	cmp	x0, #0x4
    4000106c:	54000180 	b.eq	4000109c <__reset_prep_c+0x4c>  // b.none
3:
	/* Reinitialize SCTLR from scratch in EL3 */
	ldr	w0, =(SCTLR_EL3_RES1 | SCTLR_I_BIT | SCTLR_SA_BIT)
    40001070:	18000600 	ldr	w0, 40001130 <switch_el+0x58>
	msr	sctlr_el3, x0
    40001074:	d51e1000 	msr	sctlr_el3, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el3_plat_prep_c
    40001078:	94002be3 	bl	4000c004 <z_arm64_el3_plat_prep_c>

	/* Set SP_EL1 */
	msr     sp_el1, x24
    4000107c:	d51c4118 	msr	sp_el1, x24

	b	out
    40001080:	1400000d 	b	400010b4 <out>
2:
	/* Disable alignment fault checking */
	mrs	x0, sctlr_el2
    40001084:	d53c1000 	mrs	x0, sctlr_el2
	bic	x0, x0, SCTLR_A_BIT
    40001088:	927ef800 	and	x0, x0, #0xfffffffffffffffd
	msr	sctlr_el2, x0
    4000108c:	d51c1000 	msr	sctlr_el2, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el2_plat_prep_c
    40001090:	94002bde 	bl	4000c008 <z_arm64_el2_plat_prep_c>

	/* Set SP_EL1 */
	msr     sp_el1, x24
    40001094:	d51c4118 	msr	sp_el1, x24

	b	out
    40001098:	14000007 	b	400010b4 <out>
1:
	/* Disable alignment fault checking */
	mrs	x0, sctlr_el1
    4000109c:	d5381000 	mrs	x0, sctlr_el1
	bic	x0, x0, SCTLR_A_BIT
    400010a0:	927ef800 	and	x0, x0, #0xfffffffffffffffd
	msr	sctlr_el1, x0
    400010a4:	d5181000 	msr	sctlr_el1, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el1_plat_prep_c
    400010a8:	94002bd9 	bl	4000c00c <z_arm64_el1_plat_prep_c>

	/* Set SP_EL1. We cannot use sp_el1 at EL1 */
	msr     SPSel, #1
    400010ac:	d50041bf 	msr	spsel, #0x1
	mov     sp, x24
    400010b0:	9100031f 	mov	sp, x24

00000000400010b4 <out>:
out:
	isb
    400010b4:	d5033fdf 	isb

	/* Select SP_EL0 */
	msr	SPSel, #0
    400010b8:	d50040bf 	msr	spsel, #0x0

	/* Initialize stack */
	mov	sp, x24
    400010bc:	9100031f 	mov	sp, x24

	ret	x23
    400010c0:	d65f02e0 	ret	x23

00000000400010c4 <__reset>:
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__reset)

GTEXT(__start)
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)
	/* Mask all exceptions */
	msr	DAIFSet, #0xf
    400010c4:	d5034fdf 	msr	daifset, #0xf
primary_core:
	/* advertise ourself */
	str	x1, [x0, #BOOT_PARAM_MPID_OFFSET]
#endif
	/* load primary stack and entry point */
	ldr	x24, =(z_interrupt_stacks + CONFIG_ISR_STACK_SIZE)
    400010c8:	58000398 	ldr	x24, 40001138 <switch_el+0x60>
	ldr	x25, =z_arm64_prep_c
    400010cc:	580003b9 	ldr	x25, 40001140 <switch_el+0x68>
2:
	/* Prepare for calling C code */
	bl	__reset_prep_c
    400010d0:	97ffffe0 	bl	40001050 <__reset_prep_c>

	/* Platform hook for highest EL */
	bl	z_arm64_el_highest_init
    400010d4:	94002bdc 	bl	4000c044 <z_arm64_el_highest_init>

00000000400010d8 <switch_el>:

switch_el:
	switch_el x0, 3f, 2f, 1f
    400010d8:	d5384240 	mrs	x0, currentel
    400010dc:	f100301f 	cmp	x0, #0xc
    400010e0:	540000a0 	b.eq	400010f4 <switch_el+0x1c>  // b.none
    400010e4:	f100201f 	cmp	x0, #0x8
    400010e8:	540000e0 	b.eq	40001104 <switch_el+0x2c>  // b.none
    400010ec:	f100101f 	cmp	x0, #0x4
    400010f0:	54000180 	b.eq	40001120 <switch_el+0x48>  // b.none
3:
	/* EL3 init */
	bl	z_arm64_el3_init
    400010f4:	94002bf9 	bl	4000c0d8 <z_arm64_el3_init>

	/* Get next EL */
	adr	x0, switch_el
    400010f8:	10ffff00 	adr	x0, 400010d8 <switch_el>
	bl	z_arm64_el3_get_next_el
    400010fc:	94002c20 	bl	4000c17c <z_arm64_el3_get_next_el>
	eret
    40001100:	d69f03e0 	eret

2:
	/* EL2 init */
	bl	z_arm64_el2_init
    40001104:	94002be2 	bl	4000c08c <z_arm64_el2_init>

	/* Move to EL1 with all exceptions masked */
	mov_imm	x0, (SPSR_DAIF_MASK | SPSR_MODE_EL1T)
    40001108:	d2a00000 	movz	x0, #0x0, lsl #16
    4000110c:	f2807880 	movk	x0, #0x3c4
	msr	spsr_el2, x0
    40001110:	d51c4000 	msr	spsr_el2, x0

	adr	x0, 1f
    40001114:	10000060 	adr	x0, 40001120 <switch_el+0x48>
	msr	elr_el2, x0
    40001118:	d51c4020 	msr	elr_el2, x0
	eret
    4000111c:	d69f03e0 	eret

1:
	/* EL1 init */
	bl	z_arm64_el1_init
    40001120:	94002c04 	bl	4000c130 <z_arm64_el1_init>

	/* Enable SError interrupts */
	msr	DAIFClr, #(DAIFCLR_ABT_BIT)
    40001124:	d50344ff 	msr	daifclr, #0x4
	isb
    40001128:	d5033fdf 	isb

	ret	x25  /* either z_arm64_prep_c or z_arm64_secondary_prep_c */
    4000112c:	d65f0320 	ret	x25
    40001130:	30c51838 	.word	0x30c51838
    40001134:	00000000 	udf	#0
    40001138:	4006e3f0 	.word	0x4006e3f0
    4000113c:	00000000 	.word	0x00000000
    40001140:	4000bfc0 	.word	0x4000bfc0
    40001144:	00000000 	.word	0x00000000

0000000040001148 <_isr_wrapper>:

GTEXT(_isr_wrapper)
SECTION_FUNC(TEXT, _isr_wrapper)

	/* ++(_kernel->nested) to be checked by arch_is_in_isr() */
	inc_nest_counter x0, x1
    40001148:	d53bd060 	mrs	x0, tpidrro_el0
    4000114c:	927db000 	and	x0, x0, #0xfffffffffff8
    40001150:	f9400001 	ldr	x1, [x0]
    40001154:	91000421 	add	x1, x1, #0x1
    40001158:	f9000001 	str	x1, [x0]

#ifdef CONFIG_SCHED_THREAD_USAGE
	bl	z_sched_usage_stop
    4000115c:	94003ba2 	bl	4000ffe4 <z_sched_usage_stop>
	bl	sys_trace_isr_enter
#endif

	/* Get active IRQ number from the interrupt controller */
#if !defined(CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER)
	bl	arm_gic_get_active
    40001160:	94003298 	bl	4000dbc0 <arm_gic_get_active>
#if CONFIG_GIC_VER >= 3
	/*
	 * Ignore Special INTIDs 1020..1023 see 2.2.1 of Arm Generic Interrupt Controller
	 * Architecture Specification GIC architecture version 3 and version 4
	 */
	cmp	x0, 1019
    40001164:	f10fec1f 	cmp	x0, #0x3fb
	b.le	oob
    40001168:	5400008d 	b.le	40001178 <oob>
	cmp	x0, 1023
    4000116c:	f10ffc1f 	cmp	x0, #0x3ff
	b.gt	oob
    40001170:	5400004c 	b.gt	40001178 <oob>
	b	spurious_continue
    40001174:	1400000c 	b	400011a4 <spurious_continue>

0000000040001178 <oob>:

oob:
#endif
	/* IRQ out of bounds */
	mov	x1, #(CONFIG_NUM_IRQS - 1)
    40001178:	d2801b61 	mov	x1, #0xdb                  	// #219
	cmp	x0, x1
    4000117c:	eb01001f 	cmp	x0, x1
	b.hi	spurious_continue
    40001180:	54000128 	b.hi	400011a4 <spurious_continue>  // b.pmore

	stp	x0, xzr, [sp, #-16]!
    40001184:	a9bf7fe0 	stp	x0, xzr, [sp, #-16]!

	/* Retrieve the interrupt service routine */
	ldr	x1, =_sw_isr_table
    40001188:	580002c1 	ldr	x1, 400011e0 <exit+0x4>
	add	x1, x1, x0, lsl #4	/* table is 16-byte wide */
    4000118c:	8b001021 	add	x1, x1, x0, lsl #4
	ldp	x0, x3, [x1] /* arg in x0, ISR in x3 */
    40001190:	a9400c20 	ldp	x0, x3, [x1]

	/*
	 * Call the ISR. Unmask and mask again the IRQs to support nested
	 * exception handlers
	 */
	msr	daifclr, #(DAIFCLR_IRQ_BIT)
    40001194:	d50342ff 	msr	daifclr, #0x2
	blr	x3
    40001198:	d63f0060 	blr	x3
	msr	daifset, #(DAIFSET_IRQ_BIT)
    4000119c:	d50342df 	msr	daifset, #0x2

	/* Signal end-of-interrupt */
	ldp	x0, xzr, [sp], #16
    400011a0:	a8c17fe0 	ldp	x0, xzr, [sp], #16

00000000400011a4 <spurious_continue>:

spurious_continue:
#if !defined(CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER)
	bl	arm_gic_eoi
    400011a4:	94003289 	bl	4000dbc8 <arm_gic_eoi>
#ifdef CONFIG_TRACING
	bl	sys_trace_isr_exit
#endif

	/* if (--(_kernel->nested) != 0) exit */
	dec_nest_counter x0, x1
    400011a8:	d53bd060 	mrs	x0, tpidrro_el0
    400011ac:	927db000 	and	x0, x0, #0xfffffffffff8
    400011b0:	f9400001 	ldr	x1, [x0]
    400011b4:	f1000421 	subs	x1, x1, #0x1
    400011b8:	f9000001 	str	x1, [x0]

	bne	exit
    400011bc:	54000101 	b.ne	400011dc <exit>  // b.any
	 * - The next thread to schedule in x0
	 * - The current thread in x1. This value is returned using the
	 *   **old_thread parameter, so we need to make space on the stack for
	 *   that.
	 */
	sub	sp, sp, #16
    400011c0:	d10043ff 	sub	sp, sp, #0x10
	mov	x0, sp
    400011c4:	910003e0 	mov	x0, sp
	bl	z_arch_get_next_switch_handle
    400011c8:	94002c3a 	bl	4000c2b0 <z_arch_get_next_switch_handle>
	ldp	x1, xzr, [sp], #16
    400011cc:	a8c17fe1 	ldp	x1, xzr, [sp], #16

	/*
	 * x0: 1st thread in the ready queue
	 * x1: _current thread
	 */
	cmp	x0, x1
    400011d0:	eb01001f 	cmp	x0, x1
	beq	exit
    400011d4:	54000040 	b.eq	400011dc <exit>  // b.none

	/* Switch thread */
	bl	z_arm64_context_switch
    400011d8:	94002bf4 	bl	4000c1a8 <z_arm64_context_switch>

00000000400011dc <exit>:

exit:
#ifdef CONFIG_STACK_SENTINEL
	bl	z_check_stack_sentinel
#endif
	b	z_arm64_exit_exc
    400011dc:	14002c3e 	b	4000c2d4 <z_arm64_exit_exc>
    400011e0:	400120f0 	.word	0x400120f0
    400011e4:	00000000 	.word	0x00000000

00000000400011e8 <_OffsetAbsSyms>:
GEN_NAMED_OFFSET_SYM(arm_smccc_res_t, a4, a4_a5);
GEN_NAMED_OFFSET_SYM(arm_smccc_res_t, a6, a6_a7);

#endif /* CONFIG_HAS_ARM_SMCCC */

GEN_ABS_SYM_END
    400011e8:	d65f03c0 	ret

00000000400011ec <timer_expired_handler>:

extern void foo(void);

void timer_expired_handler(struct k_timer *timer)
{
	LOG_INF("Timer expired.");
    400011ec:	d0000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    400011f0:	91334001 	add	x1, x0, #0xcd0
    400011f4:	b94cd000 	ldr	w0, [x0, #3280]
    400011f8:	12000800 	and	w0, w0, #0x7
    400011fc:	7100081f 	cmp	w0, #0x2
    40001200:	540001a9 	b.ls	40001234 <timer_expired_handler+0x48>  // b.plast
 *
 * @return Source ID.
 */
static inline uint32_t log_dynamic_source_id(struct log_source_dynamic_data *data)
{
	return ((uint8_t *)data - (uint8_t *)__log_dynamic_start)/
    40001204:	d0000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40001208:	91334000 	add	x0, x0, #0xcd0
    4000120c:	cb000021 	sub	x1, x1, x0
{
    40001210:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	LOG_INF("Timer expired.");
    40001214:	f0000080 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    40001218:	9116e000 	add	x0, x0, #0x5b8
    4000121c:	d342fc21 	lsr	x1, x1, #2
{
    40001220:	910003fd 	mov	x29, sp
	LOG_INF("Timer expired.");
    40001224:	531a2421 	ubfiz	w1, w1, #6, #10
    40001228:	32000421 	orr	w1, w1, #0x3
    4000122c:	94000d9d 	bl	400048a0 <log_0>

	/* Call another module to present logging from multiple sources. */
	foo();
}
    40001230:	a8c17bfd 	ldp	x29, x30, [sp], #16
	foo();
    40001234:	1400013d 	b	40001728 <foo>

0000000040001238 <cmd_demo_board>:

	return 0;
}

static int cmd_demo_board(const struct shell *sh, size_t argc, char **argv)
{
    40001238:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(sh, CONFIG_BOARD);
    4000123c:	52800101 	mov	w1, #0x8                   	// #8
    40001240:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001244:	91171c42 	add	x2, x2, #0x5c7
{
    40001248:	910003fd 	mov	x29, sp
	shell_print(sh, CONFIG_BOARD);
    4000124c:	94001ee6 	bl	40008de4 <shell_fprintf>

	return 0;
}
    40001250:	52800000 	mov	w0, #0x0                   	// #0
    40001254:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40001258:	d65f03c0 	ret

000000004000125c <cmd_demo_ping>:
{
    4000125c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_print(shell, "pong");
    40001260:	52800101 	mov	w1, #0x8                   	// #8
    40001264:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001268:	91176042 	add	x2, x2, #0x5d8
{
    4000126c:	910003fd 	mov	x29, sp
	shell_print(shell, "pong");
    40001270:	94001edd 	bl	40008de4 <shell_fprintf>
}
    40001274:	52800000 	mov	w0, #0x0                   	// #0
    40001278:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000127c:	d65f03c0 	ret

0000000040001280 <cmd_demo_params>:
	return 0;
}
#endif

static int cmd_demo_params(const struct shell *shell, size_t argc, char **argv)
{
    40001280:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	shell_print(shell, "argc = %zd", argc);
    40001284:	aa0103e3 	mov	x3, x1
{
    40001288:	910003fd 	mov	x29, sp
    4000128c:	f9001bf7 	str	x23, [sp, #48]
	for (size_t cnt = 0; cnt < argc; cnt++) {
		shell_print(shell, "  argv[%zd] = %s", cnt, argv[cnt]);
    40001290:	f0000097 	adrp	x23, 40014000 <shell_m_sub_colors+0x50>
    40001294:	9117aaf7 	add	x23, x23, #0x5ea
{
    40001298:	a90153f3 	stp	x19, x20, [sp, #16]
	for (size_t cnt = 0; cnt < argc; cnt++) {
    4000129c:	d2800013 	mov	x19, #0x0                   	// #0
{
    400012a0:	aa0103f4 	mov	x20, x1
	shell_print(shell, "argc = %zd", argc);
    400012a4:	52800101 	mov	w1, #0x8                   	// #8
{
    400012a8:	a9025bf5 	stp	x21, x22, [sp, #32]
    400012ac:	aa0003f5 	mov	x21, x0
    400012b0:	aa0203f6 	mov	x22, x2
	shell_print(shell, "argc = %zd", argc);
    400012b4:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    400012b8:	91177842 	add	x2, x2, #0x5de
    400012bc:	94001eca 	bl	40008de4 <shell_fprintf>
	for (size_t cnt = 0; cnt < argc; cnt++) {
    400012c0:	eb14027f 	cmp	x19, x20
    400012c4:	540000e1 	b.ne	400012e0 <cmd_demo_params+0x60>  // b.any
	}

	return 0;
}
    400012c8:	52800000 	mov	w0, #0x0                   	// #0
    400012cc:	a94153f3 	ldp	x19, x20, [sp, #16]
    400012d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400012d4:	f9401bf7 	ldr	x23, [sp, #48]
    400012d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400012dc:	d65f03c0 	ret
		shell_print(shell, "  argv[%zd] = %s", cnt, argv[cnt]);
    400012e0:	f8737ac4 	ldr	x4, [x22, x19, lsl #3]
    400012e4:	aa1303e3 	mov	x3, x19
    400012e8:	aa1703e2 	mov	x2, x23
    400012ec:	aa1503e0 	mov	x0, x21
    400012f0:	52800101 	mov	w1, #0x8                   	// #8
	for (size_t cnt = 0; cnt < argc; cnt++) {
    400012f4:	91000673 	add	x19, x19, #0x1
		shell_print(shell, "  argv[%zd] = %s", cnt, argv[cnt]);
    400012f8:	94001ebb 	bl	40008de4 <shell_fprintf>
	for (size_t cnt = 0; cnt < argc; cnt++) {
    400012fc:	17fffff1 	b	400012c0 <cmd_demo_params+0x40>

0000000040001300 <cmd_version>:

	return 0;
}

static int cmd_version(const struct shell *shell, size_t argc, char **argv)
{
    40001300:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Zephyr version %s", KERNEL_VERSION_STRING);
    40001304:	52800101 	mov	w1, #0x8                   	// #8
    40001308:	f0000083 	adrp	x3, 40014000 <shell_m_sub_colors+0x50>
    4000130c:	9117f063 	add	x3, x3, #0x5fc
{
    40001310:	910003fd 	mov	x29, sp
	shell_print(shell, "Zephyr version %s", KERNEL_VERSION_STRING);
    40001314:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001318:	91180c42 	add	x2, x2, #0x603
    4000131c:	94001eb2 	bl	40008de4 <shell_fprintf>

	return 0;
}
    40001320:	52800000 	mov	w0, #0x0                   	// #0
    40001324:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40001328:	d65f03c0 	ret

000000004000132c <cmd_demo_hexdump>:
{
    4000132c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	shell_print(shell, "argc = %zd", argc);
    40001330:	aa0103e3 	mov	x3, x1
{
    40001334:	910003fd 	mov	x29, sp
    40001338:	a90363f7 	stp	x23, x24, [sp, #48]
		shell_print(shell, "argv[%zd]", cnt);
    4000133c:	f0000097 	adrp	x23, 40014000 <shell_m_sub_colors+0x50>
    40001340:	91185af7 	add	x23, x23, #0x616
{
    40001344:	a90153f3 	stp	x19, x20, [sp, #16]
	for (size_t cnt = 0; cnt < argc; cnt++) {
    40001348:	d2800013 	mov	x19, #0x0                   	// #0
{
    4000134c:	aa0103f4 	mov	x20, x1
	shell_print(shell, "argc = %zd", argc);
    40001350:	52800101 	mov	w1, #0x8                   	// #8
{
    40001354:	a9025bf5 	stp	x21, x22, [sp, #32]
    40001358:	aa0003f5 	mov	x21, x0
    4000135c:	aa0203f6 	mov	x22, x2
	shell_print(shell, "argc = %zd", argc);
    40001360:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001364:	91177842 	add	x2, x2, #0x5de
    40001368:	94001e9f 	bl	40008de4 <shell_fprintf>
	for (size_t cnt = 0; cnt < argc; cnt++) {
    4000136c:	eb14027f 	cmp	x19, x20
    40001370:	540000e1 	b.ne	4000138c <cmd_demo_hexdump+0x60>  // b.any
}
    40001374:	52800000 	mov	w0, #0x0                   	// #0
    40001378:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000137c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40001380:	a94363f7 	ldp	x23, x24, [sp, #48]
    40001384:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40001388:	d65f03c0 	ret
		shell_print(shell, "argv[%zd]", cnt);
    4000138c:	aa1303e3 	mov	x3, x19
    40001390:	aa1703e2 	mov	x2, x23
    40001394:	52800101 	mov	w1, #0x8                   	// #8
    40001398:	aa1503e0 	mov	x0, x21
    4000139c:	94001e92 	bl	40008de4 <shell_fprintf>
		shell_hexdump(shell, argv[cnt], strlen(argv[cnt]));
    400013a0:	f8737ad8 	ldr	x24, [x22, x19, lsl #3]
	for (size_t cnt = 0; cnt < argc; cnt++) {
    400013a4:	91000673 	add	x19, x19, #0x1
		shell_hexdump(shell, argv[cnt], strlen(argv[cnt]));
    400013a8:	aa1803e0 	mov	x0, x24
    400013ac:	94002f97 	bl	4000d208 <strlen>
    400013b0:	aa1803e1 	mov	x1, x24
    400013b4:	aa0003e2 	mov	x2, x0
    400013b8:	aa1503e0 	mov	x0, x21
    400013bc:	94001f1f 	bl	40009038 <shell_hexdump>
	for (size_t cnt = 0; cnt < argc; cnt++) {
    400013c0:	17ffffeb 	b	4000136c <cmd_demo_hexdump+0x40>

00000000400013c4 <set_bypass>:
	shell_print(shell, "\n");
	return 0;
}

static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
{
    400013c4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400013c8:	910003fd 	mov	x29, sp
    400013cc:	a90153f3 	stp	x19, x20, [sp, #16]
	static bool in_use;

	if (bypass && in_use) {
    400013d0:	90000113 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    400013d4:	3964b262 	ldrb	w2, [x19, #2348]
{
    400013d8:	f90013f5 	str	x21, [sp, #32]
    400013dc:	aa0003f4 	mov	x20, x0
    400013e0:	aa0103f5 	mov	x21, x1
	if (bypass && in_use) {
    400013e4:	b4000161 	cbz	x1, 40001410 <set_bypass+0x4c>
    400013e8:	34000142 	cbz	w2, 40001410 <set_bypass+0x4c>
		shell_error(sh, "Sample supports setting bypass on single instance.");
    400013ec:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    400013f0:	91188442 	add	x2, x2, #0x621
    400013f4:	52800021 	mov	w1, #0x1                   	// #1
    400013f8:	94001e7b 	bl	40008de4 <shell_fprintf>
    400013fc:	128001e0 	mov	w0, #0xfffffff0            	// #-16
	}

	shell_set_bypass(sh, bypass);

	return 0;
}
    40001400:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001404:	f94013f5 	ldr	x21, [sp, #32]
    40001408:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000140c:	d65f03c0 	ret
	in_use = !in_use;
    40001410:	52000042 	eor	w2, w2, #0x1
    40001414:	3924b262 	strb	w2, [x19, #2348]
	if (in_use) {
    40001418:	34000102 	cbz	w2, 40001438 <set_bypass+0x74>
		shell_print(sh, "Bypass started, press ctrl-x ctrl-q to escape");
    4000141c:	aa1403e0 	mov	x0, x20
    40001420:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001424:	91195442 	add	x2, x2, #0x655
    40001428:	52800101 	mov	w1, #0x8                   	// #8
    4000142c:	94001e6e 	bl	40008de4 <shell_fprintf>
		in_use = true;
    40001430:	52800020 	mov	w0, #0x1                   	// #1
    40001434:	3924b260 	strb	w0, [x19, #2348]
	shell_set_bypass(sh, bypass);
    40001438:	aa1403e0 	mov	x0, x20
    4000143c:	aa1503e1 	mov	x1, x21
    40001440:	94001f27 	bl	400090dc <shell_set_bypass>
	return 0;
    40001444:	52800000 	mov	w0, #0x0                   	// #0
    40001448:	17ffffee 	b	40001400 <set_bypass+0x3c>

000000004000144c <cmd_bypass>:

}

static int cmd_bypass(const struct shell *sh, size_t argc, char **argv)
{
	return set_bypass(sh, bypass_cb);
    4000144c:	90000001 	adrp	x1, 40001000 <__aarch64_ldclr8_acq_rel+0x10>
    40001450:	91116021 	add	x1, x1, #0x458
    40001454:	17ffffdc 	b	400013c4 <set_bypass>

0000000040001458 <bypass_cb>:
{
    40001458:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000145c:	910003fd 	mov	x29, sp
    40001460:	a90153f3 	stp	x19, x20, [sp, #16]
    40001464:	aa0003f4 	mov	x20, x0
    40001468:	aa0103f3 	mov	x19, x1
    4000146c:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (tail == CHAR_1 && data[0] == CHAR_2) {
    40001470:	90000115 	adrp	x21, 40021000 <k_sys_work_q+0x200>
    40001474:	3964b6a0 	ldrb	w0, [x21, #2349]
{
    40001478:	f9001bf7 	str	x23, [sp, #48]
    4000147c:	aa0203f6 	mov	x22, x2
	if (tail == CHAR_1 && data[0] == CHAR_2) {
    40001480:	7100601f 	cmp	w0, #0x18
    40001484:	54000081 	b.ne	40001494 <bypass_cb+0x3c>  // b.any
    40001488:	39400020 	ldrb	w0, [x1]
    4000148c:	7100441f 	cmp	w0, #0x11
    40001490:	54000260 	b.eq	400014dc <bypass_cb+0x84>  // b.none
		for (int i = 0; i < (len - 1); i++) {
    40001494:	d10006c1 	sub	x1, x22, #0x1
    40001498:	52800000 	mov	w0, #0x0                   	// #0
    4000149c:	93407c02 	sxtw	x2, w0
    400014a0:	eb20c03f 	cmp	x1, w0, sxtw
    400014a4:	540000e8 	b.hi	400014c0 <bypass_cb+0x68>  // b.pmore
	tail = data[len - 1];
    400014a8:	38616a60 	ldrb	w0, [x19, x1]
		shell_fprintf(sh, SHELL_INFO, "%02x ", data[i]);
    400014ac:	f0000097 	adrp	x23, 40014000 <shell_m_sub_colors+0x50>
    400014b0:	911a46f7 	add	x23, x23, #0x691
	tail = data[len - 1];
    400014b4:	3924b6a0 	strb	w0, [x21, #2349]
	for (int i = 0; i < len; i++) {
    400014b8:	52800015 	mov	w21, #0x0                   	// #0
    400014bc:	1400001c 	b	4000152c <bypass_cb+0xd4>
			if (data[i] == CHAR_1 && data[i + 1] == CHAR_2) {
    400014c0:	38626a62 	ldrb	w2, [x19, x2]
    400014c4:	11000400 	add	w0, w0, #0x1
    400014c8:	7100605f 	cmp	w2, #0x18
    400014cc:	54fffe81 	b.ne	4000149c <bypass_cb+0x44>  // b.any
    400014d0:	3860ca62 	ldrb	w2, [x19, w0, sxtw]
    400014d4:	7100445f 	cmp	w2, #0x11
    400014d8:	54fffe21 	b.ne	4000149c <bypass_cb+0x44>  // b.any
		shell_print(sh, "Exit bypass");
    400014dc:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    400014e0:	911a1042 	add	x2, x2, #0x684
    400014e4:	aa1403e0 	mov	x0, x20
    400014e8:	52800101 	mov	w1, #0x8                   	// #8
    400014ec:	94001e3e 	bl	40008de4 <shell_fprintf>
		set_bypass(sh, NULL);
    400014f0:	aa1403e0 	mov	x0, x20
    400014f4:	d2800001 	mov	x1, #0x0                   	// #0
    400014f8:	97ffffb3 	bl	400013c4 <set_bypass>
		tail = 0;
    400014fc:	3924b6bf 	strb	wzr, [x21, #2349]
}
    40001500:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001504:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40001508:	f9401bf7 	ldr	x23, [sp, #48]
    4000150c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40001510:	d65f03c0 	ret
		shell_fprintf(sh, SHELL_INFO, "%02x ", data[i]);
    40001514:	38606a63 	ldrb	w3, [x19, x0]
	for (int i = 0; i < len; i++) {
    40001518:	110006b5 	add	w21, w21, #0x1
		shell_fprintf(sh, SHELL_INFO, "%02x ", data[i]);
    4000151c:	aa1703e2 	mov	x2, x23
    40001520:	aa1403e0 	mov	x0, x20
    40001524:	52800041 	mov	w1, #0x2                   	// #2
    40001528:	94001e2f 	bl	40008de4 <shell_fprintf>
	for (int i = 0; i < len; i++) {
    4000152c:	93407ea0 	sxtw	x0, w21
    40001530:	eb35c2df 	cmp	x22, w21, sxtw
    40001534:	54ffff08 	b.hi	40001514 <bypass_cb+0xbc>  // b.pmore
		shell_fprintf(sh, SHELL_INFO, "%c", data[i]);
    40001538:	900000b7 	adrp	x23, 40015000 <prefix.1+0x2aa>
    4000153c:	9126b2f7 	add	x23, x23, #0x9ac
	for (int i = 0; i < len; i++) {
    40001540:	52800015 	mov	w21, #0x0                   	// #0
	shell_fprintf(sh, SHELL_INFO, "| ");
    40001544:	aa1403e0 	mov	x0, x20
    40001548:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    4000154c:	911a5c42 	add	x2, x2, #0x697
    40001550:	52800041 	mov	w1, #0x2                   	// #2
    40001554:	94001e24 	bl	40008de4 <shell_fprintf>
	for (int i = 0; i < len; i++) {
    40001558:	93407ea0 	sxtw	x0, w21
    4000155c:	eb35c2df 	cmp	x22, w21, sxtw
    40001560:	54000148 	b.hi	40001588 <bypass_cb+0x130>  // b.pmore
	shell_fprintf(sh, SHELL_INFO, "\n");
    40001564:	aa1403e0 	mov	x0, x20
    40001568:	900000a2 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000156c:	91096042 	add	x2, x2, #0x258
    40001570:	52800041 	mov	w1, #0x2                   	// #2
}
    40001574:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001578:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000157c:	f9401bf7 	ldr	x23, [sp, #48]
    40001580:	a8c47bfd 	ldp	x29, x30, [sp], #64
	shell_fprintf(sh, SHELL_INFO, "\n");
    40001584:	14001e18 	b	40008de4 <shell_fprintf>
		shell_fprintf(sh, SHELL_INFO, "%c", data[i]);
    40001588:	38606a63 	ldrb	w3, [x19, x0]
    4000158c:	aa1703e2 	mov	x2, x23
    40001590:	aa1403e0 	mov	x0, x20
    40001594:	52800041 	mov	w1, #0x2                   	// #2
	for (int i = 0; i < len; i++) {
    40001598:	110006b5 	add	w21, w21, #0x1
		shell_fprintf(sh, SHELL_INFO, "%c", data[i]);
    4000159c:	94001e12 	bl	40008de4 <shell_fprintf>
	for (int i = 0; i < len; i++) {
    400015a0:	17ffffee 	b	40001558 <bypass_cb+0x100>

00000000400015a4 <cmd_log_test_stop>:
{
    400015a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400015a8:	910003fd 	mov	x29, sp
    400015ac:	f9000bf3 	str	x19, [sp, #16]
    400015b0:	aa0003f3 	mov	x19, x0
		arch_syscall_invoke1(*(uintptr_t *)&timer, K_SYSCALL_K_TIMER_STOP);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_timer_stop(timer);
    400015b4:	d0000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    400015b8:	9133a000 	add	x0, x0, #0xce8
    400015bc:	94003d9e 	bl	40010c34 <z_impl_k_timer_stop>
	shell_print(shell, "Log test stopped");
    400015c0:	aa1303e0 	mov	x0, x19
    400015c4:	52800101 	mov	w1, #0x8                   	// #8
    400015c8:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    400015cc:	911a6842 	add	x2, x2, #0x69a
    400015d0:	94001e05 	bl	40008de4 <shell_fprintf>
}
    400015d4:	52800000 	mov	w0, #0x0                   	// #0
    400015d8:	f9400bf3 	ldr	x19, [sp, #16]
    400015dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400015e0:	d65f03c0 	ret

00000000400015e4 <cmd_log_test_start_demo>:
{
    400015e4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400015e8:	910003fd 	mov	x29, sp
    400015ec:	f9000bf3 	str	x19, [sp, #16]
    400015f0:	aa0003f3 	mov	x19, x0
	z_impl_k_timer_start(timer, duration, period);
    400015f4:	d2800282 	mov	x2, #0x14                  	// #20
    400015f8:	d0000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    400015fc:	9133a000 	add	x0, x0, #0xce8
    40001600:	aa0203e1 	mov	x1, x2
    40001604:	94003d68 	bl	40010ba4 <z_impl_k_timer_start>
	shell_print(shell, "Log test started\n");
    40001608:	aa1303e0 	mov	x0, x19
    4000160c:	52800101 	mov	w1, #0x8                   	// #8
    40001610:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001614:	911ab042 	add	x2, x2, #0x6ac
    40001618:	94001df3 	bl	40008de4 <shell_fprintf>
}
    4000161c:	52800000 	mov	w0, #0x0                   	// #0
    40001620:	f9400bf3 	ldr	x19, [sp, #16]
    40001624:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40001628:	d65f03c0 	ret

000000004000162c <cmd_dict_value_3>:
	shell_print(shell, "(syntax, value) : (%s, %d)", argv[0], val);

	return 0;
}

SHELL_SUBCMD_DICT_SET_CREATE(sub_dict_cmds, cmd_dict,
    4000162c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_print(shell, "(syntax, value) : (%s, %d)", argv[0], val);
    40001630:	52800064 	mov	w4, #0x3                   	// #3
    40001634:	52800101 	mov	w1, #0x8                   	// #8
SHELL_SUBCMD_DICT_SET_CREATE(sub_dict_cmds, cmd_dict,
    40001638:	910003fd 	mov	x29, sp
	shell_print(shell, "(syntax, value) : (%s, %d)", argv[0], val);
    4000163c:	f9400043 	ldr	x3, [x2]
    40001640:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001644:	911afc42 	add	x2, x2, #0x6bf
    40001648:	94001de7 	bl	40008de4 <shell_fprintf>
SHELL_SUBCMD_DICT_SET_CREATE(sub_dict_cmds, cmd_dict,
    4000164c:	52800000 	mov	w0, #0x0                   	// #0
    40001650:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40001654:	d65f03c0 	ret

0000000040001658 <cmd_log_test_start_flood>:
{
    40001658:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000165c:	910003fd 	mov	x29, sp
    40001660:	f9000bf3 	str	x19, [sp, #16]
    40001664:	aa0003f3 	mov	x19, x0
    40001668:	d2800022 	mov	x2, #0x1                   	// #1
    4000166c:	d0000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40001670:	9133a000 	add	x0, x0, #0xce8
    40001674:	aa0203e1 	mov	x1, x2
    40001678:	94003d4b 	bl	40010ba4 <z_impl_k_timer_start>
	shell_print(shell, "Log test started\n");
    4000167c:	aa1303e0 	mov	x0, x19
    40001680:	52800101 	mov	w1, #0x8                   	// #8
    40001684:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001688:	911ab042 	add	x2, x2, #0x6ac
    4000168c:	94001dd6 	bl	40008de4 <shell_fprintf>
}
    40001690:	52800000 	mov	w0, #0x0                   	// #0
    40001694:	f9400bf3 	ldr	x19, [sp, #16]
    40001698:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000169c:	d65f03c0 	ret

00000000400016a0 <cmd_dict_value_0>:
SHELL_SUBCMD_DICT_SET_CREATE(sub_dict_cmds, cmd_dict,
    400016a0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_print(shell, "(syntax, value) : (%s, %d)", argv[0], val);
    400016a4:	52800004 	mov	w4, #0x0                   	// #0
    400016a8:	52800101 	mov	w1, #0x8                   	// #8
SHELL_SUBCMD_DICT_SET_CREATE(sub_dict_cmds, cmd_dict,
    400016ac:	910003fd 	mov	x29, sp
	shell_print(shell, "(syntax, value) : (%s, %d)", argv[0], val);
    400016b0:	f9400043 	ldr	x3, [x2]
    400016b4:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    400016b8:	911afc42 	add	x2, x2, #0x6bf
    400016bc:	94001dca 	bl	40008de4 <shell_fprintf>
SHELL_SUBCMD_DICT_SET_CREATE(sub_dict_cmds, cmd_dict,
    400016c0:	52800000 	mov	w0, #0x0                   	// #0
    400016c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400016c8:	d65f03c0 	ret

00000000400016cc <cmd_dict_value_1>:
    400016cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_print(shell, "(syntax, value) : (%s, %d)", argv[0], val);
    400016d0:	52800024 	mov	w4, #0x1                   	// #1
    400016d4:	52800101 	mov	w1, #0x8                   	// #8
SHELL_SUBCMD_DICT_SET_CREATE(sub_dict_cmds, cmd_dict,
    400016d8:	910003fd 	mov	x29, sp
	shell_print(shell, "(syntax, value) : (%s, %d)", argv[0], val);
    400016dc:	f9400043 	ldr	x3, [x2]
    400016e0:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    400016e4:	911afc42 	add	x2, x2, #0x6bf
    400016e8:	94001dbf 	bl	40008de4 <shell_fprintf>
SHELL_SUBCMD_DICT_SET_CREATE(sub_dict_cmds, cmd_dict,
    400016ec:	52800000 	mov	w0, #0x0                   	// #0
    400016f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400016f4:	d65f03c0 	ret

00000000400016f8 <cmd_dict_value_2>:
    400016f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_print(shell, "(syntax, value) : (%s, %d)", argv[0], val);
    400016fc:	52800044 	mov	w4, #0x2                   	// #2
    40001700:	52800101 	mov	w1, #0x8                   	// #8
SHELL_SUBCMD_DICT_SET_CREATE(sub_dict_cmds, cmd_dict,
    40001704:	910003fd 	mov	x29, sp
	shell_print(shell, "(syntax, value) : (%s, %d)", argv[0], val);
    40001708:	f9400043 	ldr	x3, [x2]
    4000170c:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001710:	911afc42 	add	x2, x2, #0x6bf
    40001714:	94001db4 	bl	40008de4 <shell_fprintf>
SHELL_SUBCMD_DICT_SET_CREATE(sub_dict_cmds, cmd_dict,
    40001718:	52800000 	mov	w0, #0x0                   	// #0
    4000171c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40001720:	d65f03c0 	ret

0000000040001724 <main>:
	while (!dtr) {
		uart_line_ctrl_get(dev, UART_LINE_CTRL_DTR, &dtr);
		k_sleep(K_MSEC(100));
	}
#endif
}
    40001724:	d65f03c0 	ret

0000000040001728 <foo>:

#include <logging/log.h>
LOG_MODULE_REGISTER(app_test);

void foo(void)
{
    40001728:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000172c:	910003fd 	mov	x29, sp
    40001730:	a90153f3 	stp	x19, x20, [sp, #16]
	LOG_INF("info message");
    40001734:	d0000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40001738:	91335013 	add	x19, x0, #0xcd4
    4000173c:	b94cd401 	ldr	w1, [x0, #3284]
    40001740:	aa0003f4 	mov	x20, x0
    40001744:	12000821 	and	w1, w1, #0x7
    40001748:	7100083f 	cmp	w1, #0x2
    4000174c:	54000149 	b.ls	40001774 <foo+0x4c>  // b.plast
    40001750:	d0000361 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
    40001754:	91334021 	add	x1, x1, #0xcd0
    40001758:	cb010261 	sub	x1, x19, x1
    4000175c:	f0000080 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    40001760:	9121d000 	add	x0, x0, #0x874
    40001764:	d342fc21 	lsr	x1, x1, #2
    40001768:	531a2421 	ubfiz	w1, w1, #6, #10
    4000176c:	32000421 	orr	w1, w1, #0x3
    40001770:	94000c4c 	bl	400048a0 <log_0>
	LOG_WRN("warning message");
    40001774:	b94cd680 	ldr	w0, [x20, #3284]
    40001778:	721f041f 	tst	w0, #0x6
    4000177c:	54000140 	b.eq	400017a4 <foo+0x7c>  // b.none
    40001780:	d0000361 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
    40001784:	91334021 	add	x1, x1, #0xcd0
    40001788:	cb010261 	sub	x1, x19, x1
    4000178c:	f0000080 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    40001790:	91220400 	add	x0, x0, #0x881
    40001794:	d342fc21 	lsr	x1, x1, #2
    40001798:	531a2421 	ubfiz	w1, w1, #6, #10
    4000179c:	321f0021 	orr	w1, w1, #0x2
    400017a0:	94000c40 	bl	400048a0 <log_0>
	LOG_ERR("err message");
    400017a4:	b94cd680 	ldr	w0, [x20, #3284]
    400017a8:	f240081f 	tst	x0, #0x7
    400017ac:	54000180 	b.eq	400017dc <foo+0xb4>  // b.none
    400017b0:	d0000361 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
    400017b4:	91334021 	add	x1, x1, #0xcd0
    400017b8:	cb010261 	sub	x1, x19, x1
    400017bc:	f0000080 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    400017c0:	91224400 	add	x0, x0, #0x891
}
    400017c4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400017c8:	d342fc21 	lsr	x1, x1, #2
    400017cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	LOG_ERR("err message");
    400017d0:	531a2421 	ubfiz	w1, w1, #6, #10
    400017d4:	32000021 	orr	w1, w1, #0x1
    400017d8:	14000c32 	b	400048a0 <log_0>
}
    400017dc:	a94153f3 	ldp	x19, x20, [sp, #16]
    400017e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400017e4:	d65f03c0 	ret

00000000400017e8 <dynamic_cmd_get>:
}

/* dynamic command creation */
static void dynamic_cmd_get(size_t idx, struct shell_static_entry *entry)
{
	if (idx < dynamic_cmd_cnt) {
    400017e8:	90000102 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    400017ec:	396f0842 	ldrb	w2, [x2, #3010]
    400017f0:	eb00005f 	cmp	x2, x0
    400017f4:	54000169 	b.ls	40001820 <dynamic_cmd_get+0x38>  // b.plast
		/* m_dynamic_cmd_buffer must be sorted alphabetically to ensure
		 * correct CLI completion
		 */
		entry->syntax = dynamic_cmd_buffer[idx];
    400017f8:	8b001400 	add	x0, x0, x0, lsl #5
    400017fc:	90000102 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    40001800:	9124b842 	add	x2, x2, #0x92e
		entry->handler  = NULL;
    40001804:	a9017c3f 	stp	xzr, xzr, [x1, #16]
		entry->syntax = dynamic_cmd_buffer[idx];
    40001808:	8b000040 	add	x0, x2, x0
    4000180c:	f9000020 	str	x0, [x1]
		entry->subcmd = NULL;
		entry->help = "Show dynamic command name.";
    40001810:	f0000080 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    40001814:	91229800 	add	x0, x0, #0x8a6
    40001818:	f9000420 	str	x0, [x1, #8]
		/* if there are no more dynamic commands available syntax
		 * must be set to NULL.
		 */
		entry->syntax = NULL;
	}
}
    4000181c:	d65f03c0 	ret
		entry->syntax = NULL;
    40001820:	f900003f 	str	xzr, [x1]
}
    40001824:	17fffffe 	b	4000181c <dynamic_cmd_get+0x34>

0000000040001828 <string_cmp>:
	return strcmp((const char *)p_a, (const char *)p_b);
    40001828:	14002e88 	b	4000d248 <strcmp>

000000004000182c <cmd_dynamic_remove>:
{
    4000182c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40001830:	910003fd 	mov	x29, sp
    40001834:	a9025bf5 	stp	x21, x22, [sp, #32]
		if (!strcmp(dynamic_cmd_buffer[idx], argv[1])) {
    40001838:	90000116 	adrp	x22, 40021000 <k_sys_work_q+0x200>
    4000183c:	9124bad6 	add	x22, x22, #0x92e
{
    40001840:	a90363f7 	stp	x23, x24, [sp, #48]
    40001844:	aa0003f7 	mov	x23, x0
    40001848:	aa0203f8 	mov	x24, x2
    4000184c:	a9046bf9 	stp	x25, x26, [sp, #64]
	for (uint8_t idx = 0; idx <  dynamic_cmd_cnt; idx++) {
    40001850:	90000115 	adrp	x21, 40021000 <k_sys_work_q+0x200>
    40001854:	912f0aba 	add	x26, x21, #0xbc2
{
    40001858:	a90153f3 	stp	x19, x20, [sp, #16]
	for (uint8_t idx = 0; idx <  dynamic_cmd_cnt; idx++) {
    4000185c:	52800013 	mov	w19, #0x0                   	// #0
{
    40001860:	f9002bfb 	str	x27, [sp, #80]
	for (uint8_t idx = 0; idx <  dynamic_cmd_cnt; idx++) {
    40001864:	39400340 	ldrb	w0, [x26]
		if (!strcmp(dynamic_cmd_buffer[idx], argv[1])) {
    40001868:	f9400701 	ldr	x1, [x24, #8]
	for (uint8_t idx = 0; idx <  dynamic_cmd_cnt; idx++) {
    4000186c:	6b13001f 	cmp	w0, w19
    40001870:	54000128 	b.hi	40001894 <cmd_dynamic_remove+0x68>  // b.pmore
	shell_error(shell, "did not find command: %s", argv[1]);
    40001874:	aa0103e3 	mov	x3, x1
    40001878:	aa1703e0 	mov	x0, x23
    4000187c:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001880:	91237c42 	add	x2, x2, #0x8df
    40001884:	52800021 	mov	w1, #0x1                   	// #1
	return -ENOEXEC;
    40001888:	128000f4 	mov	w20, #0xfffffff8            	// #-8
	shell_error(shell, "did not find command: %s", argv[1]);
    4000188c:	94001d56 	bl	40008de4 <shell_fprintf>
	return -ENOEXEC;
    40001890:	14000012 	b	400018d8 <cmd_dynamic_remove+0xac>
		if (!strcmp(dynamic_cmd_buffer[idx], argv[1])) {
    40001894:	52800439 	mov	w25, #0x21                  	// #33
    40001898:	9bb95a7b 	umaddl	x27, w19, w25, x22
    4000189c:	aa1b03e0 	mov	x0, x27
    400018a0:	94002e6a 	bl	4000d248 <strcmp>
    400018a4:	2a0003f4 	mov	w20, w0
    400018a8:	35000380 	cbnz	w0, 40001918 <cmd_dynamic_remove+0xec>
			if (idx == MAX_CMD_CNT - 1) {
    400018ac:	71004e7f 	cmp	w19, #0x13
    400018b0:	54000241 	b.ne	400018f8 <cmd_dynamic_remove+0xcc>  // b.any
				dynamic_cmd_buffer[idx][0] = '\0';
    400018b4:	3909cedf 	strb	wzr, [x22, #627]
			--dynamic_cmd_cnt;
    400018b8:	396f0aa0 	ldrb	w0, [x21, #3010]
			shell_print(shell, "command removed successfully");
    400018bc:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    400018c0:	91230442 	add	x2, x2, #0x8c1
    400018c4:	52800101 	mov	w1, #0x8                   	// #8
			--dynamic_cmd_cnt;
    400018c8:	51000400 	sub	w0, w0, #0x1
    400018cc:	392f0aa0 	strb	w0, [x21, #3010]
			shell_print(shell, "command removed successfully");
    400018d0:	aa1703e0 	mov	x0, x23
    400018d4:	94001d44 	bl	40008de4 <shell_fprintf>
}
    400018d8:	2a1403e0 	mov	w0, w20
    400018dc:	a94153f3 	ldp	x19, x20, [sp, #16]
    400018e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400018e4:	a94363f7 	ldp	x23, x24, [sp, #48]
    400018e8:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400018ec:	f9402bfb 	ldr	x27, [sp, #80]
    400018f0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    400018f4:	d65f03c0 	ret
					(dynamic_cmd_cnt - idx));
    400018f8:	39400342 	ldrb	w2, [x26]
					dynamic_cmd_buffer[idx + 1],
    400018fc:	11000661 	add	w1, w19, #0x1
				memmove(dynamic_cmd_buffer[idx],
    40001900:	aa1b03e0 	mov	x0, x27
					(dynamic_cmd_cnt - idx));
    40001904:	4b130042 	sub	w2, w2, w19
				memmove(dynamic_cmd_buffer[idx],
    40001908:	9b395821 	smaddl	x1, w1, w25, x22
    4000190c:	9b397c42 	smull	x2, w2, w25
    40001910:	94002e72 	bl	4000d2d8 <memmove>
    40001914:	17ffffe9 	b	400018b8 <cmd_dynamic_remove+0x8c>
	for (uint8_t idx = 0; idx <  dynamic_cmd_cnt; idx++) {
    40001918:	11000673 	add	w19, w19, #0x1
    4000191c:	12001e73 	and	w19, w19, #0xff
    40001920:	17ffffd1 	b	40001864 <cmd_dynamic_remove+0x38>

0000000040001924 <cmd_dynamic_show>:
{
    40001924:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40001928:	910003fd 	mov	x29, sp
    4000192c:	a90153f3 	stp	x19, x20, [sp, #16]
	if (dynamic_cmd_cnt == 0U) {
    40001930:	90000114 	adrp	x20, 40021000 <k_sys_work_q+0x200>
    40001934:	396f0a81 	ldrb	w1, [x20, #3010]
{
    40001938:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000193c:	f9001bf7 	str	x23, [sp, #48]
	if (dynamic_cmd_cnt == 0U) {
    40001940:	35000161 	cbnz	w1, 4000196c <cmd_dynamic_show+0x48>
		shell_warn(shell, "Please add some commands first.");
    40001944:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001948:	9123e442 	add	x2, x2, #0x8f9
    4000194c:	52800061 	mov	w1, #0x3                   	// #3
    40001950:	94001d25 	bl	40008de4 <shell_fprintf>
    40001954:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
    40001958:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000195c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40001960:	f9401bf7 	ldr	x23, [sp, #48]
    40001964:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40001968:	d65f03c0 	ret
		shell_print(shell, "[%3d] %s", i, dynamic_cmd_buffer[i]);
    4000196c:	90000116 	adrp	x22, 40021000 <k_sys_work_q+0x200>
    40001970:	9124bad6 	add	x22, x22, #0x92e
    40001974:	f0000097 	adrp	x23, 40014000 <shell_m_sub_colors+0x50>
    40001978:	9124c6f7 	add	x23, x23, #0x931
	for (uint8_t i = 0; i < dynamic_cmd_cnt; i++) {
    4000197c:	912f0a94 	add	x20, x20, #0xbc2
    40001980:	52800013 	mov	w19, #0x0                   	// #0
    40001984:	aa0003f5 	mov	x21, x0
	shell_print(shell, "Dynamic command list:");
    40001988:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    4000198c:	91246842 	add	x2, x2, #0x91a
    40001990:	52800101 	mov	w1, #0x8                   	// #8
    40001994:	94001d14 	bl	40008de4 <shell_fprintf>
	for (uint8_t i = 0; i < dynamic_cmd_cnt; i++) {
    40001998:	39400280 	ldrb	w0, [x20]
    4000199c:	6b13001f 	cmp	w0, w19
    400019a0:	54000068 	b.hi	400019ac <cmd_dynamic_show+0x88>  // b.pmore
	return 0;
    400019a4:	52800000 	mov	w0, #0x0                   	// #0
    400019a8:	17ffffec 	b	40001958 <cmd_dynamic_show+0x34>
		shell_print(shell, "[%3d] %s", i, dynamic_cmd_buffer[i]);
    400019ac:	52800424 	mov	w4, #0x21                  	// #33
    400019b0:	2a1303e3 	mov	w3, w19
    400019b4:	aa1703e2 	mov	x2, x23
    400019b8:	aa1503e0 	mov	x0, x21
    400019bc:	9ba45a64 	umaddl	x4, w19, w4, x22
	for (uint8_t i = 0; i < dynamic_cmd_cnt; i++) {
    400019c0:	11000673 	add	w19, w19, #0x1
		shell_print(shell, "[%3d] %s", i, dynamic_cmd_buffer[i]);
    400019c4:	52800101 	mov	w1, #0x8                   	// #8
	for (uint8_t i = 0; i < dynamic_cmd_cnt; i++) {
    400019c8:	12001e73 	and	w19, w19, #0xff
		shell_print(shell, "[%3d] %s", i, dynamic_cmd_buffer[i]);
    400019cc:	94001d06 	bl	40008de4 <shell_fprintf>
	for (uint8_t i = 0; i < dynamic_cmd_cnt; i++) {
    400019d0:	17fffff2 	b	40001998 <cmd_dynamic_show+0x74>

00000000400019d4 <cmd_dynamic_execute>:
{
    400019d4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    400019d8:	910003fd 	mov	x29, sp
    400019dc:	a9025bf5 	stp	x21, x22, [sp, #32]
    400019e0:	aa0003f6 	mov	x22, x0
    400019e4:	aa0203f5 	mov	x21, x2
    400019e8:	a90363f7 	stp	x23, x24, [sp, #48]
	for (uint8_t idx = 0; idx <  dynamic_cmd_cnt; idx++) {
    400019ec:	90000117 	adrp	x23, 40021000 <k_sys_work_q+0x200>
    400019f0:	912f0af7 	add	x23, x23, #0xbc2
		if (!strcmp(dynamic_cmd_buffer[idx], argv[1])) {
    400019f4:	90000118 	adrp	x24, 40021000 <k_sys_work_q+0x200>
    400019f8:	9124bb18 	add	x24, x24, #0x92e
{
    400019fc:	a90153f3 	stp	x19, x20, [sp, #16]
	for (uint8_t idx = 0; idx <  dynamic_cmd_cnt; idx++) {
    40001a00:	52800013 	mov	w19, #0x0                   	// #0
{
    40001a04:	f90023f9 	str	x25, [sp, #64]
		if (!strcmp(dynamic_cmd_buffer[idx], argv[1])) {
    40001a08:	52800439 	mov	w25, #0x21                  	// #33
	for (uint8_t idx = 0; idx <  dynamic_cmd_cnt; idx++) {
    40001a0c:	394002e0 	ldrb	w0, [x23]
		if (!strcmp(dynamic_cmd_buffer[idx], argv[1])) {
    40001a10:	f94006a1 	ldr	x1, [x21, #8]
	for (uint8_t idx = 0; idx <  dynamic_cmd_cnt; idx++) {
    40001a14:	6b13001f 	cmp	w0, w19
    40001a18:	54000148 	b.hi	40001a40 <cmd_dynamic_execute+0x6c>  // b.pmore
	shell_error(shell, "%s: uknown parameter: %s", argv[0], argv[1]);
    40001a1c:	f94002a3 	ldr	x3, [x21]
    40001a20:	aa0103e4 	mov	x4, x1
    40001a24:	aa1603e0 	mov	x0, x22
    40001a28:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001a2c:	91254042 	add	x2, x2, #0x950
    40001a30:	52800021 	mov	w1, #0x1                   	// #1
	return -ENOEXEC;
    40001a34:	128000f4 	mov	w20, #0xfffffff8            	// #-8
	shell_error(shell, "%s: uknown parameter: %s", argv[0], argv[1]);
    40001a38:	94001ceb 	bl	40008de4 <shell_fprintf>
	return -ENOEXEC;
    40001a3c:	1400000b 	b	40001a68 <cmd_dynamic_execute+0x94>
		if (!strcmp(dynamic_cmd_buffer[idx], argv[1])) {
    40001a40:	9bb96260 	umaddl	x0, w19, w25, x24
    40001a44:	94002e01 	bl	4000d248 <strcmp>
    40001a48:	2a0003f4 	mov	w20, w0
    40001a4c:	350001c0 	cbnz	w0, 40001a84 <cmd_dynamic_execute+0xb0>
			shell_print(shell, "dynamic command: %s", argv[1]);
    40001a50:	f94006a3 	ldr	x3, [x21, #8]
    40001a54:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001a58:	9124ec42 	add	x2, x2, #0x93b
    40001a5c:	aa1603e0 	mov	x0, x22
    40001a60:	52800101 	mov	w1, #0x8                   	// #8
    40001a64:	94001ce0 	bl	40008de4 <shell_fprintf>
}
    40001a68:	2a1403e0 	mov	w0, w20
    40001a6c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001a70:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40001a74:	a94363f7 	ldp	x23, x24, [sp, #48]
    40001a78:	f94023f9 	ldr	x25, [sp, #64]
    40001a7c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40001a80:	d65f03c0 	ret
	for (uint8_t idx = 0; idx <  dynamic_cmd_cnt; idx++) {
    40001a84:	11000673 	add	w19, w19, #0x1
    40001a88:	12001e73 	and	w19, w19, #0xff
    40001a8c:	17ffffe0 	b	40001a0c <cmd_dynamic_execute+0x38>

0000000040001a90 <cmd_dynamic_add>:
{
    40001a90:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40001a94:	910003fd 	mov	x29, sp
    40001a98:	a90153f3 	stp	x19, x20, [sp, #16]
	if (dynamic_cmd_cnt >= MAX_CMD_CNT) {
    40001a9c:	90000114 	adrp	x20, 40021000 <k_sys_work_q+0x200>
    40001aa0:	396f0a81 	ldrb	w1, [x20, #3010]
{
    40001aa4:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (dynamic_cmd_cnt >= MAX_CMD_CNT) {
    40001aa8:	71004c3f 	cmp	w1, #0x13
{
    40001aac:	a90363f7 	stp	x23, x24, [sp, #48]
	if (dynamic_cmd_cnt >= MAX_CMD_CNT) {
    40001ab0:	54000169 	b.ls	40001adc <cmd_dynamic_add+0x4c>  // b.plast
		shell_error(shell, "command limit reached");
    40001ab4:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001ab8:	9125a842 	add	x2, x2, #0x96a
    40001abc:	52800021 	mov	w1, #0x1                   	// #1
			shell_error(shell, "duplicated command");
    40001ac0:	94001cc9 	bl	40008de4 <shell_fprintf>
			return -ENOEXEC;
    40001ac4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
    40001ac8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001acc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40001ad0:	a94363f7 	ldp	x23, x24, [sp, #48]
    40001ad4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40001ad8:	d65f03c0 	ret
    40001adc:	aa0003f3 	mov	x19, x0
    40001ae0:	aa0203f5 	mov	x21, x2
	cmd_len = strlen(argv[1]);
    40001ae4:	f9400440 	ldr	x0, [x2, #8]
    40001ae8:	94002dc8 	bl	4000d208 <strlen>
    40001aec:	12003c00 	and	w0, w0, #0xffff
	if (cmd_len >= MAX_CMD_LEN) {
    40001af0:	7100801f 	cmp	w0, #0x20
    40001af4:	54000208 	b.hi	40001b34 <cmd_dynamic_add+0xa4>  // b.pmore
		if (!isalnum((int)(argv[1][idx]))) {
    40001af8:	f94006a4 	ldr	x4, [x21, #8]
    40001afc:	d2800001 	mov	x1, #0x0                   	// #0
	for (idx = 0U; idx < cmd_len; idx++) {
    40001b00:	6b21201f 	cmp	w0, w1, uxth
    40001b04:	54000228 	b.hi	40001b48 <cmd_dynamic_add+0xb8>  // b.pmore
    40001b08:	90000116 	adrp	x22, 40021000 <k_sys_work_q+0x200>
    40001b0c:	9124bad6 	add	x22, x22, #0x92e
    40001b10:	aa1603f8 	mov	x24, x22
    40001b14:	52800297 	mov	w23, #0x14                  	// #20
		if (!strcmp(dynamic_cmd_buffer[idx], argv[1])) {
    40001b18:	f94006a1 	ldr	x1, [x21, #8]
    40001b1c:	aa1603e0 	mov	x0, x22
    40001b20:	94002dca 	bl	4000d248 <strcmp>
    40001b24:	350002c0 	cbnz	w0, 40001b7c <cmd_dynamic_add+0xec>
			shell_error(shell, "duplicated command");
    40001b28:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001b2c:	91274442 	add	x2, x2, #0x9d1
    40001b30:	14000003 	b	40001b3c <cmd_dynamic_add+0xac>
		shell_error(shell, "too long command");
    40001b34:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001b38:	91260442 	add	x2, x2, #0x981
			shell_error(shell, "duplicated command");
    40001b3c:	aa1303e0 	mov	x0, x19
    40001b40:	52800021 	mov	w1, #0x1                   	// #1
    40001b44:	17ffffdf 	b	40001ac0 <cmd_dynamic_add+0x30>
		if (!isalnum((int)(argv[1][idx]))) {
    40001b48:	38616882 	ldrb	w2, [x4, x1]
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
}

static inline int isalpha(int c)
{
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    40001b4c:	321b0043 	orr	w3, w2, #0x20
    40001b50:	51018463 	sub	w3, w3, #0x61
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
    40001b54:	7100647f 	cmp	w3, #0x19
    40001b58:	540000e9 	b.ls	40001b74 <cmd_dynamic_add+0xe4>  // b.plast
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    40001b5c:	5100c042 	sub	w2, w2, #0x30
	return (int)(isalpha(chr) || isdigit(chr));
    40001b60:	7100245f 	cmp	w2, #0x9
    40001b64:	54000089 	b.ls	40001b74 <cmd_dynamic_add+0xe4>  // b.plast
			shell_error(shell,
    40001b68:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001b6c:	91264c42 	add	x2, x2, #0x993
    40001b70:	17fffff3 	b	40001b3c <cmd_dynamic_add+0xac>
	for (idx = 0U; idx < cmd_len; idx++) {
    40001b74:	91000421 	add	x1, x1, #0x1
    40001b78:	17ffffe2 	b	40001b00 <cmd_dynamic_add+0x70>
	for (idx = 0U; idx < MAX_CMD_CNT; idx++) {
    40001b7c:	510006f7 	sub	w23, w23, #0x1
    40001b80:	910086d6 	add	x22, x22, #0x21
    40001b84:	72001ef7 	ands	w23, w23, #0xff
    40001b88:	54fffc81 	b.ne	40001b18 <cmd_dynamic_add+0x88>  // b.any
	sprintf(dynamic_cmd_buffer[dynamic_cmd_cnt++], "%s", argv[1]);
    40001b8c:	396f0a80 	ldrb	w0, [x20, #3010]
    40001b90:	52800423 	mov	w3, #0x21                  	// #33
    40001b94:	f94006a2 	ldr	x2, [x21, #8]
    40001b98:	11000401 	add	w1, w0, #0x1
    40001b9c:	392f0a81 	strb	w1, [x20, #3010]
    40001ba0:	900000a1 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40001ba4:	910dbc21 	add	x1, x1, #0x36f
    40001ba8:	9ba36000 	umaddl	x0, w0, w3, x24
    40001bac:	94002e22 	bl	4000d434 <sprintf>
static inline void qsort(void *base, size_t nmemb, size_t size,
	int (*compar)(const void *, const void *))
{
	typedef int (*compar3)(const void *, const void *, void *);

	qsort_r(base, nmemb, size, (compar3)compar, NULL);
    40001bb0:	396f0a81 	ldrb	w1, [x20, #3010]
    40001bb4:	90000003 	adrp	x3, 40001000 <__aarch64_ldclr8_acq_rel+0x10>
    40001bb8:	9120a063 	add	x3, x3, #0x828
    40001bbc:	d2800004 	mov	x4, #0x0                   	// #0
    40001bc0:	aa1803e0 	mov	x0, x24
    40001bc4:	d2800422 	mov	x2, #0x21                  	// #33
    40001bc8:	94002d17 	bl	4000d024 <qsort_r>
	shell_print(shell, "command added successfully");
    40001bcc:	aa1303e0 	mov	x0, x19
    40001bd0:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001bd4:	91279442 	add	x2, x2, #0x9e5
    40001bd8:	52800101 	mov	w1, #0x8                   	// #8
    40001bdc:	94001c82 	bl	40008de4 <shell_fprintf>
	return 0;
    40001be0:	52800000 	mov	w0, #0x0                   	// #0
    40001be4:	17ffffb9 	b	40001ac8 <cmd_dynamic_add+0x38>

0000000040001be8 <shell_init_from_work>:
#include <shell/shell_uart.h>
#include <drivers/uart.h>
#include <device.h>

void shell_init_from_work(struct k_work *work)
{
    40001be8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40001bec:	910003fd 	mov	x29, sp
    40001bf0:	f9000bf3 	str	x19, [sp, #16]
	bool log_backend = CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > 0;
	uint32_t level =
		(CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > LOG_LEVEL_DBG) ?
		CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL;

	shell_init(shell_backend_uart_get_ptr(), dev,
    40001bf4:	94001731 	bl	400078b8 <shell_backend_uart_get_ptr>
    40001bf8:	aa0003f3 	mov	x19, x0
		   shell_backend_uart_get_ptr()->ctx->cfg.flags,
    40001bfc:	9400172f 	bl	400078b8 <shell_backend_uart_get_ptr>
    40001c00:	f9400800 	ldr	x0, [x0, #16]
	shell_init(shell_backend_uart_get_ptr(), dev,
    40001c04:	52800084 	mov	w4, #0x4                   	// #4
    40001c08:	52800023 	mov	w3, #0x1                   	// #1
    40001c0c:	b0000081 	adrp	x1, 40012000 <__rodata_region_start>
    40001c10:	91024021 	add	x1, x1, #0x90
    40001c14:	b9429802 	ldr	w2, [x0, #664]
    40001c18:	aa1303e0 	mov	x0, x19
		   log_backend, level);
}
    40001c1c:	f9400bf3 	ldr	x19, [sp, #16]
    40001c20:	a8c27bfd 	ldp	x29, x30, [sp], #32
	shell_init(shell_backend_uart_get_ptr(), dev,
    40001c24:	14001b71 	b	400089e8 <shell_init>

0000000040001c28 <cmd_uart_release>:
		k_timer_start(&uart_poll_timer, K_MSEC(10), K_MSEC(10));
	}
}

static int cmd_uart_release(const struct shell *shell, size_t argc, char **argv)
{
    40001c28:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40001c2c:	910003fd 	mov	x29, sp
    40001c30:	a90153f3 	stp	x19, x20, [sp, #16]
    40001c34:	aa0003f4 	mov	x20, x0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	if (shell != shell_backend_uart_get_ptr()) {
    40001c38:	94001720 	bl	400078b8 <shell_backend_uart_get_ptr>
    40001c3c:	eb14001f 	cmp	x0, x20
    40001c40:	54000140 	b.eq	40001c68 <cmd_uart_release+0x40>  // b.none
		shell_error(shell, "Command dedicated for shell over uart");
    40001c44:	aa1403e0 	mov	x0, x20
    40001c48:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001c4c:	912e3842 	add	x2, x2, #0xb8e
    40001c50:	52800021 	mov	w1, #0x1                   	// #1
    40001c54:	94001c64 	bl	40008de4 <shell_fprintf>
    40001c58:	128002a0 	mov	w0, #0xffffffea            	// #-22

	shell_print(shell, "Uninitializing shell, use 'x' to reinitialize");
	shell_uninit(shell, shell_uninit_cb);

	return 0;
}
    40001c5c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001c60:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40001c64:	d65f03c0 	ret
	shell_print(shell, "Uninitializing shell, use 'x' to reinitialize");
    40001c68:	f0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40001c6c:	912ed442 	add	x2, x2, #0xbb5
    40001c70:	aa0003f3 	mov	x19, x0
    40001c74:	52800101 	mov	w1, #0x8                   	// #8
    40001c78:	94001c5b 	bl	40008de4 <shell_fprintf>
	shell_uninit(shell, shell_uninit_cb);
    40001c7c:	aa1303e0 	mov	x0, x19
    40001c80:	90000001 	adrp	x1, 40001000 <__aarch64_ldclr8_acq_rel+0x10>
    40001c84:	91325021 	add	x1, x1, #0xc94
    40001c88:	94001bb6 	bl	40008b60 <shell_uninit>
	return 0;
    40001c8c:	52800000 	mov	w0, #0x0                   	// #0
    40001c90:	17fffff3 	b	40001c5c <cmd_uart_release+0x34>

0000000040001c94 <shell_uninit_cb>:
{
    40001c94:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40001c98:	910003fd 	mov	x29, sp
    40001c9c:	f9000bf3 	str	x19, [sp, #16]
static inline void uart_irq_callback_user_data_set(const struct device *dev,
						   uart_irq_callback_user_data_t cb,
						   void *user_data)
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    40001ca0:	b0000093 	adrp	x19, 40012000 <__rodata_region_start>
    40001ca4:	91024273 	add	x19, x19, #0x90
    40001ca8:	f9400a60 	ldr	x0, [x19, #16]
		(const struct uart_driver_api *)dev->api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    40001cac:	b4000100 	cbz	x0, 40001ccc <shell_uninit_cb+0x38>
    40001cb0:	f9404803 	ldr	x3, [x0, #144]
    40001cb4:	b40000c3 	cbz	x3, 40001ccc <shell_uninit_cb+0x38>
		api->irq_callback_set(dev, cb, user_data);
    40001cb8:	90000001 	adrp	x1, 40001000 <__aarch64_ldclr8_acq_rel+0x10>
    40001cbc:	9133e021 	add	x1, x1, #0xcf8
    40001cc0:	aa1303e0 	mov	x0, x19
    40001cc4:	d2800002 	mov	x2, #0x0                   	// #0
    40001cc8:	d63f0060 	blr	x3
	if (api->irq_rx_enable != NULL) {
    40001ccc:	f9400a60 	ldr	x0, [x19, #16]
    40001cd0:	f9402801 	ldr	x1, [x0, #80]
    40001cd4:	b40000c1 	cbz	x1, 40001cec <shell_uninit_cb+0x58>
		api->irq_rx_enable(dev);
    40001cd8:	aa1303e0 	mov	x0, x19
    40001cdc:	aa0103f0 	mov	x16, x1
}
    40001ce0:	f9400bf3 	ldr	x19, [sp, #16]
    40001ce4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40001ce8:	d61f0200 	br	x16
    40001cec:	f9400bf3 	ldr	x19, [sp, #16]
    40001cf0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40001cf4:	d65f03c0 	ret

0000000040001cf8 <direct_uart_callback>:
{
    40001cf8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40001cfc:	910003fd 	mov	x29, sp
    40001d00:	a90153f3 	stp	x19, x20, [sp, #16]
    40001d04:	aa0003f3 	mov	x19, x0
    40001d08:	f90013f5 	str	x21, [sp, #32]
	if (api->irq_update == NULL) {
    40001d0c:	f9400801 	ldr	x1, [x0, #16]
    40001d10:	f9404421 	ldr	x1, [x1, #136]
    40001d14:	b4000041 	cbz	x1, 40001d1c <direct_uart_callback+0x24>
	return api->irq_update(dev);
    40001d18:	d63f0020 	blr	x1
	if (api->irq_rx_ready == NULL) {
    40001d1c:	f9400a60 	ldr	x0, [x19, #16]
    40001d20:	f9403401 	ldr	x1, [x0, #104]
    40001d24:	b50002a1 	cbnz	x1, 40001d78 <direct_uart_callback+0x80>
	return api->fifo_read(dev, rx_data, size);
    40001d28:	90000114 	adrp	x20, 40021000 <k_sys_work_q+0x200>
    40001d2c:	912f0e94 	add	x20, x20, #0xbc3
			if (!tx_busy) {
    40001d30:	90000115 	adrp	x21, 40021000 <k_sys_work_q+0x200>
    40001d34:	912f12b5 	add	x21, x21, #0xbc4
	if (api->fifo_read == NULL) {
    40001d38:	f9400a60 	ldr	x0, [x19, #16]
    40001d3c:	f9401803 	ldr	x3, [x0, #48]
    40001d40:	b40000c3 	cbz	x3, 40001d58 <direct_uart_callback+0x60>
	return api->fifo_read(dev, rx_data, size);
    40001d44:	aa1403e1 	mov	x1, x20
    40001d48:	aa1303e0 	mov	x0, x19
    40001d4c:	52800022 	mov	w2, #0x1                   	// #1
    40001d50:	d63f0060 	blr	x3
		while (uart_fifo_read(dev, buf, sizeof(buf))) {
    40001d54:	34000180 	cbz	w0, 40001d84 <direct_uart_callback+0x8c>
			if (!tx_busy) {
    40001d58:	394002a0 	ldrb	w0, [x21]
    40001d5c:	35fffee0 	cbnz	w0, 40001d38 <direct_uart_callback+0x40>
	if (api->irq_tx_enable != NULL) {
    40001d60:	f9400a60 	ldr	x0, [x19, #16]
    40001d64:	f9401c01 	ldr	x1, [x0, #56]
    40001d68:	b4fffe81 	cbz	x1, 40001d38 <direct_uart_callback+0x40>
		api->irq_tx_enable(dev);
    40001d6c:	aa1303e0 	mov	x0, x19
    40001d70:	d63f0020 	blr	x1
    40001d74:	17fffff1 	b	40001d38 <direct_uart_callback+0x40>
	return api->irq_rx_ready(dev);
    40001d78:	aa1303e0 	mov	x0, x19
    40001d7c:	d63f0020 	blr	x1
	if (uart_irq_rx_ready(dev)) {
    40001d80:	35fffd40 	cbnz	w0, 40001d28 <direct_uart_callback+0x30>
	if (api->irq_tx_ready == NULL) {
    40001d84:	f9400a60 	ldr	x0, [x19, #16]
    40001d88:	f9402401 	ldr	x1, [x0, #72]
    40001d8c:	b5000201 	cbnz	x1, 40001dcc <direct_uart_callback+0xd4>
		if (!tx_busy) {
    40001d90:	90000100 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40001d94:	396f1001 	ldrb	w1, [x0, #3012]
    40001d98:	aa0003f4 	mov	x20, x0
    40001d9c:	35000261 	cbnz	w1, 40001de8 <direct_uart_callback+0xf0>
	if (api->fifo_fill == NULL) {
    40001da0:	f9400a60 	ldr	x0, [x19, #16]
    40001da4:	f9401403 	ldr	x3, [x0, #40]
    40001da8:	b40000c3 	cbz	x3, 40001dc0 <direct_uart_callback+0xc8>
	return api->fifo_fill(dev, tx_data, size);
    40001dac:	90000101 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40001db0:	912f0c21 	add	x1, x1, #0xbc3
    40001db4:	aa1303e0 	mov	x0, x19
    40001db8:	52800022 	mov	w2, #0x1                   	// #1
    40001dbc:	d63f0060 	blr	x3
			tx_busy = true;
    40001dc0:	52800020 	mov	w0, #0x1                   	// #1
    40001dc4:	392f1280 	strb	w0, [x20, #3012]
    40001dc8:	14000004 	b	40001dd8 <direct_uart_callback+0xe0>
	return api->irq_tx_ready(dev);
    40001dcc:	aa1303e0 	mov	x0, x19
    40001dd0:	d63f0020 	blr	x1
	if (uart_irq_tx_ready(dev)) {
    40001dd4:	35fffde0 	cbnz	w0, 40001d90 <direct_uart_callback+0x98>
}
    40001dd8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001ddc:	f94013f5 	ldr	x21, [sp, #32]
    40001de0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40001de4:	d65f03c0 	ret
			tx_busy = false;
    40001de8:	392f101f 	strb	wzr, [x0, #3012]
	if (api->irq_tx_disable != NULL) {
    40001dec:	f9400a60 	ldr	x0, [x19, #16]
    40001df0:	f9402001 	ldr	x1, [x0, #64]
    40001df4:	b4000061 	cbz	x1, 40001e00 <direct_uart_callback+0x108>
		api->irq_tx_disable(dev);
    40001df8:	aa1303e0 	mov	x0, x19
    40001dfc:	d63f0020 	blr	x1
			if (buf[0] == 'x') {
    40001e00:	90000100 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40001e04:	396f0c00 	ldrb	w0, [x0, #3011]
    40001e08:	7101e01f 	cmp	w0, #0x78
    40001e0c:	54fffe61 	b.ne	40001dd8 <direct_uart_callback+0xe0>  // b.any
	if (api->irq_rx_disable != NULL) {
    40001e10:	f9400a60 	ldr	x0, [x19, #16]
    40001e14:	f9402c01 	ldr	x1, [x0, #88]
    40001e18:	b4000061 	cbz	x1, 40001e24 <direct_uart_callback+0x12c>
		api->irq_rx_disable(dev);
    40001e1c:	aa1303e0 	mov	x0, x19
    40001e20:	d63f0020 	blr	x1
	k_work_init(&shell_init_work, shell_init_from_work);
    40001e24:	90000113 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    40001e28:	91070273 	add	x19, x19, #0x1c0
    40001e2c:	aa1303e0 	mov	x0, x19
    40001e30:	90000001 	adrp	x1, 40001000 <__aarch64_ldclr8_acq_rel+0x10>
    40001e34:	912fa021 	add	x1, x1, #0xbe8
    40001e38:	94003612 	bl	4000f680 <k_work_init>
	int err = k_work_submit(&shell_init_work);
    40001e3c:	aa1303e0 	mov	x0, x19
}
    40001e40:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001e44:	f94013f5 	ldr	x21, [sp, #32]
    40001e48:	a8c37bfd 	ldp	x29, x30, [sp], #48
	int err = k_work_submit(&shell_init_work);
    40001e4c:	14003626 	b	4000f6e4 <k_work_submit>

0000000040001e50 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    40001e50:	52800000 	mov	w0, #0x0                   	// #0
    40001e54:	d65f03c0 	ret

0000000040001e58 <str_out>:
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    40001e58:	f9400024 	ldr	x4, [x1]
    40001e5c:	b9400c22 	ldr	w2, [x1, #12]
		ctx->count++;
		return c;
	}

	if (ctx->count == ctx->max - 1) {
		ctx->str[ctx->count++] = '\0';
    40001e60:	11000445 	add	w5, w2, #0x1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    40001e64:	b4000084 	cbz	x4, 40001e74 <str_out+0x1c>
    40001e68:	b9400823 	ldr	w3, [x1, #8]
    40001e6c:	6b02007f 	cmp	w3, w2
    40001e70:	5400006c 	b.gt	40001e7c <str_out+0x24>
		ctx->count++;
    40001e74:	b9000c25 	str	w5, [x1, #12]
	} else {
		ctx->str[ctx->count++] = c;
	}

	return c;
}
    40001e78:	d65f03c0 	ret
		ctx->str[ctx->count++] = '\0';
    40001e7c:	b9000c25 	str	w5, [x1, #12]
	if (ctx->count == ctx->max - 1) {
    40001e80:	51000463 	sub	w3, w3, #0x1
		ctx->str[ctx->count++] = '\0';
    40001e84:	93407c46 	sxtw	x6, w2
	if (ctx->count == ctx->max - 1) {
    40001e88:	6b02007f 	cmp	w3, w2
    40001e8c:	54000061 	b.ne	40001e98 <str_out+0x40>  // b.any
		ctx->str[ctx->count++] = '\0';
    40001e90:	3826689f 	strb	wzr, [x4, x6]
    40001e94:	17fffff9 	b	40001e78 <str_out+0x20>
		ctx->str[ctx->count++] = c;
    40001e98:	38266880 	strb	w0, [x4, x6]
    40001e9c:	17fffff7 	b	40001e78 <str_out+0x20>

0000000040001ea0 <__printk_hook_install>:
	_char_out = fn;
    40001ea0:	d0000361 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
    40001ea4:	f905cc20 	str	x0, [x1, #2968]
}
    40001ea8:	d65f03c0 	ret

0000000040001eac <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    40001eac:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40001eb0:	910003fd 	mov	x29, sp
    40001eb4:	f9000bf3 	str	x19, [sp, #16]
    40001eb8:	aa0003f3 	mov	x19, x0
	struct str_context ctx = { str, size, 0 };
    40001ebc:	f90023e0 	str	x0, [sp, #64]
    40001ec0:	29097fe1 	stp	w1, wzr, [sp, #72]

	cbvprintf(str_out, &ctx, fmt, ap);
    40001ec4:	a9400460 	ldp	x0, x1, [x3]
    40001ec8:	a90207e0 	stp	x0, x1, [sp, #32]
    40001ecc:	a9410460 	ldp	x0, x1, [x3, #16]
    40001ed0:	910083e3 	add	x3, sp, #0x20
    40001ed4:	a90307e0 	stp	x0, x1, [sp, #48]
    40001ed8:	910103e1 	add	x1, sp, #0x40
    40001edc:	90000000 	adrp	x0, 40001000 <__aarch64_ldclr8_acq_rel+0x10>
    40001ee0:	91396000 	add	x0, x0, #0xe58
    40001ee4:	94000252 	bl	4000282c <cbvprintf>

	if (ctx.count < ctx.max) {
    40001ee8:	294903e1 	ldp	w1, w0, [sp, #72]
    40001eec:	6b01001f 	cmp	w0, w1
    40001ef0:	5400004a 	b.ge	40001ef8 <vsnprintk+0x4c>  // b.tcont
		str[ctx.count] = '\0';
    40001ef4:	3820ca7f 	strb	wzr, [x19, w0, sxtw]
	}

	return ctx.count;
}
    40001ef8:	f9400bf3 	ldr	x19, [sp, #16]
    40001efc:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40001f00:	d65f03c0 	ret

0000000040001f04 <snprintk>:
{
    40001f04:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40001f08:	910003fd 	mov	x29, sp
    40001f0c:	a90d93e3 	stp	x3, x4, [sp, #216]
	va_start(ap, fmt);
    40001f10:	910403e3 	add	x3, sp, #0x100
    40001f14:	a9030fe3 	stp	x3, x3, [sp, #48]
    40001f18:	910343e3 	add	x3, sp, #0xd0
    40001f1c:	f90023e3 	str	x3, [sp, #64]
    40001f20:	128004e3 	mov	w3, #0xffffffd8            	// #-40
    40001f24:	b9004be3 	str	w3, [sp, #72]
    40001f28:	12800fe3 	mov	w3, #0xffffff80            	// #-128
    40001f2c:	b9004fe3 	str	w3, [sp, #76]
	ret = vsnprintk(str, size, fmt, ap);
    40001f30:	910043e3 	add	x3, sp, #0x10
{
    40001f34:	a90e9be5 	stp	x5, x6, [sp, #232]
	ret = vsnprintk(str, size, fmt, ap);
    40001f38:	a94317e4 	ldp	x4, x5, [sp, #48]
    40001f3c:	a90117e4 	stp	x4, x5, [sp, #16]
    40001f40:	a94417e4 	ldp	x4, x5, [sp, #64]
    40001f44:	a90217e4 	stp	x4, x5, [sp, #32]
{
    40001f48:	3d8017e0 	str	q0, [sp, #80]
    40001f4c:	3d801be1 	str	q1, [sp, #96]
    40001f50:	3d801fe2 	str	q2, [sp, #112]
    40001f54:	3d8023e3 	str	q3, [sp, #128]
    40001f58:	3d8027e4 	str	q4, [sp, #144]
    40001f5c:	3d802be5 	str	q5, [sp, #160]
    40001f60:	3d802fe6 	str	q6, [sp, #176]
    40001f64:	3d8033e7 	str	q7, [sp, #192]
    40001f68:	f9007fe7 	str	x7, [sp, #248]
	ret = vsnprintk(str, size, fmt, ap);
    40001f6c:	97ffffd0 	bl	40001eac <vsnprintk>
}
    40001f70:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40001f74:	d65f03c0 	ret

0000000040001f78 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    40001f78:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40001f7c:	aa0003e4 	mov	x4, x0
    40001f80:	aa0103e0 	mov	x0, x1
    40001f84:	910003fd 	mov	x29, sp
    40001f88:	aa0203e1 	mov	x1, x2
    40001f8c:	aa0303e2 	mov	x2, x3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    40001f90:	d63f0080 	blr	x4
	return z_impl_z_current_get();
    40001f94:	940037e4 	bl	4000ff24 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
    40001f98:	940039bc 	bl	40010688 <z_impl_k_thread_abort>

0000000040001f9c <timeutil_timegm64>:
}

int64_t timeutil_timegm64(const struct tm *tm)
{
	int64_t y = 1900 + (int64_t)tm->tm_year;
	unsigned int m = tm->tm_mon + 1;
    40001f9c:	29418403 	ldp	w3, w1, [x0, #12]
    40001fa0:	11000421 	add	w1, w1, #0x1
	unsigned int d = tm->tm_mday - 1;
    40001fa4:	51000466 	sub	w6, w3, #0x1
	int64_t y = 1900 + (int64_t)tm->tm_year;
    40001fa8:	b9801403 	ldrsw	x3, [x0, #20]
	y -= m <= 2;
    40001fac:	7100083f 	cmp	w1, #0x2
    40001fb0:	9a9f87e2 	cset	x2, ls  // ls = plast
	int64_t y = 1900 + (int64_t)tm->tm_year;
    40001fb4:	911db063 	add	x3, x3, #0x76c
	int64_t era = (y >= 0 ? y : y - 399) / 400;
    40001fb8:	eb020063 	subs	x3, x3, x2
    40001fbc:	d2803202 	mov	x2, #0x190                 	// #400
    40001fc0:	540004c5 	b.pl	40002058 <timeutil_timegm64+0xbc>  // b.nfrst
    40001fc4:	d1063c64 	sub	x4, x3, #0x18f
    40001fc8:	9ac20c82 	sdiv	x2, x4, x2
	unsigned int yoe = y - era * 400;
    40001fcc:	128031e4 	mov	w4, #0xfffffe70            	// #-400
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
    40001fd0:	7100083f 	cmp	w1, #0x2
	int64_t ndays = time_days_from_civil(y, m, d);
	int64_t time = tm->tm_sec;

	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
    40001fd4:	b9400805 	ldr	w5, [x0, #8]
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
    40001fd8:	12800047 	mov	w7, #0xfffffffd            	// #-3
	unsigned int yoe = y - era * 400;
    40001fdc:	1b020c83 	madd	w3, w4, w2, w3
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
    40001fe0:	52800124 	mov	w4, #0x9                   	// #9
    40001fe4:	1a8480e7 	csel	w7, w7, w4, hi  // hi = pmore
	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
    40001fe8:	69402004 	ldpsw	x4, x8, [x0]
    40001fec:	52800780 	mov	w0, #0x3c                  	// #60
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
    40001ff0:	0b070021 	add	w1, w1, w7
	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
    40001ff4:	9b2020a5 	smaddl	x5, w5, w0, x8
    40001ff8:	d2800780 	mov	x0, #0x3c                  	// #60
    40001ffc:	9b0010a5 	madd	x5, x5, x0, x4
	unsigned int doe = yoe * 365U + yoe / 4U - yoe / 100U + doy;
    40002000:	53027c60 	lsr	w0, w3, #2
    40002004:	52802da4 	mov	w4, #0x16d                 	// #365
    40002008:	1b040064 	madd	w4, w3, w4, w0
    4000200c:	52800c80 	mov	w0, #0x64                  	// #100
    40002010:	1ac00863 	udiv	w3, w3, w0
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
    40002014:	52801320 	mov	w0, #0x99                  	// #153
    40002018:	1b007c21 	mul	w1, w1, w0
    4000201c:	528000a0 	mov	w0, #0x5                   	// #5
    40002020:	11000821 	add	w1, w1, #0x2
	unsigned int doe = yoe * 365U + yoe / 4U - yoe / 100U + doy;
    40002024:	4b0300c3 	sub	w3, w6, w3
    40002028:	0b030083 	add	w3, w4, w3
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
    4000202c:	1ac00821 	udiv	w1, w1, w0
	return era * 146097 + (time_t)doe - 719468;
    40002030:	d2875620 	mov	x0, #0x3ab1                	// #15025
    40002034:	f2a00040 	movk	x0, #0x2, lsl #16
    40002038:	0b010061 	add	w1, w3, w1
    4000203c:	9b000442 	madd	x2, x2, x0, x1
	time += 86400LL * ndays;

	return time;
}
    40002040:	d28a3000 	mov	x0, #0x5180                	// #20864
    40002044:	f2a00020 	movk	x0, #0x1, lsl #16
	return era * 146097 + (time_t)doe - 719468;
    40002048:	d142bc42 	sub	x2, x2, #0xaf, lsl #12
    4000204c:	d129b042 	sub	x2, x2, #0xa6c
}
    40002050:	9b001440 	madd	x0, x2, x0, x5
    40002054:	d65f03c0 	ret
	int64_t era = (y >= 0 ? y : y - 399) / 400;
    40002058:	9ac20c62 	sdiv	x2, x3, x2
    4000205c:	17ffffdc 	b	40001fcc <timeutil_timegm64+0x30>

0000000040002060 <timeutil_timegm>:

time_t timeutil_timegm(const struct tm *tm)
{
    40002060:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40002064:	910003fd 	mov	x29, sp
    40002068:	f9000bf3 	str	x19, [sp, #16]
	int64_t time = timeutil_timegm64(tm);
    4000206c:	97ffffcc 	bl	40001f9c <timeutil_timegm64>
    40002070:	aa0003f3 	mov	x19, x0
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
    40002074:	940030d0 	bl	4000e3b4 <z_impl_z_errno>
	time_t rv = (time_t)time;

	errno = 0;
    40002078:	b900001f 	str	wzr, [x0]
		errno = ERANGE;
		rv = -1;
	}

	return rv;
}
    4000207c:	aa1303e0 	mov	x0, x19
    40002080:	f9400bf3 	ldr	x19, [sp, #16]
    40002084:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40002088:	d65f03c0 	ret

000000004000208c <chunk_size>:
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
    4000208c:	8b214c01 	add	x1, x0, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    40002090:	b9400420 	ldr	w0, [x1, #4]
}
    40002094:	53017c00 	lsr	w0, w0, #1
    40002098:	d65f03c0 	ret

000000004000209c <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    4000209c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400020a0:	aa0003e2 	mov	x2, x0
    400020a4:	2a0103e3 	mov	w3, w1
    400020a8:	910003fd 	mov	x29, sp
	chunk_set(h, c, LEFT_SIZE, size);
}

static inline bool solo_free_header(struct z_heap *h, chunkid_t c)
{
	return big_heap(h) && chunk_size(h, c) == 1U;
    400020ac:	97fffff8 	bl	4000208c <chunk_size>
	if (!solo_free_header(h, c)) {
    400020b0:	7100041f 	cmp	w0, #0x1
    400020b4:	54000260 	b.eq	40002100 <free_list_add+0x64>  // b.none
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    400020b8:	51000400 	sub	w0, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
    400020bc:	528003e1 	mov	w1, #0x1f                  	// #31
    400020c0:	5ac01000 	clz	w0, w0
    400020c4:	4b000020 	sub	w0, w1, w0
	if (b->next == 0U) {
    400020c8:	d37d7c61 	ubfiz	x1, x3, #3, #32
    400020cc:	91002026 	add	x6, x1, #0x8
		((uint32_t *)cmem)[f] = val;
    400020d0:	91003021 	add	x1, x1, #0xc
    400020d4:	8b20c847 	add	x7, x2, w0, sxtw #2
    400020d8:	b94010e5 	ldr	w5, [x7, #16]
    400020dc:	35000165 	cbnz	w5, 40002108 <free_list_add+0x6c>
		h->avail_buckets |= (1 << bidx);
    400020e0:	52800024 	mov	w4, #0x1                   	// #1
    400020e4:	1ac02084 	lsl	w4, w4, w0
    400020e8:	b9400c40 	ldr	w0, [x2, #12]
    400020ec:	2a040000 	orr	w0, w0, w4
    400020f0:	b9000c40 	str	w0, [x2, #12]
		b->next = c;
    400020f4:	b90010e3 	str	w3, [x7, #16]
    400020f8:	b8266843 	str	w3, [x2, x6]
    400020fc:	b8216843 	str	w3, [x2, x1]
		int bidx = bucket_idx(h, chunk_size(h, c));
		free_list_add_bidx(h, c, bidx);
	}
}
    40002100:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40002104:	d65f03c0 	ret
		return ((uint32_t *)cmem)[f];
    40002108:	d37d7ca0 	ubfiz	x0, x5, #3, #32
    4000210c:	91002000 	add	x0, x0, #0x8
    40002110:	b8606844 	ldr	w4, [x2, x0]
		((uint32_t *)cmem)[f] = val;
    40002114:	b8266844 	str	w4, [x2, x6]
    40002118:	b8216845 	str	w5, [x2, x1]
    4000211c:	8b244c44 	add	x4, x2, w4, uxtw #3
    40002120:	b9000c83 	str	w3, [x4, #12]
    40002124:	b8206843 	str	w3, [x2, x0]
    40002128:	17fffff6 	b	40002100 <free_list_add+0x64>

000000004000212c <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
    4000212c:	d1002042 	sub	x2, x2, #0x8

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    40002130:	91001c23 	add	x3, x1, #0x7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    40002134:	8b020022 	add	x2, x1, x2
{
    40002138:	aa0003e4 	mov	x4, x0
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    4000213c:	927df042 	and	x2, x2, #0xfffffffffffffff8
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    40002140:	927df060 	and	x0, x3, #0xfffffffffffffff8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    40002144:	cb000042 	sub	x2, x2, x0
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
    40002148:	91004005 	add	x5, x0, #0x10
	heap->heap = h;
    4000214c:	f9000080 	str	x0, [x4]
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    40002150:	52800404 	mov	w4, #0x20                  	// #32
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    40002154:	d343fc42 	lsr	x2, x2, #3
	h->avail_buckets = 0;
    40002158:	29017c02 	stp	w2, wzr, [x0, #8]
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    4000215c:	51000441 	sub	w1, w2, #0x1
	return 31 - __builtin_clz(usable_sz);
    40002160:	5ac01023 	clz	w3, w1
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    40002164:	52800481 	mov	w1, #0x24                  	// #36
    40002168:	4b030021 	sub	w1, w1, w3
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    4000216c:	4b030084 	sub	w4, w4, w3
    40002170:	d28000e3 	mov	x3, #0x7                   	// #7
    40002174:	8b21c861 	add	x1, x3, w1, sxtw #2
	for (int i = 0; i < nb_buckets; i++) {
    40002178:	d2800003 	mov	x3, #0x0                   	// #0
    4000217c:	d343fc21 	lsr	x1, x1, #3
    40002180:	6b03009f 	cmp	w4, w3
    40002184:	5400020c 	b.gt	400021c4 <sys_heap_init+0x98>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    40002188:	531f7823 	lsl	w3, w1, #1
		((uint32_t *)cmem)[f] = val;
    4000218c:	8b010c05 	add	x5, x0, x1, lsl #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    40002190:	32000063 	orr	w3, w3, #0x1
	void *cmem = &buf[c];
    40002194:	d37df024 	lsl	x4, x1, #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    40002198:	29000c1f 	stp	wzr, w3, [x0]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    4000219c:	4b010043 	sub	w3, w2, w1
	void *cmem = &buf[c];
    400021a0:	d37d7c42 	ubfiz	x2, x2, #3, #32
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    400021a4:	531f7866 	lsl	w6, w3, #1
		((uint32_t *)cmem)[f] = val;
    400021a8:	b90004a6 	str	w6, [x5, #4]
    400021ac:	b8246801 	str	w1, [x0, x4]
    400021b0:	8b020004 	add	x4, x0, x2
    400021b4:	b8226803 	str	w3, [x0, x2]
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    400021b8:	52800022 	mov	w2, #0x1                   	// #1
    400021bc:	b9000482 	str	w2, [x4, #4]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
    400021c0:	17ffffb7 	b	4000209c <free_list_add>
		h->buckets[i].next = 0;
    400021c4:	b82378bf 	str	wzr, [x5, x3, lsl #2]
	for (int i = 0; i < nb_buckets; i++) {
    400021c8:	91000463 	add	x3, x3, #0x1
    400021cc:	17ffffed 	b	40002180 <sys_heap_init+0x54>

00000000400021d0 <setup_bundle_data.constprop.0>:
			      size_t offset, size_t num_bits)
{
	bd->sidx = offset / bundle_bitness(bitarray);
	bd->soff = offset % bundle_bitness(bitarray);

	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    400021d0:	d1000442 	sub	x2, x2, #0x1
	bd->sidx = offset / bundle_bitness(bitarray);
    400021d4:	d345fc25 	lsr	x5, x1, #5
	bd->soff = offset % bundle_bitness(bitarray);
    400021d8:	92401023 	and	x3, x1, #0x1f
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    400021dc:	8b010041 	add	x1, x2, x1
	bd->eoff = (offset + num_bits - 1) % bundle_bitness(bitarray);

	bd->smask = ~(BIT(bd->soff) - 1);
    400021e0:	d2800022 	mov	x2, #0x1                   	// #1
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    400021e4:	d345fc24 	lsr	x4, x1, #5
	bd->eoff = (offset + num_bits - 1) % bundle_bitness(bitarray);
    400021e8:	92401021 	and	x1, x1, #0x1f
    400021ec:	a9010403 	stp	x3, x1, [x0, #16]
	bd->smask = ~(BIT(bd->soff) - 1);
    400021f0:	9ac32043 	lsl	x3, x2, x3
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
    400021f4:	9ac12042 	lsl	x2, x2, x1
    400021f8:	51000441 	sub	w1, w2, #0x1
	bd->smask = ~(BIT(bd->soff) - 1);
    400021fc:	4b0303e3 	neg	w3, w3
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
    40002200:	2a020021 	orr	w1, w1, w2

	if (bd->sidx == bd->eidx) {
		/* The region lies within the same bundle. So combine the masks. */
		bd->smask &= bd->emask;
    40002204:	eb0400bf 	cmp	x5, x4
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
    40002208:	b9002401 	str	w1, [x0, #36]
		bd->smask &= bd->emask;
    4000220c:	0a010061 	and	w1, w3, w1
    40002210:	1a830021 	csel	w1, w1, w3, eq  // eq = none
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    40002214:	a9001005 	stp	x5, x4, [x0]
		bd->smask &= bd->emask;
    40002218:	b9002001 	str	w1, [x0, #32]
	}
}
    4000221c:	d65f03c0 	ret

0000000040002220 <set_region>:
 *                 prior call to match_region().
 */
static void set_region(sys_bitarray_t *bitarray, size_t offset,
		       size_t num_bits, bool to_set,
		       struct bundle_data *bd)
{
    40002220:	aa0003e7 	mov	x7, x0
    40002224:	12001c69 	and	w9, w3, #0xff
	int idx;
	struct bundle_data bdata;

	if (bd == NULL) {
    40002228:	b50005e4 	cbnz	x4, 400022e4 <set_region+0xc4>
{
    4000222c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
		bd = &bdata;
		setup_bundle_data(bitarray, bd, offset, num_bits);
    40002230:	910063e0 	add	x0, sp, #0x18
{
    40002234:	910003fd 	mov	x29, sp
		setup_bundle_data(bitarray, bd, offset, num_bits);
    40002238:	97ffffe6 	bl	400021d0 <setup_bundle_data.constprop.0>
	}

	if (bd->sidx == bd->eidx) {
		/* Start/end at same bundle */
		if (to_set) {
			bitarray->bundles[bd->sidx] |= bd->smask;
    4000223c:	f94004e2 	ldr	x2, [x7, #8]
	if (bd->sidx == bd->eidx) {
    40002240:	a9401801 	ldp	x1, x6, [x0]
			bitarray->bundles[bd->sidx] |= bd->smask;
    40002244:	b9402004 	ldr	w4, [x0, #32]
    40002248:	d37ef428 	lsl	x8, x1, #2
	if (bd->sidx == bd->eidx) {
    4000224c:	eb06003f 	cmp	x1, x6
			bitarray->bundles[bd->sidx] |= bd->smask;
    40002250:	b8686845 	ldr	w5, [x2, x8]
	if (bd->sidx == bd->eidx) {
    40002254:	54000101 	b.ne	40002274 <set_region+0x54>  // b.any
			bitarray->bundles[bd->sidx] |= bd->smask;
    40002258:	0a2400a0 	bic	w0, w5, w4
    4000225c:	7100013f 	cmp	w9, #0x0
    40002260:	2a0400a5 	orr	w5, w5, w4
    40002264:	1a8010a5 	csel	w5, w5, w0, ne  // ne = any
    40002268:	b8286845 	str	w5, [x2, x8]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
				bitarray->bundles[idx] = 0U;
			}
		}
	}
}
    4000226c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40002270:	d65f03c0 	ret
			bitarray->bundles[bd->eidx] |= bd->emask;
    40002274:	d37ef4c7 	lsl	x7, x6, #2
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40002278:	11000421 	add	w1, w1, #0x1
		if (to_set) {
    4000227c:	340001c9 	cbz	w9, 400022b4 <set_region+0x94>
			bitarray->bundles[bd->sidx] |= bd->smask;
    40002280:	2a0400a5 	orr	w5, w5, w4
    40002284:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] |= bd->emask;
    40002288:	b8676843 	ldr	w3, [x2, x7]
    4000228c:	b9402400 	ldr	w0, [x0, #36]
    40002290:	2a000063 	orr	w3, w3, w0
    40002294:	b8276843 	str	w3, [x2, x7]
				bitarray->bundles[idx] = ~0U;
    40002298:	12800003 	mov	w3, #0xffffffff            	// #-1
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    4000229c:	93407c20 	sxtw	x0, w1
    400022a0:	eb21c0df 	cmp	x6, w1, sxtw
    400022a4:	54fffe49 	b.ls	4000226c <set_region+0x4c>  // b.plast
    400022a8:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = ~0U;
    400022ac:	b8207843 	str	w3, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400022b0:	17fffffb 	b	4000229c <set_region+0x7c>
			bitarray->bundles[bd->sidx] &= ~bd->smask;
    400022b4:	0a2400a5 	bic	w5, w5, w4
    400022b8:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] &= ~bd->emask;
    400022bc:	b8676843 	ldr	w3, [x2, x7]
    400022c0:	b9402400 	ldr	w0, [x0, #36]
    400022c4:	0a200060 	bic	w0, w3, w0
    400022c8:	b8276840 	str	w0, [x2, x7]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400022cc:	93407c20 	sxtw	x0, w1
    400022d0:	eb21c0df 	cmp	x6, w1, sxtw
    400022d4:	54fffcc9 	b.ls	4000226c <set_region+0x4c>  // b.plast
    400022d8:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = 0U;
    400022dc:	b820785f 	str	wzr, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400022e0:	17fffffb 	b	400022cc <set_region+0xac>
    400022e4:	aa0403e0 	mov	x0, x4
			bitarray->bundles[bd->sidx] |= bd->smask;
    400022e8:	b9402084 	ldr	w4, [x4, #32]
    400022ec:	f94004e2 	ldr	x2, [x7, #8]
	if (bd->sidx == bd->eidx) {
    400022f0:	a9401801 	ldp	x1, x6, [x0]
			bitarray->bundles[bd->sidx] |= bd->smask;
    400022f4:	d37ef428 	lsl	x8, x1, #2
	if (bd->sidx == bd->eidx) {
    400022f8:	eb06003f 	cmp	x1, x6
			bitarray->bundles[bd->sidx] |= bd->smask;
    400022fc:	b8686845 	ldr	w5, [x2, x8]
	if (bd->sidx == bd->eidx) {
    40002300:	540000e1 	b.ne	4000231c <set_region+0xfc>  // b.any
			bitarray->bundles[bd->sidx] |= bd->smask;
    40002304:	0a2400a0 	bic	w0, w5, w4
    40002308:	7100013f 	cmp	w9, #0x0
    4000230c:	2a0400a5 	orr	w5, w5, w4
    40002310:	1a8010a5 	csel	w5, w5, w0, ne  // ne = any
    40002314:	b8286845 	str	w5, [x2, x8]
    40002318:	d65f03c0 	ret
			bitarray->bundles[bd->eidx] |= bd->emask;
    4000231c:	d37ef4c7 	lsl	x7, x6, #2
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40002320:	11000421 	add	w1, w1, #0x1
		if (to_set) {
    40002324:	340001e9 	cbz	w9, 40002360 <set_region+0x140>
			bitarray->bundles[bd->sidx] |= bd->smask;
    40002328:	2a0400a5 	orr	w5, w5, w4
    4000232c:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] |= bd->emask;
    40002330:	b8676843 	ldr	w3, [x2, x7]
    40002334:	b9402400 	ldr	w0, [x0, #36]
    40002338:	2a000063 	orr	w3, w3, w0
    4000233c:	b8276843 	str	w3, [x2, x7]
				bitarray->bundles[idx] = ~0U;
    40002340:	12800003 	mov	w3, #0xffffffff            	// #-1
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40002344:	93407c20 	sxtw	x0, w1
    40002348:	eb21c0df 	cmp	x6, w1, sxtw
    4000234c:	54000048 	b.hi	40002354 <set_region+0x134>  // b.pmore
    40002350:	d65f03c0 	ret
    40002354:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = ~0U;
    40002358:	b8207843 	str	w3, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    4000235c:	17fffffa 	b	40002344 <set_region+0x124>
			bitarray->bundles[bd->sidx] &= ~bd->smask;
    40002360:	0a2400a5 	bic	w5, w5, w4
    40002364:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] &= ~bd->emask;
    40002368:	b8676843 	ldr	w3, [x2, x7]
    4000236c:	b9402400 	ldr	w0, [x0, #36]
    40002370:	0a200060 	bic	w0, w3, w0
    40002374:	b8276840 	str	w0, [x2, x7]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40002378:	93407c20 	sxtw	x0, w1
    4000237c:	eb21c0df 	cmp	x6, w1, sxtw
    40002380:	54000048 	b.hi	40002388 <set_region+0x168>  // b.pmore
    40002384:	d65f03c0 	ret
    40002388:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = 0U;
    4000238c:	b820785f 	str	wzr, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40002390:	17fffffa 	b	40002378 <set_region+0x158>

0000000040002394 <set_clear_region>:
	return is_region_set_clear(bitarray, num_bits, offset, false);
}

static int set_clear_region(sys_bitarray_t *bitarray, size_t num_bits,
			    size_t offset, bool to_set)
{
    40002394:	aa0103e5 	mov	x5, x1
    40002398:	aa0203e1 	mov	x1, x2
	int ret;
	size_t off_end = offset + num_bits - 1;
    4000239c:	d10004a2 	sub	x2, x5, #0x1
    400023a0:	8b010042 	add	x2, x2, x1
MAKE_REG_HELPER(cntv_ctl_el0)
MAKE_REG_HELPER(cntv_cval_el0)
MAKE_REG_HELPER(cntvct_el0);
MAKE_REG_HELPER(cntvoff_el2);
MAKE_REG_HELPER(currentel);
MAKE_REG_HELPER(daif)
    400023a4:	d53b422a 	mrs	x10, daif
			  :: "i" (DAIFCLR_IRQ_BIT) : "memory");
}

static ALWAYS_INLINE void disable_irq(void)
{
	__asm__ volatile ("msr DAIFSet, %0"
    400023a8:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&bitarray->lock);

	__ASSERT_NO_MSG(bitarray->num_bits > 0);

	if ((num_bits == 0)
    400023ac:	b4000265 	cbz	x5, 400023f8 <set_clear_region+0x64>
	    || (num_bits > bitarray->num_bits)
    400023b0:	b9400004 	ldr	w4, [x0]
    400023b4:	eb05009f 	cmp	x4, x5
    400023b8:	54000203 	b.cc	400023f8 <set_clear_region+0x64>  // b.lo, b.ul, b.last
	    || (offset >= bitarray->num_bits)
    400023bc:	eb01009f 	cmp	x4, x1
    400023c0:	540001c9 	b.ls	400023f8 <set_clear_region+0x64>  // b.plast
	    || (off_end >= bitarray->num_bits)) {
    400023c4:	eb02009f 	cmp	x4, x2
    400023c8:	54000189 	b.ls	400023f8 <set_clear_region+0x64>  // b.plast
{
    400023cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400023d0:	12001c63 	and	w3, w3, #0xff
		ret = -EINVAL;
		goto out;
	}

	set_region(bitarray, offset, num_bits, to_set, NULL);
    400023d4:	aa0503e2 	mov	x2, x5
{
    400023d8:	910003fd 	mov	x29, sp
	set_region(bitarray, offset, num_bits, to_set, NULL);
    400023dc:	d2800004 	mov	x4, #0x0                   	// #0
    400023e0:	97ffff90 	bl	40002220 <set_region>
	ret = 0;
    400023e4:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    400023e8:	92407d4a 	and	x10, x10, #0xffffffff
    400023ec:	d51b422a 	msr	daif, x10

out:
	k_spin_unlock(&bitarray->lock, key);
	return ret;
}
    400023f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400023f4:	d65f03c0 	ret
		ret = -EINVAL;
    400023f8:	128002a0 	mov	w0, #0xffffffea            	// #-22
    400023fc:	92407d4a 	and	x10, x10, #0xffffffff
    40002400:	d51b422a 	msr	daif, x10
}
    40002404:	d65f03c0 	ret

0000000040002408 <match_region>:
{
    40002408:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000240c:	aa0003e8 	mov	x8, x0
    40002410:	aa0403e0 	mov	x0, x4
    40002414:	910003fd 	mov	x29, sp
    40002418:	12001c67 	and	w7, w3, #0xff
    4000241c:	aa0503e6 	mov	x6, x5
	setup_bundle_data(bitarray, bd, offset, num_bits);
    40002420:	97ffff6c 	bl	400021d0 <setup_bundle_data.constprop.0>
	if (bd->sidx == bd->eidx) {
    40002424:	a9401002 	ldp	x2, x4, [x0]
    40002428:	b9402001 	ldr	w1, [x0, #32]
    4000242c:	f9400503 	ldr	x3, [x8, #8]
    40002430:	eb04005f 	cmp	x2, x4
    40002434:	54000221 	b.ne	40002478 <match_region+0x70>  // b.any
		bundle = bitarray->bundles[bd->sidx];
    40002438:	b8627860 	ldr	w0, [x3, x2, lsl #2]
		if (!match_set) {
    4000243c:	35000047 	cbnz	w7, 40002444 <match_region+0x3c>
			bundle = ~bundle;
    40002440:	2a2003e0 	mvn	w0, w0
		if ((bundle & bd->smask) != bd->smask) {
    40002444:	6a20003f 	bics	wzr, w1, w0
    40002448:	54000400 	b.eq	400024c8 <match_region+0xc0>  // b.none
			mismatch_bundle = ~bundle & bd->smask;
    4000244c:	0a200020 	bic	w0, w1, w0
	if (mismatch != NULL) {
    40002450:	b4000106 	cbz	x6, 40002470 <match_region+0x68>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
    40002454:	7100001f 	cmp	w0, #0x0
    40002458:	5ac00000 	rbit	w0, w0
    4000245c:	5ac01000 	clz	w0, w0
    40002460:	1a8007e0 	csinc	w0, wzr, w0, eq  // eq = none
		mismatch_bit_off = find_lsb_set(mismatch_bundle) - 1;
    40002464:	51000400 	sub	w0, w0, #0x1
		*mismatch = (uint32_t)mismatch_bit_off;
    40002468:	0b021400 	add	w0, w0, w2, lsl #5
    4000246c:	f90000c0 	str	x0, [x6]
	return false;
    40002470:	52800000 	mov	w0, #0x0                   	// #0
    40002474:	14000016 	b	400024cc <match_region+0xc4>
	bundle = bitarray->bundles[bd->sidx];
    40002478:	b8627865 	ldr	w5, [x3, x2, lsl #2]
	if (!match_set) {
    4000247c:	35000047 	cbnz	w7, 40002484 <match_region+0x7c>
		bundle = ~bundle;
    40002480:	2a2503e5 	mvn	w5, w5
	if ((bundle & bd->smask) != bd->smask) {
    40002484:	6a25003f 	bics	wzr, w1, w5
    40002488:	54000060 	b.eq	40002494 <match_region+0x8c>  // b.none
		mismatch_bundle = ~bundle & bd->smask;
    4000248c:	0a250020 	bic	w0, w1, w5
		goto mismatch;
    40002490:	17fffff0 	b	40002450 <match_region+0x48>
	bundle = bitarray->bundles[bd->eidx];
    40002494:	b8647861 	ldr	w1, [x3, x4, lsl #2]
	if (!match_set) {
    40002498:	35000047 	cbnz	w7, 400024a0 <match_region+0x98>
		bundle = ~bundle;
    4000249c:	2a2103e1 	mvn	w1, w1
	if ((bundle & bd->emask) != bd->emask) {
    400024a0:	b9402400 	ldr	w0, [x0, #36]
    400024a4:	6a21001f 	bics	wzr, w0, w1
    400024a8:	54000080 	b.eq	400024b8 <match_region+0xb0>  // b.none
		mismatch_bundle = ~bundle & bd->emask;
    400024ac:	0a210000 	bic	w0, w0, w1
		goto mismatch;
    400024b0:	aa0403e2 	mov	x2, x4
    400024b4:	17ffffe7 	b	40002450 <match_region+0x48>
	for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400024b8:	11000441 	add	w1, w2, #0x1
    400024bc:	93407c22 	sxtw	x2, w1
    400024c0:	eb21c09f 	cmp	x4, w1, sxtw
    400024c4:	54000088 	b.hi	400024d4 <match_region+0xcc>  // b.pmore
	return true;
    400024c8:	52800020 	mov	w0, #0x1                   	// #1
}
    400024cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400024d0:	d65f03c0 	ret
		bundle = bitarray->bundles[idx];
    400024d4:	b8627860 	ldr	w0, [x3, x2, lsl #2]
		if (match_set) {
    400024d8:	34000047 	cbz	w7, 400024e0 <match_region+0xd8>
			bundle = ~bundle;
    400024dc:	2a2003e0 	mvn	w0, w0
		if (bundle != 0U) {
    400024e0:	34000060 	cbz	w0, 400024ec <match_region+0xe4>
			mismatch_bundle = ~bundle;
    400024e4:	2a2003e0 	mvn	w0, w0
			goto mismatch;
    400024e8:	17ffffda 	b	40002450 <match_region+0x48>
	for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400024ec:	11000421 	add	w1, w1, #0x1
    400024f0:	17fffff3 	b	400024bc <match_region+0xb4>

00000000400024f4 <sys_bitarray_alloc>:
    400024f4:	d53b422d 	mrs	x13, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400024f8:	d50342df 	msr	daifset, #0x2
	CHECKIF(offset == NULL) {
    400024fc:	b4000502 	cbz	x2, 4000259c <sys_bitarray_alloc+0xa8>
    40002500:	aa0103ea 	mov	x10, x1
	if ((num_bits == 0) || (num_bits > bitarray->num_bits)) {
    40002504:	b40004c1 	cbz	x1, 4000259c <sys_bitarray_alloc+0xa8>
    40002508:	b9400001 	ldr	w1, [x0]
    4000250c:	aa0003e9 	mov	x9, x0
    40002510:	eb0a003f 	cmp	x1, x10
    40002514:	54000443 	b.cc	4000259c <sys_bitarray_alloc+0xa8>  // b.lo, b.ul, b.last
    40002518:	aa0203ec 	mov	x12, x2
    4000251c:	b9400522 	ldr	w2, [x9, #4]
	for (ret = 0; ret < bitarray->num_bundles; ret++) {
    40002520:	52800000 	mov	w0, #0x0                   	// #0
    40002524:	531b6804 	lsl	w4, w0, #5
    40002528:	6b02001f 	cmp	w0, w2
    4000252c:	540001e0 	b.eq	40002568 <sys_bitarray_alloc+0x74>  // b.none
		if (~bitarray->bundles[ret] == 0U) {
    40002530:	f9400523 	ldr	x3, [x9, #8]
    40002534:	b860d863 	ldr	w3, [x3, w0, sxtw #2]
    40002538:	3100047f 	cmn	w3, #0x1
    4000253c:	54000061 	b.ne	40002548 <sys_bitarray_alloc+0x54>  // b.any
	for (ret = 0; ret < bitarray->num_bundles; ret++) {
    40002540:	11000400 	add	w0, w0, #0x1
    40002544:	17fffff8 	b	40002524 <sys_bitarray_alloc+0x30>
		if (bitarray->bundles[ret] != 0U) {
    40002548:	34000103 	cbz	w3, 40002568 <sys_bitarray_alloc+0x74>
			off_start = find_lsb_set(~bitarray->bundles[ret]) - 1;
    4000254c:	2a2303e3 	mvn	w3, w3
			bit_idx += off_start;
    40002550:	51000484 	sub	w4, w4, #0x1
    40002554:	7100007f 	cmp	w3, #0x0
    40002558:	5ac00063 	rbit	w3, w3
    4000255c:	5ac01063 	clz	w3, w3
    40002560:	1a8307e3 	csinc	w3, wzr, w3, eq  // eq = none
    40002564:	0b030084 	add	w4, w4, w3
	off_end = bitarray->num_bits - num_bits;
    40002568:	cb0a002b 	sub	x11, x1, x10
	while (bit_idx <= off_end) {
    4000256c:	2a0403ee 	mov	w14, w4
    40002570:	eb24417f 	cmp	x11, w4, uxtw
    40002574:	540001c2 	b.cs	400025ac <sys_bitarray_alloc+0xb8>  // b.hs, b.nlast
	ret = -ENOSPC;
    40002578:	12800360 	mov	w0, #0xffffffe4            	// #-28
    4000257c:	14000009 	b	400025a0 <sys_bitarray_alloc+0xac>
		bit_idx = mismatch + 1;
    40002580:	f9400be4 	ldr	x4, [sp, #16]
    40002584:	11000484 	add	w4, w4, #0x1
	while (bit_idx <= off_end) {
    40002588:	2a0403ee 	mov	w14, w4
    4000258c:	eb24417f 	cmp	x11, w4, uxtw
    40002590:	54000122 	b.cs	400025b4 <sys_bitarray_alloc+0xc0>  // b.hs, b.nlast
	ret = -ENOSPC;
    40002594:	12800360 	mov	w0, #0xffffffe4            	// #-28
out:
    40002598:	14000018 	b	400025f8 <sys_bitarray_alloc+0x104>
		ret = -EINVAL;
    4000259c:	128002a0 	mov	w0, #0xffffffea            	// #-22
MAKE_REG_HELPER(daif)
    400025a0:	92407dad 	and	x13, x13, #0xffffffff
    400025a4:	d51b422d 	msr	daif, x13
}
    400025a8:	d65f03c0 	ret
{
    400025ac:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400025b0:	910003fd 	mov	x29, sp
		if (match_region(bitarray, bit_idx, num_bits, false,
    400025b4:	910043e5 	add	x5, sp, #0x10
    400025b8:	910063e4 	add	x4, sp, #0x18
    400025bc:	aa0a03e2 	mov	x2, x10
    400025c0:	aa0e03e1 	mov	x1, x14
    400025c4:	aa0903e0 	mov	x0, x9
    400025c8:	52800003 	mov	w3, #0x0                   	// #0
    400025cc:	97ffff8f 	bl	40002408 <match_region>
    400025d0:	72001c1f 	tst	w0, #0xff
    400025d4:	54fffd60 	b.eq	40002580 <sys_bitarray_alloc+0x8c>  // b.none
			set_region(bitarray, bit_idx, num_bits, true, &bd);
    400025d8:	aa0903e0 	mov	x0, x9
    400025dc:	910063e4 	add	x4, sp, #0x18
    400025e0:	aa0a03e2 	mov	x2, x10
    400025e4:	aa0e03e1 	mov	x1, x14
    400025e8:	52800023 	mov	w3, #0x1                   	// #1
    400025ec:	97ffff0d 	bl	40002220 <set_region>
			ret = 0;
    400025f0:	52800000 	mov	w0, #0x0                   	// #0
			*offset = bit_idx;
    400025f4:	f900018e 	str	x14, [x12]
    400025f8:	92407dad 	and	x13, x13, #0xffffffff
    400025fc:	d51b422d 	msr	daif, x13
}
    40002600:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40002604:	d65f03c0 	ret

0000000040002608 <sys_bitarray_free>:
{
    40002608:	aa0103e9 	mov	x9, x1
	size_t off_end = offset + num_bits - 1;
    4000260c:	d1000421 	sub	x1, x1, #0x1
    40002610:	8b020021 	add	x1, x1, x2
    40002614:	d53b422c 	mrs	x12, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40002618:	d50342df 	msr	daifset, #0x2
	if ((num_bits == 0)
    4000261c:	b40003e9 	cbz	x9, 40002698 <sys_bitarray_free+0x90>
    40002620:	aa0203ea 	mov	x10, x2
	    || (num_bits > bitarray->num_bits)
    40002624:	b9400002 	ldr	w2, [x0]
    40002628:	aa0003eb 	mov	x11, x0
    4000262c:	eb09005f 	cmp	x2, x9
    40002630:	54000343 	b.cc	40002698 <sys_bitarray_free+0x90>  // b.lo, b.ul, b.last
	    || (offset >= bitarray->num_bits)
    40002634:	eb0a005f 	cmp	x2, x10
    40002638:	54000309 	b.ls	40002698 <sys_bitarray_free+0x90>  // b.plast
	    || (off_end >= bitarray->num_bits)) {
    4000263c:	eb01005f 	cmp	x2, x1
    40002640:	540002c9 	b.ls	40002698 <sys_bitarray_free+0x90>  // b.plast
{
    40002644:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	if (match_region(bitarray, offset, num_bits, true, &bd, NULL)) {
    40002648:	aa0903e2 	mov	x2, x9
    4000264c:	aa0a03e1 	mov	x1, x10
{
    40002650:	910003fd 	mov	x29, sp
	if (match_region(bitarray, offset, num_bits, true, &bd, NULL)) {
    40002654:	910063e4 	add	x4, sp, #0x18
    40002658:	d2800005 	mov	x5, #0x0                   	// #0
    4000265c:	52800023 	mov	w3, #0x1                   	// #1
    40002660:	97ffff6a 	bl	40002408 <match_region>
    40002664:	72001c1f 	tst	w0, #0xff
    40002668:	54000200 	b.eq	400026a8 <sys_bitarray_free+0xa0>  // b.none
		set_region(bitarray, offset, num_bits, false, &bd);
    4000266c:	aa0b03e0 	mov	x0, x11
    40002670:	910063e4 	add	x4, sp, #0x18
    40002674:	aa0903e2 	mov	x2, x9
    40002678:	aa0a03e1 	mov	x1, x10
    4000267c:	52800003 	mov	w3, #0x0                   	// #0
    40002680:	97fffee8 	bl	40002220 <set_region>
		ret = 0;
    40002684:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    40002688:	92407d8c 	and	x12, x12, #0xffffffff
    4000268c:	d51b422c 	msr	daif, x12
}
    40002690:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40002694:	d65f03c0 	ret
		ret = -EINVAL;
    40002698:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4000269c:	92407d8c 	and	x12, x12, #0xffffffff
    400026a0:	d51b422c 	msr	daif, x12
}
    400026a4:	d65f03c0 	ret
		ret = -EFAULT;
    400026a8:	128001a0 	mov	w0, #0xfffffff2            	// #-14
    400026ac:	17fffff7 	b	40002688 <sys_bitarray_free+0x80>

00000000400026b0 <sys_bitarray_set_region>:

int sys_bitarray_set_region(sys_bitarray_t *bitarray, size_t num_bits,
			    size_t offset)
{
	return set_clear_region(bitarray, num_bits, offset, true);
    400026b0:	52800023 	mov	w3, #0x1                   	// #1
    400026b4:	17ffff38 	b	40002394 <set_clear_region>

00000000400026b8 <_get_digit>:

/* Extract the next decimal character in the converted representation of a
 * fractional component.
 */
static char _get_digit(uint64_t *fr, int *digit_count)
{
    400026b8:	aa0003e3 	mov	x3, x0
	char rval;

	if (*digit_count > 0) {
    400026bc:	b9400020 	ldr	w0, [x1]
    400026c0:	7100001f 	cmp	w0, #0x0
    400026c4:	5400016d 	b.le	400026f0 <_get_digit+0x38>
		--*digit_count;
    400026c8:	51000400 	sub	w0, w0, #0x1
    400026cc:	b9000020 	str	w0, [x1]
		*fr *= 10U;
    400026d0:	f9400061 	ldr	x1, [x3]
    400026d4:	d2800140 	mov	x0, #0xa                   	// #10
    400026d8:	9b007c21 	mul	x1, x1, x0
		rval = ((*fr >> 60) & 0xF) + '0';
    400026dc:	d37cfc22 	lsr	x2, x1, #60
		*fr &= (BIT64(60) - 1U);
    400026e0:	9240ec21 	and	x1, x1, #0xfffffffffffffff
		rval = ((*fr >> 60) & 0xF) + '0';
    400026e4:	1100c040 	add	w0, w2, #0x30
		*fr &= (BIT64(60) - 1U);
    400026e8:	f9000061 	str	x1, [x3]
	} else {
		rval = '0';
	}

	return rval;
}
    400026ec:	d65f03c0 	ret
		rval = '0';
    400026f0:	52800600 	mov	w0, #0x30                  	// #48
    400026f4:	17fffffe 	b	400026ec <_get_digit+0x34>

00000000400026f8 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
    400026f8:	aa0003e5 	mov	x5, x0
    400026fc:	aa0303e0 	mov	x0, x3
	bool upcase = isupper((int)conv->specifier);
    40002700:	39400c23 	ldrb	w3, [x1, #3]
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    40002704:	51010468 	sub	w8, w3, #0x41
	switch (specifier) {
    40002708:	7101bc7f 	cmp	w3, #0x6f
    4000270c:	54000380 	b.eq	4000277c <encode_uint+0x84>  // b.none
    40002710:	54000308 	b.hi	40002770 <encode_uint+0x78>  // b.pmore
		return 16;
    40002714:	7101607f 	cmp	w3, #0x58
    40002718:	d2800144 	mov	x4, #0xa                   	// #10
    4000271c:	d2800203 	mov	x3, #0x10                  	// #16
    40002720:	9a831084 	csel	x4, x4, x3, ne  // ne = any
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
    40002724:	9ac408a7 	udiv	x7, x5, x4
    40002728:	9b0494e6 	msub	x6, x7, x4, x5

		*--bp = (lsv <= 9) ? ('0' + lsv)
    4000272c:	12001cc3 	and	w3, w6, #0xff
    40002730:	f10024df 	cmp	x6, #0x9
    40002734:	540002c8 	b.hi	4000278c <encode_uint+0x94>  // b.pmore
    40002738:	1100c063 	add	w3, w3, #0x30
    4000273c:	12001c63 	and	w3, w3, #0xff
    40002740:	381ffc03 	strb	w3, [x0, #-1]!
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
	} while ((value != 0) && (bps < bp));
    40002744:	eb0400bf 	cmp	x5, x4
    40002748:	fa422000 	ccmp	x0, x2, #0x0, cs  // cs = hs, nlast
    4000274c:	540001c8 	b.hi	40002784 <encode_uint+0x8c>  // b.pmore

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
    40002750:	79400022 	ldrh	w2, [x1]
    40002754:	362800c2 	tbz	w2, #5, 4000276c <encode_uint+0x74>
		if (radix == 8) {
    40002758:	f100209f 	cmp	x4, #0x8
    4000275c:	54000261 	b.ne	400027a8 <encode_uint+0xb0>  // b.any
			conv->altform_0 = true;
    40002760:	39400822 	ldrb	w2, [x1, #2]
    40002764:	321d0042 	orr	w2, w2, #0x8
		} else if (radix == 16) {
			conv->altform_0c = true;
    40002768:	39000822 	strb	w2, [x1, #2]
			;
		}
	}

	return bp;
}
    4000276c:	d65f03c0 	ret
	switch (specifier) {
    40002770:	121c7863 	and	w3, w3, #0xfffffff7
		return 16;
    40002774:	7101c07f 	cmp	w3, #0x70
    40002778:	17ffffe8 	b	40002718 <encode_uint+0x20>
	switch (specifier) {
    4000277c:	d2800104 	mov	x4, #0x8                   	// #8
	char *bp = bps + (bpe - bps);
    40002780:	17ffffe9 	b	40002724 <encode_uint+0x2c>
		value /= radix;
    40002784:	aa0703e5 	mov	x5, x7
    40002788:	17ffffe7 	b	40002724 <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    4000278c:	1100dc66 	add	w6, w3, #0x37
    40002790:	11015c63 	add	w3, w3, #0x57
    40002794:	12001cc6 	and	w6, w6, #0xff
    40002798:	12001c63 	and	w3, w3, #0xff
    4000279c:	7100651f 	cmp	w8, #0x19
    400027a0:	1a868063 	csel	w3, w3, w6, hi  // hi = pmore
    400027a4:	17ffffe7 	b	40002740 <encode_uint+0x48>
		} else if (radix == 16) {
    400027a8:	f100409f 	cmp	x4, #0x10
    400027ac:	54fffe01 	b.ne	4000276c <encode_uint+0x74>  // b.any
			conv->altform_0c = true;
    400027b0:	39400822 	ldrb	w2, [x1, #2]
    400027b4:	321c0042 	orr	w2, w2, #0x10
    400027b8:	17ffffec 	b	40002768 <encode_uint+0x70>

00000000400027bc <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    400027bc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400027c0:	910003fd 	mov	x29, sp
    400027c4:	a90153f3 	stp	x19, x20, [sp, #16]
    400027c8:	aa0203f4 	mov	x20, x2
	size_t count = 0;
    400027cc:	d2800013 	mov	x19, #0x0                   	// #0
{
    400027d0:	a9025bf5 	stp	x21, x22, [sp, #32]
    400027d4:	aa0003f6 	mov	x22, x0
    400027d8:	aa0303f5 	mov	x21, x3
    400027dc:	f9001bf7 	str	x23, [sp, #48]
    400027e0:	aa0103f7 	mov	x23, x1

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    400027e4:	8b130280 	add	x0, x20, x19
    400027e8:	eb0002bf 	cmp	x21, x0
    400027ec:	54000148 	b.hi	40002814 <outs+0x58>  // b.pmore
    400027f0:	b40000f5 	cbz	x21, 4000280c <outs+0x50>
			return rc;
		}
		++count;
	}

	return (int)count;
    400027f4:	2a1303e0 	mov	w0, w19
}
    400027f8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400027fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40002800:	f9401bf7 	ldr	x23, [sp, #48]
    40002804:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40002808:	d65f03c0 	ret
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    4000280c:	38736a80 	ldrb	w0, [x20, x19]
    40002810:	34ffff20 	cbz	w0, 400027f4 <outs+0x38>
		int rc = out((int)*sp++, ctx);
    40002814:	38736a80 	ldrb	w0, [x20, x19]
    40002818:	aa1703e1 	mov	x1, x23
    4000281c:	d63f02c0 	blr	x22
		if (rc < 0) {
    40002820:	37fffec0 	tbnz	w0, #31, 400027f8 <outs+0x3c>
		++count;
    40002824:	91000673 	add	x19, x19, #0x1
    40002828:	17ffffef 	b	400027e4 <outs+0x28>

000000004000282c <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    4000282c:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
    40002830:	910003fd 	mov	x29, sp
    40002834:	a90153f3 	stp	x19, x20, [sp, #16]
    40002838:	aa0003f4 	mov	x20, x0
    4000283c:	a90363f7 	stp	x23, x24, [sp, #48]
    40002840:	a9406073 	ldp	x19, x24, [x3]
    40002844:	a90573fb 	stp	x27, x28, [sp, #80]
    40002848:	b940187c 	ldr	w28, [x3, #24]
    4000284c:	f9400860 	ldr	x0, [x3, #16]
    40002850:	a9025bf5 	stp	x21, x22, [sp, #32]
    40002854:	aa0103f5 	mov	x21, x1
    40002858:	f90037e0 	str	x0, [sp, #104]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    4000285c:	d280001b 	mov	x27, #0x0                   	// #0
    40002860:	b9401c60 	ldr	w0, [x3, #28]
{
    40002864:	a9046bf9 	stp	x25, x26, [sp, #64]
    40002868:	b9007be0 	str	w0, [sp, #120]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    4000286c:	39400040 	ldrb	w0, [x2]
    40002870:	35000060 	cbnz	w0, 4000287c <cbvprintf+0x50>
			OUTC(' ');
			--width;
		}
	}

	return count;
    40002874:	2a1b03e0 	mov	w0, w27
    40002878:	14000425 	b	4000390c <cbvprintf+0x10e0>
			OUTC(*fp++);
    4000287c:	91000456 	add	x22, x2, #0x1
		if (*fp != '%') {
    40002880:	7100941f 	cmp	w0, #0x25
    40002884:	540000c0 	b.eq	4000289c <cbvprintf+0x70>  // b.none
			OUTC(*fp++);
    40002888:	aa1503e1 	mov	x1, x21
			OUTC('%');
    4000288c:	d63f0280 	blr	x20
    40002890:	37f883e0 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    40002894:	9100077b 	add	x27, x27, #0x1
		if (bps == NULL) {
    40002898:	14000195 	b	40002eec <cbvprintf+0x6c0>
	if (*sp == '%') {
    4000289c:	39400440 	ldrb	w0, [x2, #1]
		} state = {
    400028a0:	a90b7fff 	stp	xzr, xzr, [sp, #176]
	if (*sp == '%') {
    400028a4:	7100941f 	cmp	w0, #0x25
		} state = {
    400028a8:	a90c7fff 	stp	xzr, xzr, [sp, #192]
	if (*sp == '%') {
    400028ac:	540006a1 	b.ne	40002980 <cbvprintf+0x154>  // b.any
		conv->specifier = *sp++;
    400028b0:	91000856 	add	x22, x2, #0x2
    400028b4:	39030fe0 	strb	w0, [sp, #195]
		if (conv->width_star) {
    400028b8:	794183e0 	ldrh	w0, [sp, #192]
    400028bc:	36402900 	tbz	w0, #8, 40002ddc <cbvprintf+0x5b0>
			width = va_arg(ap, int);
    400028c0:	37f8279c 	tbnz	w28, #31, 40002db0 <cbvprintf+0x584>
    400028c4:	91002e61 	add	x1, x19, #0xb
    400028c8:	aa1303e0 	mov	x0, x19
    400028cc:	927df033 	and	x19, x1, #0xfffffffffffffff8
    400028d0:	b9400017 	ldr	w23, [x0]
			if (width < 0) {
    400028d4:	36f800b7 	tbz	w23, #31, 400028e8 <cbvprintf+0xbc>
				conv->flag_dash = true;
    400028d8:	794183e0 	ldrh	w0, [sp, #192]
				width = -width;
    400028dc:	4b1703f7 	neg	w23, w23
				conv->flag_dash = true;
    400028e0:	321e0000 	orr	w0, w0, #0x4
    400028e4:	790183e0 	strh	w0, [sp, #192]
		if (conv->prec_star) {
    400028e8:	794183e0 	ldrh	w0, [sp, #192]
    400028ec:	36502960 	tbz	w0, #10, 40002e18 <cbvprintf+0x5ec>
			int arg = va_arg(ap, int);
    400028f0:	37f827fc 	tbnz	w28, #31, 40002dec <cbvprintf+0x5c0>
    400028f4:	91002e61 	add	x1, x19, #0xb
    400028f8:	aa1303e0 	mov	x0, x19
    400028fc:	927df033 	and	x19, x1, #0xfffffffffffffff8
    40002900:	b9400009 	ldr	w9, [x0]
			if (arg < 0) {
    40002904:	36f800a9 	tbz	w9, #31, 40002918 <cbvprintf+0xec>
				conv->prec_present = false;
    40002908:	794183e0 	ldrh	w0, [sp, #192]
		int precision = -1;
    4000290c:	12800009 	mov	w9, #0xffffffff            	// #-1
				conv->prec_present = false;
    40002910:	12167800 	and	w0, w0, #0xfffffdff
    40002914:	790183e0 	strh	w0, [sp, #192]
		    && (conv->specifier_cat == SPECIFIER_FP)
    40002918:	39430be0 	ldrb	w0, [sp, #194]
		conv->pad0_value = 0;
    4000291c:	f80c43ff 	stur	xzr, [sp, #196]
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)
    40002920:	12000800 	and	w0, w0, #0x7
    40002924:	7100101f 	cmp	w0, #0x4
    40002928:	f94063e3 	ldr	x3, [sp, #192]
    4000292c:	54000101 	b.ne	4000294c <cbvprintf+0x120>  // b.any
		    && !conv->prec_present) {
    40002930:	7217007f 	tst	w3, #0x200
    40002934:	540000c1 	b.ne	4000294c <cbvprintf+0x120>  // b.any
			if (conv->specifier_a) {
    40002938:	79c183e0 	ldrsh	w0, [sp, #192]
				precision = 6;
    4000293c:	528001a9 	mov	w9, #0xd                   	// #13
    40002940:	7100001f 	cmp	w0, #0x0
    40002944:	528000c0 	mov	w0, #0x6                   	// #6
    40002948:	1a80b129 	csel	w9, w9, w0, lt  // lt = tstop
		enum specifier_cat_enum specifier_cat
    4000294c:	53104860 	ubfx	w0, w3, #16, #3
			= (enum length_mod_enum)conv->length_mod;
    40002950:	530b3861 	ubfx	w1, w3, #11, #4
		if (specifier_cat == SPECIFIER_SINT) {
    40002954:	7100041f 	cmp	w0, #0x1
    40002958:	54002ce1 	b.ne	40002ef4 <cbvprintf+0x6c8>  // b.any
			switch (length_mod) {
    4000295c:	51000c24 	sub	w4, w1, #0x3
    40002960:	7100109f 	cmp	w4, #0x4
    40002964:	54002628 	b.hi	40002e28 <cbvprintf+0x5fc>  // b.pmore
    40002968:	d0000080 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    4000296c:	91100000 	add	x0, x0, #0x400
    40002970:	78645800 	ldrh	w0, [x0, w4, uxtw #1]
    40002974:	10000064 	adr	x4, 40002980 <cbvprintf+0x154>
    40002978:	8b20a880 	add	x0, x4, w0, sxth #2
    4000297c:	d61f0000 	br	x0
    40002980:	52800003 	mov	w3, #0x0                   	// #0
    40002984:	52800005 	mov	w5, #0x0                   	// #0
    40002988:	52800004 	mov	w4, #0x0                   	// #0
    4000298c:	52800006 	mov	w6, #0x0                   	// #0
    40002990:	52800001 	mov	w1, #0x0                   	// #0
		switch (*sp) {
    40002994:	394002c0 	ldrb	w0, [x22]
    40002998:	7100ac1f 	cmp	w0, #0x2b
    4000299c:	540009a0 	b.eq	40002ad0 <cbvprintf+0x2a4>  // b.none
    400029a0:	540008c8 	b.hi	40002ab8 <cbvprintf+0x28c>  // b.pmore
    400029a4:	7100801f 	cmp	w0, #0x20
    400029a8:	540009a0 	b.eq	40002adc <cbvprintf+0x2b0>  // b.none
    400029ac:	71008c1f 	cmp	w0, #0x23
    400029b0:	540009a0 	b.eq	40002ae4 <cbvprintf+0x2b8>  // b.none
    400029b4:	34000081 	cbz	w1, 400029c4 <cbvprintf+0x198>
    400029b8:	794183e1 	ldrh	w1, [sp, #192]
    400029bc:	321e0021 	orr	w1, w1, #0x4
    400029c0:	790183e1 	strh	w1, [sp, #192]
    400029c4:	34000086 	cbz	w6, 400029d4 <cbvprintf+0x1a8>
    400029c8:	794183e1 	ldrh	w1, [sp, #192]
    400029cc:	321d0021 	orr	w1, w1, #0x8
    400029d0:	790183e1 	strh	w1, [sp, #192]
    400029d4:	34000084 	cbz	w4, 400029e4 <cbvprintf+0x1b8>
    400029d8:	794183e1 	ldrh	w1, [sp, #192]
    400029dc:	321c0021 	orr	w1, w1, #0x10
    400029e0:	790183e1 	strh	w1, [sp, #192]
    400029e4:	34000085 	cbz	w5, 400029f4 <cbvprintf+0x1c8>
    400029e8:	794183e1 	ldrh	w1, [sp, #192]
    400029ec:	321b0021 	orr	w1, w1, #0x20
    400029f0:	790183e1 	strh	w1, [sp, #192]
    400029f4:	34000083 	cbz	w3, 40002a04 <cbvprintf+0x1d8>
    400029f8:	794183e1 	ldrh	w1, [sp, #192]
    400029fc:	321a0021 	orr	w1, w1, #0x40
    40002a00:	790183e1 	strh	w1, [sp, #192]
	if (conv->flag_zero && conv->flag_dash) {
    40002a04:	b940c3e1 	ldr	w1, [sp, #192]
    40002a08:	52800883 	mov	w3, #0x44                  	// #68
    40002a0c:	0a030021 	and	w1, w1, w3
    40002a10:	6b03003f 	cmp	w1, w3
    40002a14:	54000081 	b.ne	40002a24 <cbvprintf+0x1f8>  // b.any
		conv->flag_zero = false;
    40002a18:	794183e1 	ldrh	w1, [sp, #192]
    40002a1c:	12197821 	and	w1, w1, #0xffffffbf
    40002a20:	790183e1 	strh	w1, [sp, #192]
	conv->width_present = true;
    40002a24:	794183e3 	ldrh	w3, [sp, #192]
	if (*sp == '*') {
    40002a28:	7100a81f 	cmp	w0, #0x2a
	conv->width_present = true;
    40002a2c:	32190061 	orr	w1, w3, #0x80
    40002a30:	790183e1 	strh	w1, [sp, #192]
	if (*sp == '*') {
    40002a34:	54000861 	b.ne	40002b40 <cbvprintf+0x314>  // b.any
			++sp;
    40002a38:	910006c1 	add	x1, x22, #0x1
		conv->width_star = true;
    40002a3c:	32190463 	orr	w3, w3, #0x180
    40002a40:	790183e3 	strh	w3, [sp, #192]
	conv->prec_present = (*sp == '.');
    40002a44:	39400020 	ldrb	w0, [x1]
    40002a48:	7100b81f 	cmp	w0, #0x2e
    40002a4c:	794183e0 	ldrh	w0, [sp, #192]
    40002a50:	1a9f17e3 	cset	w3, eq  // eq = none
    40002a54:	33170060 	bfi	w0, w3, #9, #1
    40002a58:	790183e0 	strh	w0, [sp, #192]
	if (!conv->prec_present) {
    40002a5c:	54000841 	b.ne	40002b64 <cbvprintf+0x338>  // b.any
	if (*sp == '*') {
    40002a60:	39400423 	ldrb	w3, [x1, #1]
    40002a64:	7100a87f 	cmp	w3, #0x2a
    40002a68:	54000780 	b.eq	40002b58 <cbvprintf+0x32c>  // b.none
	++sp;
    40002a6c:	91000421 	add	x1, x1, #0x1
	size_t val = 0;
    40002a70:	d2800000 	mov	x0, #0x0                   	// #0
		val = 10U * val + *sp++ - '0';
    40002a74:	d2800146 	mov	x6, #0xa                   	// #10
	while (isdigit((int)(unsigned char)*sp)) {
    40002a78:	aa0103e3 	mov	x3, x1
    40002a7c:	38401464 	ldrb	w4, [x3], #1
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    40002a80:	5100c085 	sub	w5, w4, #0x30
    40002a84:	710024bf 	cmp	w5, #0x9
    40002a88:	54000c49 	b.ls	40002c10 <cbvprintf+0x3e4>  // b.plast
	conv->unsupported |= ((conv->prec_value < 0)
    40002a8c:	f94063e3 	ldr	x3, [sp, #192]
	conv->prec_value = prec;
    40002a90:	b900cbe0 	str	w0, [sp, #200]
	conv->unsupported |= ((conv->prec_value < 0)
    40002a94:	53010463 	ubfx	w3, w3, #1, #1
			      || (prec != (size_t)conv->prec_value));
    40002a98:	37f80c60 	tbnz	w0, #31, 40002c24 <cbvprintf+0x3f8>
    40002a9c:	eb20c01f 	cmp	x0, w0, sxtw
    40002aa0:	1a9f07e0 	cset	w0, ne  // ne = any
	conv->unsupported |= ((conv->prec_value < 0)
    40002aa4:	2a000060 	orr	w0, w3, w0
    40002aa8:	794183e3 	ldrh	w3, [sp, #192]
    40002aac:	331f0003 	bfi	w3, w0, #1, #1
    40002ab0:	790183e3 	strh	w3, [sp, #192]
	return sp;
    40002ab4:	1400002c 	b	40002b64 <cbvprintf+0x338>
		switch (*sp) {
    40002ab8:	7100b41f 	cmp	w0, #0x2d
    40002abc:	54000180 	b.eq	40002aec <cbvprintf+0x2c0>  // b.none
    40002ac0:	7100c01f 	cmp	w0, #0x30
    40002ac4:	54fff781 	b.ne	400029b4 <cbvprintf+0x188>  // b.any
			conv->flag_zero = true;
    40002ac8:	52800023 	mov	w3, #0x1                   	// #1
    40002acc:	14000002 	b	40002ad4 <cbvprintf+0x2a8>
			conv->flag_plus = true;
    40002ad0:	52800026 	mov	w6, #0x1                   	// #1
			++sp;
    40002ad4:	910006d6 	add	x22, x22, #0x1
	} while (loop);
    40002ad8:	17ffffaf 	b	40002994 <cbvprintf+0x168>
			conv->flag_space = true;
    40002adc:	52800024 	mov	w4, #0x1                   	// #1
    40002ae0:	17fffffd 	b	40002ad4 <cbvprintf+0x2a8>
			conv->flag_hash = true;
    40002ae4:	52800025 	mov	w5, #0x1                   	// #1
    40002ae8:	17fffffb 	b	40002ad4 <cbvprintf+0x2a8>
		switch (*sp) {
    40002aec:	52800021 	mov	w1, #0x1                   	// #1
    40002af0:	17fffff9 	b	40002ad4 <cbvprintf+0x2a8>
		val = 10U * val + *sp++ - '0';
    40002af4:	9b067c00 	mul	x0, x0, x6
    40002af8:	aa0303e1 	mov	x1, x3
    40002afc:	d100c000 	sub	x0, x0, #0x30
    40002b00:	8b240000 	add	x0, x0, w4, uxtb
	while (isdigit((int)(unsigned char)*sp)) {
    40002b04:	aa0103e3 	mov	x3, x1
    40002b08:	38401464 	ldrb	w4, [x3], #1
    40002b0c:	5100c085 	sub	w5, w4, #0x30
    40002b10:	710024bf 	cmp	w5, #0x9
    40002b14:	54ffff09 	b.ls	40002af4 <cbvprintf+0x2c8>  // b.plast
	if (sp != wp) {
    40002b18:	eb0102df 	cmp	x22, x1
    40002b1c:	54fff940 	b.eq	40002a44 <cbvprintf+0x218>  // b.none
		conv->width_value = width;
    40002b20:	b900c7e0 	str	w0, [sp, #196]
				      || (width != (size_t)conv->width_value));
    40002b24:	37f80160 	tbnz	w0, #31, 40002b50 <cbvprintf+0x324>
    40002b28:	eb20c01f 	cmp	x0, w0, sxtw
    40002b2c:	1a9f07e3 	cset	w3, ne  // ne = any
		conv->unsupported |= ((conv->width_value < 0)
    40002b30:	794183e0 	ldrh	w0, [sp, #192]
    40002b34:	331f0060 	bfi	w0, w3, #1, #1
    40002b38:	790183e0 	strh	w0, [sp, #192]
    40002b3c:	17ffffc2 	b	40002a44 <cbvprintf+0x218>
    40002b40:	aa1603e1 	mov	x1, x22
	size_t val = 0;
    40002b44:	d2800000 	mov	x0, #0x0                   	// #0
		val = 10U * val + *sp++ - '0';
    40002b48:	d2800146 	mov	x6, #0xa                   	// #10
    40002b4c:	17ffffee 	b	40002b04 <cbvprintf+0x2d8>
				      || (width != (size_t)conv->width_value));
    40002b50:	52800023 	mov	w3, #0x1                   	// #1
    40002b54:	17fffff7 	b	40002b30 <cbvprintf+0x304>
		return ++sp;
    40002b58:	91000821 	add	x1, x1, #0x2
		conv->prec_star = true;
    40002b5c:	32160000 	orr	w0, w0, #0x400
    40002b60:	790183e0 	strh	w0, [sp, #192]
	switch (*sp) {
    40002b64:	aa0103f6 	mov	x22, x1
    40002b68:	384016c0 	ldrb	w0, [x22], #1
    40002b6c:	7101b01f 	cmp	w0, #0x6c
    40002b70:	54000860 	b.eq	40002c7c <cbvprintf+0x450>  // b.none
    40002b74:	540005c8 	b.hi	40002c2c <cbvprintf+0x400>  // b.pmore
    40002b78:	7101a01f 	cmp	w0, #0x68
    40002b7c:	54000660 	b.eq	40002c48 <cbvprintf+0x41c>  // b.none
    40002b80:	7101a81f 	cmp	w0, #0x6a
    40002b84:	540008c0 	b.eq	40002c9c <cbvprintf+0x470>  // b.none
    40002b88:	7101301f 	cmp	w0, #0x4c
    40002b8c:	54000940 	b.eq	40002cb4 <cbvprintf+0x488>  // b.none
    40002b90:	aa0103f6 	mov	x22, x1
	conv->specifier = *sp++;
    40002b94:	384016c0 	ldrb	w0, [x22], #1
    40002b98:	39030fe0 	strb	w0, [sp, #195]
	switch (conv->specifier) {
    40002b9c:	7101e01f 	cmp	w0, #0x78
    40002ba0:	54001008 	b.hi	40002da0 <cbvprintf+0x574>  // b.pmore
    40002ba4:	71015c1f 	cmp	w0, #0x57
    40002ba8:	54000928 	b.hi	40002ccc <cbvprintf+0x4a0>  // b.pmore
    40002bac:	7101041f 	cmp	w0, #0x41
    40002bb0:	540000a0 	b.eq	40002bc4 <cbvprintf+0x398>  // b.none
    40002bb4:	51011401 	sub	w1, w0, #0x45
    40002bb8:	12001c21 	and	w1, w1, #0xff
    40002bbc:	7100083f 	cmp	w1, #0x2
    40002bc0:	54000f08 	b.hi	40002da0 <cbvprintf+0x574>  // b.pmore
			|| (conv->specifier == 'A');
    40002bc4:	121a7800 	and	w0, w0, #0xffffffdf
		conv->specifier_a = (conv->specifier == 'a')
    40002bc8:	784c13e1 	ldurh	w1, [sp, #193]
			|| (conv->specifier == 'A');
    40002bcc:	7101041f 	cmp	w0, #0x41
    40002bd0:	1a9f17e0 	cset	w0, eq  // eq = none
		conv->specifier_a = (conv->specifier == 'a')
    40002bd4:	12156c21 	and	w1, w1, #0xfffff87f
    40002bd8:	53196000 	lsl	w0, w0, #7
    40002bdc:	32160000 	orr	w0, w0, #0x400
    40002be0:	2a010000 	orr	w0, w0, w1
    40002be4:	780c13e0 	sturh	w0, [sp, #193]
		if (conv->specifier_a
    40002be8:	79c183e1 	ldrsh	w1, [sp, #192]
    40002bec:	794183e0 	ldrh	w0, [sp, #192]
    40002bf0:	37f80dc1 	tbnz	w1, #31, 40002da8 <cbvprintf+0x57c>
		if (conv->length_mod == LENGTH_L) {
    40002bf4:	12150c03 	and	w3, w0, #0x7800
    40002bf8:	52830001 	mov	w1, #0x1800                	// #6144
    40002bfc:	6b01007f 	cmp	w3, w1
    40002c00:	54000a61 	b.ne	40002d4c <cbvprintf+0x520>  // b.any
			conv->length_mod = LENGTH_NONE;
    40002c04:	12116c00 	and	w0, w0, #0xffff87ff
    40002c08:	790183e0 	strh	w0, [sp, #192]
    40002c0c:	14000045 	b	40002d20 <cbvprintf+0x4f4>
		val = 10U * val + *sp++ - '0';
    40002c10:	9b067c00 	mul	x0, x0, x6
    40002c14:	aa0303e1 	mov	x1, x3
    40002c18:	d100c000 	sub	x0, x0, #0x30
    40002c1c:	8b240000 	add	x0, x0, w4, uxtb
    40002c20:	17ffff96 	b	40002a78 <cbvprintf+0x24c>
			      || (prec != (size_t)conv->prec_value));
    40002c24:	52800020 	mov	w0, #0x1                   	// #1
    40002c28:	17ffff9f 	b	40002aa4 <cbvprintf+0x278>
	switch (*sp) {
    40002c2c:	7101d01f 	cmp	w0, #0x74
    40002c30:	540003c0 	b.eq	40002ca8 <cbvprintf+0x47c>  // b.none
    40002c34:	7101e81f 	cmp	w0, #0x7a
    40002c38:	54fffac1 	b.ne	40002b90 <cbvprintf+0x364>  // b.any
		conv->length_mod = LENGTH_Z;
    40002c3c:	794183e0 	ldrh	w0, [sp, #192]
    40002c40:	528000c1 	mov	w1, #0x6                   	// #6
    40002c44:	1400000b 	b	40002c70 <cbvprintf+0x444>
		if (*++sp == 'h') {
    40002c48:	39400420 	ldrb	w0, [x1, #1]
    40002c4c:	7101a01f 	cmp	w0, #0x68
    40002c50:	794183e0 	ldrh	w0, [sp, #192]
    40002c54:	540000c1 	b.ne	40002c6c <cbvprintf+0x440>  // b.any
			conv->length_mod = LENGTH_HH;
    40002c58:	52800023 	mov	w3, #0x1                   	// #1
			conv->length_mod = LENGTH_LL;
    40002c5c:	33150c60 	bfi	w0, w3, #11, #4
			++sp;
    40002c60:	91000836 	add	x22, x1, #0x2
			conv->length_mod = LENGTH_LL;
    40002c64:	790183e0 	strh	w0, [sp, #192]
			++sp;
    40002c68:	17ffffcb 	b	40002b94 <cbvprintf+0x368>
			conv->length_mod = LENGTH_H;
    40002c6c:	52800041 	mov	w1, #0x2                   	// #2
		conv->length_mod = LENGTH_T;
    40002c70:	33150c20 	bfi	w0, w1, #11, #4
		conv->unsupported = true;
    40002c74:	790183e0 	strh	w0, [sp, #192]
		break;
    40002c78:	17ffffc7 	b	40002b94 <cbvprintf+0x368>
		if (*++sp == 'l') {
    40002c7c:	39400420 	ldrb	w0, [x1, #1]
    40002c80:	7101b01f 	cmp	w0, #0x6c
    40002c84:	794183e0 	ldrh	w0, [sp, #192]
    40002c88:	54000061 	b.ne	40002c94 <cbvprintf+0x468>  // b.any
			conv->length_mod = LENGTH_LL;
    40002c8c:	52800083 	mov	w3, #0x4                   	// #4
    40002c90:	17fffff3 	b	40002c5c <cbvprintf+0x430>
			conv->length_mod = LENGTH_L;
    40002c94:	52800061 	mov	w1, #0x3                   	// #3
    40002c98:	17fffff6 	b	40002c70 <cbvprintf+0x444>
		conv->length_mod = LENGTH_J;
    40002c9c:	794183e0 	ldrh	w0, [sp, #192]
    40002ca0:	528000a1 	mov	w1, #0x5                   	// #5
    40002ca4:	17fffff3 	b	40002c70 <cbvprintf+0x444>
		conv->length_mod = LENGTH_T;
    40002ca8:	794183e0 	ldrh	w0, [sp, #192]
    40002cac:	528000e1 	mov	w1, #0x7                   	// #7
    40002cb0:	17fffff0 	b	40002c70 <cbvprintf+0x444>
		conv->unsupported = true;
    40002cb4:	794183e0 	ldrh	w0, [sp, #192]
    40002cb8:	128f0041 	mov	w1, #0xffff87fd            	// #-30723
    40002cbc:	0a010000 	and	w0, w0, w1
    40002cc0:	52880041 	mov	w1, #0x4002                	// #16386
    40002cc4:	2a010000 	orr	w0, w0, w1
    40002cc8:	17ffffeb 	b	40002c74 <cbvprintf+0x448>
	switch (conv->specifier) {
    40002ccc:	51016003 	sub	w3, w0, #0x58
    40002cd0:	7100807f 	cmp	w3, #0x20
    40002cd4:	54000668 	b.hi	40002da0 <cbvprintf+0x574>  // b.pmore
    40002cd8:	d0000081 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    40002cdc:	91103021 	add	x1, x1, #0x40c
    40002ce0:	38634821 	ldrb	w1, [x1, w3, uxtw]
    40002ce4:	10000063 	adr	x3, 40002cf0 <cbvprintf+0x4c4>
    40002ce8:	8b218861 	add	x1, x3, w1, sxtb #2
    40002cec:	d61f0020 	br	x1
		conv->specifier_cat = SPECIFIER_SINT;
    40002cf0:	39430be1 	ldrb	w1, [sp, #194]
    40002cf4:	52800023 	mov	w3, #0x1                   	// #1
		conv->specifier_cat = SPECIFIER_UINT;
    40002cf8:	33000861 	bfxil	w1, w3, #0, #3
    40002cfc:	39030be1 	strb	w1, [sp, #194]
		if (conv->length_mod == LENGTH_UPPER_L) {
    40002d00:	794183e1 	ldrh	w1, [sp, #192]
    40002d04:	12150c23 	and	w3, w1, #0x7800
    40002d08:	7140107f 	cmp	w3, #0x4, lsl #12
    40002d0c:	54000061 	b.ne	40002d18 <cbvprintf+0x4ec>  // b.any
			conv->invalid = true;
    40002d10:	32000021 	orr	w1, w1, #0x1
    40002d14:	790183e1 	strh	w1, [sp, #192]
		if (conv->specifier == 'c') {
    40002d18:	71018c1f 	cmp	w0, #0x63
    40002d1c:	540003a0 	b.eq	40002d90 <cbvprintf+0x564>  // b.none
	bool unsupported = false;
    40002d20:	52800000 	mov	w0, #0x0                   	// #0
	conv->unsupported |= unsupported;
    40002d24:	f94063e1 	ldr	x1, [sp, #192]
    40002d28:	d3410421 	ubfx	x1, x1, #1, #1
    40002d2c:	2a010000 	orr	w0, w0, w1
    40002d30:	794183e1 	ldrh	w1, [sp, #192]
    40002d34:	331f0001 	bfi	w1, w0, #1, #1
    40002d38:	790183e1 	strh	w1, [sp, #192]
	return sp;
    40002d3c:	17fffedf 	b	400028b8 <cbvprintf+0x8c>
		conv->specifier_cat = SPECIFIER_UINT;
    40002d40:	39430be1 	ldrb	w1, [sp, #194]
    40002d44:	52800043 	mov	w3, #0x2                   	// #2
    40002d48:	17ffffec 	b	40002cf8 <cbvprintf+0x4cc>
		} else if ((conv->length_mod != LENGTH_NONE)
    40002d4c:	7215081f 	tst	w0, #0x3800
    40002d50:	54fffe80 	b.eq	40002d20 <cbvprintf+0x4f4>  // b.none
		conv->invalid = true;
    40002d54:	32000000 	orr	w0, w0, #0x1
    40002d58:	17ffffac 	b	40002c08 <cbvprintf+0x3dc>
		conv->specifier_cat = SPECIFIER_PTR;
    40002d5c:	39430be0 	ldrb	w0, [sp, #194]
    40002d60:	52800061 	mov	w1, #0x3                   	// #3
    40002d64:	33000820 	bfxil	w0, w1, #0, #3
    40002d68:	39030be0 	strb	w0, [sp, #194]
		if (conv->length_mod == LENGTH_UPPER_L) {
    40002d6c:	794183e0 	ldrh	w0, [sp, #192]
    40002d70:	12150c00 	and	w0, w0, #0x7800
    40002d74:	7140101f 	cmp	w0, #0x4, lsl #12
    40002d78:	1a9f17e0 	cset	w0, eq  // eq = none
    40002d7c:	17ffffea 	b	40002d24 <cbvprintf+0x4f8>
		conv->specifier_cat = SPECIFIER_PTR;
    40002d80:	39430be0 	ldrb	w0, [sp, #194]
    40002d84:	52800061 	mov	w1, #0x3                   	// #3
    40002d88:	33000820 	bfxil	w0, w1, #0, #3
    40002d8c:	39030be0 	strb	w0, [sp, #194]
		if (conv->length_mod != LENGTH_NONE) {
    40002d90:	794183e0 	ldrh	w0, [sp, #192]
    40002d94:	72150c1f 	tst	w0, #0x7800
    40002d98:	1a9f07e0 	cset	w0, ne  // ne = any
    40002d9c:	17ffffe2 	b	40002d24 <cbvprintf+0x4f8>
		conv->invalid = true;
    40002da0:	794183e0 	ldrh	w0, [sp, #192]
    40002da4:	17ffffec 	b	40002d54 <cbvprintf+0x528>
			unsupported = true;
    40002da8:	52800020 	mov	w0, #0x1                   	// #1
    40002dac:	17ffffde 	b	40002d24 <cbvprintf+0x4f8>
			width = va_arg(ap, int);
    40002db0:	11002381 	add	w1, w28, #0x8
    40002db4:	7100003f 	cmp	w1, #0x0
    40002db8:	540000cd 	b.le	40002dd0 <cbvprintf+0x5a4>
    40002dbc:	91002e63 	add	x3, x19, #0xb
    40002dc0:	aa1303e0 	mov	x0, x19
    40002dc4:	2a0103fc 	mov	w28, w1
    40002dc8:	927df073 	and	x19, x3, #0xfffffffffffffff8
    40002dcc:	17fffec1 	b	400028d0 <cbvprintf+0xa4>
    40002dd0:	8b3cc300 	add	x0, x24, w28, sxtw
    40002dd4:	2a0103fc 	mov	w28, w1
    40002dd8:	17fffebe 	b	400028d0 <cbvprintf+0xa4>
			width = conv->width_value;
    40002ddc:	b940c7f7 	ldr	w23, [sp, #196]
    40002de0:	f279001f 	tst	x0, #0x80
    40002de4:	5a9f12f7 	csinv	w23, w23, wzr, ne  // ne = any
    40002de8:	17fffec0 	b	400028e8 <cbvprintf+0xbc>
			int arg = va_arg(ap, int);
    40002dec:	11002381 	add	w1, w28, #0x8
    40002df0:	7100003f 	cmp	w1, #0x0
    40002df4:	540000cd 	b.le	40002e0c <cbvprintf+0x5e0>
    40002df8:	91002e63 	add	x3, x19, #0xb
    40002dfc:	aa1303e0 	mov	x0, x19
    40002e00:	2a0103fc 	mov	w28, w1
    40002e04:	927df073 	and	x19, x3, #0xfffffffffffffff8
    40002e08:	17fffebe 	b	40002900 <cbvprintf+0xd4>
    40002e0c:	8b3cc300 	add	x0, x24, w28, sxtw
    40002e10:	2a0103fc 	mov	w28, w1
    40002e14:	17fffebb 	b	40002900 <cbvprintf+0xd4>
			precision = conv->prec_value;
    40002e18:	b940cbe9 	ldr	w9, [sp, #200]
    40002e1c:	f277001f 	tst	x0, #0x200
    40002e20:	5a9f1129 	csinv	w9, w9, wzr, ne  // ne = any
    40002e24:	17fffebd 	b	40002918 <cbvprintf+0xec>
				value->sint = va_arg(ap, int);
    40002e28:	37f8019c 	tbnz	w28, #31, 40002e58 <cbvprintf+0x62c>
    40002e2c:	91002e60 	add	x0, x19, #0xb
    40002e30:	2a1c03e4 	mov	w4, w28
    40002e34:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002e38:	b9800265 	ldrsw	x5, [x19]
				value->sint =
    40002e3c:	f9005be5 	str	x5, [sp, #176]
				break;
    40002e40:	2a0403fc 	mov	w28, w4
    40002e44:	aa0003f3 	mov	x19, x0
			if (length_mod == LENGTH_HH) {
    40002e48:	7100043f 	cmp	w1, #0x1
    40002e4c:	54000361 	b.ne	40002eb8 <cbvprintf+0x68c>  // b.any
				value->uint = (unsigned char)value->uint;
    40002e50:	3942c3e0 	ldrb	w0, [sp, #176]
    40002e54:	1400001c 	b	40002ec4 <cbvprintf+0x698>
				value->sint = va_arg(ap, int);
    40002e58:	11002384 	add	w4, w28, #0x8
    40002e5c:	7100009f 	cmp	w4, #0x0
    40002e60:	5400008d 	b.le	40002e70 <cbvprintf+0x644>
    40002e64:	91002e60 	add	x0, x19, #0xb
    40002e68:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002e6c:	17fffff3 	b	40002e38 <cbvprintf+0x60c>
    40002e70:	aa1303e0 	mov	x0, x19
    40002e74:	8b3cc313 	add	x19, x24, w28, sxtw
    40002e78:	17fffff0 	b	40002e38 <cbvprintf+0x60c>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    40002e7c:	37f800dc 	tbnz	w28, #31, 40002e94 <cbvprintf+0x668>
    40002e80:	91003e60 	add	x0, x19, #0xf
    40002e84:	2a1c03e4 	mov	w4, w28
    40002e88:	927df000 	and	x0, x0, #0xfffffffffffffff8
				value->sint =
    40002e8c:	f9400265 	ldr	x5, [x19]
    40002e90:	17ffffeb 	b	40002e3c <cbvprintf+0x610>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    40002e94:	11002384 	add	w4, w28, #0x8
    40002e98:	7100009f 	cmp	w4, #0x0
    40002e9c:	5400008d 	b.le	40002eac <cbvprintf+0x680>
    40002ea0:	91003e60 	add	x0, x19, #0xf
    40002ea4:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002ea8:	17fffff9 	b	40002e8c <cbvprintf+0x660>
    40002eac:	aa1303e0 	mov	x0, x19
    40002eb0:	8b3cc313 	add	x19, x24, w28, sxtw
    40002eb4:	17fffff6 	b	40002e8c <cbvprintf+0x660>
			} else if (length_mod == LENGTH_H) {
    40002eb8:	7100083f 	cmp	w1, #0x2
    40002ebc:	54000061 	b.ne	40002ec8 <cbvprintf+0x69c>  // b.any
				value->sint = (short)value->sint;
    40002ec0:	798163e0 	ldrsh	x0, [sp, #176]
				value->uint = (unsigned short)value->uint;
    40002ec4:	f9005be0 	str	x0, [sp, #176]
		if (conv->invalid || conv->unsupported) {
    40002ec8:	b940c3e0 	ldr	w0, [sp, #192]
    40002ecc:	f240041f 	tst	x0, #0x3
    40002ed0:	540011c0 	b.eq	40003108 <cbvprintf+0x8dc>  // b.none
			OUTS(sp, fp);
    40002ed4:	aa1603e3 	mov	x3, x22
    40002ed8:	aa1503e1 	mov	x1, x21
    40002edc:	aa1403e0 	mov	x0, x20
    40002ee0:	97fffe37 	bl	400027bc <outs>
    40002ee4:	37f85140 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    40002ee8:	8b20c37b 	add	x27, x27, w0, sxtw
			while (pad_len-- > 0) {
    40002eec:	aa1603e2 	mov	x2, x22
    40002ef0:	17fffe5f 	b	4000286c <cbvprintf+0x40>
		} else if (specifier_cat == SPECIFIER_UINT) {
    40002ef4:	7100081f 	cmp	w0, #0x2
    40002ef8:	54000881 	b.ne	40003008 <cbvprintf+0x7dc>  // b.any
			switch (length_mod) {
    40002efc:	51000c24 	sub	w4, w1, #0x3
    40002f00:	7100109f 	cmp	w4, #0x4
    40002f04:	540000e8 	b.hi	40002f20 <cbvprintf+0x6f4>  // b.pmore
    40002f08:	d0000080 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    40002f0c:	9110c000 	add	x0, x0, #0x430
    40002f10:	38644800 	ldrb	w0, [x0, w4, uxtw]
    40002f14:	10000064 	adr	x4, 40002f20 <cbvprintf+0x6f4>
    40002f18:	8b208880 	add	x0, x4, w0, sxtb #2
    40002f1c:	d61f0000 	br	x0
				value->uint = va_arg(ap, unsigned int);
    40002f20:	37f801dc 	tbnz	w28, #31, 40002f58 <cbvprintf+0x72c>
    40002f24:	91002e60 	add	x0, x19, #0xb
    40002f28:	2a1c03e4 	mov	w4, w28
    40002f2c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002f30:	b9400265 	ldr	w5, [x19]
				value->uint =
    40002f34:	f9005be5 	str	x5, [sp, #176]
				break;
    40002f38:	2a0403fc 	mov	w28, w4
    40002f3c:	aa0003f3 	mov	x19, x0
			if (length_mod == LENGTH_HH) {
    40002f40:	7100043f 	cmp	w1, #0x1
    40002f44:	54fff860 	b.eq	40002e50 <cbvprintf+0x624>  // b.none
			} else if (length_mod == LENGTH_H) {
    40002f48:	7100083f 	cmp	w1, #0x2
    40002f4c:	54fffbe1 	b.ne	40002ec8 <cbvprintf+0x69c>  // b.any
				value->uint = (unsigned short)value->uint;
    40002f50:	794163e0 	ldrh	w0, [sp, #176]
    40002f54:	17ffffdc 	b	40002ec4 <cbvprintf+0x698>
				value->uint = va_arg(ap, unsigned int);
    40002f58:	11002384 	add	w4, w28, #0x8
    40002f5c:	7100009f 	cmp	w4, #0x0
    40002f60:	5400008d 	b.le	40002f70 <cbvprintf+0x744>
    40002f64:	91002e60 	add	x0, x19, #0xb
    40002f68:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002f6c:	17fffff1 	b	40002f30 <cbvprintf+0x704>
    40002f70:	aa1303e0 	mov	x0, x19
    40002f74:	8b3cc313 	add	x19, x24, w28, sxtw
    40002f78:	17ffffee 	b	40002f30 <cbvprintf+0x704>
				if ((!WCHAR_IS_SIGNED)
    40002f7c:	39430fe0 	ldrb	w0, [sp, #195]
    40002f80:	71018c1f 	cmp	w0, #0x63
    40002f84:	54000a41 	b.ne	400030cc <cbvprintf+0x8a0>  // b.any
					value->uint = (wchar_t)va_arg(ap,
    40002f88:	37f8011c 	tbnz	w28, #31, 40002fa8 <cbvprintf+0x77c>
    40002f8c:	91002e60 	add	x0, x19, #0xb
    40002f90:	2a1c03e4 	mov	w4, w28
    40002f94:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002f98:	b9400265 	ldr	w5, [x19]
			value->ptr = va_arg(ap, void *);
    40002f9c:	2a0403fc 	mov	w28, w4
    40002fa0:	f9005be5 	str	x5, [sp, #176]
    40002fa4:	1400003a 	b	4000308c <cbvprintf+0x860>
					value->uint = (wchar_t)va_arg(ap,
    40002fa8:	11002384 	add	w4, w28, #0x8
    40002fac:	7100009f 	cmp	w4, #0x0
    40002fb0:	5400008d 	b.le	40002fc0 <cbvprintf+0x794>
    40002fb4:	91002e60 	add	x0, x19, #0xb
    40002fb8:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002fbc:	17fffff7 	b	40002f98 <cbvprintf+0x76c>
    40002fc0:	aa1303e0 	mov	x0, x19
    40002fc4:	8b3cc313 	add	x19, x24, w28, sxtw
    40002fc8:	17fffff4 	b	40002f98 <cbvprintf+0x76c>
					(uint_value_type)va_arg(ap, size_t);
    40002fcc:	37f800dc 	tbnz	w28, #31, 40002fe4 <cbvprintf+0x7b8>
    40002fd0:	91003e60 	add	x0, x19, #0xf
    40002fd4:	2a1c03e4 	mov	w4, w28
    40002fd8:	927df000 	and	x0, x0, #0xfffffffffffffff8
				value->uint =
    40002fdc:	f9400265 	ldr	x5, [x19]
    40002fe0:	17ffffd5 	b	40002f34 <cbvprintf+0x708>
					(uint_value_type)va_arg(ap, size_t);
    40002fe4:	11002384 	add	w4, w28, #0x8
    40002fe8:	7100009f 	cmp	w4, #0x0
    40002fec:	5400008d 	b.le	40002ffc <cbvprintf+0x7d0>
    40002ff0:	91003e60 	add	x0, x19, #0xf
    40002ff4:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002ff8:	17fffff9 	b	40002fdc <cbvprintf+0x7b0>
    40002ffc:	aa1303e0 	mov	x0, x19
    40003000:	8b3cc313 	add	x19, x24, w28, sxtw
    40003004:	17fffff6 	b	40002fdc <cbvprintf+0x7b0>
		} else if (specifier_cat == SPECIFIER_FP) {
    40003008:	7100101f 	cmp	w0, #0x4
    4000300c:	540005c1 	b.ne	400030c4 <cbvprintf+0x898>  // b.any
				value->ldbl = va_arg(ap, long double);
    40003010:	b9407be0 	ldr	w0, [sp, #120]
			if (length_mod == LENGTH_UPPER_L) {
    40003014:	7100203f 	cmp	w1, #0x8
    40003018:	540002c1 	b.ne	40003070 <cbvprintf+0x844>  // b.any
				value->ldbl = va_arg(ap, long double);
    4000301c:	37f80120 	tbnz	w0, #31, 40003040 <cbvprintf+0x814>
    40003020:	91003e60 	add	x0, x19, #0xf
    40003024:	b9407be4 	ldr	w4, [sp, #120]
    40003028:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    4000302c:	91004013 	add	x19, x0, #0x10
    40003030:	3dc00000 	ldr	q0, [x0]
    40003034:	b9007be4 	str	w4, [sp, #120]
    40003038:	3d802fe0 	str	q0, [sp, #176]
    4000303c:	17ffffa3 	b	40002ec8 <cbvprintf+0x69c>
    40003040:	b9407be0 	ldr	w0, [sp, #120]
    40003044:	11004004 	add	w4, w0, #0x10
    40003048:	7100009f 	cmp	w4, #0x0
    4000304c:	540000ad 	b.le	40003060 <cbvprintf+0x834>
    40003050:	91003e60 	add	x0, x19, #0xf
    40003054:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    40003058:	91004013 	add	x19, x0, #0x10
    4000305c:	17fffff5 	b	40003030 <cbvprintf+0x804>
    40003060:	f94037e5 	ldr	x5, [sp, #104]
    40003064:	b9407be0 	ldr	w0, [sp, #120]
    40003068:	8b20c0a0 	add	x0, x5, w0, sxtw
    4000306c:	17fffff1 	b	40003030 <cbvprintf+0x804>
				value->dbl = va_arg(ap, double);
    40003070:	37f80120 	tbnz	w0, #31, 40003094 <cbvprintf+0x868>
    40003074:	91003e60 	add	x0, x19, #0xf
    40003078:	b9407be4 	ldr	w4, [sp, #120]
    4000307c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40003080:	fd400260 	ldr	d0, [x19]
    40003084:	b9007be4 	str	w4, [sp, #120]
    40003088:	fd005be0 	str	d0, [sp, #176]
			value->ptr = va_arg(ap, void *);
    4000308c:	aa0003f3 	mov	x19, x0
    40003090:	17ffff8e 	b	40002ec8 <cbvprintf+0x69c>
				value->dbl = va_arg(ap, double);
    40003094:	b9407be0 	ldr	w0, [sp, #120]
    40003098:	11004004 	add	w4, w0, #0x10
    4000309c:	7100009f 	cmp	w4, #0x0
    400030a0:	5400008d 	b.le	400030b0 <cbvprintf+0x884>
    400030a4:	91003e60 	add	x0, x19, #0xf
    400030a8:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400030ac:	17fffff5 	b	40003080 <cbvprintf+0x854>
    400030b0:	f94037e6 	ldr	x6, [sp, #104]
    400030b4:	aa1303e0 	mov	x0, x19
    400030b8:	b9407be5 	ldr	w5, [sp, #120]
    400030bc:	8b25c0d3 	add	x19, x6, w5, sxtw
    400030c0:	17fffff0 	b	40003080 <cbvprintf+0x854>
		} else if (specifier_cat == SPECIFIER_PTR) {
    400030c4:	71000c1f 	cmp	w0, #0x3
    400030c8:	54fff001 	b.ne	40002ec8 <cbvprintf+0x69c>  // b.any
			value->ptr = va_arg(ap, void *);
    400030cc:	37f800dc 	tbnz	w28, #31, 400030e4 <cbvprintf+0x8b8>
    400030d0:	91003e60 	add	x0, x19, #0xf
    400030d4:	2a1c03e4 	mov	w4, w28
    400030d8:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400030dc:	f9400265 	ldr	x5, [x19]
    400030e0:	17ffffaf 	b	40002f9c <cbvprintf+0x770>
    400030e4:	11002384 	add	w4, w28, #0x8
    400030e8:	7100009f 	cmp	w4, #0x0
    400030ec:	5400008d 	b.le	400030fc <cbvprintf+0x8d0>
    400030f0:	91003e60 	add	x0, x19, #0xf
    400030f4:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400030f8:	17fffff9 	b	400030dc <cbvprintf+0x8b0>
    400030fc:	aa1303e0 	mov	x0, x19
    40003100:	8b3cc313 	add	x19, x24, w28, sxtw
    40003104:	17fffff6 	b	400030dc <cbvprintf+0x8b0>
		switch (conv->specifier) {
    40003108:	39430fe5 	ldrb	w5, [sp, #195]
    4000310c:	7101e0bf 	cmp	w5, #0x78
    40003110:	54ffeee8 	b.hi	40002eec <cbvprintf+0x6c0>  // b.pmore
    40003114:	71015cbf 	cmp	w5, #0x57
    40003118:	54000468 	b.hi	400031a4 <cbvprintf+0x978>  // b.pmore
    4000311c:	710094bf 	cmp	w5, #0x25
    40003120:	54000540 	b.eq	400031c8 <cbvprintf+0x99c>  // b.none
    40003124:	710090bf 	cmp	w5, #0x24
    40003128:	54ffee29 	b.ls	40002eec <cbvprintf+0x6c0>  // b.plast
    4000312c:	710104bf 	cmp	w5, #0x41
    40003130:	540000a0 	b.eq	40003144 <cbvprintf+0x918>  // b.none
    40003134:	510114a0 	sub	w0, w5, #0x45
    40003138:	12001c00 	and	w0, w0, #0xff
    4000313c:	7100081f 	cmp	w0, #0x2
    40003140:	54ffed68 	b.hi	40002eec <cbvprintf+0x6c0>  // b.pmore
	} u = {
    40003144:	f9405be0 	ldr	x0, [sp, #176]
	if ((u.u64 & SIGN_MASK) != 0U) {
    40003148:	b7f81240 	tbnz	x0, #63, 40003390 <cbvprintf+0xb64>
	} else if (conv->flag_plus) {
    4000314c:	794183e4 	ldrh	w4, [sp, #192]
    40003150:	37181244 	tbnz	w4, #3, 40003398 <cbvprintf+0xb6c>
		*sign = ' ';
    40003154:	d3441084 	ubfx	x4, x4, #4, #1
    40003158:	531b6884 	lsl	w4, w4, #5
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    4000315c:	d374f801 	ubfx	x1, x0, #52, #11
	uint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);
    40003160:	9240cc00 	and	x0, x0, #0xfffffffffffff
    40003164:	f90047e0 	str	x0, [sp, #136]
	if (expo == BIT_MASK(EXPONENT_BITS)) {
    40003168:	711ffc3f 	cmp	w1, #0x7ff
    4000316c:	54001341 	b.ne	400033d4 <cbvprintf+0xba8>  // b.any
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    40003170:	510104a5 	sub	w5, w5, #0x41
			if (isupper((int)c)) {
    40003174:	710064bf 	cmp	w5, #0x19
		if (fract == 0) {
    40003178:	b50011c0 	cbnz	x0, 400033b0 <cbvprintf+0xb84>
			if (isupper((int)c)) {
    4000317c:	54001128 	b.hi	400033a0 <cbvprintf+0xb74>  // b.pmore
				*buf++ = 'I';
    40003180:	5289c920 	mov	w0, #0x4e49                	// #20041
    40003184:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'F';
    40003188:	528008c0 	mov	w0, #0x46                  	// #70
				*buf++ = 'n';
    4000318c:	39024be0 	strb	w0, [sp, #146]
		*bpe = buf;
    40003190:	91024ff9 	add	x25, sp, #0x93
		conv->flag_zero = false;
    40003194:	794183e0 	ldrh	w0, [sp, #192]
    40003198:	12197800 	and	w0, w0, #0xffffffbf
    4000319c:	790183e0 	strh	w0, [sp, #192]
		return bps;
    400031a0:	1400001d 	b	40003214 <cbvprintf+0x9e8>
		switch (conv->specifier) {
    400031a4:	510160a2 	sub	w2, w5, #0x58
    400031a8:	7100805f 	cmp	w2, #0x20
    400031ac:	54ffea08 	b.hi	40002eec <cbvprintf+0x6c0>  // b.pmore
    400031b0:	b0000080 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    400031b4:	9110e000 	add	x0, x0, #0x438
    400031b8:	78625800 	ldrh	w0, [x0, w2, uxtw #1]
    400031bc:	10000062 	adr	x2, 400031c8 <cbvprintf+0x99c>
    400031c0:	8b20a840 	add	x0, x2, w0, sxth #2
    400031c4:	d61f0000 	br	x0
			OUTC('%');
    400031c8:	aa1503e1 	mov	x1, x21
    400031cc:	2a0503e0 	mov	w0, w5
    400031d0:	17fffdaf 	b	4000288c <cbvprintf+0x60>
			bps = (const char *)value->ptr;
    400031d4:	f9405bfa 	ldr	x26, [sp, #176]
			if (precision >= 0) {
    400031d8:	37f80109 	tbnz	w9, #31, 400031f8 <cbvprintf+0x9cc>
				len = strnlen(bps, precision);
    400031dc:	93407d21 	sxtw	x1, w9
    400031e0:	aa1a03e0 	mov	x0, x26
    400031e4:	94002810 	bl	4000d224 <strnlen>
			bpe = bps + len;
    400031e8:	8b000359 	add	x25, x26, x0
		char sign = 0;
    400031ec:	52800004 	mov	w4, #0x0                   	// #0
		if (bps == NULL) {
    400031f0:	b500015a 	cbnz	x26, 40003218 <cbvprintf+0x9ec>
    400031f4:	17ffff3e 	b	40002eec <cbvprintf+0x6c0>
				len = strlen(bps);
    400031f8:	aa1a03e0 	mov	x0, x26
    400031fc:	94002803 	bl	4000d208 <strlen>
    40003200:	17fffffa 	b	400031e8 <cbvprintf+0x9bc>
			bpe = buf + 1;
    40003204:	910247f9 	add	x25, sp, #0x91
		char sign = 0;
    40003208:	52800004 	mov	w4, #0x0                   	// #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    4000320c:	f9405be0 	ldr	x0, [sp, #176]
    40003210:	390243e0 	strb	w0, [sp, #144]
				bps = encode_float(value->dbl, conv, precision,
    40003214:	910243fa 	add	x26, sp, #0x90
		size_t nj_len = (bpe - bps);
    40003218:	cb1a0320 	sub	x0, x25, x26
		if (sign != 0) {
    4000321c:	34000044 	cbz	w4, 40003224 <cbvprintf+0x9f8>
			nj_len += 1U;
    40003220:	91000400 	add	x0, x0, #0x1
		if (conv->altform_0c) {
    40003224:	39430be5 	ldrb	w5, [sp, #194]
    40003228:	36202b85 	tbz	w5, #4, 40003798 <cbvprintf+0xf6c>
			nj_len += 2U;
    4000322c:	91000800 	add	x0, x0, #0x2
		nj_len += conv->pad0_value;
    40003230:	b980c7e1 	ldrsw	x1, [sp, #196]
    40003234:	8b000020 	add	x0, x1, x0
		if (conv->pad_fp) {
    40003238:	36300065 	tbz	w5, #6, 40003244 <cbvprintf+0xa18>
			nj_len += conv->pad0_pre_exp;
    4000323c:	b980cbe1 	ldrsw	x1, [sp, #200]
    40003240:	8b010000 	add	x0, x0, x1
		if (width > 0) {
    40003244:	710002ff 	cmp	w23, #0x0
    40003248:	54002c8d 	b.le	400037d8 <cbvprintf+0xfac>
			width -= (int)nj_len;
    4000324c:	4b0002f7 	sub	w23, w23, w0
			if (!conv->flag_dash) {
    40003250:	f94063e0 	ldr	x0, [sp, #192]
    40003254:	721e001f 	tst	w0, #0x4
    40003258:	54002c01 	b.ne	400037d8 <cbvprintf+0xfac>  // b.any
				if (conv->flag_zero) {
    4000325c:	794183e0 	ldrh	w0, [sp, #192]
    40003260:	36303080 	tbz	w0, #6, 40003870 <cbvprintf+0x1044>
					if (sign != 0) {
    40003264:	340000e4 	cbz	w4, 40003280 <cbvprintf+0xa54>
						OUTC(sign);
    40003268:	aa1503e1 	mov	x1, x21
    4000326c:	2a0403e0 	mov	w0, w4
    40003270:	d63f0280 	blr	x20
    40003274:	37f834c0 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    40003278:	9100077b 	add	x27, x27, #0x1
						sign = 0;
    4000327c:	52800004 	mov	w4, #0x0                   	// #0
					pad = '0';
    40003280:	52800605 	mov	w5, #0x30                  	// #48
    40003284:	1400017c 	b	40003874 <cbvprintf+0x1048>
			if (conv->flag_plus) {
    40003288:	794183e4 	ldrh	w4, [sp, #192]
    4000328c:	37180384 	tbnz	w4, #3, 400032fc <cbvprintf+0xad0>
				sign = ' ';
    40003290:	d3441084 	ubfx	x4, x4, #4, #1
    40003294:	531b6884 	lsl	w4, w4, #5
			sint = value->sint;
    40003298:	f9405be0 	ldr	x0, [sp, #176]
			if (sint < 0) {
    4000329c:	b6f80080 	tbz	x0, #63, 400032ac <cbvprintf+0xa80>
				value->uint = (uint_value_type)-sint;
    400032a0:	cb0003e0 	neg	x0, x0
				sign = '-';
    400032a4:	528005a4 	mov	w4, #0x2d                  	// #45
				value->uint = (uint_value_type)-sint;
    400032a8:	f9005be0 	str	x0, [sp, #176]
			bps = encode_uint(value->uint, conv, buf, bpe);
    400032ac:	f9405be0 	ldr	x0, [sp, #176]
    400032b0:	9102a7e3 	add	x3, sp, #0xa9
    400032b4:	910243e2 	add	x2, sp, #0x90
    400032b8:	910303e1 	add	x1, sp, #0xc0
    400032bc:	b90073e4 	str	w4, [sp, #112]
    400032c0:	97fffd0e 	bl	400026f8 <encode_uint>
    400032c4:	aa0003fa 	mov	x26, x0
    400032c8:	b94073e4 	ldr	w4, [sp, #112]
			if (precision >= 0) {
    400032cc:	9102a7e3 	add	x3, sp, #0xa9
    400032d0:	37f80129 	tbnz	w9, #31, 400032f4 <cbvprintf+0xac8>
				conv->flag_zero = false;
    400032d4:	794183e1 	ldrh	w1, [sp, #192]
				size_t len = bpe - bps;
    400032d8:	cb1a0060 	sub	x0, x3, x26
				if (len < (size_t)precision) {
    400032dc:	eb29c01f 	cmp	x0, w9, sxtw
				conv->flag_zero = false;
    400032e0:	12197821 	and	w1, w1, #0xffffffbf
    400032e4:	790183e1 	strh	w1, [sp, #192]
				if (len < (size_t)precision) {
    400032e8:	54000062 	b.cs	400032f4 <cbvprintf+0xac8>  // b.hs, b.nlast
					conv->pad0_value = precision - (int)len;
    400032ec:	4b000120 	sub	w0, w9, w0
    400032f0:	b900c7e0 	str	w0, [sp, #196]
		const char *bpe = buf + sizeof(buf);
    400032f4:	aa0303f9 	mov	x25, x3
    400032f8:	17ffffbe 	b	400031f0 <cbvprintf+0x9c4>
				sign = '+';
    400032fc:	52800564 	mov	w4, #0x2b                  	// #43
    40003300:	17ffffe6 	b	40003298 <cbvprintf+0xa6c>
		switch (conv->specifier) {
    40003304:	52800004 	mov	w4, #0x0                   	// #0
    40003308:	17ffffe9 	b	400032ac <cbvprintf+0xa80>
			if (value->ptr != NULL) {
    4000330c:	f9405be0 	ldr	x0, [sp, #176]
    40003310:	b4002380 	cbz	x0, 40003780 <cbvprintf+0xf54>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    40003314:	910303e1 	add	x1, sp, #0xc0
    40003318:	9102a7e3 	add	x3, sp, #0xa9
    4000331c:	910243e2 	add	x2, sp, #0x90
    40003320:	97fffcf6 	bl	400026f8 <encode_uint>
    40003324:	aa0003fa 	mov	x26, x0
				conv->altform_0c = true;
    40003328:	794187e0 	ldrh	w0, [sp, #194]
    4000332c:	52801de1 	mov	w1, #0xef                  	// #239
		char sign = 0;
    40003330:	52800004 	mov	w4, #0x0                   	// #0
				conv->altform_0c = true;
    40003334:	0a010000 	and	w0, w0, w1
    40003338:	528f0201 	mov	w1, #0x7810                	// #30736
    4000333c:	2a010000 	orr	w0, w0, w1
    40003340:	790187e0 	strh	w0, [sp, #194]
				goto prec_int_pad0;
    40003344:	17ffffe2 	b	400032cc <cbvprintf+0xaa0>
				store_count(conv, value->ptr, count);
    40003348:	93407f60 	sxtw	x0, w27
	switch ((enum length_mod_enum)conv->length_mod) {
    4000334c:	71001c3f 	cmp	w1, #0x7
				store_count(conv, value->ptr, count);
    40003350:	f9405be2 	ldr	x2, [sp, #176]
	switch ((enum length_mod_enum)conv->length_mod) {
    40003354:	54ffdcc8 	b.hi	40002eec <cbvprintf+0x6c0>  // b.pmore
    40003358:	b0000083 	adrp	x3, 40014000 <shell_m_sub_colors+0x50>
    4000335c:	9111f063 	add	x3, x3, #0x47c
    40003360:	38614861 	ldrb	w1, [x3, w1, uxtw]
    40003364:	10000063 	adr	x3, 40003370 <cbvprintf+0xb44>
    40003368:	8b218861 	add	x1, x3, w1, sxtb #2
    4000336c:	d61f0020 	br	x1
		*(int *)dp = count;
    40003370:	b9000040 	str	w0, [x2]
		break;
    40003374:	17fffede 	b	40002eec <cbvprintf+0x6c0>
		*(signed char *)dp = (signed char)count;
    40003378:	3900005b 	strb	w27, [x2]
		break;
    4000337c:	17fffedc 	b	40002eec <cbvprintf+0x6c0>
		*(short *)dp = (short)count;
    40003380:	7900005b 	strh	w27, [x2]
		break;
    40003384:	17fffeda 	b	40002eec <cbvprintf+0x6c0>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    40003388:	f9000040 	str	x0, [x2]
		break;
    4000338c:	17fffed8 	b	40002eec <cbvprintf+0x6c0>
		*sign = '-';
    40003390:	528005a4 	mov	w4, #0x2d                  	// #45
    40003394:	17ffff72 	b	4000315c <cbvprintf+0x930>
		*sign = '+';
    40003398:	52800564 	mov	w4, #0x2b                  	// #43
    4000339c:	17ffff70 	b	4000315c <cbvprintf+0x930>
				*buf++ = 'i';
    400033a0:	528dcd20 	mov	w0, #0x6e69                	// #28265
    400033a4:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'f';
    400033a8:	52800cc0 	mov	w0, #0x66                  	// #102
    400033ac:	17ffff78 	b	4000318c <cbvprintf+0x960>
			if (isupper((int)c)) {
    400033b0:	540000a8 	b.hi	400033c4 <cbvprintf+0xb98>  // b.pmore
				*buf++ = 'N';
    400033b4:	528829c0 	mov	w0, #0x414e                	// #16718
    400033b8:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'N';
    400033bc:	528009c0 	mov	w0, #0x4e                  	// #78
    400033c0:	17ffff73 	b	4000318c <cbvprintf+0x960>
				*buf++ = 'n';
    400033c4:	528c2dc0 	mov	w0, #0x616e                	// #24942
    400033c8:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'n';
    400033cc:	52800dc0 	mov	w0, #0x6e                  	// #110
    400033d0:	17ffff6f 	b	4000318c <cbvprintf+0x960>
		c = 'f';
    400033d4:	52800cc2 	mov	w2, #0x66                  	// #102
    400033d8:	710118bf 	cmp	w5, #0x46
    400033dc:	1a8210a5 	csel	w5, w5, w2, ne  // ne = any
	fract <<= EXPONENT_BITS;
    400033e0:	d375d002 	lsl	x2, x0, #11
	fract &= ~SIGN_MASK;
    400033e4:	f90047e2 	str	x2, [sp, #136]
	if ((expo | fract) != 0) {
    400033e8:	93407c26 	sxtw	x6, w1
    400033ec:	aa0200c6 	orr	x6, x6, x2
    400033f0:	b4000f66 	cbz	x6, 400035dc <cbvprintf+0xdb0>
	bool is_subnormal = (expo == 0) && (fract != 0);
    400033f4:	7100003f 	cmp	w1, #0x0
		if (is_subnormal) {
    400033f8:	fa400804 	ccmp	x0, #0x0, #0x4, eq  // eq = none
    400033fc:	54000c61 	b.ne	40003588 <cbvprintf+0xd5c>  // b.any
		fract |= BIT_63;
    40003400:	f94047e2 	ldr	x2, [sp, #136]
		expo -= (1023 - 1);	/* +1 since .1 vs 1. */
    40003404:	510ff821 	sub	w1, w1, #0x3fe
		fract |= BIT_63;
    40003408:	52800000 	mov	w0, #0x0                   	// #0
    4000340c:	52800006 	mov	w6, #0x0                   	// #0
    40003410:	b2410042 	orr	x2, x2, #0x8000000000000000
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    40003414:	3200e7e7 	mov	w7, #0x33333333            	// #858993459
		fract |= BIT_63;
    40003418:	f90047e2 	str	x2, [sp, #136]
	while (expo < -2) {
    4000341c:	3100083f 	cmn	w1, #0x2
    40003420:	54000b8b 	b.lt	40003590 <cbvprintf+0xd64>  // b.tstop
    40003424:	34000040 	cbz	w0, 4000342c <cbvprintf+0xc00>
    40003428:	f90047e2 	str	x2, [sp, #136]
    4000342c:	f94047e0 	ldr	x0, [sp, #136]
		decexp--;
    40003430:	52800002 	mov	w2, #0x0                   	// #0
	*v /= 5U;
    40003434:	d28000a7 	mov	x7, #0x5                   	// #5
	while (expo > 0) {
    40003438:	7100003f 	cmp	w1, #0x0
    4000343c:	54000bec 	b.gt	400035b8 <cbvprintf+0xd8c>
    40003440:	34000042 	cbz	w2, 40003448 <cbvprintf+0xc1c>
    40003444:	f90047e0 	str	x0, [sp, #136]
	fract >>= (4 - expo);
    40003448:	52800080 	mov	w0, #0x4                   	// #4
    4000344c:	4b010000 	sub	w0, w0, w1
    40003450:	f94047e1 	ldr	x1, [sp, #136]
    40003454:	9ac02421 	lsr	x1, x1, x0
	if ((c == 'g') || (c == 'G')) {
    40003458:	121a78a0 	and	w0, w5, #0xffffffdf
    4000345c:	12001c00 	and	w0, w0, #0xff
    40003460:	71011c1f 	cmp	w0, #0x47
    40003464:	54000c81 	b.ne	400035f4 <cbvprintf+0xdc8>  // b.any
		if (decexp < (-4 + 1) || decexp > precision) {
    40003468:	6b06013f 	cmp	w9, w6
    4000346c:	3a43a8c1 	ccmn	w6, #0x3, #0x1, ge  // ge = tcont
    40003470:	54000bca 	b.ge	400035e8 <cbvprintf+0xdbc>  // b.tcont
				precision--;
    40003474:	7100013f 	cmp	w9, #0x0
			c += 'e' - 'g';  /* e or E */
    40003478:	510008a5 	sub	w5, w5, #0x2
				precision--;
    4000347c:	1a9fd7e0 	cset	w0, gt
			c += 'e' - 'g';  /* e or E */
    40003480:	12001ca5 	and	w5, w5, #0xff
				precision--;
    40003484:	4b000129 	sub	w9, w9, w0
		if (!conv->flag_hash && (precision > 0)) {
    40003488:	721b007f 	tst	w3, #0x20
    4000348c:	54000b41 	b.ne	400035f4 <cbvprintf+0xdc8>  // b.any
    40003490:	7100013f 	cmp	w9, #0x0
    40003494:	1a9fd7e7 	cset	w7, gt
	if (c == 'f') {
    40003498:	710198bf 	cmp	w5, #0x66
    4000349c:	54000b01 	b.ne	400035fc <cbvprintf+0xdd0>  // b.any
		if (decimals < 0) {
    400034a0:	2b060120 	adds	w0, w9, w6
    400034a4:	54000ae5 	b.pl	40003600 <cbvprintf+0xdd4>  // b.nfrst
			decimals = 0;
    400034a8:	52800000 	mov	w0, #0x0                   	// #0
    400034ac:	52800202 	mov	w2, #0x10                  	// #16
	*v /= 5U;
    400034b0:	d28000a3 	mov	x3, #0x5                   	// #5
    400034b4:	b90087e2 	str	w2, [sp, #132]
			decimals = 0;
    400034b8:	d2e10002 	mov	x2, #0x800000000000000     	// #576460752303423488
	while (decimals--) {
    400034bc:	51000400 	sub	w0, w0, #0x1
    400034c0:	3100041f 	cmn	w0, #0x1
    400034c4:	54000a61 	b.ne	40003610 <cbvprintf+0xde4>  // b.any
	fract += round;
    400034c8:	8b020021 	add	x1, x1, x2
	if (fract >= BIT64(60)) {
    400034cc:	92fe0000 	mov	x0, #0xfffffffffffffff     	// #1152921504606846975
    400034d0:	eb00003f 	cmp	x1, x0
    400034d4:	54000a48 	b.hi	4000361c <cbvprintf+0xdf0>  // b.pmore
	fract += round;
    400034d8:	f90047e1 	str	x1, [sp, #136]
	if (c == 'f') {
    400034dc:	710198bf 	cmp	w5, #0x66
    400034e0:	54000b21 	b.ne	40003644 <cbvprintf+0xe18>  // b.any
		if (decexp > 0) {
    400034e4:	710000df 	cmp	w6, #0x0
    400034e8:	54000a6d 	b.le	40003634 <cbvprintf+0xe08>
	char *buf = bps;
    400034ec:	910243f9 	add	x25, sp, #0x90
				*buf++ = _get_digit(&fract, &digit_count);
    400034f0:	910213e1 	add	x1, sp, #0x84
    400034f4:	910223e0 	add	x0, sp, #0x88
    400034f8:	97fffc70 	bl	400026b8 <_get_digit>
    400034fc:	38001720 	strb	w0, [x25], #1
			while (decexp > 0 && digit_count > 0) {
    40003500:	b94087e0 	ldr	w0, [sp, #132]
				decexp--;
    40003504:	510004c6 	sub	w6, w6, #0x1
			while (decexp > 0 && digit_count > 0) {
    40003508:	7100001f 	cmp	w0, #0x0
    4000350c:	7a40c8c4 	ccmp	w6, #0x0, #0x4, gt
    40003510:	54ffff0c 	b.gt	400034f0 <cbvprintf+0xcc4>
			conv->pad0_value = decexp;
    40003514:	b900c7e6 	str	w6, [sp, #196]
			decexp = 0;
    40003518:	52800006 	mov	w6, #0x0                   	// #0
		if (conv->flag_hash || (precision > 0)) {
    4000351c:	794183e0 	ldrh	w0, [sp, #192]
    40003520:	37280060 	tbnz	w0, #5, 4000352c <cbvprintf+0xd00>
    40003524:	7100013f 	cmp	w9, #0x0
    40003528:	54000c2d 	b.le	400036ac <cbvprintf+0xe80>
			*buf++ = '.';
    4000352c:	aa1903e3 	mov	x3, x25
    40003530:	528005c0 	mov	w0, #0x2e                  	// #46
		if (decexp < 0 && precision > 0) {
    40003534:	710000df 	cmp	w6, #0x0
    40003538:	7a40b924 	ccmp	w9, #0x0, #0x4, lt  // lt = tstop
			*buf++ = '.';
    4000353c:	38001460 	strb	w0, [x3], #1
		if (decexp < 0 && precision > 0) {
    40003540:	5400016d 	b.le	4000356c <cbvprintf+0xd40>
			conv->pad0_value = -decexp;
    40003544:	4b0603e1 	neg	w1, w6
			conv->pad_postdp = (conv->pad0_value > 0);
    40003548:	39430be0 	ldrb	w0, [sp, #194]
			conv->pad0_value = -decexp;
    4000354c:	6b01013f 	cmp	w9, w1
    40003550:	1a81b121 	csel	w1, w9, w1, lt  // lt = tstop
    40003554:	b900c7e1 	str	w1, [sp, #196]
			conv->pad_postdp = (conv->pad0_value > 0);
    40003558:	7100003f 	cmp	w1, #0x0
			precision -= conv->pad0_value;
    4000355c:	4b010129 	sub	w9, w9, w1
			conv->pad_postdp = (conv->pad0_value > 0);
    40003560:	1a9fd7e1 	cset	w1, gt
    40003564:	331b0020 	bfi	w0, w1, #5, #1
    40003568:	39030be0 	strb	w0, [sp, #194]
			*buf++ = '.';
    4000356c:	aa0303f9 	mov	x25, x3
    40003570:	1400004a 	b	40003698 <cbvprintf+0xe6c>
				expo--;
    40003574:	51000421 	sub	w1, w1, #0x1
			while (((fract <<= 1) & BIT_63) == 0) {
    40003578:	d37ff842 	lsl	x2, x2, #1
    4000357c:	b6ffffc2 	tbz	x2, #63, 40003574 <cbvprintf+0xd48>
    40003580:	f90047e2 	str	x2, [sp, #136]
    40003584:	17ffff9f 	b	40003400 <cbvprintf+0xbd4>
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    40003588:	52800001 	mov	w1, #0x0                   	// #0
    4000358c:	17fffffb 	b	40003578 <cbvprintf+0xd4c>
			expo++;
    40003590:	2a0103e8 	mov	w8, w1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    40003594:	eb4284ff 	cmp	x7, x2, lsr #33
			expo++;
    40003598:	11000421 	add	w1, w1, #0x1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    4000359c:	d341fc42 	lsr	x2, x2, #1
    400035a0:	54ffff89 	b.ls	40003590 <cbvprintf+0xd64>  // b.plast
		fract *= 5U;
    400035a4:	8b020842 	add	x2, x2, x2, lsl #2
		expo++;
    400035a8:	11000901 	add	w1, w8, #0x2
		decexp--;
    400035ac:	510004c6 	sub	w6, w6, #0x1
    400035b0:	52800020 	mov	w0, #0x1                   	// #1
    400035b4:	17ffff9a 	b	4000341c <cbvprintf+0xbf0>
		fract += 2;
    400035b8:	91000800 	add	x0, x0, #0x2
		expo--;
    400035bc:	51000421 	sub	w1, w1, #0x1
		decexp++;
    400035c0:	110004c6 	add	w6, w6, #0x1
    400035c4:	52800022 	mov	w2, #0x1                   	// #1
	*v /= 5U;
    400035c8:	9ac70800 	udiv	x0, x0, x7
			fract <<= 1;
    400035cc:	d37ff800 	lsl	x0, x0, #1
			expo--;
    400035d0:	51000421 	sub	w1, w1, #0x1
		} while (!(fract & BIT_63));
    400035d4:	b6ffffc0 	tbz	x0, #63, 400035cc <cbvprintf+0xda0>
    400035d8:	17ffff98 	b	40003438 <cbvprintf+0xc0c>
    400035dc:	52800006 	mov	w6, #0x0                   	// #0
    400035e0:	52800001 	mov	w1, #0x0                   	// #0
    400035e4:	17ffff99 	b	40003448 <cbvprintf+0xc1c>
			precision -= decexp;
    400035e8:	4b060129 	sub	w9, w9, w6
			c = 'f';
    400035ec:	52800cc5 	mov	w5, #0x66                  	// #102
    400035f0:	17ffffa6 	b	40003488 <cbvprintf+0xc5c>
	bool prune_zero = false;
    400035f4:	52800007 	mov	w7, #0x0                   	// #0
    400035f8:	17ffffa8 	b	40003498 <cbvprintf+0xc6c>
		decimals = precision + 1;
    400035fc:	11000520 	add	w0, w9, #0x1
	if (decimals > 16) {
    40003600:	7100401f 	cmp	w0, #0x10
    40003604:	52800202 	mov	w2, #0x10                  	// #16
    40003608:	1a82d000 	csel	w0, w0, w2, le
    4000360c:	17ffffa8 	b	400034ac <cbvprintf+0xc80>
	*v >>= 1;
    40003610:	d341fc42 	lsr	x2, x2, #1
	*v /= 5U;
    40003614:	9ac30842 	udiv	x2, x2, x3
}
    40003618:	17ffffa9 	b	400034bc <cbvprintf+0xc90>
	*v >>= 1;
    4000361c:	d341fc21 	lsr	x1, x1, #1
	*v /= 5U;
    40003620:	d28000a0 	mov	x0, #0x5                   	// #5
		decexp++;
    40003624:	110004c6 	add	w6, w6, #0x1
	*v /= 5U;
    40003628:	9ac00821 	udiv	x1, x1, x0
    4000362c:	f90047e1 	str	x1, [sp, #136]
		decexp++;
    40003630:	17ffffab 	b	400034dc <cbvprintf+0xcb0>
			*buf++ = '0';
    40003634:	52800600 	mov	w0, #0x30                  	// #48
    40003638:	910247f9 	add	x25, sp, #0x91
    4000363c:	390243e0 	strb	w0, [sp, #144]
    40003640:	17ffffb7 	b	4000351c <cbvprintf+0xcf0>
		*buf = _get_digit(&fract, &digit_count);
    40003644:	910213e1 	add	x1, sp, #0x84
    40003648:	910223e0 	add	x0, sp, #0x88
    4000364c:	97fffc1b 	bl	400026b8 <_get_digit>
    40003650:	12001c01 	and	w1, w0, #0xff
			decexp--;
    40003654:	7100c03f 	cmp	w1, #0x30
		*buf = _get_digit(&fract, &digit_count);
    40003658:	390243e0 	strb	w0, [sp, #144]
			decexp--;
    4000365c:	1a9f07e0 	cset	w0, ne  // ne = any
    40003660:	4b0000c6 	sub	w6, w6, w0
		if (conv->flag_hash || (precision > 0)) {
    40003664:	794183e0 	ldrh	w0, [sp, #192]
    40003668:	37280060 	tbnz	w0, #5, 40003674 <cbvprintf+0xe48>
    4000366c:	7100013f 	cmp	w9, #0x0
    40003670:	540006cd 	b.le	40003748 <cbvprintf+0xf1c>
			*buf++ = '.';
    40003674:	528005c0 	mov	w0, #0x2e                  	// #46
    40003678:	91024be3 	add	x3, sp, #0x92
    4000367c:	390247e0 	strb	w0, [sp, #145]
    40003680:	17ffffbb 	b	4000356c <cbvprintf+0xd40>
		precision--;
    40003684:	51000529 	sub	w9, w9, #0x1
		*buf++ = _get_digit(&fract, &digit_count);
    40003688:	910213e1 	add	x1, sp, #0x84
    4000368c:	910223e0 	add	x0, sp, #0x88
    40003690:	97fffc0a 	bl	400026b8 <_get_digit>
    40003694:	38001720 	strb	w0, [x25], #1
	while (precision > 0 && digit_count > 0) {
    40003698:	7100013f 	cmp	w9, #0x0
    4000369c:	5400008d 	b.le	400036ac <cbvprintf+0xe80>
    400036a0:	b94087e0 	ldr	w0, [sp, #132]
    400036a4:	7100001f 	cmp	w0, #0x0
    400036a8:	54fffeec 	b.gt	40003684 <cbvprintf+0xe58>
	if (prune_zero) {
    400036ac:	35000527 	cbnz	w7, 40003750 <cbvprintf+0xf24>
	conv->pad0_pre_exp = precision;
    400036b0:	b900cbe9 	str	w9, [sp, #200]
	if ((c == 'e') || (c == 'E')) {
    400036b4:	121a78a0 	and	w0, w5, #0xffffffdf
    400036b8:	12001c00 	and	w0, w0, #0xff
    400036bc:	7101141f 	cmp	w0, #0x45
    400036c0:	540002e1 	b.ne	4000371c <cbvprintf+0xef0>  // b.any
		*buf++ = c;
    400036c4:	aa1903e1 	mov	x1, x25
    400036c8:	38002425 	strb	w5, [x1], #2
		if (decexp < 0) {
    400036cc:	36f80526 	tbz	w6, #31, 40003770 <cbvprintf+0xf44>
			decexp = -decexp;
    400036d0:	4b0603e6 	neg	w6, w6
			*buf++ = '-';
    400036d4:	528005a0 	mov	w0, #0x2d                  	// #45
    400036d8:	39000720 	strb	w0, [x25, #1]
		if (decexp >= 100) {
    400036dc:	71018cdf 	cmp	w6, #0x63
    400036e0:	540000ed 	b.le	400036fc <cbvprintf+0xed0>
			*buf++ = (decexp / 100) + '0';
    400036e4:	52800c80 	mov	w0, #0x64                  	// #100
    400036e8:	91000f21 	add	x1, x25, #0x3
    400036ec:	1ac00cc2 	sdiv	w2, w6, w0
			decexp %= 100;
    400036f0:	1b009846 	msub	w6, w2, w0, w6
			*buf++ = (decexp / 100) + '0';
    400036f4:	1100c045 	add	w5, w2, #0x30
    400036f8:	39000b25 	strb	w5, [x25, #2]
		*buf++ = (decexp / 10) + '0';
    400036fc:	52800142 	mov	w2, #0xa                   	// #10
    40003700:	aa0103f9 	mov	x25, x1
    40003704:	1ac20cc0 	sdiv	w0, w6, w2
    40003708:	1100c005 	add	w5, w0, #0x30
		*buf++ = (decexp % 10) + '0';
    4000370c:	1b029800 	msub	w0, w0, w2, w6
		*buf++ = (decexp / 10) + '0';
    40003710:	38002725 	strb	w5, [x25], #2
		*buf++ = (decexp % 10) + '0';
    40003714:	1100c000 	add	w0, w0, #0x30
    40003718:	39000420 	strb	w0, [x1, #1]
		|| (conv->pad0_pre_exp > 0);
    4000371c:	b940c7e0 	ldr	w0, [sp, #196]
    40003720:	7100001f 	cmp	w0, #0x0
    40003724:	540002ac 	b.gt	40003778 <cbvprintf+0xf4c>
    40003728:	b940cbe0 	ldr	w0, [sp, #200]
    4000372c:	7100001f 	cmp	w0, #0x0
    40003730:	1a9fd7e1 	cset	w1, gt
	conv->pad_fp = (conv->pad0_value > 0)
    40003734:	39430be0 	ldrb	w0, [sp, #194]
    40003738:	331a0020 	bfi	w0, w1, #6, #1
    4000373c:	39030be0 	strb	w0, [sp, #194]
	*buf = 0;
    40003740:	3900033f 	strb	wzr, [x25]
	return bps;
    40003744:	17fffeb4 	b	40003214 <cbvprintf+0x9e8>
		if (*buf++ != '0') {
    40003748:	910247f9 	add	x25, sp, #0x91
    4000374c:	17ffffd8 	b	400036ac <cbvprintf+0xe80>
		conv->pad0_pre_exp = 0;
    40003750:	b900cbff 	str	wzr, [sp, #200]
		while (*--buf == '0') {
    40003754:	aa1903e1 	mov	x1, x25
    40003758:	385fff20 	ldrb	w0, [x25, #-1]!
    4000375c:	7100c01f 	cmp	w0, #0x30
    40003760:	54ffffa0 	b.eq	40003754 <cbvprintf+0xf28>  // b.none
		if (*buf != '.') {
    40003764:	7100b81f 	cmp	w0, #0x2e
    40003768:	9a810339 	csel	x25, x25, x1, eq  // eq = none
    4000376c:	17ffffd2 	b	400036b4 <cbvprintf+0xe88>
			*buf++ = '+';
    40003770:	52800560 	mov	w0, #0x2b                  	// #43
    40003774:	17ffffd9 	b	400036d8 <cbvprintf+0xeac>
		|| (conv->pad0_pre_exp > 0);
    40003778:	52800021 	mov	w1, #0x1                   	// #1
    4000377c:	17ffffee 	b	40003734 <cbvprintf+0xf08>
			bpe = bps + 5;
    40003780:	b0000083 	adrp	x3, 40014000 <shell_m_sub_colors+0x50>
    40003784:	9131d479 	add	x25, x3, #0xc75
			bps = "(nil)";
    40003788:	b0000082 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    4000378c:	9131c05a 	add	x26, x2, #0xc70
		char sign = 0;
    40003790:	52800004 	mov	w4, #0x0                   	// #0
    40003794:	17fffea1 	b	40003218 <cbvprintf+0x9ec>
		} else if (conv->altform_0) {
    40003798:	361fd4c5 	tbz	w5, #3, 40003230 <cbvprintf+0xa04>
			nj_len += 1U;
    4000379c:	91000400 	add	x0, x0, #0x1
    400037a0:	17fffea4 	b	40003230 <cbvprintf+0xa04>
					OUTC(pad);
    400037a4:	b90073e5 	str	w5, [sp, #112]
    400037a8:	aa1503e1 	mov	x1, x21
    400037ac:	b9007fe4 	str	w4, [sp, #124]
    400037b0:	2a0503e0 	mov	w0, w5
    400037b4:	d63f0280 	blr	x20
    400037b8:	37f80aa0 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    400037bc:	b94073e5 	ldr	w5, [sp, #112]
    400037c0:	9100077b 	add	x27, x27, #0x1
    400037c4:	b9407fe4 	ldr	w4, [sp, #124]
				while (width-- > 0) {
    400037c8:	2a1703e0 	mov	w0, w23
    400037cc:	510006f7 	sub	w23, w23, #0x1
    400037d0:	7100001f 	cmp	w0, #0x0
    400037d4:	54fffe8c 	b.gt	400037a4 <cbvprintf+0xf78>
		if (sign != 0) {
    400037d8:	340000c4 	cbz	w4, 400037f0 <cbvprintf+0xfc4>
			OUTC(sign);
    400037dc:	aa1503e1 	mov	x1, x21
    400037e0:	2a0403e0 	mov	w0, w4
    400037e4:	d63f0280 	blr	x20
    400037e8:	37f80920 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    400037ec:	9100077b 	add	x27, x27, #0x1
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {
    400037f0:	39430be0 	ldrb	w0, [sp, #194]
    400037f4:	36300e00 	tbz	w0, #6, 400039b4 <cbvprintf+0x1188>
			if (conv->specifier_a) {
    400037f8:	79c183e0 	ldrsh	w0, [sp, #192]
    400037fc:	cb1a037b 	sub	x27, x27, x26
    40003800:	37f80460 	tbnz	w0, #31, 4000388c <cbvprintf+0x1060>
				while (isdigit((int)*cp)) {
    40003804:	39400340 	ldrb	w0, [x26]
    40003808:	8b1b0344 	add	x4, x26, x27
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    4000380c:	5100c001 	sub	w1, w0, #0x30
    40003810:	7100243f 	cmp	w1, #0x9
    40003814:	54000749 	b.ls	400038fc <cbvprintf+0x10d0>  // b.plast
				if (!conv->pad_postdp) {
    40003818:	f94063e0 	ldr	x0, [sp, #192]
				pad_len = conv->pad0_value;
    4000381c:	b940c7fb 	ldr	w27, [sp, #196]
				if (!conv->pad_postdp) {
    40003820:	720b001f 	tst	w0, #0x200000
    40003824:	540000a1 	b.ne	40003838 <cbvprintf+0x100c>  // b.any
					while (pad_len-- > 0) {
    40003828:	51000765 	sub	w5, w27, #0x1
    4000382c:	7100037f 	cmp	w27, #0x0
    40003830:	540007cc 	b.gt	40003928 <cbvprintf+0x10fc>
    40003834:	2a0503fb 	mov	w27, w5
				if (*cp == '.') {
    40003838:	39400340 	ldrb	w0, [x26]
    4000383c:	7100b81f 	cmp	w0, #0x2e
    40003840:	54000141 	b.ne	40003868 <cbvprintf+0x103c>  // b.any
    40003844:	f9003be4 	str	x4, [sp, #112]
					OUTC(*cp++);
    40003848:	aa1503e1 	mov	x1, x21
    4000384c:	d63f0280 	blr	x20
						OUTC('0');
    40003850:	37f805e0 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    40003854:	f9403be4 	ldr	x4, [sp, #112]
					while (pad_len-- > 0) {
    40003858:	7100037f 	cmp	w27, #0x0
						OUTC('0');
    4000385c:	91000484 	add	x4, x4, #0x1
					while (pad_len-- > 0) {
    40003860:	540007ac 	b.gt	40003954 <cbvprintf+0x1128>
					OUTC(*cp++);
    40003864:	9100075a 	add	x26, x26, #0x1
    40003868:	cb1a009b 	sub	x27, x4, x26
    4000386c:	14000044 	b	4000397c <cbvprintf+0x1150>
				char pad = ' ';
    40003870:	52800405 	mov	w5, #0x20                  	// #32
					pad = '0';
    40003874:	2a1703e0 	mov	w0, w23
    40003878:	17ffffd5 	b	400037cc <cbvprintf+0xfa0>
					OUTC(*cp++);
    4000387c:	9100075a 	add	x26, x26, #0x1
    40003880:	aa1503e1 	mov	x1, x21
    40003884:	d63f0280 	blr	x20
    40003888:	37f80420 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
				while (*cp != 'p') {
    4000388c:	39400340 	ldrb	w0, [x26]
    40003890:	8b1b0341 	add	x1, x26, x27
    40003894:	7101c01f 	cmp	w0, #0x70
    40003898:	54ffff21 	b.ne	4000387c <cbvprintf+0x1050>  // b.any
			while (pad_len-- > 0) {
    4000389c:	b940cbe4 	ldr	w4, [sp, #200]
    400038a0:	aa0103fb 	mov	x27, x1
    400038a4:	0b010084 	add	w4, w4, w1
    400038a8:	4b1b0080 	sub	w0, w4, w27
    400038ac:	7100001f 	cmp	w0, #0x0
    400038b0:	5400072c 	b.gt	40003994 <cbvprintf+0x1168>
			OUTS(bps, bpe);
    400038b4:	aa1903e3 	mov	x3, x25
    400038b8:	aa1a03e2 	mov	x2, x26
    400038bc:	aa1503e1 	mov	x1, x21
    400038c0:	aa1403e0 	mov	x0, x20
    400038c4:	97fffbbe 	bl	400027bc <outs>
    400038c8:	37f80220 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    400038cc:	8b20c360 	add	x0, x27, w0, sxtw
			while (pad_len-- > 0) {
    400038d0:	aa0003fb 	mov	x27, x0
    400038d4:	0b0002f7 	add	w23, w23, w0
		while (width > 0) {
    400038d8:	4b1b02e0 	sub	w0, w23, w27
    400038dc:	7100001f 	cmp	w0, #0x0
    400038e0:	54ffb06d 	b.le	40002eec <cbvprintf+0x6c0>
			OUTC(' ');
    400038e4:	aa1503e1 	mov	x1, x21
    400038e8:	52800400 	mov	w0, #0x20                  	// #32
    400038ec:	d63f0280 	blr	x20
    400038f0:	37f800e0 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    400038f4:	9100077b 	add	x27, x27, #0x1
			--width;
    400038f8:	17fffff8 	b	400038d8 <cbvprintf+0x10ac>
					OUTC(*cp++);
    400038fc:	9100075a 	add	x26, x26, #0x1
    40003900:	aa1503e1 	mov	x1, x21
    40003904:	d63f0280 	blr	x20
    40003908:	36fff7e0 	tbz	w0, #31, 40003804 <cbvprintf+0xfd8>
#undef OUTS
#undef OUTC
}
    4000390c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003910:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003914:	a94363f7 	ldp	x23, x24, [sp, #48]
    40003918:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000391c:	a94573fb 	ldp	x27, x28, [sp, #80]
    40003920:	a8cd7bfd 	ldp	x29, x30, [sp], #208
    40003924:	d65f03c0 	ret
    40003928:	f9003be4 	str	x4, [sp, #112]
						OUTC('0');
    4000392c:	aa1503e1 	mov	x1, x21
    40003930:	b9007fe5 	str	w5, [sp, #124]
    40003934:	52800600 	mov	w0, #0x30                  	// #48
    40003938:	d63f0280 	blr	x20
    4000393c:	37fffe80 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    40003940:	f9403be4 	ldr	x4, [sp, #112]
					while (pad_len-- > 0) {
    40003944:	b9407fe5 	ldr	w5, [sp, #124]
						OUTC('0');
    40003948:	91000484 	add	x4, x4, #0x1
					while (pad_len-- > 0) {
    4000394c:	2a0503fb 	mov	w27, w5
    40003950:	17ffffb6 	b	40003828 <cbvprintf+0xffc>
    40003954:	f9003be4 	str	x4, [sp, #112]
						OUTC('0');
    40003958:	aa1503e1 	mov	x1, x21
    4000395c:	5100077b 	sub	w27, w27, #0x1
    40003960:	52800600 	mov	w0, #0x30                  	// #48
    40003964:	d63f0280 	blr	x20
    40003968:	17ffffba 	b	40003850 <cbvprintf+0x1024>
					OUTC(*cp++);
    4000396c:	9100075a 	add	x26, x26, #0x1
    40003970:	aa1503e1 	mov	x1, x21
    40003974:	d63f0280 	blr	x20
    40003978:	37fffca0 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
				while (isdigit((int)*cp)) {
    4000397c:	39400340 	ldrb	w0, [x26]
    40003980:	8b1b0341 	add	x1, x26, x27
    40003984:	5100c004 	sub	w4, w0, #0x30
    40003988:	7100249f 	cmp	w4, #0x9
    4000398c:	54ffff09 	b.ls	4000396c <cbvprintf+0x1140>  // b.plast
    40003990:	17ffffc3 	b	4000389c <cbvprintf+0x1070>
    40003994:	b90073e4 	str	w4, [sp, #112]
				OUTC('0');
    40003998:	aa1503e1 	mov	x1, x21
    4000399c:	52800600 	mov	w0, #0x30                  	// #48
    400039a0:	d63f0280 	blr	x20
    400039a4:	37fffb40 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    400039a8:	b94073e4 	ldr	w4, [sp, #112]
    400039ac:	9100077b 	add	x27, x27, #0x1
    400039b0:	17ffffbe 	b	400038a8 <cbvprintf+0x107c>
			if (conv->altform_0c | conv->altform_0) {
    400039b4:	f94063e0 	ldr	x0, [sp, #192]
    400039b8:	d3545001 	ubfx	x1, x0, #20, #1
    400039bc:	d3534c00 	ubfx	x0, x0, #19, #1
    400039c0:	2a000020 	orr	w0, w1, w0
    400039c4:	360000c0 	tbz	w0, #0, 400039dc <cbvprintf+0x11b0>
				OUTC('0');
    400039c8:	aa1503e1 	mov	x1, x21
    400039cc:	52800600 	mov	w0, #0x30                  	// #48
    400039d0:	d63f0280 	blr	x20
    400039d4:	37fff9c0 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    400039d8:	9100077b 	add	x27, x27, #0x1
			if (conv->altform_0c) {
    400039dc:	39430be0 	ldrb	w0, [sp, #194]
    400039e0:	362000c0 	tbz	w0, #4, 400039f8 <cbvprintf+0x11cc>
				OUTC(conv->specifier);
    400039e4:	39430fe0 	ldrb	w0, [sp, #195]
    400039e8:	aa1503e1 	mov	x1, x21
    400039ec:	d63f0280 	blr	x20
    400039f0:	37fff8e0 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    400039f4:	9100077b 	add	x27, x27, #0x1
			while (pad_len-- > 0) {
    400039f8:	b940c7e4 	ldr	w4, [sp, #196]
    400039fc:	0b1b0084 	add	w4, w4, w27
    40003a00:	4b1b0080 	sub	w0, w4, w27
    40003a04:	7100001f 	cmp	w0, #0x0
    40003a08:	54fff56d 	b.le	400038b4 <cbvprintf+0x1088>
    40003a0c:	b90073e4 	str	w4, [sp, #112]
				OUTC('0');
    40003a10:	aa1503e1 	mov	x1, x21
    40003a14:	52800600 	mov	w0, #0x30                  	// #48
    40003a18:	d63f0280 	blr	x20
    40003a1c:	37fff780 	tbnz	w0, #31, 4000390c <cbvprintf+0x10e0>
    40003a20:	b94073e4 	ldr	w4, [sp, #112]
    40003a24:	9100077b 	add	x27, x27, #0x1
    40003a28:	17fffff6 	b	40003a00 <cbvprintf+0x11d4>

0000000040003a2c <ring_buf_get_rewind_threshold>:
 * rewinding earlier.
 */
uint32_t __weak ring_buf_get_rewind_threshold(void)
{
	return RING_BUFFER_MAX_SIZE;
}
    40003a2c:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
    40003a30:	d65f03c0 	ret

0000000040003a34 <ring_buf_put_claim>:

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
	uint32_t space, trail_size, allocated, tmp_trail_mod;

	tmp_trail_mod = mod(buf, buf->misc.byte_mode.tmp_tail);
    40003a34:	b9402004 	ldr	w4, [x0, #32]
{
    40003a38:	aa0003e5 	mov	x5, x0
	tmp_trail_mod = mod(buf, buf->misc.byte_mode.tmp_tail);
    40003a3c:	b9400806 	ldr	w6, [x0, #8]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40003a40:	b9401007 	ldr	w7, [x0, #16]
    40003a44:	34000204 	cbz	w4, 40003a84 <ring_buf_put_claim+0x50>
    40003a48:	0a0400c4 	and	w4, w6, w4
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
    40003a4c:	b94000a3 	ldr	w3, [x5]
	trail_size = buf->size - tmp_trail_mod;
    40003a50:	4b0400e0 	sub	w0, w7, w4
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
    40003a54:	0b0300e3 	add	w3, w7, w3
    40003a58:	4b060063 	sub	w3, w3, w6

	/* Limit requested size to available size. */
	size = MIN(size, space);
    40003a5c:	6b02007f 	cmp	w3, w2
    40003a60:	1a829062 	csel	w2, w3, w2, ls  // ls = plast

	trail_size = buf->size - (tmp_trail_mod);

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
    40003a64:	6b00005f 	cmp	w2, w0
    40003a68:	1a809040 	csel	w0, w2, w0, ls  // ls = plast
	*data = &buf->buf.buf8[tmp_trail_mod];
    40003a6c:	f9400ca2 	ldr	x2, [x5, #24]

	buf->misc.byte_mode.tmp_tail =
		buf->misc.byte_mode.tmp_tail + allocated;
    40003a70:	0b0000c6 	add	w6, w6, w0
	*data = &buf->buf.buf8[tmp_trail_mod];
    40003a74:	8b244044 	add	x4, x2, w4, uxtw
    40003a78:	f9000024 	str	x4, [x1]
	buf->misc.byte_mode.tmp_tail =
    40003a7c:	b90008a6 	str	w6, [x5, #8]

	return allocated;
}
    40003a80:	d65f03c0 	ret
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40003a84:	1ac708c4 	udiv	w4, w6, w7
    40003a88:	1b079884 	msub	w4, w4, w7, w6
    40003a8c:	17fffff0 	b	40003a4c <ring_buf_put_claim+0x18>

0000000040003a90 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
    40003a90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003a94:	910003fd 	mov	x29, sp
    40003a98:	a90153f3 	stp	x19, x20, [sp, #16]
    40003a9c:	aa0003f4 	mov	x20, x0
    40003aa0:	2a0103f3 	mov	w19, w1
	uint32_t rew;
	uint32_t threshold = ring_buf_get_rewind_threshold();
    40003aa4:	97ffffe2 	bl	40003a2c <ring_buf_get_rewind_threshold>

	if ((buf->tail + size) > (buf->head + buf->size)) {
    40003aa8:	29401282 	ldp	w2, w4, [x20]
    40003aac:	b9401283 	ldr	w3, [x20, #16]
    40003ab0:	0b130081 	add	w1, w4, w19
    40003ab4:	0b020062 	add	w2, w3, w2
    40003ab8:	6b02003f 	cmp	w1, w2
    40003abc:	540001a8 	b.hi	40003af0 <ring_buf_put_finish+0x60>  // b.pmore
		return -EINVAL;
	}

	/* Check if indexes shall be rewind. */
	if (buf->tail > threshold) {
    40003ac0:	6b00009f 	cmp	w4, w0
    40003ac4:	54000129 	b.ls	40003ae8 <ring_buf_put_finish+0x58>  // b.plast
	return buf_size * (threshold / buf_size);
    40003ac8:	1ac30802 	udiv	w2, w0, w3
    40003acc:	1b037c42 	mul	w2, w2, w3
		rew = get_rewind_value(buf->size, threshold);
	} else {
		rew = 0;
	}

	buf->tail += (size - rew);
    40003ad0:	4b020021 	sub	w1, w1, w2
	buf->misc.byte_mode.tmp_tail = buf->tail;

	return 0;
    40003ad4:	52800000 	mov	w0, #0x0                   	// #0
	buf->misc.byte_mode.tmp_tail = buf->tail;
    40003ad8:	29008681 	stp	w1, w1, [x20, #4]
}
    40003adc:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003ae0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003ae4:	d65f03c0 	ret
		rew = 0;
    40003ae8:	52800002 	mov	w2, #0x0                   	// #0
    40003aec:	17fffff9 	b	40003ad0 <ring_buf_put_finish+0x40>
		return -EINVAL;
    40003af0:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40003af4:	17fffffa 	b	40003adc <ring_buf_put_finish+0x4c>

0000000040003af8 <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
    40003af8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40003afc:	910003fd 	mov	x29, sp
    40003b00:	a90153f3 	stp	x19, x20, [sp, #16]
    40003b04:	2a0203f4 	mov	w20, w2
    40003b08:	a9025bf5 	stp	x21, x22, [sp, #32]
    40003b0c:	aa0103f5 	mov	x21, x1
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
    40003b10:	52800016 	mov	w22, #0x0                   	// #0
{
    40003b14:	a90363f7 	stp	x23, x24, [sp, #48]
    40003b18:	aa0003f7 	mov	x23, x0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
    40003b1c:	2a1403e2 	mov	w2, w20
    40003b20:	910123e1 	add	x1, sp, #0x48
    40003b24:	aa1703e0 	mov	x0, x23
    40003b28:	97ffffc3 	bl	40003a34 <ring_buf_put_claim>
    40003b2c:	2a0003f8 	mov	w24, w0
		memcpy(dst, data, partial_size);
    40003b30:	f94027e0 	ldr	x0, [sp, #72]
    40003b34:	aa1503e1 	mov	x1, x21
    40003b38:	aa1803e2 	mov	x2, x24
		total_size += partial_size;
    40003b3c:	0b1802d6 	add	w22, w22, w24
		size -= partial_size;
		data += partial_size;
    40003b40:	8b1802b5 	add	x21, x21, x24
		memcpy(dst, data, partial_size);
    40003b44:	940025f4 	bl	4000d314 <memcpy>
	} while (size && partial_size);
    40003b48:	6b180294 	subs	w20, w20, w24
    40003b4c:	7a401b04 	ccmp	w24, #0x0, #0x4, ne  // ne = any
    40003b50:	54fffe61 	b.ne	40003b1c <ring_buf_put+0x24>  // b.any

	err = ring_buf_put_finish(buf, total_size);
    40003b54:	2a1603e1 	mov	w1, w22
    40003b58:	aa1703e0 	mov	x0, x23
    40003b5c:	97ffffcd 	bl	40003a90 <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
    40003b60:	2a1603e0 	mov	w0, w22
    40003b64:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003b68:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003b6c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40003b70:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40003b74:	d65f03c0 	ret

0000000040003b78 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
    40003b78:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40003b7c:	910003fd 	mov	x29, sp
    40003b80:	a90153f3 	stp	x19, x20, [sp, #16]
    40003b84:	aa0003f3 	mov	x19, x0
	uint32_t space, granted_size, trail_size, tmp_head_mod;
	uint32_t tail = buf->tail;
    40003b88:	b9400414 	ldr	w20, [x0, #4]

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
    40003b8c:	b9400c00 	ldr	w0, [x0, #12]
{
    40003b90:	a9025bf5 	stp	x21, x22, [sp, #32]
    40003b94:	aa0103f6 	mov	x22, x1
    40003b98:	2a0203f5 	mov	w21, w2
    40003b9c:	f9001bf7 	str	x23, [sp, #48]
	if (tail < buf->misc.byte_mode.tmp_head) {
    40003ba0:	6b14001f 	cmp	w0, w20
    40003ba4:	540000a9 	b.ls	40003bb8 <ring_buf_get_claim+0x40>  // b.plast
		/* Locally, increment it to pre-rewind value */
		tail += get_rewind_value(buf->size,
    40003ba8:	b9401277 	ldr	w23, [x19, #16]
    40003bac:	97ffffa0 	bl	40003a2c <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
    40003bb0:	1ad70800 	udiv	w0, w0, w23
		tail += get_rewind_value(buf->size,
    40003bb4:	1b175014 	madd	w20, w0, w23, w20
					 ring_buf_get_rewind_threshold());
	}

	tmp_head_mod = mod(buf, buf->misc.byte_mode.tmp_head);
    40003bb8:	b9402263 	ldr	w3, [x19, #32]
    40003bbc:	29419265 	ldp	w5, w4, [x19, #12]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40003bc0:	34000243 	cbz	w3, 40003c08 <ring_buf_get_claim+0x90>
    40003bc4:	0a0300a3 	and	w3, w5, w3
	space = tail - buf->misc.byte_mode.tmp_head;
    40003bc8:	4b050294 	sub	w20, w20, w5
	trail_size = buf->size - tmp_head_mod;
    40003bcc:	4b030084 	sub	w4, w4, w3
	granted_size = MIN(size, space);

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);

	*data = &buf->buf.buf8[tmp_head_mod];
    40003bd0:	f9400e61 	ldr	x1, [x19, #24]
	granted_size = MIN(size, space);
    40003bd4:	6b15029f 	cmp	w20, w21
    40003bd8:	1a959280 	csel	w0, w20, w21, ls  // ls = plast
	granted_size = MIN(trail_size, granted_size);
    40003bdc:	6b00009f 	cmp	w4, w0
    40003be0:	1a809080 	csel	w0, w4, w0, ls  // ls = plast
	*data = &buf->buf.buf8[tmp_head_mod];
    40003be4:	8b234023 	add	x3, x1, w3, uxtw
	buf->misc.byte_mode.tmp_head += granted_size;

	return granted_size;
}
    40003be8:	f9401bf7 	ldr	x23, [sp, #48]
	*data = &buf->buf.buf8[tmp_head_mod];
    40003bec:	f90002c3 	str	x3, [x22]
	buf->misc.byte_mode.tmp_head += granted_size;
    40003bf0:	0b0000a5 	add	w5, w5, w0
}
    40003bf4:	a9425bf5 	ldp	x21, x22, [sp, #32]
	buf->misc.byte_mode.tmp_head += granted_size;
    40003bf8:	b9000e65 	str	w5, [x19, #12]
}
    40003bfc:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003c00:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40003c04:	d65f03c0 	ret
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40003c08:	1ac408a3 	udiv	w3, w5, w4
    40003c0c:	1b049463 	msub	w3, w3, w4, w5
    40003c10:	17ffffee 	b	40003bc8 <ring_buf_get_claim+0x50>

0000000040003c14 <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
    40003c14:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40003c18:	910003fd 	mov	x29, sp
    40003c1c:	a90153f3 	stp	x19, x20, [sp, #16]
    40003c20:	aa0003f4 	mov	x20, x0
    40003c24:	2a0103f3 	mov	w19, w1
    40003c28:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint32_t tail = buf->tail;
    40003c2c:	b9400415 	ldr	w21, [x0, #4]
	uint32_t rew;

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
    40003c30:	b9400c00 	ldr	w0, [x0, #12]
    40003c34:	6b15001f 	cmp	w0, w21
    40003c38:	54000249 	b.ls	40003c80 <ring_buf_get_finish+0x6c>  // b.plast
		/* tail was rewinded. Locally, increment it to pre-rewind value */
		rew = get_rewind_value(buf->size,
    40003c3c:	b9401296 	ldr	w22, [x20, #16]
    40003c40:	97ffff7b 	bl	40003a2c <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
    40003c44:	1ad60800 	udiv	w0, w0, w22
    40003c48:	1b167c00 	mul	w0, w0, w22
				       ring_buf_get_rewind_threshold());
		tail += rew;
    40003c4c:	0b0002b5 	add	w21, w21, w0
	} else {
		rew = 0;
	}

	if ((buf->head + size) > tail) {
    40003c50:	b9400281 	ldr	w1, [x20]
    40003c54:	0b010261 	add	w1, w19, w1
    40003c58:	6b15003f 	cmp	w1, w21
    40003c5c:	54000168 	b.hi	40003c88 <ring_buf_get_finish+0x74>  // b.pmore
		return -EINVAL;
	}

	/* Include potential rewinding. */
	buf->head += (size - rew);
    40003c60:	4b000021 	sub	w1, w1, w0
	buf->misc.byte_mode.tmp_head = buf->head;

	return 0;
    40003c64:	52800000 	mov	w0, #0x0                   	// #0
	buf->head += (size - rew);
    40003c68:	b9000281 	str	w1, [x20]
	buf->misc.byte_mode.tmp_head = buf->head;
    40003c6c:	b9000e81 	str	w1, [x20, #12]
}
    40003c70:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003c74:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003c78:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40003c7c:	d65f03c0 	ret
		rew = 0;
    40003c80:	52800000 	mov	w0, #0x0                   	// #0
    40003c84:	17fffff3 	b	40003c50 <ring_buf_get_finish+0x3c>
		return -EINVAL;
    40003c88:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40003c8c:	17fffff9 	b	40003c70 <ring_buf_get_finish+0x5c>

0000000040003c90 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
    40003c90:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40003c94:	910003fd 	mov	x29, sp
    40003c98:	a90153f3 	stp	x19, x20, [sp, #16]
    40003c9c:	2a0203f4 	mov	w20, w2
    40003ca0:	a9025bf5 	stp	x21, x22, [sp, #32]
    40003ca4:	aa0103f5 	mov	x21, x1
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
    40003ca8:	52800016 	mov	w22, #0x0                   	// #0
{
    40003cac:	a90363f7 	stp	x23, x24, [sp, #48]
    40003cb0:	aa0003f7 	mov	x23, x0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
    40003cb4:	2a1403e2 	mov	w2, w20
    40003cb8:	910123e1 	add	x1, sp, #0x48
    40003cbc:	aa1703e0 	mov	x0, x23
    40003cc0:	97ffffae 	bl	40003b78 <ring_buf_get_claim>
    40003cc4:	2a0003f3 	mov	w19, w0
		if (data) {
    40003cc8:	b40000f5 	cbz	x21, 40003ce4 <ring_buf_get+0x54>
			memcpy(data, src, partial_size);
    40003ccc:	f94027e1 	ldr	x1, [sp, #72]
    40003cd0:	2a0003f8 	mov	w24, w0
    40003cd4:	aa1803e2 	mov	x2, x24
    40003cd8:	aa1503e0 	mov	x0, x21
			data += partial_size;
    40003cdc:	8b1802b5 	add	x21, x21, x24
			memcpy(data, src, partial_size);
    40003ce0:	9400258d 	bl	4000d314 <memcpy>
		}
		total_size += partial_size;
		size -= partial_size;
	} while (size && partial_size);
    40003ce4:	6b130294 	subs	w20, w20, w19
		total_size += partial_size;
    40003ce8:	0b1302d6 	add	w22, w22, w19
	} while (size && partial_size);
    40003cec:	7a401a64 	ccmp	w19, #0x0, #0x4, ne  // ne = any
    40003cf0:	54fffe21 	b.ne	40003cb4 <ring_buf_get+0x24>  // b.any

	err = ring_buf_get_finish(buf, total_size);
    40003cf4:	2a1603e1 	mov	w1, w22
    40003cf8:	aa1703e0 	mov	x0, x23
    40003cfc:	97ffffc6 	bl	40003c14 <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
    40003d00:	2a1603e0 	mov	w0, w22
    40003d04:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003d08:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003d0c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40003d10:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40003d14:	d65f03c0 	ret

0000000040003d18 <foldcase>:
#define EOS    '\0'

static inline int foldcase(int ch, int flags)
{

    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
    40003d18:	361800a1 	tbz	w1, #3, 40003d2c <foldcase+0x14>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    40003d1c:	51010401 	sub	w1, w0, #0x41
    40003d20:	7100643f 	cmp	w1, #0x19
    40003d24:	54000048 	b.hi	40003d2c <foldcase+0x14>  // b.pmore
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
    40003d28:	11008000 	add	w0, w0, #0x20
        return tolower(ch);
    return ch;
}
    40003d2c:	d65f03c0 	ret

0000000040003d30 <fnmatchx>:
static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
    const char *stringstart, *r;
    char c, test;

    if ((pattern == NULL) || (string == NULL))
    40003d30:	f100001f 	cmp	x0, #0x0
    40003d34:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
    40003d38:	54000061 	b.ne	40003d44 <fnmatchx+0x14>  // b.any
    {
        return FNM_NOMATCH;
    40003d3c:	52800020 	mov	w0, #0x1                   	// #1
                return FNM_NOMATCH;
            break;
        }
    }
    /* NOTREACHED */
}
    40003d40:	d65f03c0 	ret
{
    40003d44:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40003d48:	910003fd 	mov	x29, sp
    40003d4c:	a90153f3 	stp	x19, x20, [sp, #16]
    40003d50:	a9025bf5 	stp	x21, x22, [sp, #32]
    40003d54:	a90363f7 	stp	x23, x24, [sp, #48]
    40003d58:	aa0303f7 	mov	x23, x3
    40003d5c:	f90023f9 	str	x25, [sp, #64]
    if (recursion-- == 0)
    40003d60:	b40019c3 	cbz	x3, 40004098 <fnmatchx+0x368>
    40003d64:	aa0003e4 	mov	x4, x0
    40003d68:	aa0103f6 	mov	x22, x1
    40003d6c:	2a0203f3 	mov	w19, w2
    40003d70:	aa0103f4 	mov	x20, x1
            if (*string == '.' && (flags & FNM_PERIOD) &&
    40003d74:	121e0058 	and	w24, w2, #0x4
            ok = 1;
    40003d78:	52800039 	mov	w25, #0x1                   	// #1
        switch (c = FOLDCASE(*pattern++, flags)) {
    40003d7c:	aa0403f5 	mov	x21, x4
    40003d80:	2a1303e1 	mov	w1, w19
    40003d84:	384016a0 	ldrb	w0, [x21], #1
    40003d88:	97ffffe4 	bl	40003d18 <foldcase>
    40003d8c:	2a0003e1 	mov	w1, w0
    40003d90:	12001c02 	and	w2, w0, #0xff
    40003d94:	12001c00 	and	w0, w0, #0xff
            if ((flags & FNM_LEADING_DIR) && *string == '/')
    40003d98:	39400283 	ldrb	w3, [x20]
        switch (c = FOLDCASE(*pattern++, flags)) {
    40003d9c:	7100fc1f 	cmp	w0, #0x3f
    40003da0:	540003e0 	b.eq	40003e1c <fnmatchx+0xec>  // b.none
    40003da4:	721a043f 	tst	w1, #0xc0
    40003da8:	54000161 	b.ne	40003dd4 <fnmatchx+0xa4>  // b.any
    40003dac:	340002c0 	cbz	w0, 40003e04 <fnmatchx+0xd4>
    40003db0:	7100a81f 	cmp	w0, #0x2a
    40003db4:	54000620 	b.eq	40003e78 <fnmatchx+0x148>  // b.none
            if (c != FOLDCASE(*string++, flags))
    40003db8:	2a1303e1 	mov	w1, w19
    40003dbc:	2a0303e0 	mov	w0, w3
    40003dc0:	91000694 	add	x20, x20, #0x1
    40003dc4:	97ffffd5 	bl	40003d18 <foldcase>
    40003dc8:	6b00005f 	cmp	w2, w0
    40003dcc:	54000520 	b.eq	40003e70 <fnmatchx+0x140>  // b.none
    40003dd0:	14000017 	b	40003e2c <fnmatchx+0xfc>
        switch (c = FOLDCASE(*pattern++, flags)) {
    40003dd4:	71016c1f 	cmp	w0, #0x5b
    40003dd8:	54000be0 	b.eq	40003f54 <fnmatchx+0x224>  // b.none
    40003ddc:	7101701f 	cmp	w0, #0x5c
    40003de0:	54fffec1 	b.ne	40003db8 <fnmatchx+0x88>  // b.any
            if (!(flags & FNM_NOESCAPE)) {
    40003de4:	3707feb3 	tbnz	w19, #0, 40003db8 <fnmatchx+0x88>
                if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
    40003de8:	39400480 	ldrb	w0, [x4, #1]
    40003dec:	2a1303e1 	mov	w1, w19
    40003df0:	97ffffca 	bl	40003d18 <foldcase>
    40003df4:	72001c02 	ands	w2, w0, #0xff
    40003df8:	54fffe00 	b.eq	40003db8 <fnmatchx+0x88>  // b.none
    40003dfc:	91000895 	add	x21, x4, #0x2
    40003e00:	17ffffee 	b	40003db8 <fnmatchx+0x88>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
    40003e04:	36200073 	tbz	w19, #4, 40003e10 <fnmatchx+0xe0>
    40003e08:	7100bc7f 	cmp	w3, #0x2f
    40003e0c:	54000120 	b.eq	40003e30 <fnmatchx+0x100>  // b.none
            return *string == EOS ? 0 : FNM_NOMATCH;
    40003e10:	7100007f 	cmp	w3, #0x0
                        0 : FNM_NOMATCH;
    40003e14:	1a9f07e0 	cset	w0, ne  // ne = any
    40003e18:	14000006 	b	40003e30 <fnmatchx+0x100>
            if (*string == EOS)
    40003e1c:	34000083 	cbz	w3, 40003e2c <fnmatchx+0xfc>
            if (*string == '/' && (flags & FNM_PATHNAME))
    40003e20:	7100bc7f 	cmp	w3, #0x2f
    40003e24:	54000121 	b.ne	40003e48 <fnmatchx+0x118>  // b.any
    40003e28:	36080233 	tbz	w19, #1, 40003e6c <fnmatchx+0x13c>
        return FNM_NOMATCH;
    40003e2c:	52800020 	mov	w0, #0x1                   	// #1
}
    40003e30:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003e34:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003e38:	a94363f7 	ldp	x23, x24, [sp, #48]
    40003e3c:	f94023f9 	ldr	x25, [sp, #64]
    40003e40:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40003e44:	d65f03c0 	ret
            if (*string == '.' && (flags & FNM_PERIOD) &&
    40003e48:	7100b87f 	cmp	w3, #0x2e
    40003e4c:	54000101 	b.ne	40003e6c <fnmatchx+0x13c>  // b.any
    40003e50:	340000f8 	cbz	w24, 40003e6c <fnmatchx+0x13c>
    40003e54:	eb16029f 	cmp	x20, x22
    40003e58:	54fffea0 	b.eq	40003e2c <fnmatchx+0xfc>  // b.none
                (string == stringstart ||
    40003e5c:	36080093 	tbz	w19, #1, 40003e6c <fnmatchx+0x13c>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
    40003e60:	385ff280 	ldurb	w0, [x20, #-1]
    40003e64:	7100bc1f 	cmp	w0, #0x2f
    40003e68:	54fffe20 	b.eq	40003e2c <fnmatchx+0xfc>  // b.none
            ++string;
    40003e6c:	91000694 	add	x20, x20, #0x1
            break;
    40003e70:	aa1503e4 	mov	x4, x21
    40003e74:	17ffffc2 	b	40003d7c <fnmatchx+0x4c>
            c = FOLDCASE(*pattern, flags);
    40003e78:	39400480 	ldrb	w0, [x4, #1]
    40003e7c:	2a1303e1 	mov	w1, w19
                c = FOLDCASE(*++pattern, flags);
    40003e80:	97ffffa6 	bl	40003d18 <foldcase>
    40003e84:	12001c01 	and	w1, w0, #0xff
            while (c == '*')
    40003e88:	7100a83f 	cmp	w1, #0x2a
    40003e8c:	54000260 	b.eq	40003ed8 <fnmatchx+0x1a8>  // b.none
            if (*string == '.' && (flags & FNM_PERIOD) &&
    40003e90:	7100b87f 	cmp	w3, #0x2e
    40003e94:	54000101 	b.ne	40003eb4 <fnmatchx+0x184>  // b.any
    40003e98:	340000f8 	cbz	w24, 40003eb4 <fnmatchx+0x184>
    40003e9c:	eb16029f 	cmp	x20, x22
    40003ea0:	54fffc60 	b.eq	40003e2c <fnmatchx+0xfc>  // b.none
                (string == stringstart ||
    40003ea4:	36080093 	tbz	w19, #1, 40003eb4 <fnmatchx+0x184>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
    40003ea8:	385ff280 	ldurb	w0, [x20, #-1]
    40003eac:	7100bc1f 	cmp	w0, #0x2f
    40003eb0:	54fffbe0 	b.eq	40003e2c <fnmatchx+0xfc>  // b.none
            if (c == EOS) {
    40003eb4:	35000181 	cbnz	w1, 40003ee4 <fnmatchx+0x1b4>
                if (flags & FNM_PATHNAME)
    40003eb8:	121f0260 	and	w0, w19, #0x2
    40003ebc:	360ffbb3 	tbz	w19, #1, 40003e30 <fnmatchx+0x100>
                        0 : FNM_NOMATCH;
    40003ec0:	37200f13 	tbnz	w19, #4, 400040a0 <fnmatchx+0x370>
                        strchr(string, '/') == NULL ?
    40003ec4:	aa1403e0 	mov	x0, x20
    40003ec8:	528005e1 	mov	w1, #0x2f                  	// #47
    40003ecc:	940024c5 	bl	4000d1e0 <strchr>
                        0 : FNM_NOMATCH;
    40003ed0:	f100001f 	cmp	x0, #0x0
    40003ed4:	17ffffd0 	b	40003e14 <fnmatchx+0xe4>
                c = FOLDCASE(*++pattern, flags);
    40003ed8:	38401ea0 	ldrb	w0, [x21, #1]!
    40003edc:	2a1303e1 	mov	w1, w19
    40003ee0:	17ffffe8 	b	40003e80 <fnmatchx+0x150>
            } else if (c == '/' && flags & FNM_PATHNAME) {
    40003ee4:	7100bc3f 	cmp	w1, #0x2f
    40003ee8:	540002a0 	b.eq	40003f3c <fnmatchx+0x20c>  // b.none
    if (recursion-- == 0)
    40003eec:	d10006f7 	sub	x23, x23, #0x1
                switch ((e = fnmatchx(pattern, string,
    40003ef0:	121d7a78 	and	w24, w19, #0xfffffffb
                if (test == '/' && flags & FNM_PATHNAME)
    40003ef4:	121f0279 	and	w25, w19, #0x2
            while ((test = FOLDCASE(*string, flags)) != EOS) {
    40003ef8:	39400280 	ldrb	w0, [x20]
    40003efc:	2a1303e1 	mov	w1, w19
    40003f00:	97ffff86 	bl	40003d18 <foldcase>
    40003f04:	72001c16 	ands	w22, w0, #0xff
    40003f08:	54fff920 	b.eq	40003e2c <fnmatchx+0xfc>  // b.none
                switch ((e = fnmatchx(pattern, string,
    40003f0c:	aa1703e3 	mov	x3, x23
    40003f10:	2a1803e2 	mov	w2, w24
    40003f14:	aa1403e1 	mov	x1, x20
    40003f18:	aa1503e0 	mov	x0, x21
    40003f1c:	97ffff85 	bl	40003d30 <fnmatchx>
    40003f20:	7100041f 	cmp	w0, #0x1
    40003f24:	54fff861 	b.ne	40003e30 <fnmatchx+0x100>  // b.any
                if (test == '/' && flags & FNM_PATHNAME)
    40003f28:	7100bedf 	cmp	w22, #0x2f
    40003f2c:	54000041 	b.ne	40003f34 <fnmatchx+0x204>  // b.any
    40003f30:	35fff7f9 	cbnz	w25, 40003e2c <fnmatchx+0xfc>
                ++string;
    40003f34:	91000694 	add	x20, x20, #0x1
    40003f38:	17fffff0 	b	40003ef8 <fnmatchx+0x1c8>
            } else if (c == '/' && flags & FNM_PATHNAME) {
    40003f3c:	360ffd93 	tbz	w19, #1, 40003eec <fnmatchx+0x1bc>
                if ((string = strchr(string, '/')) == NULL)
    40003f40:	aa1403e0 	mov	x0, x20
    40003f44:	940024a7 	bl	4000d1e0 <strchr>
    40003f48:	aa0003f4 	mov	x20, x0
    40003f4c:	b5fff920 	cbnz	x0, 40003e70 <fnmatchx+0x140>
    40003f50:	17ffffb7 	b	40003e2c <fnmatchx+0xfc>
            if (*string == EOS)
    40003f54:	34fff6c3 	cbz	w3, 40003e2c <fnmatchx+0xfc>
            if (*string == '/' && flags & FNM_PATHNAME)
    40003f58:	7100bc7f 	cmp	w3, #0x2f
    40003f5c:	54000041 	b.ne	40003f64 <fnmatchx+0x234>  // b.any
    40003f60:	370ff673 	tbnz	w19, #1, 40003e2c <fnmatchx+0xfc>
            if ((r = rangematch(pattern,
    40003f64:	2a1303e1 	mov	w1, w19
    40003f68:	2a0303e0 	mov	w0, w3
    40003f6c:	97ffff6b 	bl	40003d18 <foldcase>
    40003f70:	2a0003e7 	mov	w7, w0
    if (pattern == NULL)
    40003f74:	b4fff5d5 	cbz	x21, 40003e2c <fnmatchx+0xfc>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    40003f78:	39400480 	ldrb	w0, [x4, #1]
        ++pattern;
    40003f7c:	91000884 	add	x4, x4, #0x2
            ok = 1;
    40003f80:	52800029 	mov	w9, #0x1                   	// #1
        if (c == '\\' && !(flags & FNM_NOESCAPE))
    40003f84:	0a09026a 	and	w10, w19, w9
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    40003f88:	7100841f 	cmp	w0, #0x21
            ok = 1;
    40003f8c:	52800006 	mov	w6, #0x0                   	// #0
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    40003f90:	1a9f17e8 	cset	w8, eq  // eq = none
    40003f94:	7101781f 	cmp	w0, #0x5e
    40003f98:	1a9f17e0 	cset	w0, eq  // eq = none
    40003f9c:	2a000108 	orr	w8, w8, w0
        ++pattern;
    40003fa0:	7100011f 	cmp	w8, #0x0
    40003fa4:	9a951084 	csel	x4, x4, x21, ne  // ne = any
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
    40003fa8:	aa0403e2 	mov	x2, x4
    40003fac:	2a1303e1 	mov	w1, w19
    40003fb0:	38401440 	ldrb	w0, [x2], #1
    40003fb4:	97ffff59 	bl	40003d18 <foldcase>
    40003fb8:	12001c05 	and	w5, w0, #0xff
    40003fbc:	710174bf 	cmp	w5, #0x5d
    40003fc0:	540001a1 	b.ne	40003ff4 <fnmatchx+0x2c4>  // b.any
    40003fc4:	350002e9 	cbnz	w9, 40004020 <fnmatchx+0x2f0>
    return ok == negate ? NULL : pattern;
    40003fc8:	6b06011f 	cmp	w8, w6
    40003fcc:	54fff300 	b.eq	40003e2c <fnmatchx+0xfc>  // b.none
            if ((r = rangematch(pattern,
    40003fd0:	b4fff2e2 	cbz	x2, 40003e2c <fnmatchx+0xfc>
            if (r == (void *)-1) {
    40003fd4:	b100045f 	cmn	x2, #0x1
    40003fd8:	54000081 	b.ne	40003fe8 <fnmatchx+0x2b8>  // b.any
                if (*string != '[')
    40003fdc:	71016c7f 	cmp	w3, #0x5b
    40003fe0:	54fff261 	b.ne	40003e2c <fnmatchx+0xfc>  // b.any
    40003fe4:	aa1503e2 	mov	x2, x21
            ++string;
    40003fe8:	91000694 	add	x20, x20, #0x1
            break;
    40003fec:	aa0203f5 	mov	x21, x2
    40003ff0:	17ffffa0 	b	40003e70 <fnmatchx+0x140>
        if (c == '/')
    40003ff4:	7100bcbf 	cmp	w5, #0x2f
    40003ff8:	54ffff20 	b.eq	40003fdc <fnmatchx+0x2ac>  // b.none
        if (c == '\\' && !(flags & FNM_NOESCAPE))
    40003ffc:	710170bf 	cmp	w5, #0x5c
    40004000:	540000e1 	b.ne	4000401c <fnmatchx+0x2ec>  // b.any
    40004004:	350000ea 	cbnz	w10, 40004020 <fnmatchx+0x2f0>
            c = FOLDCASE(*pattern++, flags);
    40004008:	39400480 	ldrb	w0, [x4, #1]
    4000400c:	2a1303e1 	mov	w1, w19
    40004010:	91000882 	add	x2, x4, #0x2
    40004014:	97ffff41 	bl	40003d18 <foldcase>
    40004018:	12001c05 	and	w5, w0, #0xff
        if (c == EOS)
    4000401c:	34fff085 	cbz	w5, 40003e2c <fnmatchx+0xfc>
        if (*pattern == '-' 
    40004020:	39400040 	ldrb	w0, [x2]
    40004024:	7100b41f 	cmp	w0, #0x2d
    40004028:	54000301 	b.ne	40004088 <fnmatchx+0x358>  // b.any
            && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
    4000402c:	39400440 	ldrb	w0, [x2, #1]
    40004030:	2a1303e1 	mov	w1, w19
    40004034:	97ffff39 	bl	40003d18 <foldcase>
    40004038:	72001c01 	ands	w1, w0, #0xff
    4000403c:	54000260 	b.eq	40004088 <fnmatchx+0x358>  // b.none
    40004040:	7101743f 	cmp	w1, #0x5d
    40004044:	54000220 	b.eq	40004088 <fnmatchx+0x358>  // b.none
            pattern += 2;
    40004048:	91000844 	add	x4, x2, #0x2
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
    4000404c:	7101703f 	cmp	w1, #0x5c
    40004050:	54000101 	b.ne	40004070 <fnmatchx+0x340>  // b.any
    40004054:	350000ea 	cbnz	w10, 40004070 <fnmatchx+0x340>
                c2 = FOLDCASE(*pattern++, flags);
    40004058:	39400840 	ldrb	w0, [x2, #2]
    4000405c:	2a1303e1 	mov	w1, w19
    40004060:	91000c44 	add	x4, x2, #0x3
    40004064:	97ffff2d 	bl	40003d18 <foldcase>
            if (c2 == EOS)
    40004068:	72001c01 	ands	w1, w0, #0xff
    4000406c:	54ffee00 	b.eq	40003e2c <fnmatchx+0xfc>  // b.none
            if (c <= test && test <= c2)
    40004070:	6b0500ff 	cmp	w7, w5
    40004074:	5400006b 	b.lt	40004080 <fnmatchx+0x350>  // b.tstop
                ok = 1;
    40004078:	6b0100ff 	cmp	w7, w1
    4000407c:	1a99c0c6 	csel	w6, w6, w25, gt
            ok = 1;
    40004080:	52800009 	mov	w9, #0x0                   	// #0
    40004084:	17ffffc9 	b	40003fa8 <fnmatchx+0x278>
        } else if (c == test)
    40004088:	6b0500ff 	cmp	w7, w5
    4000408c:	aa0203e4 	mov	x4, x2
    40004090:	1a9910c6 	csel	w6, w6, w25, ne  // ne = any
    40004094:	17fffffb 	b	40004080 <fnmatchx+0x350>
        return FNM_NORES;
    40004098:	52800060 	mov	w0, #0x3                   	// #3
    4000409c:	17ffff65 	b	40003e30 <fnmatchx+0x100>
                return 0;
    400040a0:	52800000 	mov	w0, #0x0                   	// #0
    400040a4:	17ffff63 	b	40003e30 <fnmatchx+0x100>

00000000400040a8 <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
    return fnmatchx(pattern, string, flags, 64);
    400040a8:	d2800803 	mov	x3, #0x40                  	// #64
    400040ac:	17ffff21 	b	40003d30 <fnmatchx>

00000000400040b0 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    400040b0:	d65f03c0 	ret

00000000400040b4 <z_arm64_el3_plat_init>:
	uint64_t reg = 0;

	reg = (ICC_SRE_ELx_DFB_BIT | ICC_SRE_ELx_DIB_BIT |
	       ICC_SRE_ELx_SRE_BIT | ICC_SRE_EL3_EN_BIT);

	write_sysreg(reg, ICC_SRE_EL3);
    400040b4:	d28001e0 	mov	x0, #0xf                   	// #15
    400040b8:	d51ecca0 	msr	s3_6_c12_c12_5, x0
}
    400040bc:	d65f03c0 	ret

00000000400040c0 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
    400040c0:	a9007c1f 	stp	xzr, xzr, [x0]
	list->head = NULL;
}
    400040c4:	d65f03c0 	ret

00000000400040c8 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
    400040c8:	f9400002 	ldr	x2, [x0]
    400040cc:	b50000a2 	cbnz	x2, 400040e0 <log_list_add_tail+0x18>
		list->head = msg;
    400040d0:	f9000001 	str	x1, [x0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
    400040d4:	f9000401 	str	x1, [x0, #8]
	msg->next = NULL;
    400040d8:	f900003f 	str	xzr, [x1]
}
    400040dc:	d65f03c0 	ret
		list->tail->next = msg;
    400040e0:	f9400402 	ldr	x2, [x0, #8]
    400040e4:	f9000041 	str	x1, [x2]
    400040e8:	17fffffb 	b	400040d4 <log_list_add_tail+0xc>

00000000400040ec <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
    400040ec:	f9400000 	ldr	x0, [x0]
    400040f0:	d65f03c0 	ret

00000000400040f4 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
    400040f4:	aa0003e1 	mov	x1, x0
	struct log_msg *msg = list->head;
    400040f8:	f9400000 	ldr	x0, [x0]

	if (list->head != NULL) {
    400040fc:	b4000060 	cbz	x0, 40004108 <log_list_head_get+0x14>
		list->head = list->head->next;
    40004100:	f9400002 	ldr	x2, [x0]
    40004104:	f9000022 	str	x2, [x1]
	}

	return msg;
}
    40004108:	d65f03c0 	ret

000000004000410c <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
    4000410c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40004110:	910003fd 	mov	x29, sp
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    40004114:	94000393 	bl	40004f60 <log_msg_chunk_alloc>

	if (msg != NULL) {
    40004118:	b4000080 	cbz	x0, 40004128 <z_log_msg_std_alloc+0x1c>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    4000411c:	d2800021 	mov	x1, #0x1                   	// #1
    40004120:	f9000401 	str	x1, [x0, #8]
		msg->hdr.params.raw = 0U;
    40004124:	7900201f 	strh	wzr, [x0, #16]
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
    40004128:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000412c:	d65f03c0 	ret

0000000040004130 <default_lf_get_timestamp>:
	return IS_ENABLED(CONFIG_LOG_TIMESTAMP_64BIT) ?
		sys_clock_tick_get() : k_cycle_get_32();
}

static log_timestamp_t default_lf_get_timestamp(void)
{
    40004130:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40004134:	910003fd 	mov	x29, sp
		/* coverity[OVERRUN] */
		return (int64_t) arch_syscall_invoke0(K_SYSCALL_K_UPTIME_TICKS);
	}
#endif
	compiler_barrier();
	return z_impl_k_uptime_ticks();
    40004138:	94003263 	bl	40010ac4 <z_impl_k_uptime_ticks>
	return IS_ENABLED(CONFIG_LOG_TIMESTAMP_64BIT) ?
		k_uptime_get() : k_uptime_get_32();
}
    4000413c:	d2800141 	mov	x1, #0xa                   	// #10
    40004140:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004144:	1b017c00 	mul	w0, w0, w1
    40004148:	d65f03c0 	ret

000000004000414c <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
    4000414c:	d100c3ff 	sub	sp, sp, #0x30
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    40004150:	d2800002 	mov	x2, #0x0                   	// #0
    40004154:	90000001 	adrp	x1, 40004000 <fnmatchx+0x2d0>
    40004158:	91077021 	add	x1, x1, #0x1dc
    4000415c:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004160:	91082000 	add	x0, x0, #0x208
{
    40004164:	a9017bfd 	stp	x29, x30, [sp, #16]
    40004168:	910043fd 	add	x29, sp, #0x10
    4000416c:	f90013f3 	str	x19, [sp, #32]
		k_timer_init(&log_process_thread_timer,
    40004170:	94003286 	bl	40010b88 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    40004174:	b90003ff 	str	wzr, [sp]
    40004178:	900000f3 	adrp	x19, 40020000 <logging_thread>
    4000417c:	91000273 	add	x19, x19, #0x0
    40004180:	f90007ff 	str	xzr, [sp, #8]
    40004184:	aa1303e0 	mov	x0, x19
    40004188:	528001c7 	mov	w7, #0xe                   	// #14
    4000418c:	d2800006 	mov	x6, #0x0                   	// #0
    40004190:	d2800005 	mov	x5, #0x0                   	// #0
    40004194:	d2800004 	mov	x4, #0x0                   	// #0
    40004198:	d2820002 	mov	x2, #0x1000                	// #4096
    4000419c:	90000003 	adrp	x3, 40004000 <fnmatchx+0x2d0>
    400041a0:	911d7063 	add	x3, x3, #0x75c
    400041a4:	b0000321 	adrp	x1, 40069000 <z_page_frames+0x47413>
    400041a8:	912fc021 	add	x1, x1, #0xbf0
    400041ac:	94002a99 	bl	4000ec10 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    400041b0:	b0000081 	adrp	x1, 40015000 <prefix.1+0x2aa>
    400041b4:	91016c21 	add	x1, x1, #0x5b
    400041b8:	aa1303e0 	mov	x0, x19
    400041bc:	94002a10 	bl	4000e9fc <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    400041c0:	52800000 	mov	w0, #0x0                   	// #0
    400041c4:	a9417bfd 	ldp	x29, x30, [sp, #16]
    400041c8:	f94013f3 	ldr	x19, [sp, #32]
    400041cc:	9100c3ff 	add	sp, sp, #0x30
    400041d0:	d65f03c0 	ret

00000000400041d4 <dummy_timestamp>:
    400041d4:	52800000 	mov	w0, #0x0                   	// #0
    400041d8:	d65f03c0 	ret

00000000400041dc <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    400041dc:	f0000340 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    400041e0:	91368000 	add	x0, x0, #0xda0
    400041e4:	14002c40 	b	4000f2e4 <z_impl_k_sem_give>

00000000400041e8 <z_log_get_s_mask>:
{
    400041e8:	aa0003e5 	mov	x5, x0
	uint32_t arg = 0U;
    400041ec:	52800002 	mov	w2, #0x0                   	// #0
	uint32_t mask = 0U;
    400041f0:	52800000 	mov	w0, #0x0                   	// #0
	bool arm = false;
    400041f4:	52800003 	mov	w3, #0x0                   	// #0
				mask |= BIT(arg);
    400041f8:	d2800027 	mov	x7, #0x1                   	// #1
	while ((curr = *str++) && arg < nargs) {
    400041fc:	384014a4 	ldrb	w4, [x5], #1
    40004200:	34000064 	cbz	w4, 4000420c <z_log_get_s_mask+0x24>
    40004204:	6b01005f 	cmp	w2, w1
    40004208:	54000043 	b.cc	40004210 <z_log_get_s_mask+0x28>  // b.lo, b.ul, b.last
}
    4000420c:	d65f03c0 	ret
		if (curr == '%') {
    40004210:	7100949f 	cmp	w4, #0x25
    40004214:	54000061 	b.ne	40004220 <z_log_get_s_mask+0x38>  // b.any
			arm = !arm;
    40004218:	52000063 	eor	w3, w3, #0x1
    4000421c:	17fffff8 	b	400041fc <z_log_get_s_mask+0x14>
		} else if (arm && isalpha((int)curr)) {
    40004220:	34fffee3 	cbz	w3, 400041fc <z_log_get_s_mask+0x14>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    40004224:	321b0086 	orr	w6, w4, #0x20
    40004228:	510184c6 	sub	w6, w6, #0x61
    4000422c:	710064df 	cmp	w6, #0x19
    40004230:	54fffe68 	b.hi	400041fc <z_log_get_s_mask+0x14>  // b.pmore
			if (curr == 's') {
    40004234:	7101cc9f 	cmp	w4, #0x73
    40004238:	54000061 	b.ne	40004244 <z_log_get_s_mask+0x5c>  // b.any
				mask |= BIT(arg);
    4000423c:	9ac220e3 	lsl	x3, x7, x2
    40004240:	2a030000 	orr	w0, w0, w3
			arg++;
    40004244:	11000442 	add	w2, w2, #0x1
			arm = false;
    40004248:	52800003 	mov	w3, #0x0                   	// #0
    4000424c:	17ffffec 	b	400041fc <z_log_get_s_mask+0x14>

0000000040004250 <log_core_init>:
{
    40004250:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	panic_mode = false;
    40004254:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
	timestamp_func = timestamp_getter;
    40004258:	f0000341 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
{
    4000425c:	910003fd 	mov	x29, sp
	panic_mode = false;
    40004260:	392f181f 	strb	wzr, [x0, #3014]
	dropped_cnt = 0;
    40004264:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004268:	f900f41f 	str	xzr, [x0, #488]
	timestamp_func = timestamp_getter;
    4000426c:	90000000 	adrp	x0, 40004000 <fnmatchx+0x2d0>
    40004270:	9104c000 	add	x0, x0, #0x130
    40004274:	f905d020 	str	x0, [x1, #2976]
	log_output_timestamp_freq_set(freq);
    40004278:	52807d00 	mov	w0, #0x3e8                 	// #1000
    4000427c:	94000665 	bl	40005c10 <log_output_timestamp_freq_set>
		log_msg_pool_init();
    40004280:	94000315 	bl	40004ed4 <log_msg_pool_init>
		log_list_init(&list);
    40004284:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004288:	9107e000 	add	x0, x0, #0x1f8
    4000428c:	97ffff8d 	bl	400040c0 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    40004290:	52800083 	mov	w3, #0x4                   	// #4
    40004294:	d2800602 	mov	x2, #0x30                  	// #48
    40004298:	f0000341 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
    4000429c:	910fc021 	add	x1, x1, #0x3f0
    400042a0:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    400042a4:	91098000 	add	x0, x0, #0x260
    400042a8:	9400294a 	bl	4000e7d0 <k_mem_slab_init>
}
    400042ac:	a8c17bfd 	ldp	x29, x30, [sp], #16
		z_log_runtime_filters_init();
    400042b0:	1400020d 	b	40004ae4 <z_log_runtime_filters_init>

00000000400042b4 <log_init>:
{
    400042b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    400042b8:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    400042bc:	9107c021 	add	x1, x1, #0x1f0
    400042c0:	910003fd 	mov	x29, sp
    400042c4:	d2800020 	mov	x0, #0x1                   	// #1
    400042c8:	a90153f3 	stp	x19, x20, [sp, #16]
    400042cc:	f90013f5 	str	x21, [sp, #32]
    400042d0:	97fff33c 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (atomic_inc(&initialized) != 0) {
    400042d4:	b5000140 	cbnz	x0, 400042fc <log_init+0x48>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    400042d8:	d0000073 	adrp	x19, 40012000 <__rodata_region_start>
    400042dc:	913c4273 	add	x19, x19, #0xf10
    400042e0:	d0000074 	adrp	x20, 40012000 <__rodata_region_start>
    400042e4:	913cc294 	add	x20, x20, #0xf30
    400042e8:	cb130294 	sub	x20, x20, x19
	for (i = 0; i < log_backend_count_get(); i++) {
    400042ec:	52800015 	mov	w21, #0x0                   	// #0
    400042f0:	d3459294 	ubfx	x20, x20, #5, #32
    400042f4:	6b1402bf 	cmp	w21, w20
    400042f8:	540000ab 	b.lt	4000430c <log_init+0x58>  // b.tstop
}
    400042fc:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004300:	f94013f5 	ldr	x21, [sp, #32]
    40004304:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004308:	d65f03c0 	ret
		if (backend->autostart) {
    4000430c:	39406260 	ldrb	w0, [x19, #24]
    40004310:	34000160 	cbz	w0, 4000433c <log_init+0x88>
			if (backend->api->init != NULL) {
    40004314:	f9400260 	ldr	x0, [x19]
    40004318:	f9401801 	ldr	x1, [x0, #48]
    4000431c:	b4000061 	cbz	x1, 40004328 <log_init+0x74>
				backend->api->init(backend);
    40004320:	aa1303e0 	mov	x0, x19
    40004324:	d63f0020 	blr	x1
			log_backend_enable(backend,
    40004328:	f9400660 	ldr	x0, [x19, #8]
    4000432c:	52800082 	mov	w2, #0x4                   	// #4
    40004330:	f9400001 	ldr	x1, [x0]
    40004334:	aa1303e0 	mov	x0, x19
    40004338:	94000268 	bl	40004cd8 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    4000433c:	110006b5 	add	w21, w21, #0x1
    40004340:	91008273 	add	x19, x19, #0x20
    40004344:	17ffffec 	b	400042f4 <log_init+0x40>

0000000040004348 <get_msg>:
{
    40004348:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000434c:	910003fd 	mov	x29, sp
    40004350:	f9000bf3 	str	x19, [sp, #16]
    40004354:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40004358:	d50342df 	msr	daifset, #0x2
	msg.msg = log_list_head_get(&list);
    4000435c:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004360:	9107e000 	add	x0, x0, #0x1f8
MAKE_REG_HELPER(daif)
    40004364:	92407e73 	and	x19, x19, #0xffffffff
    40004368:	97ffff63 	bl	400040f4 <log_list_head_get>
    4000436c:	d51b4233 	msr	daif, x19
}
    40004370:	f9400bf3 	ldr	x19, [sp, #16]
    40004374:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004378:	d65f03c0 	ret

000000004000437c <z_log_notify_backend_enabled>:
{
    4000437c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40004380:	910003fd 	mov	x29, sp
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
    40004384:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004388:	396f1401 	ldrb	w1, [x0, #3013]
{
    4000438c:	f9000bf3 	str	x19, [sp, #16]
    40004390:	aa0003f3 	mov	x19, x0
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
    40004394:	35000081 	cbnz	w1, 400043a4 <z_log_notify_backend_enabled+0x28>
    40004398:	f0000340 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000439c:	91368000 	add	x0, x0, #0xda0
    400043a0:	94002bd1 	bl	4000f2e4 <z_impl_k_sem_give>
	backend_attached = true;
    400043a4:	52800020 	mov	w0, #0x1                   	// #1
    400043a8:	392f1660 	strb	w0, [x19, #3013]
}
    400043ac:	f9400bf3 	ldr	x19, [sp, #16]
    400043b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400043b4:	d65f03c0 	ret

00000000400043b8 <z_log_dropped>:
{
    400043b8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400043bc:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    400043c0:	9107a021 	add	x1, x1, #0x1e8
    400043c4:	910003fd 	mov	x29, sp
    400043c8:	d2800020 	mov	x0, #0x1                   	// #1
    400043cc:	97fff2fd 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    400043d0:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    400043d4:	91078021 	add	x1, x1, #0x1e0
    400043d8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    400043dc:	97fff2f9 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
}
    400043e0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400043e4:	d65f03c0 	ret

00000000400043e8 <z_log_dropped_read_and_clear>:
{
    400043e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    400043ec:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    400043f0:	9107a021 	add	x1, x1, #0x1e8
    400043f4:	910003fd 	mov	x29, sp
    400043f8:	d2800000 	mov	x0, #0x0                   	// #0
    400043fc:	97fff2e5 	bl	40000f90 <__aarch64_swp8_acq_rel>
}
    40004400:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004404:	d65f03c0 	ret

0000000040004408 <dropped_notify>:
{
    40004408:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000440c:	910003fd 	mov	x29, sp
    40004410:	a90153f3 	stp	x19, x20, [sp, #16]
    40004414:	d0000073 	adrp	x19, 40012000 <__rodata_region_start>
    40004418:	913c4273 	add	x19, x19, #0xf10
    4000441c:	d0000074 	adrp	x20, 40012000 <__rodata_region_start>
    40004420:	913cc294 	add	x20, x20, #0xf30
    40004424:	cb130294 	sub	x20, x20, x19
    40004428:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint32_t dropped = z_log_dropped_read_and_clear();
    4000442c:	97ffffef 	bl	400043e8 <z_log_dropped_read_and_clear>
    40004430:	d3459294 	ubfx	x20, x20, #5, #32
    40004434:	2a0003f6 	mov	w22, w0
	for (int i = 0; i < log_backend_count_get(); i++) {
    40004438:	52800015 	mov	w21, #0x0                   	// #0
    4000443c:	6b1402bf 	cmp	w21, w20
    40004440:	540000ab 	b.lt	40004454 <dropped_notify+0x4c>  // b.tstop
}
    40004444:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004448:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000444c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004450:	d65f03c0 	ret
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    40004454:	f9400660 	ldr	x0, [x19, #8]
		if (log_backend_is_active(backend)) {
    40004458:	39402400 	ldrb	w0, [x0, #9]
    4000445c:	340000e0 	cbz	w0, 40004478 <dropped_notify+0x70>
	if (backend->api->dropped != NULL) {
    40004460:	f9400260 	ldr	x0, [x19]
    40004464:	f9401002 	ldr	x2, [x0, #32]
    40004468:	b4000082 	cbz	x2, 40004478 <dropped_notify+0x70>
		backend->api->dropped(backend, cnt);
    4000446c:	2a1603e1 	mov	w1, w22
    40004470:	aa1303e0 	mov	x0, x19
    40004474:	d63f0040 	blr	x2
	for (int i = 0; i < log_backend_count_get(); i++) {
    40004478:	110006b5 	add	w21, w21, #0x1
    4000447c:	91008273 	add	x19, x19, #0x20
    40004480:	17ffffef 	b	4000443c <dropped_notify+0x34>

0000000040004484 <z_log_strdup>:
{
    40004484:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40004488:	910003fd 	mov	x29, sp
    4000448c:	f9000bf3 	str	x19, [sp, #16]
    40004490:	aa0003f3 	mov	x19, x0
	return (((const char *)addr >= (const char *)RO_START) &&
    40004494:	d0000060 	adrp	x0, 40012000 <__rodata_region_start>
    40004498:	91000000 	add	x0, x0, #0x0
    4000449c:	eb00027f 	cmp	x19, x0
    400044a0:	540000a3 	b.cc	400044b4 <z_log_strdup+0x30>  // b.lo, b.ul, b.last
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
    400044a4:	f0000080 	adrp	x0, 40017000 <__aarch64_have_lse_atomics>
    400044a8:	91000000 	add	x0, x0, #0x0
    400044ac:	eb00027f 	cmp	x19, x0
    400044b0:	54000263 	b.cc	400044fc <z_log_strdup+0x78>  // b.lo, b.ul, b.last
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    400044b4:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    400044b8:	91098000 	add	x0, x0, #0x260
    400044bc:	9100a3e1 	add	x1, sp, #0x28
    400044c0:	d2800002 	mov	x2, #0x0                   	// #0
    400044c4:	940028d8 	bl	4000e824 <k_mem_slab_alloc>
	if (err != 0) {
    400044c8:	35000220 	cbnz	w0, 4000450c <z_log_strdup+0x88>
    400044cc:	f94017e1 	ldr	x1, [sp, #40]
    400044d0:	d2800020 	mov	x0, #0x1                   	// #1
    400044d4:	97fff2af 	bl	40000f90 <__aarch64_swp8_acq_rel>
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    400044d8:	f94017e0 	ldr	x0, [sp, #40]
    400044dc:	aa1303e1 	mov	x1, x19
    400044e0:	d28003e2 	mov	x2, #0x1f                  	// #31
    400044e4:	91002000 	add	x0, x0, #0x8
    400044e8:	9400232e 	bl	4000d1a0 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    400044ec:	f94017f3 	ldr	x19, [sp, #40]
    400044f0:	52800fc0 	mov	w0, #0x7e                  	// #126
	return dup->buf;
    400044f4:	91002273 	add	x19, x19, #0x8
	dup->buf[sizeof(dup->buf) - 2] = '~';
    400044f8:	7801f260 	sturh	w0, [x19, #31]
}
    400044fc:	aa1303e0 	mov	x0, x19
    40004500:	f9400bf3 	ldr	x19, [sp, #16]
    40004504:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004508:	d65f03c0 	ret
		return (char *)log_strdup_fail_msg;
    4000450c:	90000093 	adrp	x19, 40014000 <shell_m_sub_colors+0x50>
    40004510:	9131fe73 	add	x19, x19, #0xc7f
    40004514:	17fffffa 	b	400044fc <z_log_strdup+0x78>

0000000040004518 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
    40004518:	b4000120 	cbz	x0, 4000453c <log_is_strdup+0x24>
    4000451c:	f0000341 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
    40004520:	910fc021 	add	x1, x1, #0x3f0
    40004524:	eb01001f 	cmp	x0, x1
    40004528:	540000a3 	b.cc	4000453c <log_is_strdup+0x24>  // b.lo, b.ul, b.last
    4000452c:	91030021 	add	x1, x1, #0xc0
    40004530:	eb01001f 	cmp	x0, x1
    40004534:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
}
    40004538:	d65f03c0 	ret
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
    4000453c:	52800000 	mov	w0, #0x0                   	// #0
    40004540:	17fffffe 	b	40004538 <log_is_strdup+0x20>

0000000040004544 <z_impl_log_process>:
{
    40004544:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40004548:	910003fd 	mov	x29, sp
    4000454c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004550:	12001c16 	and	w22, w0, #0xff
	if (!backend_attached && !bypass) {
    40004554:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004558:	396f1400 	ldrb	w0, [x0, #3013]
{
    4000455c:	a90153f3 	stp	x19, x20, [sp, #16]
    40004560:	a90363f7 	stp	x23, x24, [sp, #48]
    40004564:	a9046bf9 	stp	x25, x26, [sp, #64]
    40004568:	a90573fb 	stp	x27, x28, [sp, #80]
	if (!backend_attached && !bypass) {
    4000456c:	35000040 	cbnz	w0, 40004574 <z_impl_log_process+0x30>
    40004570:	340002d6 	cbz	w22, 400045c8 <z_impl_log_process+0x84>
	msg = get_msg();
    40004574:	97ffff75 	bl	40004348 <get_msg>
    40004578:	aa0003f3 	mov	x19, x0
	if (msg.msg) {
    4000457c:	b4000100 	cbz	x0, 4000459c <z_impl_log_process+0x58>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    40004580:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40004584:	91078021 	add	x1, x1, #0x1e0
    40004588:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4000458c:	97fff28d 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (!bypass) {
    40004590:	340002d6 	cbz	w22, 400045e8 <z_impl_log_process+0xa4>
			log_msg_put(msg.msg);
    40004594:	aa1303e0 	mov	x0, x19
    40004598:	940002d6 	bl	400050f0 <log_msg_put>
	if (!bypass && z_log_dropped_pending()) {
    4000459c:	350000d6 	cbnz	w22, 400045b4 <z_impl_log_process+0x70>
	return dropped_cnt > 0;
    400045a0:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
	if (!bypass && z_log_dropped_pending()) {
    400045a4:	f940f400 	ldr	x0, [x0, #488]
    400045a8:	f100001f 	cmp	x0, #0x0
    400045ac:	5400004d 	b.le	400045b4 <z_impl_log_process+0x70>
		dropped_notify();
    400045b0:	97ffff96 	bl	40004408 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
    400045b4:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    400045b8:	9107e000 	add	x0, x0, #0x1f8
    400045bc:	97fffecc 	bl	400040ec <log_list_head_peek>
    400045c0:	f100001f 	cmp	x0, #0x0
    400045c4:	1a9f07f6 	cset	w22, ne  // ne = any
}
    400045c8:	2a1603e0 	mov	w0, w22
    400045cc:	a94153f3 	ldp	x19, x20, [sp, #16]
    400045d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400045d4:	a94363f7 	ldp	x23, x24, [sp, #48]
    400045d8:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400045dc:	a94573fb 	ldp	x27, x28, [sp, #80]
    400045e0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    400045e4:	d65f03c0 	ret
		    !panic_mode) {
    400045e8:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
		if (!IS_ENABLED(CONFIG_LOG2) &&
    400045ec:	396f1800 	ldrb	w0, [x0, #3014]
    400045f0:	35000300 	cbnz	w0, 40004650 <z_impl_log_process+0x10c>
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    400045f4:	79402260 	ldrh	w0, [x19, #16]
	if (!log_msg_is_std(msg)) {
    400045f8:	370002c0 	tbnz	w0, #0, 40004650 <z_impl_log_process+0x10c>
    400045fc:	f0000359 	adrp	x25, 4006f000 <sys_work_q_stack+0xc10>
    40004600:	91336339 	add	x25, x25, #0xcd8
    40004604:	f0000354 	adrp	x20, 4006f000 <sys_work_q_stack+0xc10>
    40004608:	91334294 	add	x20, x20, #0xcd0
	msg_str = log_msg_str_get(msg);
    4000460c:	aa1303e0 	mov	x0, x19
    40004610:	cb140334 	sub	x20, x25, x20
    40004614:	940002c7 	bl	40005130 <log_msg_str_get>
    40004618:	aa0003f8 	mov	x24, x0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    4000461c:	aa1303e0 	mov	x0, x19
    40004620:	9400025e 	bl	40004f98 <log_msg_nargs_get>
	return (((const char *)addr >= (const char *)RO_START) &&
    40004624:	d000007a 	adrp	x26, 40012000 <__rodata_region_start>
    40004628:	9100035a 	add	x26, x26, #0x0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    4000462c:	2a0003e1 	mov	w1, w0
		if (!is_rodata(str) && !log_is_strdup(str) &&
    40004630:	9000009b 	adrp	x27, 40014000 <shell_m_sub_colors+0x50>
    40004634:	9131ff7b 	add	x27, x27, #0xc7f
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    40004638:	aa1803e0 	mov	x0, x24
    4000463c:	d342fe94 	lsr	x20, x20, #2
    40004640:	97fffeea 	bl	400041e8 <z_log_get_s_mask>
    40004644:	2a0003f5 	mov	w21, w0
		idx = 31 - __builtin_clz(mask);
    40004648:	528003fc 	mov	w28, #0x1f                  	// #31
	while (mask) {
    4000464c:	35000135 	cbnz	w21, 40004670 <z_impl_log_process+0x12c>
	return __log_backends_end - __log_backends_start;
    40004650:	d0000074 	adrp	x20, 40012000 <__rodata_region_start>
    40004654:	913c4294 	add	x20, x20, #0xf10
    40004658:	d0000075 	adrp	x21, 40012000 <__rodata_region_start>
    4000465c:	913cc2b5 	add	x21, x21, #0xf30
    40004660:	cb1402b5 	sub	x21, x21, x20
    40004664:	52800017 	mov	w23, #0x0                   	// #0
    40004668:	d34592b5 	ubfx	x21, x21, #5, #32
    4000466c:	14000039 	b	40004750 <z_impl_log_process+0x20c>
		idx = 31 - __builtin_clz(mask);
    40004670:	5ac012b7 	clz	w23, w21
		str = (const char *)log_msg_arg_get(msg, idx);
    40004674:	aa1303e0 	mov	x0, x19
		idx = 31 - __builtin_clz(mask);
    40004678:	4b170397 	sub	w23, w28, w23
		str = (const char *)log_msg_arg_get(msg, idx);
    4000467c:	2a1703e1 	mov	w1, w23
    40004680:	94000249 	bl	40004fa4 <log_msg_arg_get>
    40004684:	aa0003e2 	mov	x2, x0
	return (((const char *)addr >= (const char *)RO_START) &&
    40004688:	eb1a001f 	cmp	x0, x26
    4000468c:	540000a3 	b.cc	400046a0 <z_impl_log_process+0x15c>  // b.lo, b.ul, b.last
		if (!is_rodata(str) && !log_is_strdup(str) &&
    40004690:	f0000080 	adrp	x0, 40017000 <__aarch64_have_lse_atomics>
    40004694:	91000000 	add	x0, x0, #0x0
    40004698:	eb00005f 	cmp	x2, x0
    4000469c:	540002c3 	b.cc	400046f4 <z_impl_log_process+0x1b0>  // b.lo, b.ul, b.last
    400046a0:	aa0203e0 	mov	x0, x2
    400046a4:	97ffff9d 	bl	40004518 <log_is_strdup>
    400046a8:	72001c1f 	tst	w0, #0xff
    400046ac:	54000241 	b.ne	400046f4 <z_impl_log_process+0x1b0>  // b.any
    400046b0:	eb1b005f 	cmp	x2, x27
    400046b4:	54000200 	b.eq	400046f4 <z_impl_log_process+0x1b0>  // b.none
	return msg->hdr.ids.source_id;
    400046b8:	f9400a61 	ldr	x1, [x19, #16]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
    400046bc:	52800000 	mov	w0, #0x0                   	// #0
    400046c0:	53167c21 	lsr	w1, w1, #22
    400046c4:	9400011b 	bl	40004b30 <log_source_name_get>
    400046c8:	aa0003e2 	mov	x2, x0
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
    400046cc:	b9400320 	ldr	w0, [x25]
    400046d0:	f240081f 	tst	x0, #0x7
    400046d4:	54000100 	b.eq	400046f4 <z_impl_log_process+0x1b0>  // b.none
    400046d8:	531a2684 	ubfiz	w4, w20, #6, #10
    400046dc:	90000080 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    400046e0:	91326400 	add	x0, x0, #0xc99
    400046e4:	32000084 	orr	w4, w4, #0x1
    400046e8:	aa1803e3 	mov	x3, x24
    400046ec:	93407ee1 	sxtw	x1, w23
    400046f0:	940000ab 	bl	4000499c <log_3>
		mask &= ~BIT(idx);
    400046f4:	d2800020 	mov	x0, #0x1                   	// #1
    400046f8:	9ad72017 	lsl	x23, x0, x23
    400046fc:	0a3702b5 	bic	w21, w21, w23
    40004700:	17ffffd3 	b	4000464c <z_impl_log_process+0x108>
	return backend->cb->active;
    40004704:	f9400680 	ldr	x0, [x20, #8]
			if (log_backend_is_active(backend) &&
    40004708:	39402400 	ldrb	w0, [x0, #9]
    4000470c:	340001e0 	cbz	w0, 40004748 <z_impl_log_process+0x204>
	return msg->hdr.ids.level;
    40004710:	f9400a61 	ldr	x1, [x19, #16]
	backend_level = log_filter_get(backend, domain_id,
    40004714:	aa1403e0 	mov	x0, x20
    40004718:	52800023 	mov	w3, #0x1                   	// #1
    4000471c:	53104838 	ubfx	w24, w1, #16, #3
    40004720:	53167c22 	lsr	w2, w1, #22
    40004724:	53135421 	ubfx	w1, w1, #19, #3
    40004728:	94000183 	bl	40004d34 <log_filter_get>
			if (log_backend_is_active(backend) &&
    4000472c:	6b00031f 	cmp	w24, w0
    40004730:	540000c8 	b.hi	40004748 <z_impl_log_process+0x204>  // b.pmore
	backend->api->put(backend, msg);
    40004734:	f9400280 	ldr	x0, [x20]
    40004738:	aa1303e1 	mov	x1, x19
    4000473c:	f9400402 	ldr	x2, [x0, #8]
    40004740:	aa1403e0 	mov	x0, x20
    40004744:	d63f0040 	blr	x2
		for (int i = 0; i < log_backend_count_get(); i++) {
    40004748:	110006f7 	add	w23, w23, #0x1
    4000474c:	91008294 	add	x20, x20, #0x20
    40004750:	6b1502ff 	cmp	w23, w21
    40004754:	54fffd8b 	b.lt	40004704 <z_impl_log_process+0x1c0>  // b.tstop
    40004758:	17ffff8f 	b	40004594 <z_impl_log_process+0x50>

000000004000475c <log_process_thread_func>:
{
    4000475c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40004760:	910003fd 	mov	x29, sp
    40004764:	f9000bf3 	str	x19, [sp, #16]
	log_init();
    40004768:	97fffed3 	bl	400042b4 <log_init>
	return z_impl_z_current_get();
    4000476c:	94002dee 	bl	4000ff24 <z_impl_z_current_get>
	proc_tid = process_tid;
    40004770:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40004774:	f9014c20 	str	x0, [x1, #664]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    40004778:	b4000100 	cbz	x0, 40004798 <log_process_thread_func+0x3c>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    4000477c:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
	    process_tid &&
    40004780:	f940f000 	ldr	x0, [x0, #480]
    40004784:	f100241f 	cmp	x0, #0x9
    40004788:	5400008d 	b.le	40004798 <log_process_thread_func+0x3c>
	z_impl_k_sem_give(sem);
    4000478c:	f0000340 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40004790:	91368000 	add	x0, x0, #0xda0
    40004794:	94002ad4 	bl	4000f2e4 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
    40004798:	f0000353 	adrp	x19, 4006f000 <sys_work_q_stack+0xc10>
    4000479c:	91368273 	add	x19, x19, #0xda0
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    400047a0:	52800000 	mov	w0, #0x0                   	// #0
    400047a4:	97ffff68 	bl	40004544 <z_impl_log_process>
		if (log_process(false) == false) {
    400047a8:	72001c1f 	tst	w0, #0xff
    400047ac:	54ffffa1 	b.ne	400047a0 <log_process_thread_func+0x44>  // b.any
    400047b0:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    400047b4:	aa1303e0 	mov	x0, x19
    400047b8:	94002ae3 	bl	4000f344 <z_impl_k_sem_take>
    400047bc:	17fffff9 	b	400047a0 <log_process_thread_func+0x44>

00000000400047c0 <msg_finalize>:
{
    400047c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400047c4:	910003fd 	mov	x29, sp
    400047c8:	a90153f3 	stp	x19, x20, [sp, #16]
    400047cc:	aa0003f3 	mov	x19, x0
	msg->hdr.ids = src_level;
    400047d0:	79002401 	strh	w1, [x0, #18]
	msg->hdr.timestamp = timestamp_func();
    400047d4:	f0000340 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    400047d8:	f945d000 	ldr	x0, [x0, #2976]
    400047dc:	d63f0000 	blr	x0
    400047e0:	b9001660 	str	w0, [x19, #20]
    400047e4:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400047e8:	d50342df 	msr	daifset, #0x2
	log_list_add_tail(&list, msg);
    400047ec:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    400047f0:	9107e000 	add	x0, x0, #0x1f8
    400047f4:	aa1303e1 	mov	x1, x19
MAKE_REG_HELPER(daif)
    400047f8:	92407e94 	and	x20, x20, #0xffffffff
    400047fc:	97fffe33 	bl	400040c8 <log_list_add_tail>
    40004800:	d51b4234 	msr	daif, x20
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    40004804:	b00000f3 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    40004808:	91078261 	add	x1, x19, #0x1e0
    4000480c:	d2800020 	mov	x0, #0x1                   	// #1
    40004810:	97fff1ec 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (panic_mode) {
    40004814:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004818:	396f1800 	ldrb	w0, [x0, #3014]
    4000481c:	34000140 	cbz	w0, 40004844 <msg_finalize+0x84>
    40004820:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40004824:	d50342df 	msr	daifset, #0x2
    40004828:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    4000482c:	92407e73 	and	x19, x19, #0xffffffff
    40004830:	97ffff45 	bl	40004544 <z_impl_log_process>
    40004834:	d51b4233 	msr	daif, x19
}
    40004838:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000483c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004840:	d65f03c0 	ret
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    40004844:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40004848:	f9414c21 	ldr	x1, [x1, #664]
    4000484c:	f940f260 	ldr	x0, [x19, #480]
    40004850:	b4ffff41 	cbz	x1, 40004838 <msg_finalize+0x78>
    40004854:	f100041f 	cmp	x0, #0x1
    40004858:	54000101 	b.ne	40004878 <msg_finalize+0xb8>  // b.any
}
    4000485c:	a94153f3 	ldp	x19, x20, [sp, #16]
	z_impl_k_timer_start(timer, duration, period);
    40004860:	d2800002 	mov	x2, #0x0                   	// #0
    40004864:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004868:	d2800c81 	mov	x1, #0x64                  	// #100
    4000486c:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004870:	91082000 	add	x0, x0, #0x208
    40004874:	140030cc 	b	40010ba4 <z_impl_k_timer_start>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    40004878:	f100281f 	cmp	x0, #0xa
    4000487c:	54fffde1 	b.ne	40004838 <msg_finalize+0x78>  // b.any
	z_impl_k_timer_stop(timer);
    40004880:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004884:	91082000 	add	x0, x0, #0x208
    40004888:	940030eb 	bl	40010c34 <z_impl_k_timer_stop>
}
    4000488c:	a94153f3 	ldp	x19, x20, [sp, #16]
	z_impl_k_sem_give(sem);
    40004890:	f0000340 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40004894:	91368000 	add	x0, x0, #0xda0
    40004898:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000489c:	14002a92 	b	4000f2e4 <z_impl_k_sem_give>

00000000400048a0 <log_0>:
{
    400048a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400048a4:	910003fd 	mov	x29, sp
    400048a8:	a90153f3 	stp	x19, x20, [sp, #16]
    400048ac:	aa0003f4 	mov	x20, x0
    400048b0:	2a0103f3 	mov	w19, w1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
    400048b4:	97fffe16 	bl	4000410c <z_log_msg_std_alloc>

	if (msg != NULL) {
    400048b8:	b40000c0 	cbz	x0, 400048d0 <log_0+0x30>
		msg->str = str;
    400048bc:	f9000c14 	str	x20, [x0, #24]
		msg_finalize(msg, src_level);
    400048c0:	2a1303e1 	mov	w1, w19
}
    400048c4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400048c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
		msg_finalize(msg, src_level);
    400048cc:	17ffffbd 	b	400047c0 <msg_finalize>
}
    400048d0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400048d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400048d8:	d65f03c0 	ret

00000000400048dc <log_1>:
{
    400048dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400048e0:	910003fd 	mov	x29, sp
    400048e4:	a90153f3 	stp	x19, x20, [sp, #16]
    400048e8:	aa0103f4 	mov	x20, x1
    400048ec:	2a0203f3 	mov	w19, w2
    400048f0:	f90013f5 	str	x21, [sp, #32]
    400048f4:	aa0003f5 	mov	x21, x0
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    400048f8:	97fffe05 	bl	4000410c <z_log_msg_std_alloc>

	if (msg != NULL) {
    400048fc:	b4000160 	cbz	x0, 40004928 <log_1+0x4c>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
    40004900:	79402001 	ldrh	w1, [x0, #16]
    40004904:	52800022 	mov	w2, #0x1                   	// #1
		msg->payload.single.args[0] = arg1;
    40004908:	a901d015 	stp	x21, x20, [x0, #24]
		msg->hdr.params.std.nargs = 1U;
    4000490c:	33140c41 	bfi	w1, w2, #12, #4
    40004910:	79002001 	strh	w1, [x0, #16]
		msg_finalize(msg, src_level);
    40004914:	2a1303e1 	mov	w1, w19
}
    40004918:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000491c:	f94013f5 	ldr	x21, [sp, #32]
    40004920:	a8c37bfd 	ldp	x29, x30, [sp], #48
		msg_finalize(msg, src_level);
    40004924:	17ffffa7 	b	400047c0 <msg_finalize>
}
    40004928:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000492c:	f94013f5 	ldr	x21, [sp, #32]
    40004930:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004934:	d65f03c0 	ret

0000000040004938 <log_2>:
{
    40004938:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000493c:	910003fd 	mov	x29, sp
    40004940:	a90153f3 	stp	x19, x20, [sp, #16]
    40004944:	aa0203f4 	mov	x20, x2
    40004948:	2a0303f3 	mov	w19, w3
    4000494c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004950:	aa0003f6 	mov	x22, x0
    40004954:	aa0103f5 	mov	x21, x1
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    40004958:	97fffded 	bl	4000410c <z_log_msg_std_alloc>

	if (msg != NULL) {
    4000495c:	b4000180 	cbz	x0, 4000498c <log_2+0x54>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
    40004960:	79402001 	ldrh	w1, [x0, #16]
    40004964:	52800042 	mov	w2, #0x2                   	// #2
		msg->payload.single.args[0] = arg1;
    40004968:	a901d416 	stp	x22, x21, [x0, #24]
		msg->hdr.params.std.nargs = 2U;
    4000496c:	33140c41 	bfi	w1, w2, #12, #4
    40004970:	79002001 	strh	w1, [x0, #16]
		msg->payload.single.args[1] = arg2;
    40004974:	f9001414 	str	x20, [x0, #40]
		msg_finalize(msg, src_level);
    40004978:	2a1303e1 	mov	w1, w19
}
    4000497c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004980:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004984:	a8c37bfd 	ldp	x29, x30, [sp], #48
		msg_finalize(msg, src_level);
    40004988:	17ffff8e 	b	400047c0 <msg_finalize>
}
    4000498c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004990:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004994:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004998:	d65f03c0 	ret

000000004000499c <log_3>:
{
    4000499c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400049a0:	910003fd 	mov	x29, sp
    400049a4:	a90153f3 	stp	x19, x20, [sp, #16]
    400049a8:	aa0303f4 	mov	x20, x3
    400049ac:	2a0403f3 	mov	w19, w4
    400049b0:	a9025bf5 	stp	x21, x22, [sp, #32]
    400049b4:	aa0103f6 	mov	x22, x1
    400049b8:	aa0203f5 	mov	x21, x2
    400049bc:	f9001bf7 	str	x23, [sp, #48]
    400049c0:	aa0003f7 	mov	x23, x0
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    400049c4:	97fffdd2 	bl	4000410c <z_log_msg_std_alloc>

	if (msg != NULL) {
    400049c8:	b40001a0 	cbz	x0, 400049fc <log_3+0x60>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
    400049cc:	79402001 	ldrh	w1, [x0, #16]
    400049d0:	52800062 	mov	w2, #0x3                   	// #3
		msg->payload.single.args[0] = arg1;
    400049d4:	a901d817 	stp	x23, x22, [x0, #24]
		msg->hdr.params.std.nargs = 3U;
    400049d8:	33140c41 	bfi	w1, w2, #12, #4
    400049dc:	79002001 	strh	w1, [x0, #16]
		msg->payload.single.args[1] = arg2;
		msg->payload.single.args[2] = arg3;
    400049e0:	a902d015 	stp	x21, x20, [x0, #40]
		msg_finalize(msg, src_level);
    400049e4:	2a1303e1 	mov	w1, w19
}
    400049e8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400049ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400049f0:	f9401bf7 	ldr	x23, [sp, #48]
    400049f4:	a8c47bfd 	ldp	x29, x30, [sp], #64
		msg_finalize(msg, src_level);
    400049f8:	17ffff72 	b	400047c0 <msg_finalize>
}
    400049fc:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004a00:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004a04:	f9401bf7 	ldr	x23, [sp, #48]
    40004a08:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40004a0c:	d65f03c0 	ret

0000000040004a10 <z_impl_log_panic>:
	if (panic_mode) {
    40004a10:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004a14:	396f1801 	ldrb	w1, [x0, #3014]
    40004a18:	35000481 	cbnz	w1, 40004aa8 <z_impl_log_panic+0x98>
{
    40004a1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40004a20:	910003fd 	mov	x29, sp
    40004a24:	a90153f3 	stp	x19, x20, [sp, #16]
	return __log_backends_end - __log_backends_start;
    40004a28:	d0000073 	adrp	x19, 40012000 <__rodata_region_start>
    40004a2c:	913c4273 	add	x19, x19, #0xf10
    40004a30:	d0000074 	adrp	x20, 40012000 <__rodata_region_start>
    40004a34:	913cc294 	add	x20, x20, #0xf30
    40004a38:	cb130294 	sub	x20, x20, x19
    40004a3c:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (int i = 0; i < log_backend_count_get(); i++) {
    40004a40:	52800015 	mov	w21, #0x0                   	// #0
    40004a44:	d3459294 	ubfx	x20, x20, #5, #32
    40004a48:	aa0003f6 	mov	x22, x0
	log_init();
    40004a4c:	97fffe1a 	bl	400042b4 <log_init>
	for (int i = 0; i < log_backend_count_get(); i++) {
    40004a50:	6b1402bf 	cmp	w21, w20
    40004a54:	5400016b 	b.lt	40004a80 <z_impl_log_panic+0x70>  // b.tstop
    40004a58:	52800000 	mov	w0, #0x0                   	// #0
    40004a5c:	97fffeba 	bl	40004544 <z_impl_log_process>
		while (log_process(false) == true) {
    40004a60:	72001c1f 	tst	w0, #0xff
    40004a64:	54ffffa1 	b.ne	40004a58 <z_impl_log_panic+0x48>  // b.any
	panic_mode = true;
    40004a68:	52800020 	mov	w0, #0x1                   	// #1
    40004a6c:	392f1ac0 	strb	w0, [x22, #3014]
}
    40004a70:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004a74:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004a78:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004a7c:	d65f03c0 	ret
	return backend->cb->active;
    40004a80:	f9400660 	ldr	x0, [x19, #8]
		if (log_backend_is_active(backend)) {
    40004a84:	39402400 	ldrb	w0, [x0, #9]
    40004a88:	340000a0 	cbz	w0, 40004a9c <z_impl_log_panic+0x8c>
	backend->api->panic(backend);
    40004a8c:	f9400260 	ldr	x0, [x19]
    40004a90:	f9401401 	ldr	x1, [x0, #40]
    40004a94:	aa1303e0 	mov	x0, x19
    40004a98:	d63f0020 	blr	x1
	for (int i = 0; i < log_backend_count_get(); i++) {
    40004a9c:	110006b5 	add	w21, w21, #0x1
    40004aa0:	91008273 	add	x19, x19, #0x20
    40004aa4:	17ffffeb 	b	40004a50 <z_impl_log_panic+0x40>
    40004aa8:	d65f03c0 	ret

0000000040004aac <z_log_free>:
{
    40004aac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    40004ab0:	d1002001 	sub	x1, x0, #0x8
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    40004ab4:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
{
    40004ab8:	910003fd 	mov	x29, sp
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    40004abc:	f9000fe1 	str	x1, [sp, #24]
    40004ac0:	97fff140 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (atomic_dec(&dup->refcount) == 1) {
    40004ac4:	f100041f 	cmp	x0, #0x1
    40004ac8:	540000a1 	b.ne	40004adc <z_log_free+0x30>  // b.any
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    40004acc:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004ad0:	91098000 	add	x0, x0, #0x260
    40004ad4:	910063e1 	add	x1, sp, #0x18
    40004ad8:	94002775 	bl	4000e8ac <k_mem_slab_free>
}
    40004adc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004ae0:	d65f03c0 	ret

0000000040004ae4 <z_log_runtime_filters_init>:
	 *
	 * Each log source's aggregated runtime level is set to match its
	 * compile-time level. When backends are attached later on in
	 * log_init(), they'll be initialized to the same value.
	 */
	for (int i = 0; i < z_log_sources_count(); i++) {
    40004ae4:	d0000061 	adrp	x1, 40012000 <__rodata_region_start>
    40004ae8:	913ac021 	add	x1, x1, #0xeb0
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    40004aec:	d0000060 	adrp	x0, 40012000 <__rodata_region_start>
    40004af0:	913c4000 	add	x0, x0, #0xf10
    40004af4:	cb010000 	sub	x0, x0, x1
    40004af8:	f0000342 	adrp	x2, 4006f000 <sys_work_q_stack+0xc10>
    40004afc:	91334042 	add	x2, x2, #0xcd0
    40004b00:	52800003 	mov	w3, #0x0                   	// #0
    40004b04:	d3448c00 	ubfx	x0, x0, #4, #32
    40004b08:	91004021 	add	x1, x1, #0x10
    40004b0c:	6b00007f 	cmp	w3, w0
    40004b10:	54000041 	b.ne	40004b18 <z_log_runtime_filters_init+0x34>  // b.any

		LOG_FILTER_SLOT_SET(filters,
				    LOG_FILTER_AGGR_SLOT_IDX,
				    level);
	}
}
    40004b14:	d65f03c0 	ret
		LOG_FILTER_SLOT_SET(filters,
    40004b18:	b9400044 	ldr	w4, [x2]
	for (int i = 0; i < z_log_sources_count(); i++) {
    40004b1c:	11000463 	add	w3, w3, #0x1
		LOG_FILTER_SLOT_SET(filters,
    40004b20:	385f8025 	ldurb	w5, [x1, #-8]
    40004b24:	330008a4 	bfxil	w4, w5, #0, #3
    40004b28:	b8004444 	str	w4, [x2], #4
	for (int i = 0; i < z_log_sources_count(); i++) {
    40004b2c:	17fffff7 	b	40004b08 <z_log_runtime_filters_init+0x24>

0000000040004b30 <log_source_name_get>:
    40004b30:	d0000062 	adrp	x2, 40012000 <__rodata_region_start>
    40004b34:	913ac042 	add	x2, x2, #0xeb0
    40004b38:	d0000060 	adrp	x0, 40012000 <__rodata_region_start>
    40004b3c:	913c4000 	add	x0, x0, #0xf10
    40004b40:	cb020000 	sub	x0, x0, x2
    40004b44:	d344fc00 	lsr	x0, x0, #4
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    40004b48:	6b00003f 	cmp	w1, w0
    40004b4c:	54000082 	b.cs	40004b5c <log_source_name_get+0x2c>  // b.hs, b.nlast
	return __log_const_start[source_id].name;
    40004b50:	d37c7c21 	ubfiz	x1, x1, #4, #32
    40004b54:	f8616840 	ldr	x0, [x2, x1]
}
    40004b58:	d65f03c0 	ret
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    40004b5c:	d2800000 	mov	x0, #0x0                   	// #0
    40004b60:	17fffffe 	b	40004b58 <log_source_name_get+0x28>

0000000040004b64 <z_impl_log_filter_set>:
}

uint32_t z_impl_log_filter_set(struct log_backend const *const backend,
			       uint32_t domain_id, int16_t source_id,
			       uint32_t level)
{
    40004b64:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40004b68:	910003fd 	mov	x29, sp
    40004b6c:	a90153f3 	stp	x19, x20, [sp, #16]
    40004b70:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004b74:	13003c56 	sxth	w22, w2
    40004b78:	2a0303f5 	mov	w21, w3
    40004b7c:	a90363f7 	stp	x23, x24, [sp, #48]
    40004b80:	f90023f9 	str	x25, [sp, #64]
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)) {
		uint32_t new_aggr_filter;

		uint32_t *filters = z_log_dynamic_filters_get(source_id);

		if (backend == NULL) {
    40004b84:	b5000380 	cbnz	x0, 40004bf4 <z_impl_log_filter_set+0x90>
	return __log_backends_end - __log_backends_start;
    40004b88:	d0000078 	adrp	x24, 40012000 <__rodata_region_start>
    40004b8c:	913c4318 	add	x24, x24, #0xf10
    40004b90:	d0000074 	adrp	x20, 40012000 <__rodata_region_start>
    40004b94:	913cc294 	add	x20, x20, #0xf30
    40004b98:	cb180294 	sub	x20, x20, x24
    40004b9c:	2a0103f9 	mov	w25, w1
    40004ba0:	d2800017 	mov	x23, #0x0                   	// #0
			struct log_backend const *iter_backend;
			uint32_t max = 0U;
    40004ba4:	52800013 	mov	w19, #0x0                   	// #0
    40004ba8:	d3459294 	ubfx	x20, x20, #5, #32
			uint32_t current;

			for (int i = 0; i < log_backend_count_get(); i++) {
    40004bac:	6b17029f 	cmp	w20, w23
    40004bb0:	5400010c 	b.gt	40004bd0 <z_impl_log_filter_set+0x6c>
					    new_aggr_filter);
		}
	}

	return level;
}
    40004bb4:	2a1303e0 	mov	w0, w19
    40004bb8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004bbc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004bc0:	a94363f7 	ldp	x23, x24, [sp, #48]
    40004bc4:	f94023f9 	ldr	x25, [sp, #64]
    40004bc8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40004bcc:	d65f03c0 	ret
		/* coverity[OVERRUN] */
		return (uint32_t) arch_syscall_invoke4(*(uintptr_t *)&backend, *(uintptr_t *)&domain_id, *(uintptr_t *)&source_id, *(uintptr_t *)&level, K_SYSCALL_LOG_FILTER_SET);
	}
#endif
	compiler_barrier();
	return z_impl_log_filter_set(backend, domain_id, source_id, level);
    40004bd0:	8b171700 	add	x0, x24, x23, lsl #5
    40004bd4:	2a1503e3 	mov	w3, w21
    40004bd8:	2a1603e2 	mov	w2, w22
    40004bdc:	2a1903e1 	mov	w1, w25
    40004be0:	97ffffe1 	bl	40004b64 <z_impl_log_filter_set>
				max = MAX(current, max);
    40004be4:	6b00027f 	cmp	w19, w0
    40004be8:	1a802273 	csel	w19, w19, w0, cs  // cs = hs, nlast
			for (int i = 0; i < log_backend_count_get(); i++) {
    40004bec:	910006f7 	add	x23, x23, #0x1
    40004bf0:	17ffffef 	b	40004bac <z_impl_log_filter_set+0x48>
	return __log_const_start[source_id].level;
    40004bf4:	2a1603e5 	mov	w5, w22
    40004bf8:	d0000061 	adrp	x1, 40012000 <__rodata_region_start>
    40004bfc:	913ac021 	add	x1, x1, #0xeb0
    40004c00:	d37c7ed6 	ubfiz	x22, x22, #4, #32
	return backend->cb->id;
    40004c04:	f9400400 	ldr	x0, [x0, #8]
    40004c08:	8b160021 	add	x1, x1, x22
			LOG_FILTER_SLOT_SET(filters,
    40004c0c:	f0000342 	adrp	x2, 4006f000 <sys_work_q_stack+0xc10>
    40004c10:	91334042 	add	x2, x2, #0xcd0

		return LOG_FILTER_SLOT_GET(filters,
					   log_backend_id_get(backend));
	}

	return log_compiled_level_get(source_id);
    40004c14:	39402033 	ldrb	w19, [x1, #8]
			LOG_FILTER_SLOT_SET(filters,
    40004c18:	d28000e1 	mov	x1, #0x7                   	// #7
    40004c1c:	39402000 	ldrb	w0, [x0, #8]
			level = MIN(level, max);
    40004c20:	6b03027f 	cmp	w19, w3
    40004c24:	1a839273 	csel	w19, w19, w3, ls  // ls = plast
			LOG_FILTER_SLOT_SET(filters,
    40004c28:	b8657843 	ldr	w3, [x2, x5, lsl #2]
    40004c2c:	0b000400 	add	w0, w0, w0, lsl #1
    40004c30:	9ac02021 	lsl	x1, x1, x0
    40004c34:	0a210061 	bic	w1, w3, w1
    40004c38:	92400a63 	and	x3, x19, #0x7
    40004c3c:	9ac02060 	lsl	x0, x3, x0
    40004c40:	52800063 	mov	w3, #0x3                   	// #3
    40004c44:	2a000021 	orr	w1, w1, w0
	uint32_t max_filter = LOG_LEVEL_NONE;
    40004c48:	52800000 	mov	w0, #0x0                   	// #0
		uint32_t tmp_filter = LOG_FILTER_SLOT_GET(&filters, i);
    40004c4c:	1ac32424 	lsr	w4, w1, w3
    40004c50:	12000884 	and	w4, w4, #0x7
    40004c54:	6b04001f 	cmp	w0, w4
    40004c58:	11000c63 	add	w3, w3, #0x3
    40004c5c:	1a842000 	csel	w0, w0, w4, cs  // cs = hs, nlast
	for (i = first_slot; i < LOG_FILTERS_NUM_OF_SLOTS; i++) {
    40004c60:	7100787f 	cmp	w3, #0x1e
    40004c64:	54ffff41 	b.ne	40004c4c <z_impl_log_filter_set+0xe8>  // b.any
			LOG_FILTER_SLOT_SET(filters,
    40004c68:	121d7021 	and	w1, w1, #0xfffffff8
    40004c6c:	2a000021 	orr	w1, w1, w0
    40004c70:	b8257841 	str	w1, [x2, x5, lsl #2]
	return level;
    40004c74:	17ffffd0 	b	40004bb4 <z_impl_log_filter_set+0x50>

0000000040004c78 <backend_filter_set>:
{
    40004c78:	aa0003e8 	mov	x8, x0
    40004c7c:	d0000066 	adrp	x6, 40012000 <__rodata_region_start>
    40004c80:	913c40c6 	add	x6, x6, #0xf10
    40004c84:	d0000060 	adrp	x0, 40012000 <__rodata_region_start>
    40004c88:	913ac000 	add	x0, x0, #0xeb0
		for (int i = 0; i < z_log_sources_count(); i++) {
    40004c8c:	52800007 	mov	w7, #0x0                   	// #0
    40004c90:	cb0000c6 	sub	x6, x6, x0
{
    40004c94:	2a0103e9 	mov	w9, w1
    40004c98:	d3448cc6 	ubfx	x6, x6, #4, #32
		for (int i = 0; i < z_log_sources_count(); i++) {
    40004c9c:	6b0600ff 	cmp	w7, w6
    40004ca0:	54000041 	b.ne	40004ca8 <backend_filter_set+0x30>  // b.any
    40004ca4:	d65f03c0 	ret
{
    40004ca8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40004cac:	910003fd 	mov	x29, sp
    40004cb0:	52800001 	mov	w1, #0x0                   	// #0
    40004cb4:	2a0703e2 	mov	w2, w7
    40004cb8:	2a0903e3 	mov	w3, w9
    40004cbc:	aa0803e0 	mov	x0, x8
		for (int i = 0; i < z_log_sources_count(); i++) {
    40004cc0:	110004e7 	add	w7, w7, #0x1
    40004cc4:	97ffffa8 	bl	40004b64 <z_impl_log_filter_set>
    40004cc8:	6b0600ff 	cmp	w7, w6
    40004ccc:	54ffff21 	b.ne	40004cb0 <backend_filter_set+0x38>  // b.any
}
    40004cd0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004cd4:	d65f03c0 	ret

0000000040004cd8 <log_backend_enable>:
{
    40004cd8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	id += backend - log_backend_get(0);
    40004cdc:	d0000063 	adrp	x3, 40012000 <__rodata_region_start>
    40004ce0:	913c4063 	add	x3, x3, #0xf10
{
    40004ce4:	910003fd 	mov	x29, sp
    40004ce8:	aa0103eb 	mov	x11, x1
    40004cec:	2a0203e1 	mov	w1, w2
	id += backend - log_backend_get(0);
    40004cf0:	cb030003 	sub	x3, x0, x3
{
    40004cf4:	aa0003ea 	mov	x10, x0
	backend->cb->id = id;
    40004cf8:	f9400402 	ldr	x2, [x0, #8]
	id += backend - log_backend_get(0);
    40004cfc:	9345fc63 	asr	x3, x3, #5
    40004d00:	11000463 	add	w3, w3, #0x1
	log_backend_id_set(backend, id);
    40004d04:	39002043 	strb	w3, [x2, #8]
	backend_filter_set(backend, level);
    40004d08:	97ffffdc 	bl	40004c78 <backend_filter_set>
	backend->cb->ctx = ctx;
    40004d0c:	f9400540 	ldr	x0, [x10, #8]
	backend->cb->active = true;
    40004d10:	52800021 	mov	w1, #0x1                   	// #1
	backend->cb->ctx = ctx;
    40004d14:	f900000b 	str	x11, [x0]
	backend->cb->active = true;
    40004d18:	39002401 	strb	w1, [x0, #9]
}
    40004d1c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	z_log_notify_backend_enabled();
    40004d20:	17fffd97 	b	4000437c <z_log_notify_backend_enabled>

0000000040004d24 <log_backend_disable>:
	backend->cb->active = false;
    40004d24:	f9400401 	ldr	x1, [x0, #8]
    40004d28:	3900243f 	strb	wzr, [x1, #9]
	backend_filter_set(backend, LOG_LEVEL_NONE);
    40004d2c:	52800001 	mov	w1, #0x0                   	// #0
    40004d30:	17ffffd2 	b	40004c78 <backend_filter_set>

0000000040004d34 <log_filter_get>:
{
    40004d34:	13003c42 	sxth	w2, w2
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) && runtime) {
    40004d38:	72001c7f 	tst	w3, #0xff
    40004d3c:	54000160 	b.eq	40004d68 <log_filter_get+0x34>  // b.none
		if (source_id < 0) {
    40004d40:	37f80202 	tbnz	w2, #31, 40004d80 <log_filter_get+0x4c>
	return backend->cb->id;
    40004d44:	f9400400 	ldr	x0, [x0, #8]
		return LOG_FILTER_SLOT_GET(filters,
    40004d48:	39402000 	ldrb	w0, [x0, #8]
    40004d4c:	0b000401 	add	w1, w0, w0, lsl #1
    40004d50:	f0000340 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40004d54:	91334000 	add	x0, x0, #0xcd0
    40004d58:	b8625800 	ldr	w0, [x0, w2, uxtw #2]
    40004d5c:	1ac12400 	lsr	w0, w0, w1
    40004d60:	12000800 	and	w0, w0, #0x7
}
    40004d64:	d65f03c0 	ret
	return __log_const_start[source_id].level;
    40004d68:	d37c7c40 	ubfiz	x0, x2, #4, #32
    40004d6c:	d0000062 	adrp	x2, 40012000 <__rodata_region_start>
    40004d70:	913ac042 	add	x2, x2, #0xeb0
    40004d74:	8b000042 	add	x2, x2, x0
	return log_compiled_level_get(source_id);
    40004d78:	39402040 	ldrb	w0, [x2, #8]
    40004d7c:	17fffffa 	b	40004d64 <log_filter_get+0x30>
			return LOG_LEVEL_DBG;
    40004d80:	52800080 	mov	w0, #0x4                   	// #4
    40004d84:	17fffff8 	b	40004d64 <log_filter_get+0x30>

0000000040004d88 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
    40004d88:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40004d8c:	910003fd 	mov	x29, sp
    40004d90:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004d94:	aa0103f5 	mov	x21, x1
	uint32_t available_len = msg->hdr.params.hexdump.length;
    40004d98:	f9400801 	ldr	x1, [x0, #16]
{
    40004d9c:	a90153f3 	stp	x19, x20, [sp, #16]
    40004da0:	aa0303f3 	mov	x19, x3
    40004da4:	a90363f7 	stp	x23, x24, [sp, #48]
	uint32_t available_len = msg->hdr.params.hexdump.length;
    40004da8:	53023c23 	ubfx	w3, w1, #2, #14
{
    40004dac:	f90023f9 	str	x25, [sp, #64]
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
    40004db0:	d3423c21 	ubfx	x1, x1, #2, #14
    40004db4:	eb13003f 	cmp	x1, x19
    40004db8:	54000108 	b.hi	40004dd8 <log_msg_hexdump_data_op+0x50>  // b.pmore
		*length = 0;
    40004dbc:	f900005f 	str	xzr, [x2]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
    40004dc0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004dc4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004dc8:	a94363f7 	ldp	x23, x24, [sp, #48]
    40004dcc:	f94023f9 	ldr	x25, [sp, #64]
    40004dd0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40004dd4:	d65f03c0 	ret
    40004dd8:	12001c98 	and	w24, w4, #0xff
	if ((offset + *length) > available_len) {
    40004ddc:	f9400044 	ldr	x4, [x2]
    40004de0:	8b040264 	add	x4, x19, x4
    40004de4:	eb04003f 	cmp	x1, x4
    40004de8:	54000062 	b.cs	40004df4 <log_msg_hexdump_data_op+0x6c>  // b.hs, b.nlast
		*length = available_len - offset;
    40004dec:	cb130021 	sub	x1, x1, x19
    40004df0:	f9000041 	str	x1, [x2]
	req_len = *length;
    40004df4:	f9400059 	ldr	x25, [x2]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    40004df8:	7100807f 	cmp	w3, #0x20
	req_len = *length;
    40004dfc:	2a1903f7 	mov	w23, w25
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    40004e00:	54000489 	b.ls	40004e90 <log_msg_hexdump_data_op+0x108>  // b.plast
		cont = msg->payload.ext.next;
    40004e04:	f9401016 	ldr	x22, [x0, #32]
		head_data = msg->payload.ext.data.bytes;
    40004e08:	9100a001 	add	x1, x0, #0x28
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    40004e0c:	52800303 	mov	w3, #0x18                  	// #24
	if (offset < chunk_len) {
    40004e10:	2a0303e2 	mov	w2, w3
    40004e14:	eb13005f 	cmp	x2, x19
    40004e18:	54000489 	b.ls	40004ea8 <log_msg_hexdump_data_op+0x120>  // b.plast
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    40004e1c:	6b19007f 	cmp	w3, w25
			(void)memcpy(&head_data[offset], data, cpy_len);
    40004e20:	8b130020 	add	x0, x1, x19
    40004e24:	1a838334 	csel	w20, w25, w3, hi  // hi = pmore
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    40004e28:	1a999077 	csel	w23, w3, w25, ls  // ls = plast
			(void)memcpy(&head_data[offset], data, cpy_len);
    40004e2c:	aa1403e2 	mov	x2, x20
		if (put_op) {
    40004e30:	34000378 	cbz	w24, 40004e9c <log_msg_hexdump_data_op+0x114>
			(void)memcpy(&head_data[offset], data, cpy_len);
    40004e34:	aa1503e1 	mov	x1, x21
		req_len -= cpy_len;
    40004e38:	4b170337 	sub	w23, w25, w23
		data += cpy_len;
    40004e3c:	8b1402b5 	add	x21, x21, x20
			(void)memcpy(data, &head_data[offset], cpy_len);
    40004e40:	94002135 	bl	4000d314 <memcpy>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
    40004e44:	52800714 	mov	w20, #0x38                  	// #56
	while ((req_len > 0) && (cont != NULL)) {
    40004e48:	710002ff 	cmp	w23, #0x0
    40004e4c:	fa401ac4 	ccmp	x22, #0x0, #0x4, ne  // ne = any
    40004e50:	54fffb80 	b.eq	40004dc0 <log_msg_hexdump_data_op+0x38>  // b.none
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
    40004e54:	4b130282 	sub	w2, w20, w19
			(void)memcpy(&cont->payload.bytes[offset],
    40004e58:	91002273 	add	x19, x19, #0x8
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    40004e5c:	6b17005f 	cmp	w2, w23
			(void)memcpy(&cont->payload.bytes[offset],
    40004e60:	8b1302c0 	add	x0, x22, x19
    40004e64:	1a979053 	csel	w19, w2, w23, ls  // ls = plast
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    40004e68:	1a979059 	csel	w25, w2, w23, ls  // ls = plast
			(void)memcpy(&cont->payload.bytes[offset],
    40004e6c:	aa1303e2 	mov	x2, x19
		if (put_op) {
    40004e70:	340002d8 	cbz	w24, 40004ec8 <log_msg_hexdump_data_op+0x140>
			(void)memcpy(&cont->payload.bytes[offset],
    40004e74:	aa1503e1 	mov	x1, x21
		data += cpy_len;
    40004e78:	8b1302b5 	add	x21, x21, x19
			(void)memcpy(data, &cont->payload.bytes[offset],
    40004e7c:	94002126 	bl	4000d314 <memcpy>
		req_len -= cpy_len;
    40004e80:	4b1902f7 	sub	w23, w23, w25
		offset = 0;
    40004e84:	d2800013 	mov	x19, #0x0                   	// #0
		cont = cont->next;
    40004e88:	f94002d6 	ldr	x22, [x22]
		data += cpy_len;
    40004e8c:	17ffffef 	b	40004e48 <log_msg_hexdump_data_op+0xc0>
		head_data = msg->payload.single.bytes;
    40004e90:	91008001 	add	x1, x0, #0x20
	struct log_msg_cont *cont = NULL;
    40004e94:	d2800016 	mov	x22, #0x0                   	// #0
    40004e98:	17ffffde 	b	40004e10 <log_msg_hexdump_data_op+0x88>
			(void)memcpy(data, &head_data[offset], cpy_len);
    40004e9c:	aa0003e1 	mov	x1, x0
    40004ea0:	aa1503e0 	mov	x0, x21
    40004ea4:	17ffffe5 	b	40004e38 <log_msg_hexdump_data_op+0xb0>
		offset -= chunk_len;
    40004ea8:	cb020273 	sub	x19, x19, x2
		if (cont == NULL) {
    40004eac:	b5000056 	cbnz	x22, 40004eb4 <log_msg_hexdump_data_op+0x12c>
			cont = msg->payload.ext.next;
    40004eb0:	f9401016 	ldr	x22, [x0, #32]
		while (offset >= chunk_len) {
    40004eb4:	f100de7f 	cmp	x19, #0x37
    40004eb8:	54fffc69 	b.ls	40004e44 <log_msg_hexdump_data_op+0xbc>  // b.plast
			offset -= chunk_len;
    40004ebc:	d100e273 	sub	x19, x19, #0x38
			cont = cont->next;
    40004ec0:	f94002d6 	ldr	x22, [x22]
			offset -= chunk_len;
    40004ec4:	17fffffc 	b	40004eb4 <log_msg_hexdump_data_op+0x12c>
			(void)memcpy(data, &cont->payload.bytes[offset],
    40004ec8:	aa0003e1 	mov	x1, x0
    40004ecc:	aa1503e0 	mov	x0, x21
    40004ed0:	17ffffea 	b	40004e78 <log_msg_hexdump_data_op+0xf0>

0000000040004ed4 <log_msg_pool_init>:
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    40004ed4:	52800203 	mov	w3, #0x10                  	// #16
    40004ed8:	d2800802 	mov	x2, #0x40                  	// #64
    40004edc:	f0000341 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
    40004ee0:	9112c021 	add	x1, x1, #0x4b0
    40004ee4:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004ee8:	910a8000 	add	x0, x0, #0x2a0
    40004eec:	14002639 	b	4000e7d0 <k_mem_slab_init>

0000000040004ef0 <log_msg_get>:
{
    40004ef0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    40004ef4:	91002001 	add	x1, x0, #0x8
    40004ef8:	d2800020 	mov	x0, #0x1                   	// #1
    40004efc:	910003fd 	mov	x29, sp
    40004f00:	97fff030 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
}
    40004f04:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004f08:	d65f03c0 	ret

0000000040004f0c <log_msg_no_space_handle>:
{
    40004f0c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40004f10:	910003fd 	mov	x29, sp
    40004f14:	a90153f3 	stp	x19, x20, [sp, #16]
			err = k_mem_slab_alloc(&log_msg_pool,
    40004f18:	b00000f4 	adrp	x20, 40021000 <k_sys_work_q+0x200>
    40004f1c:	910a8294 	add	x20, x20, #0x2a0
	union log_msg_chunk *msg = NULL;
    40004f20:	f90017ff 	str	xzr, [sp, #40]
	return z_impl_log_process(bypass);
    40004f24:	52800020 	mov	w0, #0x1                   	// #1
    40004f28:	97fffd87 	bl	40004544 <z_impl_log_process>
    40004f2c:	12001c13 	and	w19, w0, #0xff
			z_log_dropped();
    40004f30:	97fffd22 	bl	400043b8 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    40004f34:	9100a3e1 	add	x1, sp, #0x28
    40004f38:	aa1403e0 	mov	x0, x20
    40004f3c:	d2800002 	mov	x2, #0x0                   	// #0
    40004f40:	94002639 	bl	4000e824 <k_mem_slab_alloc>
		} while ((err != 0) && more);
    40004f44:	7100001f 	cmp	w0, #0x0
    40004f48:	7a401a64 	ccmp	w19, #0x0, #0x4, ne  // ne = any
    40004f4c:	54fffec1 	b.ne	40004f24 <log_msg_no_space_handle+0x18>  // b.any
}
    40004f50:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004f54:	f94017e0 	ldr	x0, [sp, #40]
    40004f58:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004f5c:	d65f03c0 	ret

0000000040004f60 <log_msg_chunk_alloc>:
{
    40004f60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    40004f64:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40004f68:	910a8000 	add	x0, x0, #0x2a0
{
    40004f6c:	910003fd 	mov	x29, sp
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    40004f70:	910063e1 	add	x1, sp, #0x18
    40004f74:	d2800002 	mov	x2, #0x0                   	// #0
	union log_msg_chunk *msg = NULL;
    40004f78:	f9000fff 	str	xzr, [sp, #24]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    40004f7c:	9400262a 	bl	4000e824 <k_mem_slab_alloc>
	if (err != 0) {
    40004f80:	34000060 	cbz	w0, 40004f8c <log_msg_chunk_alloc+0x2c>
		msg = log_msg_no_space_handle();
    40004f84:	97ffffe2 	bl	40004f0c <log_msg_no_space_handle>
    40004f88:	f9000fe0 	str	x0, [sp, #24]
}
    40004f8c:	f9400fe0 	ldr	x0, [sp, #24]
    40004f90:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004f94:	d65f03c0 	ret

0000000040004f98 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
    40004f98:	f9400800 	ldr	x0, [x0, #16]
}
    40004f9c:	530c3c00 	ubfx	w0, w0, #12, #4
    40004fa0:	d65f03c0 	ret

0000000040004fa4 <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
    40004fa4:	f9400802 	ldr	x2, [x0, #16]
    40004fa8:	530c3c42 	ubfx	w2, w2, #12, #4
    40004fac:	6b01005f 	cmp	w2, w1
    40004fb0:	540002a9 	b.ls	40005004 <log_msg_arg_get+0x60>  // b.plast
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    40004fb4:	7100105f 	cmp	w2, #0x4
    40004fb8:	54000088 	b.hi	40004fc8 <log_msg_arg_get+0x24>  // b.pmore
		arg = msg->payload.single.args[arg_idx];
    40004fbc:	8b214c01 	add	x1, x0, w1, uxtw #3
    40004fc0:	f9401020 	ldr	x0, [x1, #32]
}
    40004fc4:	d65f03c0 	ret
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
    40004fc8:	7100083f 	cmp	w1, #0x2
    40004fcc:	54000088 	b.hi	40004fdc <log_msg_arg_get+0x38>  // b.pmore
		return msg->payload.ext.data.args[arg_idx];
    40004fd0:	8b214c01 	add	x1, x0, w1, uxtw #3
    40004fd4:	f9401420 	ldr	x0, [x1, #40]
    40004fd8:	17fffffb 	b	40004fc4 <log_msg_arg_get+0x20>
	cont = msg->payload.ext.next;
    40004fdc:	f9401000 	ldr	x0, [x0, #32]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
    40004fe0:	51000c21 	sub	w1, w1, #0x3
	while (arg_idx >= ARGS_CONT_MSG) {
    40004fe4:	7100183f 	cmp	w1, #0x6
    40004fe8:	54000088 	b.hi	40004ff8 <log_msg_arg_get+0x54>  // b.pmore
	return cont->payload.args[arg_idx];
    40004fec:	8b214c01 	add	x1, x0, w1, uxtw #3
    40004ff0:	f9400420 	ldr	x0, [x1, #8]
    40004ff4:	17fffff4 	b	40004fc4 <log_msg_arg_get+0x20>
		arg_idx -= ARGS_CONT_MSG;
    40004ff8:	51001c21 	sub	w1, w1, #0x7
		cont = cont->next;
    40004ffc:	f9400000 	ldr	x0, [x0]
    40005000:	17fffff9 	b	40004fe4 <log_msg_arg_get+0x40>
		return 0;
    40005004:	d2800000 	mov	x0, #0x0                   	// #0
    40005008:	17ffffef 	b	40004fc4 <log_msg_arg_get+0x20>

000000004000500c <msg_free>:
{
    4000500c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40005010:	910003fd 	mov	x29, sp
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    40005014:	79402001 	ldrh	w1, [x0, #16]
    40005018:	a90153f3 	stp	x19, x20, [sp, #16]
    4000501c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005020:	f9001fe0 	str	x0, [sp, #56]
	if (log_msg_is_std(msg) && nargs) {
    40005024:	370003a1 	tbnz	w1, #0, 40005098 <msg_free+0x8c>
	return msg->hdr.params.std.nargs;
    40005028:	f9400800 	ldr	x0, [x0, #16]
    4000502c:	530c3c16 	ubfx	w22, w0, #12, #4
	if (log_msg_is_std(msg) && nargs) {
    40005030:	72140c1f 	tst	w0, #0xf000
    40005034:	54000320 	b.eq	40005098 <msg_free+0x8c>  // b.none
		uint32_t smask = 0U;
    40005038:	52800013 	mov	w19, #0x0                   	// #0
		for (i = 0U; i < nargs; i++) {
    4000503c:	52800014 	mov	w20, #0x0                   	// #0
			void *buf = (void *)log_msg_arg_get(msg, i);
    40005040:	f9401fe0 	ldr	x0, [sp, #56]
    40005044:	2a1403e1 	mov	w1, w20
    40005048:	97ffffd7 	bl	40004fa4 <log_msg_arg_get>
    4000504c:	aa0003f5 	mov	x21, x0
			if (log_is_strdup(buf)) {
    40005050:	97fffd32 	bl	40004518 <log_is_strdup>
    40005054:	72001c1f 	tst	w0, #0xff
    40005058:	540001a0 	b.eq	4000508c <msg_free+0x80>  // b.none
				if (smask == 0U) {
    4000505c:	350000f3 	cbnz	w19, 40005078 <msg_free+0x6c>
					smask = z_log_get_s_mask(
    40005060:	f9401fe0 	ldr	x0, [sp, #56]
    40005064:	2a1603e1 	mov	w1, w22
    40005068:	f9400c00 	ldr	x0, [x0, #24]
    4000506c:	97fffc5f 	bl	400041e8 <z_log_get_s_mask>
    40005070:	2a0003f3 	mov	w19, w0
					if (smask == 0U) {
    40005074:	34000120 	cbz	w0, 40005098 <msg_free+0x8c>
				if (smask & BIT(i)) {
    40005078:	2a1303e0 	mov	w0, w19
    4000507c:	9ad42400 	lsr	x0, x0, x20
    40005080:	36000060 	tbz	w0, #0, 4000508c <msg_free+0x80>
					z_log_free(buf);
    40005084:	aa1503e0 	mov	x0, x21
    40005088:	97fffe89 	bl	40004aac <z_log_free>
		for (i = 0U; i < nargs; i++) {
    4000508c:	11000694 	add	w20, w20, #0x1
    40005090:	6b16029f 	cmp	w20, w22
    40005094:	54fffd63 	b.cc	40005040 <msg_free+0x34>  // b.lo, b.ul, b.last
	if (msg->hdr.params.generic.ext == 1) {
    40005098:	f9401fe0 	ldr	x0, [sp, #56]
    4000509c:	900000f3 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    400050a0:	910a8273 	add	x19, x19, #0x2a0
    400050a4:	79402001 	ldrh	w1, [x0, #16]
    400050a8:	360800a1 	tbz	w1, #1, 400050bc <msg_free+0xb0>
		cont_free(msg->payload.ext.next);
    400050ac:	f9401000 	ldr	x0, [x0, #32]
    400050b0:	f90027e0 	str	x0, [sp, #72]
	while (cont != NULL) {
    400050b4:	f94027e0 	ldr	x0, [sp, #72]
    400050b8:	b5000100 	cbnz	x0, 400050d8 <msg_free+0xcc>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    400050bc:	9100e3e1 	add	x1, sp, #0x38
    400050c0:	aa1303e0 	mov	x0, x19
    400050c4:	940025fa 	bl	4000e8ac <k_mem_slab_free>
}
    400050c8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400050cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400050d0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    400050d4:	d65f03c0 	ret
		next = cont->next;
    400050d8:	f9400014 	ldr	x20, [x0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    400050dc:	910123e1 	add	x1, sp, #0x48
    400050e0:	aa1303e0 	mov	x0, x19
    400050e4:	940025f2 	bl	4000e8ac <k_mem_slab_free>
		cont = next;
    400050e8:	f90027f4 	str	x20, [sp, #72]
    400050ec:	17fffff2 	b	400050b4 <msg_free+0xa8>

00000000400050f0 <log_msg_put>:
{
    400050f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    400050f4:	91002001 	add	x1, x0, #0x8
    400050f8:	910003fd 	mov	x29, sp
    400050fc:	f9000bf3 	str	x19, [sp, #16]
    40005100:	aa0003f3 	mov	x19, x0
    40005104:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    40005108:	97ffefae 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (msg->hdr.ref_cnt == 0) {
    4000510c:	f9400660 	ldr	x0, [x19, #8]
    40005110:	b50000a0 	cbnz	x0, 40005124 <log_msg_put+0x34>
		msg_free(msg);
    40005114:	aa1303e0 	mov	x0, x19
}
    40005118:	f9400bf3 	ldr	x19, [sp, #16]
    4000511c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		msg_free(msg);
    40005120:	17ffffbb 	b	4000500c <msg_free>
}
    40005124:	f9400bf3 	ldr	x19, [sp, #16]
    40005128:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000512c:	d65f03c0 	ret

0000000040005130 <log_msg_str_get>:
}
    40005130:	f9400c00 	ldr	x0, [x0, #24]
    40005134:	d65f03c0 	ret

0000000040005138 <log_msg_hexdump_data_get>:
void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
	log_msg_hexdump_data_op(msg, data, length, offset, false);
    40005138:	52800004 	mov	w4, #0x0                   	// #0
    4000513c:	17ffff13 	b	40004d88 <log_msg_hexdump_data_op>

0000000040005140 <log_msg_mem_get_free>:
 *
 * @return Number of unallocated memory blocks.
 */
static inline uint32_t k_mem_slab_num_free_get(struct k_mem_slab *slab)
{
	return slab->num_blocks - slab->num_used;
    40005140:	900000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40005144:	910a8021 	add	x1, x1, #0x2a0
    40005148:	b9401022 	ldr	w2, [x1, #16]
    4000514c:	b9403020 	ldr	w0, [x1, #48]
}

uint32_t log_msg_mem_get_free(void)
{
	return k_mem_slab_num_free_get(&log_msg_pool);
}
    40005150:	4b000040 	sub	w0, w2, w0
    40005154:	d65f03c0 	ret

0000000040005158 <log_msg_mem_get_used>:

uint32_t log_msg_mem_get_used(void)
{
	return k_mem_slab_num_used_get(&log_msg_pool);
}
    40005158:	900000e0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000515c:	b942d000 	ldr	w0, [x0, #720]
    40005160:	d65f03c0 	ret

0000000040005164 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
    40005164:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40005168:	910003fd 	mov	x29, sp
    4000516c:	a90153f3 	stp	x19, x20, [sp, #16]
    40005170:	aa0103f4 	mov	x20, x1
    40005174:	aa0203f3 	mov	x19, x2
    40005178:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000517c:	aa0003f5 	mov	x21, x0
    40005180:	aa0303f6 	mov	x22, x3
	int processed;

	do {
		processed = outf(buf, len, ctx);
    40005184:	aa1303e1 	mov	x1, x19
    40005188:	aa1403e0 	mov	x0, x20
    4000518c:	aa1603e2 	mov	x2, x22
    40005190:	d63f02a0 	blr	x21
		len -= processed;
		buf += processed;
    40005194:	8b20c294 	add	x20, x20, w0, sxtw
	} while (len != 0);
    40005198:	eb20c273 	subs	x19, x19, w0, sxtw
    4000519c:	54ffff41 	b.ne	40005184 <buffer_write+0x20>  // b.any
}
    400051a0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400051a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400051a8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400051ac:	d65f03c0 	ret

00000000400051b0 <print_formatted>:
{
    400051b0:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    400051b4:	910003fd 	mov	x29, sp
    400051b8:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    400051bc:	910403e2 	add	x2, sp, #0x100
    400051c0:	a9030be2 	stp	x2, x2, [sp, #48]
    400051c4:	910343e2 	add	x2, sp, #0xd0
    400051c8:	f90023e2 	str	x2, [sp, #64]
    400051cc:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    400051d0:	b9004be2 	str	w2, [sp, #72]
    400051d4:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    400051d8:	b9004fe2 	str	w2, [sp, #76]
	length = cbvprintf(out_func, (void *)output, fmt, args);
    400051dc:	a9430fe2 	ldp	x2, x3, [sp, #48]
    400051e0:	a9010fe2 	stp	x2, x3, [sp, #16]
    400051e4:	a9440fe2 	ldp	x2, x3, [sp, #64]
    400051e8:	a9020fe2 	stp	x2, x3, [sp, #32]
    400051ec:	910043e3 	add	x3, sp, #0x10
    400051f0:	aa0103e2 	mov	x2, x1
    400051f4:	aa0003e1 	mov	x1, x0
    400051f8:	90000000 	adrp	x0, 40005000 <log_msg_arg_get+0x5c>
    400051fc:	91266000 	add	x0, x0, #0x998
{
    40005200:	3d8017e0 	str	q0, [sp, #80]
    40005204:	3d801be1 	str	q1, [sp, #96]
    40005208:	3d801fe2 	str	q2, [sp, #112]
    4000520c:	3d8023e3 	str	q3, [sp, #128]
    40005210:	3d8027e4 	str	q4, [sp, #144]
    40005214:	3d802be5 	str	q5, [sp, #160]
    40005218:	3d802fe6 	str	q6, [sp, #176]
    4000521c:	3d8033e7 	str	q7, [sp, #192]
    40005220:	a90e17e4 	stp	x4, x5, [sp, #224]
    40005224:	a90f1fe6 	stp	x6, x7, [sp, #240]
	length = cbvprintf(out_func, (void *)output, fmt, args);
    40005228:	97fff581 	bl	4000282c <cbvprintf>
}
    4000522c:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40005230:	d65f03c0 	ret

0000000040005234 <std_print>:
	}
}

static void std_print(struct log_msg *msg,
		      const struct log_output *output)
{
    40005234:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40005238:	910003fd 	mov	x29, sp
    4000523c:	a90153f3 	stp	x19, x20, [sp, #16]
    40005240:	aa0103f4 	mov	x20, x1
    40005244:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005248:	aa0003f6 	mov	x22, x0
    4000524c:	a90363f7 	stp	x23, x24, [sp, #48]
	const char *str = log_msg_str_get(msg);
	uint32_t nargs = log_msg_nargs_get(msg);
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
	int i;

	for (i = 0; i < nargs; i++) {
    40005250:	52800017 	mov	w23, #0x0                   	// #0
{
    40005254:	f90023f9 	str	x25, [sp, #64]
    40005258:	d10143ff 	sub	sp, sp, #0x50
	const char *str = log_msg_str_get(msg);
    4000525c:	97ffffb5 	bl	40005130 <log_msg_str_get>
    40005260:	aa0003f5 	mov	x21, x0
	uint32_t nargs = log_msg_nargs_get(msg);
    40005264:	aa1603e0 	mov	x0, x22
    40005268:	97ffff4c 	bl	40004f98 <log_msg_nargs_get>
    4000526c:	2a0003f8 	mov	w24, w0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
    40005270:	d37d7f01 	ubfiz	x1, x24, #3, #32
    40005274:	91003c21 	add	x1, x1, #0xf
    40005278:	927c7c21 	and	x1, x1, #0xffffffff0
    4000527c:	cb2163ff 	sub	sp, sp, x1
    40005280:	910143f3 	add	x19, sp, #0x50
	for (i = 0; i < nargs; i++) {
    40005284:	6b1802ff 	cmp	w23, w24
    40005288:	54000161 	b.ne	400052b4 <std_print+0x80>  // b.any
		args[i] = log_msg_arg_get(msg, i);
	}

	switch (log_msg_nargs_get(msg)) {
    4000528c:	aa1603e0 	mov	x0, x22
    40005290:	97ffff42 	bl	40004f98 <log_msg_nargs_get>
    40005294:	71003c1f 	cmp	w0, #0xf
    40005298:	54000228 	b.hi	400052dc <std_print+0xa8>  // b.pmore
    4000529c:	f0000061 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    400052a0:	91121021 	add	x1, x1, #0x484
    400052a4:	78605820 	ldrh	w0, [x1, w0, uxtw #1]
    400052a8:	10000061 	adr	x1, 400052b4 <std_print+0x80>
    400052ac:	8b20a820 	add	x0, x1, w0, sxth #2
    400052b0:	d61f0000 	br	x0
		args[i] = log_msg_arg_get(msg, i);
    400052b4:	937d7ef9 	sbfiz	x25, x23, #3, #32
    400052b8:	2a1703e1 	mov	w1, w23
    400052bc:	aa1603e0 	mov	x0, x22
	for (i = 0; i < nargs; i++) {
    400052c0:	110006f7 	add	w23, w23, #0x1
		args[i] = log_msg_arg_get(msg, i);
    400052c4:	97ffff38 	bl	40004fa4 <log_msg_arg_get>
    400052c8:	f8396a60 	str	x0, [x19, x25]
	for (i = 0; i < nargs; i++) {
    400052cc:	17ffffee 	b	40005284 <std_print+0x50>
	case 0:
		print_formatted(output, str);
    400052d0:	aa1503e1 	mov	x1, x21
    400052d4:	aa1403e0 	mov	x0, x20
    400052d8:	97ffffb6 	bl	400051b0 <print_formatted>
	default:
		/* Unsupported number of arguments. */
		__ASSERT_NO_MSG(true);
		break;
	}
}
    400052dc:	910003bf 	mov	sp, x29
    400052e0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400052e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400052e8:	a94363f7 	ldp	x23, x24, [sp, #48]
    400052ec:	f94023f9 	ldr	x25, [sp, #64]
    400052f0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    400052f4:	d65f03c0 	ret
		print_formatted(output, str, args[0]);
    400052f8:	f9400262 	ldr	x2, [x19]
    400052fc:	aa1503e1 	mov	x1, x21
    40005300:	aa1403e0 	mov	x0, x20
    40005304:	97ffffab 	bl	400051b0 <print_formatted>
		break;
    40005308:	17fffff5 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1]);
    4000530c:	a9400e62 	ldp	x2, x3, [x19]
    40005310:	aa1503e1 	mov	x1, x21
    40005314:	aa1403e0 	mov	x0, x20
    40005318:	97ffffa6 	bl	400051b0 <print_formatted>
		break;
    4000531c:	17fffff0 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2]);
    40005320:	a9400e62 	ldp	x2, x3, [x19]
    40005324:	aa1503e1 	mov	x1, x21
    40005328:	f9400a64 	ldr	x4, [x19, #16]
    4000532c:	aa1403e0 	mov	x0, x20
    40005330:	97ffffa0 	bl	400051b0 <print_formatted>
		break;
    40005334:	17ffffea 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    40005338:	a9400e62 	ldp	x2, x3, [x19]
    4000533c:	aa1503e1 	mov	x1, x21
    40005340:	a9411664 	ldp	x4, x5, [x19, #16]
    40005344:	aa1403e0 	mov	x0, x20
    40005348:	97ffff9a 	bl	400051b0 <print_formatted>
		break;
    4000534c:	17ffffe4 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    40005350:	a9400e62 	ldp	x2, x3, [x19]
    40005354:	aa1503e1 	mov	x1, x21
    40005358:	a9411664 	ldp	x4, x5, [x19, #16]
    4000535c:	aa1403e0 	mov	x0, x20
    40005360:	f9401266 	ldr	x6, [x19, #32]
    40005364:	97ffff93 	bl	400051b0 <print_formatted>
		break;
    40005368:	17ffffdd 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    4000536c:	a9400e62 	ldp	x2, x3, [x19]
    40005370:	aa1503e1 	mov	x1, x21
    40005374:	a9411664 	ldp	x4, x5, [x19, #16]
    40005378:	aa1403e0 	mov	x0, x20
    4000537c:	a9421e66 	ldp	x6, x7, [x19, #32]
    40005380:	97ffff8c 	bl	400051b0 <print_formatted>
		break;
    40005384:	17ffffd6 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    40005388:	f9401a60 	ldr	x0, [x19, #48]
    4000538c:	f90003e0 	str	x0, [sp]
    40005390:	aa1503e1 	mov	x1, x21
    40005394:	aa1403e0 	mov	x0, x20
    40005398:	a9400e62 	ldp	x2, x3, [x19]
    4000539c:	a9411664 	ldp	x4, x5, [x19, #16]
    400053a0:	a9421e66 	ldp	x6, x7, [x19, #32]
    400053a4:	97ffff83 	bl	400051b0 <print_formatted>
		break;
    400053a8:	17ffffcd 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    400053ac:	f9401e60 	ldr	x0, [x19, #56]
    400053b0:	f90007e0 	str	x0, [sp, #8]
    400053b4:	aa1503e1 	mov	x1, x21
    400053b8:	f9401a60 	ldr	x0, [x19, #48]
    400053bc:	f90003e0 	str	x0, [sp]
    400053c0:	aa1403e0 	mov	x0, x20
    400053c4:	a9400e62 	ldp	x2, x3, [x19]
    400053c8:	a9411664 	ldp	x4, x5, [x19, #16]
    400053cc:	a9421e66 	ldp	x6, x7, [x19, #32]
    400053d0:	97ffff78 	bl	400051b0 <print_formatted>
		break;
    400053d4:	17ffffc2 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    400053d8:	f9402260 	ldr	x0, [x19, #64]
    400053dc:	f9000be0 	str	x0, [sp, #16]
    400053e0:	aa1503e1 	mov	x1, x21
    400053e4:	f9401e60 	ldr	x0, [x19, #56]
    400053e8:	f90007e0 	str	x0, [sp, #8]
    400053ec:	f9401a60 	ldr	x0, [x19, #48]
    400053f0:	f90003e0 	str	x0, [sp]
    400053f4:	aa1403e0 	mov	x0, x20
    400053f8:	a9400e62 	ldp	x2, x3, [x19]
    400053fc:	a9411664 	ldp	x4, x5, [x19, #16]
    40005400:	a9421e66 	ldp	x6, x7, [x19, #32]
    40005404:	97ffff6b 	bl	400051b0 <print_formatted>
		break;
    40005408:	17ffffb5 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    4000540c:	f9402660 	ldr	x0, [x19, #72]
    40005410:	f9000fe0 	str	x0, [sp, #24]
    40005414:	aa1503e1 	mov	x1, x21
    40005418:	f9402260 	ldr	x0, [x19, #64]
    4000541c:	f9000be0 	str	x0, [sp, #16]
    40005420:	f9401e60 	ldr	x0, [x19, #56]
    40005424:	f90007e0 	str	x0, [sp, #8]
    40005428:	f9401a60 	ldr	x0, [x19, #48]
    4000542c:	f90003e0 	str	x0, [sp]
    40005430:	aa1403e0 	mov	x0, x20
    40005434:	a9400e62 	ldp	x2, x3, [x19]
    40005438:	a9411664 	ldp	x4, x5, [x19, #16]
    4000543c:	a9421e66 	ldp	x6, x7, [x19, #32]
    40005440:	97ffff5c 	bl	400051b0 <print_formatted>
		break;
    40005444:	17ffffa6 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    40005448:	f9402a60 	ldr	x0, [x19, #80]
    4000544c:	f90013e0 	str	x0, [sp, #32]
    40005450:	aa1503e1 	mov	x1, x21
    40005454:	f9402660 	ldr	x0, [x19, #72]
    40005458:	f9000fe0 	str	x0, [sp, #24]
    4000545c:	f9402260 	ldr	x0, [x19, #64]
    40005460:	f9000be0 	str	x0, [sp, #16]
    40005464:	f9401e60 	ldr	x0, [x19, #56]
    40005468:	f90007e0 	str	x0, [sp, #8]
    4000546c:	f9401a60 	ldr	x0, [x19, #48]
    40005470:	f90003e0 	str	x0, [sp]
    40005474:	aa1403e0 	mov	x0, x20
    40005478:	a9400e62 	ldp	x2, x3, [x19]
    4000547c:	a9411664 	ldp	x4, x5, [x19, #16]
    40005480:	a9421e66 	ldp	x6, x7, [x19, #32]
    40005484:	97ffff4b 	bl	400051b0 <print_formatted>
		break;
    40005488:	17ffff95 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    4000548c:	f9402e60 	ldr	x0, [x19, #88]
    40005490:	f90017e0 	str	x0, [sp, #40]
    40005494:	aa1503e1 	mov	x1, x21
    40005498:	f9402a60 	ldr	x0, [x19, #80]
    4000549c:	f90013e0 	str	x0, [sp, #32]
    400054a0:	f9402660 	ldr	x0, [x19, #72]
    400054a4:	f9000fe0 	str	x0, [sp, #24]
    400054a8:	f9402260 	ldr	x0, [x19, #64]
    400054ac:	f9000be0 	str	x0, [sp, #16]
    400054b0:	f9401e60 	ldr	x0, [x19, #56]
    400054b4:	f90007e0 	str	x0, [sp, #8]
    400054b8:	f9401a60 	ldr	x0, [x19, #48]
    400054bc:	f90003e0 	str	x0, [sp]
    400054c0:	aa1403e0 	mov	x0, x20
    400054c4:	a9400e62 	ldp	x2, x3, [x19]
    400054c8:	a9411664 	ldp	x4, x5, [x19, #16]
    400054cc:	a9421e66 	ldp	x6, x7, [x19, #32]
    400054d0:	97ffff38 	bl	400051b0 <print_formatted>
		break;
    400054d4:	17ffff82 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    400054d8:	f9403260 	ldr	x0, [x19, #96]
    400054dc:	f9001be0 	str	x0, [sp, #48]
    400054e0:	aa1503e1 	mov	x1, x21
    400054e4:	f9402e60 	ldr	x0, [x19, #88]
    400054e8:	f90017e0 	str	x0, [sp, #40]
    400054ec:	f9402a60 	ldr	x0, [x19, #80]
    400054f0:	f90013e0 	str	x0, [sp, #32]
    400054f4:	f9402660 	ldr	x0, [x19, #72]
    400054f8:	f9000fe0 	str	x0, [sp, #24]
    400054fc:	f9402260 	ldr	x0, [x19, #64]
    40005500:	f9000be0 	str	x0, [sp, #16]
    40005504:	f9401e60 	ldr	x0, [x19, #56]
    40005508:	f90007e0 	str	x0, [sp, #8]
    4000550c:	f9401a60 	ldr	x0, [x19, #48]
    40005510:	f90003e0 	str	x0, [sp]
    40005514:	aa1403e0 	mov	x0, x20
    40005518:	a9400e62 	ldp	x2, x3, [x19]
    4000551c:	a9411664 	ldp	x4, x5, [x19, #16]
    40005520:	a9421e66 	ldp	x6, x7, [x19, #32]
    40005524:	97ffff23 	bl	400051b0 <print_formatted>
		break;
    40005528:	17ffff6d 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    4000552c:	f9403660 	ldr	x0, [x19, #104]
    40005530:	f9001fe0 	str	x0, [sp, #56]
    40005534:	aa1503e1 	mov	x1, x21
    40005538:	f9403260 	ldr	x0, [x19, #96]
    4000553c:	f9001be0 	str	x0, [sp, #48]
    40005540:	f9402e60 	ldr	x0, [x19, #88]
    40005544:	f90017e0 	str	x0, [sp, #40]
    40005548:	f9402a60 	ldr	x0, [x19, #80]
    4000554c:	f90013e0 	str	x0, [sp, #32]
    40005550:	f9402660 	ldr	x0, [x19, #72]
    40005554:	f9000fe0 	str	x0, [sp, #24]
    40005558:	f9402260 	ldr	x0, [x19, #64]
    4000555c:	f9000be0 	str	x0, [sp, #16]
    40005560:	f9401e60 	ldr	x0, [x19, #56]
    40005564:	f90007e0 	str	x0, [sp, #8]
    40005568:	f9401a60 	ldr	x0, [x19, #48]
    4000556c:	f90003e0 	str	x0, [sp]
    40005570:	aa1403e0 	mov	x0, x20
    40005574:	a9400e62 	ldp	x2, x3, [x19]
    40005578:	a9411664 	ldp	x4, x5, [x19, #16]
    4000557c:	a9421e66 	ldp	x6, x7, [x19, #32]
    40005580:	97ffff0c 	bl	400051b0 <print_formatted>
		break;
    40005584:	17ffff56 	b	400052dc <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    40005588:	f9403a60 	ldr	x0, [x19, #112]
    4000558c:	f90023e0 	str	x0, [sp, #64]
    40005590:	aa1503e1 	mov	x1, x21
    40005594:	f9403660 	ldr	x0, [x19, #104]
    40005598:	f9001fe0 	str	x0, [sp, #56]
    4000559c:	f9403260 	ldr	x0, [x19, #96]
    400055a0:	f9001be0 	str	x0, [sp, #48]
    400055a4:	f9402e60 	ldr	x0, [x19, #88]
    400055a8:	f90017e0 	str	x0, [sp, #40]
    400055ac:	f9402a60 	ldr	x0, [x19, #80]
    400055b0:	f90013e0 	str	x0, [sp, #32]
    400055b4:	f9402660 	ldr	x0, [x19, #72]
    400055b8:	f9000fe0 	str	x0, [sp, #24]
    400055bc:	f9402260 	ldr	x0, [x19, #64]
    400055c0:	f9000be0 	str	x0, [sp, #16]
    400055c4:	f9401e60 	ldr	x0, [x19, #56]
    400055c8:	f90007e0 	str	x0, [sp, #8]
    400055cc:	f9401a60 	ldr	x0, [x19, #48]
    400055d0:	f90003e0 	str	x0, [sp]
    400055d4:	aa1403e0 	mov	x0, x20
    400055d8:	a9400e62 	ldp	x2, x3, [x19]
    400055dc:	a9411664 	ldp	x4, x5, [x19, #16]
    400055e0:	a9421e66 	ldp	x6, x7, [x19, #32]
    400055e4:	97fffef3 	bl	400051b0 <print_formatted>
}
    400055e8:	17ffff3d 	b	400052dc <std_print+0xa8>

00000000400055ec <hexdump_line_print>:

static void hexdump_line_print(const struct log_output *output,
			       const uint8_t *data, uint32_t length,
			       int prefix_offset, uint32_t flags)
{
    400055ec:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    400055f0:	910003fd 	mov	x29, sp
    400055f4:	a90153f3 	stp	x19, x20, [sp, #16]
    400055f8:	aa0003f3 	mov	x19, x0
    400055fc:	2a0303f4 	mov	w20, w3
    40005600:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005604:	aa0103f5 	mov	x21, x1
    40005608:	2a0203f6 	mov	w22, w2
    4000560c:	a90363f7 	stp	x23, x24, [sp, #48]
    40005610:	a9046bf9 	stp	x25, x26, [sp, #64]
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    40005614:	372000a4 	tbnz	w4, #4, 40005628 <hexdump_line_print+0x3c>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    40005618:	36280684 	tbz	w4, #5, 400056e8 <hexdump_line_print+0xfc>
		print_formatted(ctx, "\n");
    4000561c:	90000081 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40005620:	91096021 	add	x1, x1, #0x258
		print_formatted(ctx, "\r\n");
    40005624:	97fffee3 	bl	400051b0 <print_formatted>
	newline_print(output, flags);

	for (int i = 0; i < prefix_offset; i++) {
		print_formatted(output, " ");
    40005628:	f0000078 	adrp	x24, 40014000 <shell_m_sub_colors+0x50>
    4000562c:	91337f18 	add	x24, x24, #0xcdf
{
    40005630:	52800017 	mov	w23, #0x0                   	// #0
	for (int i = 0; i < prefix_offset; i++) {
    40005634:	6b1402ff 	cmp	w23, w20
    40005638:	540005eb 	b.lt	400056f4 <hexdump_line_print+0x108>  // b.tstop
		}

		if (i < length) {
			print_formatted(output, "%02x ", data[i]);
		} else {
			print_formatted(output, "   ");
    4000563c:	f0000078 	adrp	x24, 40014000 <shell_m_sub_colors+0x50>
    40005640:	91337718 	add	x24, x24, #0xcdd
			print_formatted(output, "%02x ", data[i]);
    40005644:	f0000079 	adrp	x25, 40014000 <shell_m_sub_colors+0x50>
    40005648:	911a4739 	add	x25, x25, #0x691
    4000564c:	d2800014 	mov	x20, #0x0                   	// #0
			print_formatted(output, " ");
    40005650:	f000007a 	adrp	x26, 40014000 <shell_m_sub_colors+0x50>
		if (i < length) {
    40005654:	2a1403f7 	mov	w23, w20
    40005658:	6b1402df 	cmp	w22, w20
    4000565c:	54000669 	b.ls	40005728 <hexdump_line_print+0x13c>  // b.plast
			print_formatted(output, "%02x ", data[i]);
    40005660:	38746aa2 	ldrb	w2, [x21, x20]
    40005664:	aa1903e1 	mov	x1, x25
    40005668:	aa1303e0 	mov	x0, x19
    4000566c:	97fffed1 	bl	400051b0 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    40005670:	f1003e9f 	cmp	x20, #0xf
    40005674:	540004a1 	b.ne	40005708 <hexdump_line_print+0x11c>  // b.any
			char c = (char)data[i];

			print_formatted(output, "%c",
			      isprint((int)c) ? c : '.');
		} else {
			print_formatted(output, " ");
    40005678:	f0000077 	adrp	x23, 40014000 <shell_m_sub_colors+0x50>
    4000567c:	91337ef7 	add	x23, x23, #0xcdf
			print_formatted(output, "%c",
    40005680:	90000099 	adrp	x25, 40015000 <prefix.1+0x2aa>
    40005684:	9126b339 	add	x25, x25, #0x9ac
	print_formatted(output, "|");
    40005688:	d2800014 	mov	x20, #0x0                   	// #0
    4000568c:	528005da 	mov	w26, #0x2e                  	// #46
    40005690:	aa1303e0 	mov	x0, x19
    40005694:	f0000061 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    40005698:	91338421 	add	x1, x1, #0xce1
    4000569c:	97fffec5 	bl	400051b0 <print_formatted>
		if (i < length) {
    400056a0:	2a1403f8 	mov	w24, w20
    400056a4:	6b1402df 	cmp	w22, w20
    400056a8:	54000589 	b.ls	40005758 <hexdump_line_print+0x16c>  // b.plast
			char c = (char)data[i];
    400056ac:	38746aa2 	ldrb	w2, [x21, x20]
			print_formatted(output, "%c",
    400056b0:	aa1903e1 	mov	x1, x25
	return (int)((((unsigned)c) >= ' ') &&
    400056b4:	51008040 	sub	w0, w2, #0x20
    400056b8:	71017c1f 	cmp	w0, #0x5f
    400056bc:	aa1303e0 	mov	x0, x19
    400056c0:	1a9a3042 	csel	w2, w2, w26, cc  // cc = lo, ul, last
    400056c4:	97fffebb 	bl	400051b0 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    400056c8:	f1003e9f 	cmp	x20, #0xf
    400056cc:	54000361 	b.ne	40005738 <hexdump_line_print+0x14c>  // b.any
		}
	}
}
    400056d0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400056d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400056d8:	a94363f7 	ldp	x23, x24, [sp, #48]
    400056dc:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400056e0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    400056e4:	d65f03c0 	ret
		print_formatted(ctx, "\r\n");
    400056e8:	f0000061 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    400056ec:	9137e021 	add	x1, x1, #0xdf8
    400056f0:	17ffffcd 	b	40005624 <hexdump_line_print+0x38>
		print_formatted(output, " ");
    400056f4:	aa1803e1 	mov	x1, x24
    400056f8:	aa1303e0 	mov	x0, x19
	for (int i = 0; i < prefix_offset; i++) {
    400056fc:	110006f7 	add	w23, w23, #0x1
		print_formatted(output, " ");
    40005700:	97fffeac 	bl	400051b0 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    40005704:	17ffffcc 	b	40005634 <hexdump_line_print+0x48>
		if (i > 0 && !(i % 8)) {
    40005708:	110006f7 	add	w23, w23, #0x1
    4000570c:	f2400aff 	tst	x23, #0x7
    40005710:	54000081 	b.ne	40005720 <hexdump_line_print+0x134>  // b.any
			print_formatted(output, " ");
    40005714:	91337f41 	add	x1, x26, #0xcdf
    40005718:	aa1303e0 	mov	x0, x19
    4000571c:	97fffea5 	bl	400051b0 <print_formatted>
    40005720:	91000694 	add	x20, x20, #0x1
    40005724:	17ffffcc 	b	40005654 <hexdump_line_print+0x68>
			print_formatted(output, "   ");
    40005728:	aa1803e1 	mov	x1, x24
    4000572c:	aa1303e0 	mov	x0, x19
    40005730:	97fffea0 	bl	400051b0 <print_formatted>
    40005734:	17ffffcf 	b	40005670 <hexdump_line_print+0x84>
		if (i > 0 && !(i % 8)) {
    40005738:	11000718 	add	w24, w24, #0x1
    4000573c:	f2400b1f 	tst	x24, #0x7
    40005740:	54000081 	b.ne	40005750 <hexdump_line_print+0x164>  // b.any
			print_formatted(output, " ");
    40005744:	aa1703e1 	mov	x1, x23
    40005748:	aa1303e0 	mov	x0, x19
    4000574c:	97fffe99 	bl	400051b0 <print_formatted>
    40005750:	91000694 	add	x20, x20, #0x1
    40005754:	17ffffd3 	b	400056a0 <hexdump_line_print+0xb4>
			print_formatted(output, " ");
    40005758:	aa1703e1 	mov	x1, x23
    4000575c:	aa1303e0 	mov	x0, x19
    40005760:	97fffe94 	bl	400051b0 <print_formatted>
    40005764:	17ffffd9 	b	400056c8 <hexdump_line_print+0xdc>

0000000040005768 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
    40005768:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000576c:	910003fd 	mov	x29, sp
    40005770:	a90153f3 	stp	x19, x20, [sp, #16]
    40005774:	aa0003f3 	mov	x19, x0
    40005778:	12001c94 	and	w20, w4, #0xff
    4000577c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005780:	12001cb6 	and	w22, w5, #0xff
    40005784:	13003cd5 	sxth	w21, w6
    40005788:	a90363f7 	stp	x23, x24, [sp, #48]
    4000578c:	12001c57 	and	w23, w2, #0xff
    40005790:	121d0038 	and	w24, w1, #0x8
    40005794:	a9046bf9 	stp	x25, x26, [sp, #64]
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    40005798:	12000039 	and	w25, w1, #0x1
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
    4000579c:	36080a41 	tbz	w1, #1, 400058e4 <prefix_print+0x17c>
    400057a0:	2a0303e2 	mov	w2, w3
	if (!format) {
    400057a4:	52800883 	mov	w3, #0x44                  	// #68
    400057a8:	6a03003f 	tst	w1, w3
    400057ac:	54000681 	b.ne	4000587c <prefix_print+0x114>  // b.any
		length = print_formatted(output, "[%08lu] ", timestamp);
    400057b0:	f0000061 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    400057b4:	9133c421 	add	x1, x1, #0xcf1
    400057b8:	97fffe7e 	bl	400051b0 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
    400057bc:	2a0003fa 	mov	w26, w0
	if (color) {
    400057c0:	34000199 	cbz	w25, 400057f0 <prefix_print+0x88>
		const char *log_color = start && (colors[level] != NULL) ?
    400057c4:	2a1403e1 	mov	w1, w20
    400057c8:	d0000060 	adrp	x0, 40013000 <shell_cmd_help>
    400057cc:	9118e000 	add	x0, x0, #0x638
    400057d0:	f8617802 	ldr	x2, [x0, x1, lsl #3]
    400057d4:	b5000062 	cbnz	x2, 400057e0 <prefix_print+0x78>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    400057d8:	f0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    400057dc:	91338c42 	add	x2, x2, #0xce3
		print_formatted(output, "%s", log_color);
    400057e0:	90000081 	adrp	x1, 40015000 <prefix.1+0x2aa>
    400057e4:	910dbc21 	add	x1, x1, #0x36f
    400057e8:	aa1303e0 	mov	x0, x19
    400057ec:	97fffe71 	bl	400051b0 <print_formatted>
	if (level_on) {
    400057f0:	340007f8 	cbz	w24, 400058ec <prefix_print+0x184>
		total += print_formatted(output, "<%s> ", severity[level]);
    400057f4:	2a1403e1 	mov	w1, w20
    400057f8:	d0000060 	adrp	x0, 40013000 <shell_cmd_help>
    400057fc:	91198000 	add	x0, x0, #0x660
    40005800:	f8617802 	ldr	x2, [x0, x1, lsl #3]
    40005804:	aa1303e0 	mov	x0, x19
    40005808:	f0000061 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    4000580c:	91345821 	add	x1, x1, #0xd16
    40005810:	97fffe68 	bl	400051b0 <print_formatted>
    40005814:	2a0003f8 	mov	w24, w0
	if (source_id >= 0) {
    40005818:	37f80255 	tbnz	w21, #31, 40005860 <prefix_print+0xf8>
		total += print_formatted(output,
    4000581c:	340006d7 	cbz	w23, 400058f4 <prefix_print+0x18c>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    40005820:	52800021 	mov	w1, #0x1                   	// #1
		total += print_formatted(output,
    40005824:	f0000060 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    40005828:	1ad42021 	lsl	w1, w1, w20
		total += print_formatted(output,
    4000582c:	9133b400 	add	x0, x0, #0xced
    40005830:	f27c003f 	tst	x1, #0x10
    40005834:	f0000074 	adrp	x20, 40014000 <shell_m_sub_colors+0x50>
    40005838:	9133a294 	add	x20, x20, #0xce8
    4000583c:	9a800294 	csel	x20, x20, x0, eq  // eq = none
    40005840:	2a1503e1 	mov	w1, w21
    40005844:	2a1603e0 	mov	w0, w22
    40005848:	97fffcba 	bl	40004b30 <log_source_name_get>
    4000584c:	aa0003e2 	mov	x2, x0
    40005850:	aa1403e1 	mov	x1, x20
    40005854:	aa1303e0 	mov	x0, x19
    40005858:	97fffe56 	bl	400051b0 <print_formatted>
    4000585c:	0b000318 	add	w24, w24, w0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
    40005860:	0b1a0300 	add	w0, w24, w26
    40005864:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005868:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000586c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40005870:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40005874:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40005878:	d65f03c0 	ret
	} else if (freq != 0U) {
    4000587c:	900000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40005880:	b9480026 	ldr	w6, [x1, #2048]
    40005884:	340002c6 	cbz	w6, 400058dc <prefix_print+0x174>
		timestamp /= timestamp_div;
    40005888:	900000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000588c:	b9480421 	ldr	w1, [x1, #2052]
    40005890:	5281c204 	mov	w4, #0xe10                 	// #3600
			length = print_formatted(output,
    40005894:	52800787 	mov	w7, #0x3c                  	// #60
		timestamp /= timestamp_div;
    40005898:	1ac10843 	udiv	w3, w2, w1
		total_seconds = timestamp / freq;
    4000589c:	1ac60861 	udiv	w1, w3, w6
		seconds -= hours * 3600U;
    400058a0:	1ac40822 	udiv	w2, w1, w4
    400058a4:	1b048444 	msub	w4, w2, w4, w1
		remainder = timestamp % freq;
    400058a8:	1b068c21 	msub	w1, w1, w6, w3
		ms = (remainder * 1000U) / freq;
    400058ac:	52807d03 	mov	w3, #0x3e8                 	// #1000
    400058b0:	1b037c21 	mul	w1, w1, w3
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    400058b4:	1ac60825 	udiv	w5, w1, w6
    400058b8:	1b0684a1 	msub	w1, w5, w6, w1
    400058bc:	1b037c21 	mul	w1, w1, w3
			length = print_formatted(output,
    400058c0:	1ac70883 	udiv	w3, w4, w7
    400058c4:	1ac60826 	udiv	w6, w1, w6
    400058c8:	f0000061 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    400058cc:	9133e821 	add	x1, x1, #0xcfa
    400058d0:	1b079064 	msub	w4, w3, w7, w4
    400058d4:	97fffe37 	bl	400051b0 <print_formatted>
    400058d8:	17ffffb9 	b	400057bc <prefix_print+0x54>
		length = 0;
    400058dc:	52800000 	mov	w0, #0x0                   	// #0
    400058e0:	17ffffb7 	b	400057bc <prefix_print+0x54>
    400058e4:	121f003a 	and	w26, w1, #0x2
    400058e8:	17ffffb6 	b	400057c0 <prefix_print+0x58>
	int total = 0;
    400058ec:	52800018 	mov	w24, #0x0                   	// #0
    400058f0:	17ffffca 	b	40005818 <prefix_print+0xb0>
		total += print_formatted(output,
    400058f4:	f0000074 	adrp	x20, 40014000 <shell_m_sub_colors+0x50>
    400058f8:	9133a294 	add	x20, x20, #0xce8
    400058fc:	17ffffd1 	b	40005840 <prefix_print+0xd8>

0000000040005900 <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
    40005900:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005904:	910003fd 	mov	x29, sp
    40005908:	a90153f3 	stp	x19, x20, [sp, #16]
    4000590c:	aa0003f4 	mov	x20, x0
    40005910:	2a0103f3 	mov	w19, w1
	if (color) {
    40005914:	360000d3 	tbz	w19, #0, 4000592c <postfix_print+0x2c>
		print_formatted(output, "%s", log_color);
    40005918:	f0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    4000591c:	91338c42 	add	x2, x2, #0xce3
    40005920:	90000081 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40005924:	910dbc21 	add	x1, x1, #0x36f
    40005928:	97fffe22 	bl	400051b0 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    4000592c:	37200173 	tbnz	w19, #4, 40005958 <postfix_print+0x58>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    40005930:	362800f3 	tbz	w19, #5, 4000594c <postfix_print+0x4c>
		print_formatted(ctx, "\n");
    40005934:	90000081 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40005938:	91096021 	add	x1, x1, #0x258
		print_formatted(ctx, "\r\n");
    4000593c:	aa1403e0 	mov	x0, x20
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
    40005940:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005944:	a8c27bfd 	ldp	x29, x30, [sp], #32
		print_formatted(ctx, "\r\n");
    40005948:	17fffe1a 	b	400051b0 <print_formatted>
    4000594c:	f0000061 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    40005950:	9137e021 	add	x1, x1, #0xdf8
    40005954:	17fffffa 	b	4000593c <postfix_print+0x3c>
}
    40005958:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000595c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005960:	d65f03c0 	ret

0000000040005964 <log_output_flush>:
{
    40005964:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005968:	910003fd 	mov	x29, sp
    4000596c:	f9000bf3 	str	x19, [sp, #16]
    40005970:	aa0003f3 	mov	x19, x0
	buffer_write(output->func, output->buf,
    40005974:	a9408400 	ldp	x0, x1, [x0, #8]
    40005978:	a9400c02 	ldp	x2, x3, [x0]
    4000597c:	f9400260 	ldr	x0, [x19]
    40005980:	97fffdf9 	bl	40005164 <buffer_write>
	output->control_block->offset = 0;
    40005984:	f9400660 	ldr	x0, [x19, #8]
}
    40005988:	f9400bf3 	ldr	x19, [sp, #16]
	output->control_block->offset = 0;
    4000598c:	f900001f 	str	xzr, [x0]
}
    40005990:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005994:	d65f03c0 	ret

0000000040005998 <out_func>:
{
    40005998:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000599c:	910003fd 	mov	x29, sp
    400059a0:	a90153f3 	stp	x19, x20, [sp, #16]
    400059a4:	2a0003f4 	mov	w20, w0
    400059a8:	aa0103f3 	mov	x19, x1
	if (out_ctx->control_block->offset == out_ctx->size) {
    400059ac:	f9400420 	ldr	x0, [x1, #8]
    400059b0:	f9400001 	ldr	x1, [x0]
    400059b4:	f9400e60 	ldr	x0, [x19, #24]
    400059b8:	eb00003f 	cmp	x1, x0
    400059bc:	54000061 	b.ne	400059c8 <out_func+0x30>  // b.any
		log_output_flush(out_ctx);
    400059c0:	aa1303e0 	mov	x0, x19
    400059c4:	97ffffe8 	bl	40005964 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    400059c8:	f9400661 	ldr	x1, [x19, #8]
    400059cc:	d2800020 	mov	x0, #0x1                   	// #1
    400059d0:	97ffed7c 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	out_ctx->buf[idx] = (uint8_t)c;
    400059d4:	f9400a61 	ldr	x1, [x19, #16]
    400059d8:	3820c834 	strb	w20, [x1, w0, sxtw]
}
    400059dc:	52800000 	mov	w0, #0x0                   	// #0
    400059e0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400059e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400059e8:	d65f03c0 	ret

00000000400059ec <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg,
			    uint32_t flags)
{
    400059ec:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    400059f0:	910003fd 	mov	x29, sp
	return msg->hdr.ids.level;
    400059f4:	f9400825 	ldr	x5, [x1, #16]
    400059f8:	a90153f3 	stp	x19, x20, [sp, #16]
    400059fc:	aa0003f3 	mov	x19, x0
    40005a00:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005a04:	aa0103f4 	mov	x20, x1
    40005a08:	2a0203f5 	mov	w21, w2
    40005a0c:	a90363f7 	stp	x23, x24, [sp, #48]
		log_output_msg_syst_process(output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(output, flags, std_msg, timestamp,
    40005a10:	721008bf 	tst	w5, #0x70000
    40005a14:	d35048b8 	ubfx	x24, x5, #16, #3
{
    40005a18:	f90023f9 	str	x25, [sp, #64]
	uint8_t level = (uint8_t)log_msg_level_get(msg);
    40005a1c:	531048b7 	ubfx	w23, w5, #16, #3
			0 : prefix_print(output, flags, std_msg, timestamp,
    40005a20:	54000300 	b.eq	40005a80 <log_output_msg_process+0x94>  // b.none
    40005a24:	b9401683 	ldr	w3, [x20, #20]
    40005a28:	53167ca6 	lsr	w6, w5, #22
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    40005a2c:	79402022 	ldrh	w2, [x1, #16]
    40005a30:	d35354a5 	ubfx	x5, x5, #19, #3
    40005a34:	2a1803e4 	mov	w4, w24
    40005a38:	2a1503e1 	mov	w1, w21
    40005a3c:	2a2203e2 	mvn	w2, w2
    40005a40:	12000042 	and	w2, w2, #0x1
    40005a44:	97ffff49 	bl	40005768 <prefix_print>
    40005a48:	2a0003f6 	mov	w22, w0
    40005a4c:	79402280 	ldrh	w0, [x20, #16]
    40005a50:	2a2003e0 	mvn	w0, w0
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
    40005a54:	12000019 	and	w25, w0, #0x1
    40005a58:	36000180 	tbz	w0, #0, 40005a88 <log_output_msg_process+0x9c>
		std_print(msg, output);
    40005a5c:	aa1303e1 	mov	x1, x19
    40005a60:	aa1403e0 	mov	x0, x20
    40005a64:	97fffdf4 	bl	40005234 <std_print>
		raw_string_print(msg, output);
	} else {
		hexdump_print(msg, output, prefix_offset, flags);
	}

	if (!raw_string) {
    40005a68:	34000477 	cbz	w23, 40005af4 <log_output_msg_process+0x108>
		postfix_print(output, flags, level);
    40005a6c:	2a1803e2 	mov	w2, w24
    40005a70:	2a1503e1 	mov	w1, w21
    40005a74:	aa1303e0 	mov	x0, x19
    40005a78:	97ffffa2 	bl	40005900 <postfix_print>
    40005a7c:	1400001e 	b	40005af4 <log_output_msg_process+0x108>
			0 : prefix_print(output, flags, std_msg, timestamp,
    40005a80:	52800016 	mov	w22, #0x0                   	// #0
    40005a84:	17fffff2 	b	40005a4c <log_output_msg_process+0x60>
	} else if (raw_string) {
    40005a88:	35000457 	cbnz	w23, 40005b10 <log_output_msg_process+0x124>
	size_t offset = 0;
    40005a8c:	d2800015 	mov	x21, #0x0                   	// #0
		length = output->size;
    40005a90:	a9410261 	ldp	x1, x0, [x19, #16]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
    40005a94:	aa1503e3 	mov	x3, x21
    40005a98:	910183e2 	add	x2, sp, #0x60
		length = output->size;
    40005a9c:	f90033e0 	str	x0, [sp, #96]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
    40005aa0:	aa1403e0 	mov	x0, x20
    40005aa4:	97fffda5 	bl	40005138 <log_msg_hexdump_data_get>
		output->control_block->offset = length;
    40005aa8:	f9400660 	ldr	x0, [x19, #8]
    40005aac:	f94033e1 	ldr	x1, [sp, #96]
    40005ab0:	f9000001 	str	x1, [x0]
		if (length != 0) {
    40005ab4:	b40000c1 	cbz	x1, 40005acc <log_output_msg_process+0xe0>
			eol = (output->buf[length - 1] == '\n');
    40005ab8:	f9400a60 	ldr	x0, [x19, #16]
    40005abc:	8b010000 	add	x0, x0, x1
    40005ac0:	385ff000 	ldurb	w0, [x0, #-1]
    40005ac4:	7100281f 	cmp	w0, #0xa
    40005ac8:	1a9f17f9 	cset	w25, eq  // eq = none
		log_output_flush(output);
    40005acc:	aa1303e0 	mov	x0, x19
    40005ad0:	97ffffa5 	bl	40005964 <log_output_flush>
		offset += length;
    40005ad4:	f94033e0 	ldr	x0, [sp, #96]
    40005ad8:	8b0002b5 	add	x21, x21, x0
	} while (length > 0);
    40005adc:	b5fffda0 	cbnz	x0, 40005a90 <log_output_msg_process+0xa4>
	if (eol) {
    40005ae0:	340000b9 	cbz	w25, 40005af4 <log_output_msg_process+0x108>
		print_formatted(output, "\r");
    40005ae4:	f0000061 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    40005ae8:	91347021 	add	x1, x1, #0xd1c
    40005aec:	aa1303e0 	mov	x0, x19
    40005af0:	97fffdb0 	bl	400051b0 <print_formatted>
	}

	log_output_flush(output);
    40005af4:	aa1303e0 	mov	x0, x19
}
    40005af8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005afc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005b00:	a94363f7 	ldp	x23, x24, [sp, #48]
    40005b04:	f94023f9 	ldr	x25, [sp, #64]
    40005b08:	a8c77bfd 	ldp	x29, x30, [sp], #112
	log_output_flush(output);
    40005b0c:	17ffff96 	b	40005964 <log_output_flush>
	uint32_t offset = 0U;
    40005b10:	52800017 	mov	w23, #0x0                   	// #0
		length = sizeof(buf);
    40005b14:	d2800219 	mov	x25, #0x10                  	// #16
	print_formatted(output, "%s", log_msg_str_get(msg));
    40005b18:	aa1403e0 	mov	x0, x20
    40005b1c:	97fffd85 	bl	40005130 <log_msg_str_get>
    40005b20:	90000081 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40005b24:	910dbc21 	add	x1, x1, #0x36f
    40005b28:	aa0003e2 	mov	x2, x0
    40005b2c:	aa1303e0 	mov	x0, x19
    40005b30:	97fffda0 	bl	400051b0 <print_formatted>
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    40005b34:	910163e2 	add	x2, sp, #0x58
    40005b38:	2a1703e3 	mov	w3, w23
    40005b3c:	910183e1 	add	x1, sp, #0x60
    40005b40:	aa1403e0 	mov	x0, x20
		length = sizeof(buf);
    40005b44:	f9002ff9 	str	x25, [sp, #88]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    40005b48:	97fffd7c 	bl	40005138 <log_msg_hexdump_data_get>
		if (length) {
    40005b4c:	f9402fe2 	ldr	x2, [sp, #88]
    40005b50:	b4fff8e2 	cbz	x2, 40005a6c <log_output_msg_process+0x80>
			hexdump_line_print(output, buf, length,
    40005b54:	aa1303e0 	mov	x0, x19
    40005b58:	2a1503e4 	mov	w4, w21
    40005b5c:	2a1603e3 	mov	w3, w22
    40005b60:	910183e1 	add	x1, sp, #0x60
    40005b64:	97fffea2 	bl	400055ec <hexdump_line_print>
			offset += length;
    40005b68:	f9402fe0 	ldr	x0, [sp, #88]
    40005b6c:	0b0002f7 	add	w23, w23, w0
		length = sizeof(buf);
    40005b70:	17fffff1 	b	40005b34 <log_output_msg_process+0x148>

0000000040005b74 <log_output_dropped_process>:
	postfix_print(output, flags, level);
	log_output_flush(output);
}

void log_output_dropped_process(const struct log_output *output, uint32_t cnt)
{
    40005b74:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
    40005b78:	5284e1e3 	mov	w3, #0x270f                	// #9999
    40005b7c:	6b03003f 	cmp	w1, w3
{
    40005b80:	910003fd 	mov	x29, sp
    40005b84:	a90153f3 	stp	x19, x20, [sp, #16]
    40005b88:	aa0003f3 	mov	x19, x0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    40005b8c:	1a839023 	csel	w3, w1, w3, ls  // ls = plast
    40005b90:	9100e3e0 	add	x0, sp, #0x38
    40005b94:	d28000a1 	mov	x1, #0x5                   	// #5
    40005b98:	90000082 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40005b9c:	911f8442 	add	x2, x2, #0x7e1
	log_output_func_t outf = output->func;
    40005ba0:	f9400274 	ldr	x20, [x19]
{
    40005ba4:	f90013f5 	str	x21, [sp, #32]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    40005ba8:	97fff0d7 	bl	40001f04 <snprintk>
    40005bac:	2a0003f5 	mov	w21, w0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    40005bb0:	f9400660 	ldr	x0, [x19, #8]
    40005bb4:	d2800082 	mov	x2, #0x4                   	// #4
    40005bb8:	f0000061 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    40005bbc:	91355821 	add	x1, x1, #0xd56
    40005bc0:	f9400403 	ldr	x3, [x0, #8]
    40005bc4:	aa1403e0 	mov	x0, x20
    40005bc8:	97fffd67 	bl	40005164 <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
    40005bcc:	f9400660 	ldr	x0, [x19, #8]
    40005bd0:	93407ea2 	sxtw	x2, w21
    40005bd4:	9100e3e1 	add	x1, sp, #0x38
    40005bd8:	f9400403 	ldr	x3, [x0, #8]
    40005bdc:	aa1403e0 	mov	x0, x20
    40005be0:	97fffd61 	bl	40005164 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
    40005be4:	f9400660 	ldr	x0, [x19, #8]
    40005be8:	d28002e2 	mov	x2, #0x17                  	// #23
    40005bec:	f0000061 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    40005bf0:	9134f821 	add	x1, x1, #0xd3e
    40005bf4:	f9400403 	ldr	x3, [x0, #8]
    40005bf8:	aa1403e0 	mov	x0, x20
    40005bfc:	97fffd5a 	bl	40005164 <buffer_write>
		     output->control_block->ctx);
}
    40005c00:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005c04:	f94013f5 	ldr	x21, [sp, #32]
    40005c08:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40005c0c:	d65f03c0 	ret

0000000040005c10 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
    40005c10:	900000e2 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    40005c14:	52800021 	mov	w1, #0x1                   	// #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    40005c18:	52884804 	mov	w4, #0x4240                	// #16960
    40005c1c:	72a001e4 	movk	w4, #0xf, lsl #16
	timestamp_div = 1U;
    40005c20:	b9080441 	str	w1, [x2, #2052]
	while (frequency > 1000000) {
    40005c24:	52800003 	mov	w3, #0x0                   	// #0
    40005c28:	6b04001f 	cmp	w0, w4
    40005c2c:	540000c8 	b.hi	40005c44 <log_output_timestamp_freq_set+0x34>  // b.pmore
    40005c30:	34000043 	cbz	w3, 40005c38 <log_output_timestamp_freq_set+0x28>
    40005c34:	b9080441 	str	w1, [x2, #2052]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
    40005c38:	900000e1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40005c3c:	b9080020 	str	w0, [x1, #2048]
}
    40005c40:	d65f03c0 	ret
		frequency /= 2U;
    40005c44:	53017c00 	lsr	w0, w0, #1
		timestamp_div *= 2U;
    40005c48:	531f7821 	lsl	w1, w1, #1
    40005c4c:	52800023 	mov	w3, #0x1                   	// #1
    40005c50:	17fffff6 	b	40005c28 <log_output_timestamp_freq_set+0x18>

0000000040005c54 <severity_lvl_get>:

static void severity_lvl_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &dsub_module_name;
    40005c54:	d0000062 	adrp	x2, 40013000 <shell_cmd_help>
    40005c58:	911b0042 	add	x2, x2, #0x6c0
    40005c5c:	a900883f 	stp	xzr, x2, [x1, #8]
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
					severity_lvls_sorted[idx] : NULL;
    40005c60:	f100101f 	cmp	x0, #0x4
	entry->handler = NULL;
    40005c64:	f9000c3f 	str	xzr, [x1, #24]
					severity_lvls_sorted[idx] : NULL;
    40005c68:	540000c8 	b.hi	40005c80 <severity_lvl_get+0x2c>  // b.pmore
    40005c6c:	d0000062 	adrp	x2, 40013000 <shell_cmd_help>
    40005c70:	911c2042 	add	x2, x2, #0x708
    40005c74:	f8607840 	ldr	x0, [x2, x0, lsl #3]
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
    40005c78:	f9000020 	str	x0, [x1]
}
    40005c7c:	d65f03c0 	ret
					severity_lvls_sorted[idx] : NULL;
    40005c80:	d2800000 	mov	x0, #0x0                   	// #0
    40005c84:	17fffffd 	b	40005c78 <severity_lvl_get+0x24>

0000000040005c88 <log_halt>:
	backend->cb->active = false;
    40005c88:	f9400420 	ldr	x0, [x1, #8]
    40005c8c:	3900241f 	strb	wzr, [x0, #9]
		    size_t argc,
		    char **argv)
{
	log_backend_deactivate(backend);
	return 0;
}
    40005c90:	52800000 	mov	w0, #0x0                   	// #0
    40005c94:	d65f03c0 	ret

0000000040005c98 <log_go>:
	backend->cb->active = true;
    40005c98:	f9400420 	ldr	x0, [x1, #8]
    40005c9c:	52800021 	mov	w1, #0x1                   	// #1
    40005ca0:	39002401 	strb	w1, [x0, #9]
		  size_t argc,
		  char **argv)
{
	log_backend_activate(backend, backend->cb->ctx);
	return 0;
}
    40005ca4:	52800000 	mov	w0, #0x0                   	// #0
    40005ca8:	d65f03c0 	ret

0000000040005cac <backend_name_get>:

static void backend_name_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &sub_log_backend;
    40005cac:	d0000062 	adrp	x2, 40013000 <shell_cmd_help>
    40005cb0:	9126c042 	add	x2, x2, #0x9b0
	return __log_backends_end - __log_backends_start;
    40005cb4:	b0000063 	adrp	x3, 40012000 <__rodata_region_start>
    40005cb8:	913c4063 	add	x3, x3, #0xf10
	entry->handler = NULL;
    40005cbc:	a9017c22 	stp	x2, xzr, [x1, #16]
    40005cc0:	b0000062 	adrp	x2, 40012000 <__rodata_region_start>
    40005cc4:	913cc042 	add	x2, x2, #0xf30
    40005cc8:	cb030042 	sub	x2, x2, x3
	entry->help  = NULL;
    40005ccc:	a9007c3f 	stp	xzr, xzr, [x1]
	entry->syntax  = NULL;

	if (idx < log_backend_count_get()) {
    40005cd0:	93459042 	sbfx	x2, x2, #5, #32
    40005cd4:	eb00005f 	cmp	x2, x0
    40005cd8:	540000a9 	b.ls	40005cec <backend_name_get+0x40>  // b.plast
		const struct log_backend *backend = log_backend_get(idx);

		entry->syntax = backend->name;
    40005cdc:	d37b7c00 	ubfiz	x0, x0, #5, #32
    40005ce0:	8b000063 	add	x3, x3, x0
    40005ce4:	f9400860 	ldr	x0, [x3, #16]
    40005ce8:	f9000020 	str	x0, [x1]
	}
}
    40005cec:	d65f03c0 	ret

0000000040005cf0 <cmd_log_memory_slabs>:
{
    40005cf0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005cf4:	910003fd 	mov	x29, sp
    40005cf8:	a90153f3 	stp	x19, x20, [sp, #16]
    40005cfc:	aa0003f3 	mov	x19, x0
	slabs_free = log_msg_mem_get_free();
    40005d00:	97fffd10 	bl	40005140 <log_msg_mem_get_free>
    40005d04:	2a0003f4 	mov	w20, w0
	used = log_msg_mem_get_used();
    40005d08:	97fffd14 	bl	40005158 <log_msg_mem_get_used>
	shell_print(sh, "Blocks used:\t%d", used);
    40005d0c:	52800101 	mov	w1, #0x8                   	// #8
    40005d10:	2a0003e3 	mov	w3, w0
    40005d14:	f0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40005d18:	91356c42 	add	x2, x2, #0xd5b
    40005d1c:	aa1303e0 	mov	x0, x19
    40005d20:	94000c31 	bl	40008de4 <shell_fprintf>
	shell_print(sh, "Blocks free:\t%d", slabs_free);
    40005d24:	2a1403e3 	mov	w3, w20
    40005d28:	aa1303e0 	mov	x0, x19
    40005d2c:	52800101 	mov	w1, #0x8                   	// #8
    40005d30:	f0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40005d34:	9135b042 	add	x2, x2, #0xd6c
    40005d38:	94000c2b 	bl	40008de4 <shell_fprintf>
		shell_print(
    40005d3c:	aa1303e0 	mov	x0, x19
    40005d40:	52800101 	mov	w1, #0x8                   	// #8
    40005d44:	f0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40005d48:	9135f442 	add	x2, x2, #0xd7d
    40005d4c:	94000c26 	bl	40008de4 <shell_fprintf>
}
    40005d50:	52800000 	mov	w0, #0x0                   	// #0
    40005d54:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005d58:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005d5c:	d65f03c0 	ret

0000000040005d60 <cmd_log_backends_list>:
{
    40005d60:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40005d64:	910003fd 	mov	x29, sp
    40005d68:	a90153f3 	stp	x19, x20, [sp, #16]
    40005d6c:	b0000073 	adrp	x19, 40012000 <__rodata_region_start>
    40005d70:	913c4273 	add	x19, x19, #0xf10
    40005d74:	b0000074 	adrp	x20, 40012000 <__rodata_region_start>
    40005d78:	913cc294 	add	x20, x20, #0xf30
    40005d7c:	cb130294 	sub	x20, x20, x19
    40005d80:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005d84:	aa0003f6 	mov	x22, x0
    40005d88:	d3459294 	ubfx	x20, x20, #5, #32
    40005d8c:	a90363f7 	stp	x23, x24, [sp, #48]
		shell_fprintf(shell, SHELL_NORMAL,
    40005d90:	f0000077 	adrp	x23, 40014000 <shell_m_sub_colors+0x50>
    40005d94:	913746f7 	add	x23, x23, #0xdd1
    40005d98:	f0000078 	adrp	x24, 40014000 <shell_m_sub_colors+0x50>
    40005d9c:	91372718 	add	x24, x24, #0xdc9
	for (int i = 0; i < backend_count; i++) {
    40005da0:	52800015 	mov	w21, #0x0                   	// #0
{
    40005da4:	f90023f9 	str	x25, [sp, #64]
		shell_fprintf(shell, SHELL_NORMAL,
    40005da8:	f0000079 	adrp	x25, 40014000 <shell_m_sub_colors+0x50>
	for (int i = 0; i < backend_count; i++) {
    40005dac:	6b1402bf 	cmp	w21, w20
    40005db0:	5400010b 	b.lt	40005dd0 <cmd_log_backends_list+0x70>  // b.tstop
}
    40005db4:	52800000 	mov	w0, #0x0                   	// #0
    40005db8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005dbc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005dc0:	a94363f7 	ldp	x23, x24, [sp, #48]
    40005dc4:	f94023f9 	ldr	x25, [sp, #64]
    40005dc8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40005dcc:	d65f03c0 	ret
		shell_fprintf(shell, SHELL_NORMAL,
    40005dd0:	a9408e60 	ldp	x0, x3, [x19, #8]
    40005dd4:	91376b22 	add	x2, x25, #0xdda
	for (int i = 0; i < backend_count; i++) {
    40005dd8:	110006b5 	add	w21, w21, #0x1
    40005ddc:	91008273 	add	x19, x19, #0x20
		shell_fprintf(shell, SHELL_NORMAL,
    40005de0:	39402401 	ldrb	w1, [x0, #9]
    40005de4:	39402005 	ldrb	w5, [x0, #8]
    40005de8:	aa1603e0 	mov	x0, x22
    40005dec:	7100003f 	cmp	w1, #0x0
    40005df0:	52800101 	mov	w1, #0x8                   	// #8
    40005df4:	9a971304 	csel	x4, x24, x23, ne  // ne = any
    40005df8:	94000bfb 	bl	40008de4 <shell_fprintf>
	for (int i = 0; i < backend_count; i++) {
    40005dfc:	17ffffec 	b	40005dac <cmd_log_backends_list+0x4c>

0000000040005e00 <log_status>:
{
    40005e00:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40005e04:	910003fd 	mov	x29, sp
    40005e08:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005e0c:	aa0103f6 	mov	x22, x1
    40005e10:	b0000061 	adrp	x1, 40012000 <__rodata_region_start>
    40005e14:	913ac021 	add	x1, x1, #0xeb0
    40005e18:	a90153f3 	stp	x19, x20, [sp, #16]
    40005e1c:	b0000074 	adrp	x20, 40012000 <__rodata_region_start>
    40005e20:	913c4294 	add	x20, x20, #0xf10
    40005e24:	a90363f7 	stp	x23, x24, [sp, #48]
    40005e28:	cb010294 	sub	x20, x20, x1
	return backend->cb->active;
    40005e2c:	f94006c1 	ldr	x1, [x22, #8]
    40005e30:	a9046bf9 	stp	x25, x26, [sp, #64]
    40005e34:	aa0003f5 	mov	x21, x0
    40005e38:	d3448e94 	ubfx	x20, x20, #4, #32
	if (!log_backend_is_active(backend)) {
    40005e3c:	39402421 	ldrb	w1, [x1, #9]
    40005e40:	350000a1 	cbnz	w1, 40005e54 <log_status+0x54>
		shell_warn(shell, "Logs are halted!");
    40005e44:	f0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40005e48:	9137ec42 	add	x2, x2, #0xdfb
    40005e4c:	52800061 	mov	w1, #0x3                   	// #3
    40005e50:	94000be5 	bl	40008de4 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
    40005e54:	f0000063 	adrp	x3, 40014000 <shell_m_sub_colors+0x50>
    40005e58:	91383463 	add	x3, x3, #0xe0d
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
    40005e5c:	d0000077 	adrp	x23, 40013000 <shell_cmd_help>
    40005e60:	911b82f7 	add	x23, x23, #0x6e0
    40005e64:	f0000078 	adrp	x24, 40014000 <shell_m_sub_colors+0x50>
    40005e68:	9139d318 	add	x24, x24, #0xe74
	for (int16_t i = 0U; i < modules_cnt; i++) {
    40005e6c:	52800013 	mov	w19, #0x0                   	// #0
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
    40005e70:	aa1503e0 	mov	x0, x21
    40005e74:	52800101 	mov	w1, #0x8                   	// #8
    40005e78:	f0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40005e7c:	91386442 	add	x2, x2, #0xe19
    40005e80:	94000bd9 	bl	40008de4 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL,
    40005e84:	aa1503e0 	mov	x0, x21
    40005e88:	f0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40005e8c:	9138dc42 	add	x2, x2, #0xe37
    40005e90:	52800101 	mov	w1, #0x8                   	// #8
    40005e94:	94000bd4 	bl	40008de4 <shell_fprintf>
	for (int16_t i = 0U; i < modules_cnt; i++) {
    40005e98:	6b14027f 	cmp	w19, w20
    40005e9c:	54000103 	b.cc	40005ebc <log_status+0xbc>  // b.lo, b.ul, b.last
}
    40005ea0:	52800000 	mov	w0, #0x0                   	// #0
    40005ea4:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005ea8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005eac:	a94363f7 	ldp	x23, x24, [sp, #48]
    40005eb0:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40005eb4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40005eb8:	d65f03c0 	ret
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
    40005ebc:	2a1303e2 	mov	w2, w19
    40005ec0:	52800023 	mov	w3, #0x1                   	// #1
    40005ec4:	52800001 	mov	w1, #0x0                   	// #0
    40005ec8:	aa1603e0 	mov	x0, x22
    40005ecc:	97fffb9a 	bl	40004d34 <log_filter_get>
    40005ed0:	2a0003f9 	mov	w25, w0
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
    40005ed4:	2a1303e2 	mov	w2, w19
    40005ed8:	52800003 	mov	w3, #0x0                   	// #0
    40005edc:	52800001 	mov	w1, #0x0                   	// #0
    40005ee0:	aa1603e0 	mov	x0, x22
    40005ee4:	97fffb94 	bl	40004d34 <log_filter_get>
    40005ee8:	2a0003fa 	mov	w26, w0
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
    40005eec:	2a1303e1 	mov	w1, w19
    40005ef0:	52800000 	mov	w0, #0x0                   	// #0
    40005ef4:	97fffb0f 	bl	40004b30 <log_source_name_get>
	for (int16_t i = 0U; i < modules_cnt; i++) {
    40005ef8:	11000673 	add	w19, w19, #0x1
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
    40005efc:	f87a5ae5 	ldr	x5, [x23, w26, uxtw #3]
    40005f00:	aa0003e3 	mov	x3, x0
    40005f04:	f8795ae4 	ldr	x4, [x23, w25, uxtw #3]
    40005f08:	aa1803e2 	mov	x2, x24
    40005f0c:	aa1503e0 	mov	x0, x21
    40005f10:	52800101 	mov	w1, #0x8                   	// #8
	for (int16_t i = 0U; i < modules_cnt; i++) {
    40005f14:	13003e73 	sxth	w19, w19
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
    40005f18:	94000bb3 	bl	40008de4 <shell_fprintf>
	for (int16_t i = 0U; i < modules_cnt; i++) {
    40005f1c:	17ffffdf 	b	40005e98 <log_status+0x98>

0000000040005f20 <module_name_get>:
{
    40005f20:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005f24:	910003fd 	mov	x29, sp
    40005f28:	f9000bf3 	str	x19, [sp, #16]
    40005f2c:	aa0103f3 	mov	x19, x1
	entry->subcmd = &dsub_module_name;
    40005f30:	d0000061 	adrp	x1, 40013000 <shell_cmd_help>
    40005f34:	911b0021 	add	x1, x1, #0x6c0
    40005f38:	a900867f 	stp	xzr, x1, [x19, #8]
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
    40005f3c:	2a0003e1 	mov	w1, w0
    40005f40:	52800000 	mov	w0, #0x0                   	// #0
	entry->handler = NULL;
    40005f44:	f9000e7f 	str	xzr, [x19, #24]
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
    40005f48:	97fffafa 	bl	40004b30 <log_source_name_get>
    40005f4c:	f9000260 	str	x0, [x19]
}
    40005f50:	f9400bf3 	ldr	x19, [sp, #16]
    40005f54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005f58:	d65f03c0 	ret

0000000040005f5c <shell_backend_cmd_execute>:
{
    40005f5c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40005f60:	910003fd 	mov	x29, sp
    40005f64:	a90573fb 	stp	x27, x28, [sp, #80]
	char const *name = argv[-1];
    40005f68:	f85f805b 	ldur	x27, [x2, #-8]
{
    40005f6c:	a90153f3 	stp	x19, x20, [sp, #16]
	return __log_backends_end - __log_backends_start;
    40005f70:	b0000073 	adrp	x19, 40012000 <__rodata_region_start>
    40005f74:	913cc273 	add	x19, x19, #0xf30
    40005f78:	a9046bf9 	stp	x25, x26, [sp, #64]
    40005f7c:	b0000079 	adrp	x25, 40012000 <__rodata_region_start>
    40005f80:	913c4339 	add	x25, x25, #0xf10
    40005f84:	aa0003fa 	mov	x26, x0
    40005f88:	cb190273 	sub	x19, x19, x25
	size_t slen = strlen(name);
    40005f8c:	aa1b03e0 	mov	x0, x27
{
    40005f90:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005f94:	aa0203f6 	mov	x22, x2
    40005f98:	d3459273 	ubfx	x19, x19, #5, #32
    40005f9c:	a90363f7 	stp	x23, x24, [sp, #48]
    40005fa0:	aa0303f8 	mov	x24, x3
    40005fa4:	aa0103f7 	mov	x23, x1
	size_t slen = strlen(name);
    40005fa8:	94001c98 	bl	4000d208 <strlen>
    40005fac:	aa0003fc 	mov	x28, x0
	for (int i = 0; i < log_backend_count_get(); i++) {
    40005fb0:	aa1903e3 	mov	x3, x25
    40005fb4:	52800014 	mov	w20, #0x0                   	// #0
    40005fb8:	6b13029f 	cmp	w20, w19
    40005fbc:	5400012b 	b.lt	40005fe0 <shell_backend_cmd_execute+0x84>  // b.tstop
		shell_error(shell, "Invalid backend: %s", name);
    40005fc0:	aa1b03e3 	mov	x3, x27
    40005fc4:	aa1a03e0 	mov	x0, x26
    40005fc8:	f0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40005fcc:	913a2042 	add	x2, x2, #0xe88
    40005fd0:	52800021 	mov	w1, #0x1                   	// #1
		return -ENOEXEC;
    40005fd4:	128000f5 	mov	w21, #0xfffffff8            	// #-8
		shell_error(shell, "Invalid backend: %s", name);
    40005fd8:	94000b83 	bl	40008de4 <shell_fprintf>
		return -ENOEXEC;
    40005fdc:	14000010 	b	4000601c <shell_backend_cmd_execute+0xc0>
		if (strncmp(name, backend->name, slen) == 0) {
    40005fe0:	f9400861 	ldr	x1, [x3, #16]
    40005fe4:	aa1c03e2 	mov	x2, x28
    40005fe8:	aa1b03e0 	mov	x0, x27
    40005fec:	f90037e3 	str	x3, [sp, #104]
    40005ff0:	94001c9f 	bl	4000d26c <strncmp>
    40005ff4:	2a0003f5 	mov	w21, w0
    40005ff8:	f94037e3 	ldr	x3, [sp, #104]
    40005ffc:	91008063 	add	x3, x3, #0x20
    40006000:	350001e0 	cbnz	w0, 4000603c <shell_backend_cmd_execute+0xe0>
	return &__log_backends_start[idx];
    40006004:	d37b7e94 	ubfiz	x20, x20, #5, #32
		func(shell, backend, argc, argv);
    40006008:	aa1603e3 	mov	x3, x22
    4000600c:	aa1703e2 	mov	x2, x23
    40006010:	8b140321 	add	x1, x25, x20
    40006014:	aa1a03e0 	mov	x0, x26
    40006018:	d63f0300 	blr	x24
}
    4000601c:	2a1503e0 	mov	w0, w21
    40006020:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006024:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006028:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000602c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40006030:	a94573fb 	ldp	x27, x28, [sp, #80]
    40006034:	a8c77bfd 	ldp	x29, x30, [sp], #112
    40006038:	d65f03c0 	ret
	for (int i = 0; i < log_backend_count_get(); i++) {
    4000603c:	11000694 	add	w20, w20, #0x1
    40006040:	17ffffde 	b	40005fb8 <shell_backend_cmd_execute+0x5c>

0000000040006044 <cmd_log_backend_status>:
{
    40006044:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_backend_cmd_execute(shell, argc, argv, log_status);
    40006048:	f0ffffe3 	adrp	x3, 40005000 <log_msg_arg_get+0x5c>
    4000604c:	91380063 	add	x3, x3, #0xe00
{
    40006050:	910003fd 	mov	x29, sp
	shell_backend_cmd_execute(shell, argc, argv, log_status);
    40006054:	97ffffc2 	bl	40005f5c <shell_backend_cmd_execute>
}
    40006058:	52800000 	mov	w0, #0x0                   	// #0
    4000605c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40006060:	d65f03c0 	ret

0000000040006064 <cmd_log_backend_halt>:
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
    40006064:	f0ffffe3 	adrp	x3, 40005000 <log_msg_arg_get+0x5c>
    40006068:	91322063 	add	x3, x3, #0xc88
    4000606c:	17ffffbc 	b	40005f5c <shell_backend_cmd_execute>

0000000040006070 <cmd_log_backend_go>:
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
    40006070:	f0ffffe3 	adrp	x3, 40005000 <log_msg_arg_get+0x5c>
    40006074:	91326063 	add	x3, x3, #0xc98
    40006078:	17ffffb9 	b	40005f5c <shell_backend_cmd_execute>

000000004000607c <cmd_log_backend_enable>:
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
    4000607c:	90000003 	adrp	x3, 40006000 <shell_backend_cmd_execute+0xa4>
    40006080:	910a6063 	add	x3, x3, #0x298
    40006084:	17ffffb6 	b	40005f5c <shell_backend_cmd_execute>

0000000040006088 <cmd_log_backend_disable>:
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
    40006088:	90000003 	adrp	x3, 40006000 <shell_backend_cmd_execute+0xa4>
    4000608c:	910ea063 	add	x3, x3, #0x3a8
    40006090:	17ffffb3 	b	40005f5c <shell_backend_cmd_execute>

0000000040006094 <shell_state_precheck>:
	if (shell->log_backend->control_block->state
    40006094:	f9401c01 	ldr	x1, [x0, #56]
    40006098:	f9400c21 	ldr	x1, [x1, #24]
    4000609c:	b9400821 	ldr	w1, [x1, #8]
    400060a0:	35000141 	cbnz	w1, 400060c8 <shell_state_precheck+0x34>
{
    400060a4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		shell_error(shell, "Shell log backend not initialized.");
    400060a8:	52800021 	mov	w1, #0x1                   	// #1
    400060ac:	d0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    400060b0:	913a7442 	add	x2, x2, #0xe9d
{
    400060b4:	910003fd 	mov	x29, sp
		shell_error(shell, "Shell log backend not initialized.");
    400060b8:	94000b4b 	bl	40008de4 <shell_fprintf>
    400060bc:	52800000 	mov	w0, #0x0                   	// #0
}
    400060c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400060c4:	d65f03c0 	ret
	return true;
    400060c8:	52800020 	mov	w0, #0x1                   	// #1
}
    400060cc:	d65f03c0 	ret

00000000400060d0 <cmd_log_self_status>:
{
    400060d0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400060d4:	910003fd 	mov	x29, sp
    400060d8:	a90153f3 	stp	x19, x20, [sp, #16]
    400060dc:	aa0003f3 	mov	x19, x0
    400060e0:	aa0103f4 	mov	x20, x1
    400060e4:	f90013f5 	str	x21, [sp, #32]
    400060e8:	aa0203f5 	mov	x21, x2
	if (!shell_state_precheck(shell)) {
    400060ec:	97ffffea 	bl	40006094 <shell_state_precheck>
    400060f0:	72001c1f 	tst	w0, #0xff
    400060f4:	540000e0 	b.eq	40006110 <cmd_log_self_status+0x40>  // b.none
	log_status(shell, shell->log_backend->backend, argc, argv);
    400060f8:	f9401e60 	ldr	x0, [x19, #56]
    400060fc:	aa1503e3 	mov	x3, x21
    40006100:	aa1403e2 	mov	x2, x20
    40006104:	f9400001 	ldr	x1, [x0]
    40006108:	aa1303e0 	mov	x0, x19
    4000610c:	97ffff3d 	bl	40005e00 <log_status>
}
    40006110:	52800000 	mov	w0, #0x0                   	// #0
    40006114:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006118:	f94013f5 	ldr	x21, [sp, #32]
    4000611c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40006120:	d65f03c0 	ret

0000000040006124 <filters_set>:
{
    40006124:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	int cnt = all ? z_log_sources_count() : argc;
    40006128:	f100005f 	cmp	x2, #0x0
{
    4000612c:	910003fd 	mov	x29, sp
    40006130:	a90153f3 	stp	x19, x20, [sp, #16]
    40006134:	90000073 	adrp	x19, 40012000 <__rodata_region_start>
    40006138:	913c4273 	add	x19, x19, #0xf10
    4000613c:	a90363f7 	stp	x23, x24, [sp, #48]
    40006140:	aa0103f7 	mov	x23, x1
    40006144:	90000061 	adrp	x1, 40012000 <__rodata_region_start>
    40006148:	913ac021 	add	x1, x1, #0xeb0
    4000614c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40006150:	cb010273 	sub	x19, x19, x1
    40006154:	a9046bf9 	stp	x25, x26, [sp, #64]
    40006158:	aa0003f6 	mov	x22, x0
    4000615c:	d344fe73 	lsr	x19, x19, #4
	int cnt = all ? z_log_sources_count() : argc;
    40006160:	1a931041 	csel	w1, w2, w19, ne  // ne = any
    40006164:	b90067e1 	str	w1, [sp, #100]
	if (!backend->cb->active) {
    40006168:	f94006e1 	ldr	x1, [x23, #8]
{
    4000616c:	a90573fb 	stp	x27, x28, [sp, #80]
    40006170:	aa0203f4 	mov	x20, x2
    40006174:	aa0303f5 	mov	x21, x3
    40006178:	2a0403f8 	mov	w24, w4
	if (!backend->cb->active) {
    4000617c:	39402421 	ldrb	w1, [x1, #9]
    40006180:	350000a1 	cbnz	w1, 40006194 <filters_set+0x70>
		shell_warn(shell, "Backend not active.");
    40006184:	d0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40006188:	913b0442 	add	x2, x2, #0xec1
    4000618c:	52800061 	mov	w1, #0x3                   	// #3
    40006190:	94000b15 	bl	40008de4 <shell_fprintf>
				shell_warn(shell, "%s: level set to %s.",
    40006194:	b0000079 	adrp	x25, 40013000 <shell_cmd_help>
    40006198:	911b8339 	add	x25, x25, #0x6e0
    4000619c:	d000007a 	adrp	x26, 40014000 <shell_m_sub_colors+0x50>
    400061a0:	913b5b5a 	add	x26, x26, #0xed6
    400061a4:	b9006bf3 	str	w19, [sp, #104]
    400061a8:	d2800013 	mov	x19, #0x0                   	// #0
	for (i = 0; i < cnt; i++) {
    400061ac:	b94067e0 	ldr	w0, [sp, #100]
    400061b0:	2a1303fb 	mov	w27, w19
    400061b4:	2a1303e2 	mov	w2, w19
    400061b8:	6b13001f 	cmp	w0, w19
    400061bc:	5400010c 	b.gt	400061dc <filters_set+0xb8>
}
    400061c0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400061c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400061c8:	a94363f7 	ldp	x23, x24, [sp, #48]
    400061cc:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400061d0:	a94573fb 	ldp	x27, x28, [sp, #80]
    400061d4:	a8c77bfd 	ldp	x29, x30, [sp], #112
    400061d8:	d65f03c0 	ret
		id = all ? i : module_id_get(argv[i]);
    400061dc:	b4000314 	cbz	x20, 4000623c <filters_set+0x118>
    400061e0:	f8737abc 	ldr	x28, [x21, x19, lsl #3]
	for (i = 0U; i < modules_cnt; i++) {
    400061e4:	52800003 	mov	w3, #0x0                   	// #0
    400061e8:	b9406be0 	ldr	w0, [sp, #104]
    400061ec:	6b03001f 	cmp	w0, w3
    400061f0:	54000101 	b.ne	40006210 <filters_set+0xec>  // b.any
			shell_error(shell, "%s: unknown source name.", argv[i]);
    400061f4:	f8737aa3 	ldr	x3, [x21, x19, lsl #3]
    400061f8:	aa1603e0 	mov	x0, x22
    400061fc:	d0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40006200:	913bb042 	add	x2, x2, #0xeec
    40006204:	52800021 	mov	w1, #0x1                   	// #1
    40006208:	94000af7 	bl	40008de4 <shell_fprintf>
    4000620c:	1400001d 	b	40006280 <filters_set+0x15c>
		tmp_name = log_source_name_get(CONFIG_LOG_DOMAIN_ID, i);
    40006210:	2a0303e1 	mov	w1, w3
    40006214:	52800000 	mov	w0, #0x0                   	// #0
    40006218:	b9006fe3 	str	w3, [sp, #108]
    4000621c:	97fffa45 	bl	40004b30 <log_source_name_get>
		if (strncmp(tmp_name, name, 64) == 0) {
    40006220:	aa1c03e1 	mov	x1, x28
    40006224:	d2800802 	mov	x2, #0x40                  	// #64
    40006228:	94001c11 	bl	4000d26c <strncmp>
    4000622c:	b9406fe3 	ldr	w3, [sp, #108]
    40006230:	350002c0 	cbnz	w0, 40006288 <filters_set+0x164>
			return i;
    40006234:	2a0303e2 	mov	w2, w3
		if (id >= 0) {
    40006238:	37fffde3 	tbnz	w3, #31, 400061f4 <filters_set+0xd0>
	return z_impl_log_filter_set(backend, domain_id, source_id, level);
    4000623c:	52800001 	mov	w1, #0x0                   	// #0
    40006240:	2a1803e3 	mov	w3, w24
    40006244:	aa1703e0 	mov	x0, x23
    40006248:	97fffa47 	bl	40004b64 <z_impl_log_filter_set>
    4000624c:	2a0003fc 	mov	w28, w0
			if (set_lvl != level) {
    40006250:	6b00031f 	cmp	w24, w0
    40006254:	54000160 	b.eq	40006280 <filters_set+0x15c>  // b.none
						CONFIG_LOG_DOMAIN_ID, i) :
    40006258:	b50001d4 	cbnz	x20, 40006290 <filters_set+0x16c>
					log_source_name_get(
    4000625c:	2a1b03e1 	mov	w1, w27
    40006260:	52800000 	mov	w0, #0x0                   	// #0
    40006264:	97fffa33 	bl	40004b30 <log_source_name_get>
    40006268:	aa0003e3 	mov	x3, x0
				shell_warn(shell, "%s: level set to %s.",
    4000626c:	f87c5b24 	ldr	x4, [x25, w28, uxtw #3]
    40006270:	aa1a03e2 	mov	x2, x26
    40006274:	aa1603e0 	mov	x0, x22
    40006278:	52800061 	mov	w1, #0x3                   	// #3
    4000627c:	94000ada 	bl	40008de4 <shell_fprintf>
	for (i = 0; i < cnt; i++) {
    40006280:	91000673 	add	x19, x19, #0x1
    40006284:	17ffffca 	b	400061ac <filters_set+0x88>
	for (i = 0U; i < modules_cnt; i++) {
    40006288:	11000463 	add	w3, w3, #0x1
    4000628c:	17ffffd7 	b	400061e8 <filters_set+0xc4>
						CONFIG_LOG_DOMAIN_ID, i) :
    40006290:	f8737aa3 	ldr	x3, [x21, x19, lsl #3]
    40006294:	17fffff6 	b	4000626c <filters_set+0x148>

0000000040006298 <log_enable>:
{
    40006298:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000629c:	910003fd 	mov	x29, sp
    400062a0:	a9046bf9 	stp	x25, x26, [sp, #64]
		if (strncmp(str, severity_lvls[i], 4) == 0) {
    400062a4:	b0000079 	adrp	x25, 40013000 <shell_cmd_help>
    400062a8:	911b8339 	add	x25, x25, #0x6e0
	severity_level = severity_level_get(argv[1]);
    400062ac:	f940047a 	ldr	x26, [x3, #8]
{
    400062b0:	a90153f3 	stp	x19, x20, [sp, #16]
    400062b4:	aa0303f4 	mov	x20, x3
    400062b8:	a9025bf5 	stp	x21, x22, [sp, #32]
    400062bc:	aa0003f6 	mov	x22, x0
	severity_level = severity_level_get(argv[1]);
    400062c0:	d2800015 	mov	x21, #0x0                   	// #0
{
    400062c4:	a90363f7 	stp	x23, x24, [sp, #48]
    400062c8:	aa0103f7 	mov	x23, x1
    400062cc:	aa0203f8 	mov	x24, x2
		if (strncmp(str, severity_lvls[i], 4) == 0) {
    400062d0:	f8757b21 	ldr	x1, [x25, x21, lsl #3]
    400062d4:	aa1a03e0 	mov	x0, x26
    400062d8:	d2800082 	mov	x2, #0x4                   	// #4
    400062dc:	94001be4 	bl	4000d26c <strncmp>
    400062e0:	2a0003f3 	mov	w19, w0
    400062e4:	34000240 	cbz	w0, 4000632c <log_enable+0x94>
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
    400062e8:	910006b5 	add	x21, x21, #0x1
    400062ec:	f10016bf 	cmp	x21, #0x5
    400062f0:	54ffff01 	b.ne	400062d0 <log_enable+0x38>  // b.any
		shell_error(shell, "Invalid severity: %s", argv[1]);
    400062f4:	f9400683 	ldr	x3, [x20, #8]
    400062f8:	d0000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    400062fc:	913c1842 	add	x2, x2, #0xf06
    40006300:	aa1603e0 	mov	x0, x22
    40006304:	52800021 	mov	w1, #0x1                   	// #1
    40006308:	128000f3 	mov	w19, #0xfffffff8            	// #-8
    4000630c:	94000ab6 	bl	40008de4 <shell_fprintf>
}
    40006310:	2a1303e0 	mov	w0, w19
    40006314:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006318:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000631c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40006320:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40006324:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40006328:	d65f03c0 	ret
	filters_set(shell, backend, argc - 2, &argv[2], severity_level);
    4000632c:	2a1503e4 	mov	w4, w21
    40006330:	91004283 	add	x3, x20, #0x10
    40006334:	d1000b02 	sub	x2, x24, #0x2
    40006338:	aa1703e1 	mov	x1, x23
    4000633c:	aa1603e0 	mov	x0, x22
    40006340:	97ffff79 	bl	40006124 <filters_set>
	return 0;
    40006344:	17fffff3 	b	40006310 <log_enable+0x78>

0000000040006348 <cmd_log_self_enable>:
{
    40006348:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000634c:	910003fd 	mov	x29, sp
    40006350:	a90153f3 	stp	x19, x20, [sp, #16]
    40006354:	aa0003f3 	mov	x19, x0
    40006358:	aa0103f4 	mov	x20, x1
    4000635c:	f90013f5 	str	x21, [sp, #32]
    40006360:	aa0203f5 	mov	x21, x2
	if (!shell_state_precheck(shell)) {
    40006364:	97ffff4c 	bl	40006094 <shell_state_precheck>
    40006368:	72001c1f 	tst	w0, #0xff
    4000636c:	54000140 	b.eq	40006394 <cmd_log_self_enable+0x4c>  // b.none
	return log_enable(shell, shell->log_backend->backend, argc, argv);
    40006370:	f9401e60 	ldr	x0, [x19, #56]
    40006374:	aa1503e3 	mov	x3, x21
    40006378:	aa1403e2 	mov	x2, x20
}
    4000637c:	f94013f5 	ldr	x21, [sp, #32]
	return log_enable(shell, shell->log_backend->backend, argc, argv);
    40006380:	f9400001 	ldr	x1, [x0]
    40006384:	aa1303e0 	mov	x0, x19
}
    40006388:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000638c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return log_enable(shell, shell->log_backend->backend, argc, argv);
    40006390:	17ffffc2 	b	40006298 <log_enable>
}
    40006394:	52800000 	mov	w0, #0x0                   	// #0
    40006398:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000639c:	f94013f5 	ldr	x21, [sp, #32]
    400063a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400063a4:	d65f03c0 	ret

00000000400063a8 <log_disable>:
{
    400063a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	filters_set(shell, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
    400063ac:	91002063 	add	x3, x3, #0x8
    400063b0:	d1000442 	sub	x2, x2, #0x1
{
    400063b4:	910003fd 	mov	x29, sp
	filters_set(shell, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
    400063b8:	52800004 	mov	w4, #0x0                   	// #0
    400063bc:	97ffff5a 	bl	40006124 <filters_set>
}
    400063c0:	52800000 	mov	w0, #0x0                   	// #0
    400063c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400063c8:	d65f03c0 	ret

00000000400063cc <cmd_log_self_disable>:
{
    400063cc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400063d0:	910003fd 	mov	x29, sp
    400063d4:	a90153f3 	stp	x19, x20, [sp, #16]
    400063d8:	aa0003f3 	mov	x19, x0
    400063dc:	aa0103f4 	mov	x20, x1
    400063e0:	f90013f5 	str	x21, [sp, #32]
    400063e4:	aa0203f5 	mov	x21, x2
	if (!shell_state_precheck(shell)) {
    400063e8:	97ffff2b 	bl	40006094 <shell_state_precheck>
    400063ec:	72001c1f 	tst	w0, #0xff
    400063f0:	54000140 	b.eq	40006418 <cmd_log_self_disable+0x4c>  // b.none
	return log_disable(shell, shell->log_backend->backend, argc, argv);
    400063f4:	f9401e60 	ldr	x0, [x19, #56]
    400063f8:	aa1503e3 	mov	x3, x21
    400063fc:	aa1403e2 	mov	x2, x20
}
    40006400:	f94013f5 	ldr	x21, [sp, #32]
	return log_disable(shell, shell->log_backend->backend, argc, argv);
    40006404:	f9400001 	ldr	x1, [x0]
    40006408:	aa1303e0 	mov	x0, x19
}
    4000640c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006410:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return log_disable(shell, shell->log_backend->backend, argc, argv);
    40006414:	17ffffe5 	b	400063a8 <log_disable>
}
    40006418:	52800000 	mov	w0, #0x0                   	// #0
    4000641c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006420:	f94013f5 	ldr	x21, [sp, #32]
    40006424:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40006428:	d65f03c0 	ret

000000004000642c <cmd_log_self_go>:
{
    4000642c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40006430:	910003fd 	mov	x29, sp
    40006434:	f9000bf3 	str	x19, [sp, #16]
    40006438:	aa0003f3 	mov	x19, x0
	if (!shell_state_precheck(shell)) {
    4000643c:	97ffff16 	bl	40006094 <shell_state_precheck>
    40006440:	72001c1f 	tst	w0, #0xff
    40006444:	540000c0 	b.eq	4000645c <cmd_log_self_go+0x30>  // b.none
	return log_go(shell, shell->log_backend->backend, argc, argv);
    40006448:	f9401e60 	ldr	x0, [x19, #56]
	backend->cb->active = true;
    4000644c:	52800021 	mov	w1, #0x1                   	// #1
	log_backend_activate(backend, backend->cb->ctx);
    40006450:	f9400000 	ldr	x0, [x0]
    40006454:	f9400400 	ldr	x0, [x0, #8]
    40006458:	39002401 	strb	w1, [x0, #9]
}
    4000645c:	52800000 	mov	w0, #0x0                   	// #0
    40006460:	f9400bf3 	ldr	x19, [sp, #16]
    40006464:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40006468:	d65f03c0 	ret

000000004000646c <cmd_log_self_halt>:
{
    4000646c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40006470:	910003fd 	mov	x29, sp
    40006474:	f9000bf3 	str	x19, [sp, #16]
    40006478:	aa0003f3 	mov	x19, x0
	if (!shell_state_precheck(shell)) {
    4000647c:	97ffff06 	bl	40006094 <shell_state_precheck>
    40006480:	72001c1f 	tst	w0, #0xff
    40006484:	540000a0 	b.eq	40006498 <cmd_log_self_halt+0x2c>  // b.none
	return log_halt(shell, shell->log_backend->backend, argc, argv);
    40006488:	f9401e60 	ldr	x0, [x19, #56]
	backend->cb->active = false;
    4000648c:	f9400000 	ldr	x0, [x0]
    40006490:	f9400400 	ldr	x0, [x0, #8]
    40006494:	3900241f 	strb	wzr, [x0, #9]
}
    40006498:	52800000 	mov	w0, #0x0                   	// #0
    4000649c:	f9400bf3 	ldr	x19, [sp, #16]
    400064a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400064a4:	d65f03c0 	ret

00000000400064a8 <cmd_kernel_version>:
#include <drivers/timer/system_timer.h>
#include <kernel.h>

static int cmd_kernel_version(const struct shell *shell,
			      size_t argc, char **argv)
{
    400064a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400064ac:	910003fd 	mov	x29, sp
    400064b0:	f9000bf3 	str	x19, [sp, #16]
    400064b4:	aa0003f3 	mov	x19, x0
	uint32_t version = sys_kernel_version_get();
    400064b8:	9400224d 	bl	4000edec <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Zephyr version %d.%d.%d",
    400064bc:	d3483c05 	ubfx	x5, x0, #8, #8
    400064c0:	d3505c04 	ubfx	x4, x0, #16, #8
    400064c4:	53187c03 	lsr	w3, w0, #24
    400064c8:	52800101 	mov	w1, #0x8                   	// #8
    400064cc:	aa1303e0 	mov	x0, x19
    400064d0:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400064d4:	91030442 	add	x2, x2, #0xc1
    400064d8:	94000a43 	bl	40008de4 <shell_fprintf>
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
    400064dc:	52800000 	mov	w0, #0x0                   	// #0
    400064e0:	f9400bf3 	ldr	x19, [sp, #16]
    400064e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400064e8:	d65f03c0 	ret

00000000400064ec <cmd_kernel_uptime>:

static int cmd_kernel_uptime(const struct shell *shell,
			     size_t argc, char **argv)
{
    400064ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400064f0:	910003fd 	mov	x29, sp
    400064f4:	f9000bf3 	str	x19, [sp, #16]
    400064f8:	aa0003f3 	mov	x19, x0
	return z_impl_k_uptime_ticks();
    400064fc:	94002972 	bl	40010ac4 <z_impl_k_uptime_ticks>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Uptime: %u ms", k_uptime_get_32());
    40006500:	d2800143 	mov	x3, #0xa                   	// #10
    40006504:	52800101 	mov	w1, #0x8                   	// #8
    40006508:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000650c:	91036842 	add	x2, x2, #0xda
    40006510:	1b037c03 	mul	w3, w0, w3
    40006514:	aa1303e0 	mov	x0, x19
    40006518:	94000a33 	bl	40008de4 <shell_fprintf>
	return 0;
}
    4000651c:	52800000 	mov	w0, #0x0                   	// #0
    40006520:	f9400bf3 	ldr	x19, [sp, #16]
    40006524:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40006528:	d65f03c0 	ret

000000004000652c <cmd_kernel_threads>:

}

static int cmd_kernel_threads(const struct shell *shell,
			      size_t argc, char **argv)
{
    4000652c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40006530:	910003fd 	mov	x29, sp
    40006534:	f9000bf3 	str	x19, [sp, #16]
    40006538:	aa0003f3 	mov	x19, x0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Scheduler: %u since last call", sys_clock_elapsed());
    4000653c:	94001f15 	bl	4000e190 <sys_clock_elapsed>
    40006540:	2a0003e3 	mov	w3, w0
    40006544:	52800101 	mov	w1, #0x8                   	// #8
    40006548:	aa1303e0 	mov	x0, x19
    4000654c:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006550:	9103a442 	add	x2, x2, #0xe9
    40006554:	94000a24 	bl	40008de4 <shell_fprintf>
	shell_print(shell, "Threads:");
    40006558:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000655c:	91042042 	add	x2, x2, #0x108
    40006560:	aa1303e0 	mov	x0, x19
    40006564:	52800101 	mov	w1, #0x8                   	// #8
    40006568:	94000a1f 	bl	40008de4 <shell_fprintf>
	k_thread_foreach(shell_tdata_dump, (void *)shell);
    4000656c:	aa1303e1 	mov	x1, x19
    40006570:	90000000 	adrp	x0, 40006000 <shell_backend_cmd_execute+0xa4>
    40006574:	91186000 	add	x0, x0, #0x618
    40006578:	940020f1 	bl	4000e93c <k_thread_foreach>
	return 0;
}
    4000657c:	52800000 	mov	w0, #0x0                   	// #0
    40006580:	f9400bf3 	ldr	x19, [sp, #16]
    40006584:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40006588:	d65f03c0 	ret

000000004000658c <cmd_kernel_stacks>:
extern K_KERNEL_STACK_ARRAY_DEFINE(z_interrupt_stacks, CONFIG_MP_NUM_CPUS,
				   CONFIG_ISR_STACK_SIZE);

static int cmd_kernel_stacks(const struct shell *shell,
			     size_t argc, char **argv)
{
    4000658c:	d100c3ff 	sub	sp, sp, #0x30
	uint8_t *buf;
	size_t size, unused;

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	k_thread_foreach(shell_stack_dump, (void *)shell);
    40006590:	aa0003e1 	mov	x1, x0
{
    40006594:	a9017bfd 	stp	x29, x30, [sp, #16]
    40006598:	910043fd 	add	x29, sp, #0x10
    4000659c:	f90013f3 	str	x19, [sp, #32]
    400065a0:	aa0003f3 	mov	x19, x0
	k_thread_foreach(shell_stack_dump, (void *)shell);
    400065a4:	90000000 	adrp	x0, 40006000 <shell_backend_cmd_execute+0xa4>
    400065a8:	911f2000 	add	x0, x0, #0x7c8
    400065ac:	940020e4 	bl	4000e93c <k_thread_foreach>
		buf = Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]);
		size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]);

		unused = 0;
		for (size_t i = 0; i < size; i++) {
			if (buf[i] == 0xAAU) {
    400065b0:	f0000323 	adrp	x3, 4006d000 <z_idle_stacks+0xc10>
    400065b4:	910fc063 	add	x3, x3, #0x3f0
		unused = 0;
    400065b8:	d2800006 	mov	x6, #0x0                   	// #0
			if (buf[i] == 0xAAU) {
    400065bc:	386368c0 	ldrb	w0, [x6, x3]
    400065c0:	7102a81f 	cmp	w0, #0xaa
    400065c4:	54000081 	b.ne	400065d4 <cmd_kernel_stacks+0x48>  // b.any
				unused++;
    400065c8:	910004c6 	add	x6, x6, #0x1
		for (size_t i = 0; i < size; i++) {
    400065cc:	f14004df 	cmp	x6, #0x1, lsl #12
    400065d0:	54ffff61 	b.ne	400065bc <cmd_kernel_stacks+0x30>  // b.any
			} else {
				break;
			}
		}

		shell_print(shell,
    400065d4:	d2820005 	mov	x5, #0x1000                	// #4096
    400065d8:	cb0600a7 	sub	x7, x5, x6
    400065dc:	d2800c82 	mov	x2, #0x64                  	// #100
    400065e0:	aa1303e0 	mov	x0, x19
    400065e4:	52800004 	mov	w4, #0x0                   	// #0
    400065e8:	52800101 	mov	w1, #0x8                   	// #8
    400065ec:	9b027ce2 	mul	x2, x7, x2
    400065f0:	d34cfc42 	lsr	x2, x2, #12
    400065f4:	a9000be5 	stp	x5, x2, [sp]
    400065f8:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400065fc:	91044842 	add	x2, x2, #0x112
    40006600:	940009f9 	bl	40008de4 <shell_fprintf>
			      size - unused, size,
			      ((size - unused) * 100U) / size);
	}

	return 0;
}
    40006604:	52800000 	mov	w0, #0x0                   	// #0
    40006608:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000660c:	f94013f3 	ldr	x19, [sp, #32]
    40006610:	9100c3ff 	add	sp, sp, #0x30
    40006614:	d65f03c0 	ret

0000000040006618 <shell_tdata_dump>:
{
    40006618:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000661c:	910003fd 	mov	x29, sp
    40006620:	a90153f3 	stp	x19, x20, [sp, #16]
    40006624:	aa0003f3 	mov	x19, x0
    40006628:	aa0103f4 	mov	x20, x1
    4000662c:	a9025bf5 	stp	x21, x22, [sp, #32]
	size_t size = thread->stack_info.size;
    40006630:	f9409816 	ldr	x22, [x0, #304]
	tname = k_thread_name_get(thread);
    40006634:	94002102 	bl	4000ea3c <k_thread_name_get>
    40006638:	aa0003f5 	mov	x21, x0
	return z_impl_z_current_get();
    4000663c:	9400263a 	bl	4000ff24 <z_impl_z_current_get>
	shell_print(shell, "%s%p %-10s",
    40006640:	eb00027f 	cmp	x19, x0
    40006644:	d0000063 	adrp	x3, 40014000 <shell_m_sub_colors+0x50>
    40006648:	f0000061 	adrp	x1, 40015000 <prefix.1+0x2aa>
    4000664c:	91337c60 	add	x0, x3, #0xcdf
    40006650:	91056023 	add	x3, x1, #0x158
    40006654:	9a800063 	csel	x3, x3, x0, eq  // eq = none
    40006658:	b5000075 	cbnz	x21, 40006664 <shell_tdata_dump+0x4c>
    4000665c:	f0000075 	adrp	x21, 40015000 <prefix.1+0x2aa>
    40006660:	91056ab5 	add	x21, x21, #0x15a
    40006664:	aa1503e5 	mov	x5, x21
    40006668:	aa1303e4 	mov	x4, x19
    4000666c:	aa1403e0 	mov	x0, x20
    40006670:	52800101 	mov	w1, #0x8                   	// #8
    40006674:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006678:	91057442 	add	x2, x2, #0x15d
    4000667c:	940009da 	bl	40008de4 <shell_fprintf>
	shell_print(shell, "\toptions: 0x%x, priority: %d timeout: %" PRId64,
    40006680:	39c06a64 	ldrsb	w4, [x19, #26]
    40006684:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006688:	9105a442 	add	x2, x2, #0x169
    4000668c:	39406263 	ldrb	w3, [x19, #24]
    40006690:	f9402265 	ldr	x5, [x19, #64]
    40006694:	52800101 	mov	w1, #0x8                   	// #8
    40006698:	aa1403e0 	mov	x0, x20
    4000669c:	940009d2 	bl	40008de4 <shell_fprintf>
	shell_print(shell, "\tstate: %s, entry: %p", k_thread_state_str(thread),
    400066a0:	aa1303e0 	mov	x0, x19
    400066a4:	940020e8 	bl	4000ea44 <k_thread_state_str>
    400066a8:	f9406e64 	ldr	x4, [x19, #216]
    400066ac:	aa0003e3 	mov	x3, x0
    400066b0:	52800101 	mov	w1, #0x8                   	// #8
    400066b4:	aa1403e0 	mov	x0, x20
    400066b8:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400066bc:	91065442 	add	x2, x2, #0x195
    400066c0:	940009c9 	bl	40008de4 <shell_fprintf>
	if (k_thread_runtime_stats_get(thread, &rt_stats_thread) != 0) {
    400066c4:	910103e1 	add	x1, sp, #0x40
    400066c8:	aa1303e0 	mov	x0, x19
    400066cc:	940021ae 	bl	4000ed84 <k_thread_runtime_stats_get>
    400066d0:	2a0003f5 	mov	w21, w0
	if (k_thread_runtime_stats_all_get(&rt_stats_all) != 0) {
    400066d4:	910123e0 	add	x0, sp, #0x48
    400066d8:	940021bb 	bl	4000edc4 <k_thread_runtime_stats_all_get>
    400066dc:	2a0002b5 	orr	w21, w21, w0
    400066e0:	35000315 	cbnz	w21, 40006740 <shell_tdata_dump+0x128>
		shell_print(shell, "\tTotal execution cycles: %" PRIu64 " (%u %%)",
    400066e4:	a94413e3 	ldp	x3, x4, [sp, #64]
		pcnt = (rt_stats_thread.execution_cycles * 100U) /
    400066e8:	d2800c80 	mov	x0, #0x64                  	// #100
		shell_print(shell, "\tTotal execution cycles: %" PRIu64 " (%u %%)",
    400066ec:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400066f0:	9106b042 	add	x2, x2, #0x1ac
    400066f4:	52800101 	mov	w1, #0x8                   	// #8
		pcnt = (rt_stats_thread.execution_cycles * 100U) /
    400066f8:	9b007c60 	mul	x0, x3, x0
		shell_print(shell, "\tTotal execution cycles: %" PRIu64 " (%u %%)",
    400066fc:	9ac40804 	udiv	x4, x0, x4
    40006700:	aa1403e0 	mov	x0, x20
    40006704:	940009b8 	bl	40008de4 <shell_fprintf>
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
    40006708:	9100e3e1 	add	x1, sp, #0x38
    4000670c:	aa1303e0 	mov	x0, x19
    40006710:	94002191 	bl	4000ed54 <z_impl_k_thread_stack_space_get>
    40006714:	2a0003e3 	mov	w3, w0
	if (ret) {
    40006718:	34000200 	cbz	w0, 40006758 <shell_tdata_dump+0x140>
		shell_print(shell,
    4000671c:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006720:	9107d842 	add	x2, x2, #0x1f6
    40006724:	aa1403e0 	mov	x0, x20
    40006728:	52800101 	mov	w1, #0x8                   	// #8
    4000672c:	940009ae 	bl	40008de4 <shell_fprintf>
}
    40006730:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006734:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006738:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4000673c:	d65f03c0 	ret
		shell_print(shell, "\tTotal execution cycles: ? (? %%)");
    40006740:	aa1403e0 	mov	x0, x20
    40006744:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006748:	91074c42 	add	x2, x2, #0x1d3
    4000674c:	52800101 	mov	w1, #0x8                   	// #8
    40006750:	940009a5 	bl	40008de4 <shell_fprintf>
    40006754:	17ffffed 	b	40006708 <shell_tdata_dump+0xf0>
		pcnt = ((size - unused) * 100U) / size;
    40006758:	f9401fe4 	ldr	x4, [sp, #56]
    4000675c:	d2800c87 	mov	x7, #0x64                  	// #100
		shell_print(shell,
    40006760:	aa1603e6 	mov	x6, x22
    40006764:	aa1603e3 	mov	x3, x22
		pcnt = ((size - unused) * 100U) / size;
    40006768:	cb0402c5 	sub	x5, x22, x4
		shell_print(shell,
    4000676c:	aa1403e0 	mov	x0, x20
    40006770:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006774:	91088c42 	add	x2, x2, #0x223
    40006778:	52800101 	mov	w1, #0x8                   	// #8
		pcnt = ((size - unused) * 100U) / size;
    4000677c:	9b077ca7 	mul	x7, x5, x7
		shell_print(shell,
    40006780:	9ad608e7 	udiv	x7, x7, x22
    40006784:	94000998 	bl	40008de4 <shell_fprintf>
}
    40006788:	17ffffea 	b	40006730 <shell_tdata_dump+0x118>

000000004000678c <cmd_kernel_cycles>:
{
    4000678c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40006790:	910003fd 	mov	x29, sp
    40006794:	f9000bf3 	str	x19, [sp, #16]
    40006798:	aa0003f3 	mov	x19, x0
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
    4000679c:	94001e89 	bl	4000e1c0 <sys_clock_cycle_get_32>
	shell_print(shell, "cycles: %u hw cycles", k_cycle_get_32());
    400067a0:	2a0003e3 	mov	w3, w0
    400067a4:	52800101 	mov	w1, #0x8                   	// #8
    400067a8:	aa1303e0 	mov	x0, x19
    400067ac:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400067b0:	91096842 	add	x2, x2, #0x25a
    400067b4:	9400098c 	bl	40008de4 <shell_fprintf>
}
    400067b8:	52800000 	mov	w0, #0x0                   	// #0
    400067bc:	f9400bf3 	ldr	x19, [sp, #16]
    400067c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400067c4:	d65f03c0 	ret

00000000400067c8 <shell_stack_dump>:
{
    400067c8:	d10143ff 	sub	sp, sp, #0x50
    400067cc:	a9017bfd 	stp	x29, x30, [sp, #16]
    400067d0:	910043fd 	add	x29, sp, #0x10
    400067d4:	a90253f3 	stp	x19, x20, [sp, #32]
    400067d8:	aa0003f3 	mov	x19, x0
    400067dc:	aa0103f4 	mov	x20, x1
    400067e0:	f9001bf5 	str	x21, [sp, #48]
	size_t size = thread->stack_info.size;
    400067e4:	f9409815 	ldr	x21, [x0, #304]
    400067e8:	910123e1 	add	x1, sp, #0x48
    400067ec:	9400215a 	bl	4000ed54 <z_impl_k_thread_stack_space_get>
	if (ret) {
    400067f0:	34000180 	cbz	w0, 40006820 <shell_stack_dump+0x58>
    400067f4:	2a0003e3 	mov	w3, w0
		shell_print(shell,
    400067f8:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400067fc:	9107d842 	add	x2, x2, #0x1f6
    40006800:	aa1403e0 	mov	x0, x20
    40006804:	52800101 	mov	w1, #0x8                   	// #8
    40006808:	94000977 	bl	40008de4 <shell_fprintf>
}
    4000680c:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40006810:	a94253f3 	ldp	x19, x20, [sp, #32]
    40006814:	f9401bf5 	ldr	x21, [sp, #48]
    40006818:	910143ff 	add	sp, sp, #0x50
    4000681c:	d65f03c0 	ret
	tname = k_thread_name_get((struct k_thread *)thread);
    40006820:	aa1303e0 	mov	x0, x19
    40006824:	94002086 	bl	4000ea3c <k_thread_name_get>
	pcnt = ((size - unused) * 100U) / size;
    40006828:	f94027e6 	ldr	x6, [sp, #72]
    4000682c:	d2800c82 	mov	x2, #0x64                  	// #100
	tname = k_thread_name_get((struct k_thread *)thread);
    40006830:	aa0003e4 	mov	x4, x0
	pcnt = ((size - unused) * 100U) / size;
    40006834:	cb0602a7 	sub	x7, x21, x6
    40006838:	9b027ce2 	mul	x2, x7, x2
    4000683c:	9ad50842 	udiv	x2, x2, x21
	shell_print((const struct shell *)user_data,
    40006840:	b5000060 	cbnz	x0, 4000684c <shell_stack_dump+0x84>
    40006844:	f0000064 	adrp	x4, 40015000 <prefix.1+0x2aa>
    40006848:	91056884 	add	x4, x4, #0x15a
    4000684c:	f90003f5 	str	x21, [sp]
    40006850:	aa1503e5 	mov	x5, x21
    40006854:	b9000be2 	str	w2, [sp, #8]
    40006858:	aa1303e3 	mov	x3, x19
    4000685c:	aa1403e0 	mov	x0, x20
    40006860:	52800101 	mov	w1, #0x8                   	// #8
    40006864:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006868:	9109c042 	add	x2, x2, #0x270
    4000686c:	9400095e 	bl	40008de4 <shell_fprintf>
    40006870:	17ffffe7 	b	4000680c <shell_stack_dump+0x44>

0000000040006874 <get_device_name>:
};

static const char *get_device_name(const struct device *dev,
				   char *buf,
				   size_t len)
{
    40006874:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40006878:	aa0003e3 	mov	x3, x0
    4000687c:	910003fd 	mov	x29, sp
	const char *name = dev->name;
    40006880:	f9400000 	ldr	x0, [x0]
{
    40006884:	f9000bf3 	str	x19, [sp, #16]
    40006888:	aa0103f3 	mov	x19, x1
    4000688c:	aa0203e1 	mov	x1, x2

	if ((name == NULL) || (name[0] == 0)) {
    40006890:	b4000060 	cbz	x0, 4000689c <get_device_name+0x28>
    40006894:	39400002 	ldrb	w2, [x0]
    40006898:	350000c2 	cbnz	w2, 400068b0 <get_device_name+0x3c>
		snprintf(buf, len, "[%p]", dev);
    4000689c:	aa1303e0 	mov	x0, x19
    400068a0:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400068a4:	910cfc42 	add	x2, x2, #0x33f
    400068a8:	94001abd 	bl	4000d39c <snprintf>
		name = buf;
    400068ac:	aa1303e0 	mov	x0, x19
	}

	return name;
}
    400068b0:	f9400bf3 	ldr	x19, [sp, #16]
    400068b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400068b8:	d65f03c0 	ret

00000000400068bc <cmd_device_list_visitor>:
	size_t buf_size;
};

static int cmd_device_list_visitor(const struct device *dev,
				   void *context)
{
    400068bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400068c0:	910003fd 	mov	x29, sp
	const struct cmd_device_list_visitor_context *ctx = context;

	shell_fprintf(ctx->shell, SHELL_NORMAL, "  requires: %s\n",
    400068c4:	f9400822 	ldr	x2, [x1, #16]
{
    400068c8:	f9000bf3 	str	x19, [sp, #16]
	shell_fprintf(ctx->shell, SHELL_NORMAL, "  requires: %s\n",
    400068cc:	a9400433 	ldp	x19, x1, [x1]
    400068d0:	97ffffe9 	bl	40006874 <get_device_name>
    400068d4:	aa0003e3 	mov	x3, x0
    400068d8:	52800101 	mov	w1, #0x8                   	// #8
    400068dc:	aa1303e0 	mov	x0, x19
    400068e0:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400068e4:	910d1042 	add	x2, x2, #0x344
    400068e8:	9400093f 	bl	40008de4 <shell_fprintf>
		      get_device_name(dev, ctx->buf, ctx->buf_size));

	return 0;
}
    400068ec:	52800000 	mov	w0, #0x0                   	// #0
    400068f0:	f9400bf3 	ldr	x19, [sp, #16]
    400068f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400068f8:	d65f03c0 	ret

00000000400068fc <cmd_device_list>:

static int cmd_device_list(const struct shell *shell,
			   size_t argc, char **argv)
{
    400068fc:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    40006900:	910003fd 	mov	x29, sp
    40006904:	a90153f3 	stp	x19, x20, [sp, #16]
    40006908:	aa0003f4 	mov	x20, x0
	const struct device *devlist;
	size_t devcnt = z_device_get_all_static(&devlist);
    4000690c:	910123e0 	add	x0, sp, #0x48
{
    40006910:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (dev = devlist; dev < devlist_end; dev++) {
		char buf[20];
		const char *name = get_device_name(dev, buf, sizeof(buf));
		const char *state = "READY";

		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
    40006914:	f0000076 	adrp	x22, 40015000 <prefix.1+0x2aa>
    40006918:	910db6d6 	add	x22, x22, #0x36d
{
    4000691c:	a90363f7 	stp	x23, x24, [sp, #48]
	size_t devcnt = z_device_get_all_static(&devlist);
    40006920:	94001e81 	bl	4000e324 <z_device_get_all_static>
	const struct device *devlist_end = devlist + devcnt;
    40006924:	d2800602 	mov	x2, #0x30                  	// #48
    40006928:	f94027e1 	ldr	x1, [sp, #72]
		if (!device_is_ready(dev)) {
			state = "DISABLED";
    4000692c:	f0000077 	adrp	x23, 40015000 <prefix.1+0x2aa>
    40006930:	910d6af7 	add	x23, x23, #0x35a
		const char *name = get_device_name(dev, buf, sizeof(buf));
    40006934:	910143f8 	add	x24, sp, #0x50
	const struct device *devlist_end = devlist + devcnt;
    40006938:	9b020415 	madd	x21, x0, x2, x1
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
    4000693c:	aa1403e0 	mov	x0, x20
    40006940:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006944:	910d8c42 	add	x2, x2, #0x363
    40006948:	52800101 	mov	w1, #0x8                   	// #8
    4000694c:	94000926 	bl	40008de4 <shell_fprintf>
	for (dev = devlist; dev < devlist_end; dev++) {
    40006950:	f94027f3 	ldr	x19, [sp, #72]
    40006954:	eb15027f 	cmp	x19, x21
    40006958:	540000e3 	b.cc	40006974 <cmd_device_list+0x78>  // b.lo, b.ul, b.last
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
		}
	}

	return 0;
}
    4000695c:	52800000 	mov	w0, #0x0                   	// #0
    40006960:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006964:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006968:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000696c:	a8c87bfd 	ldp	x29, x30, [sp], #128
    40006970:	d65f03c0 	ret
		const char *name = get_device_name(dev, buf, sizeof(buf));
    40006974:	aa1803e1 	mov	x1, x24
    40006978:	aa1303e0 	mov	x0, x19
    4000697c:	d2800282 	mov	x2, #0x14                  	// #20
    40006980:	97ffffbd 	bl	40006874 <get_device_name>
		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
    40006984:	aa1603e2 	mov	x2, x22
    40006988:	aa0003e3 	mov	x3, x0
    4000698c:	52800101 	mov	w1, #0x8                   	// #8
    40006990:	aa1403e0 	mov	x0, x20
    40006994:	94000914 	bl	40008de4 <shell_fprintf>
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
    40006998:	aa1303e0 	mov	x0, x19
    4000699c:	94001e6d 	bl	4000e350 <z_device_ready>
			state = "DISABLED";
    400069a0:	72001c1f 	tst	w0, #0xff
    400069a4:	f0000063 	adrp	x3, 40015000 <prefix.1+0x2aa>
		shell_fprintf(shell, SHELL_NORMAL, " (%s)\n", state);
    400069a8:	910d5063 	add	x3, x3, #0x354
    400069ac:	aa1403e0 	mov	x0, x20
    400069b0:	9a971063 	csel	x3, x3, x23, ne  // ne = any
    400069b4:	52800101 	mov	w1, #0x8                   	// #8
    400069b8:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400069bc:	910dc842 	add	x2, x2, #0x372
    400069c0:	94000909 	bl	40008de4 <shell_fprintf>
			struct cmd_device_list_visitor_context ctx = {
    400069c4:	a906e3f4 	stp	x20, x24, [sp, #104]
    400069c8:	d2800280 	mov	x0, #0x14                  	// #20
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
    400069cc:	9101a3e2 	add	x2, sp, #0x68
    400069d0:	90000001 	adrp	x1, 40006000 <shell_backend_cmd_execute+0xa4>
    400069d4:	9122f021 	add	x1, x1, #0x8bc
			struct cmd_device_list_visitor_context ctx = {
    400069d8:	f9003fe0 	str	x0, [sp, #120]
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
    400069dc:	aa1303e0 	mov	x0, x19
	for (dev = devlist; dev < devlist_end; dev++) {
    400069e0:	9100c273 	add	x19, x19, #0x30
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
    400069e4:	94001e64 	bl	4000e374 <device_required_foreach>
	for (dev = devlist; dev < devlist_end; dev++) {
    400069e8:	17ffffdb 	b	40006954 <cmd_device_list+0x58>

00000000400069ec <device_get_config_level>:
{
    400069ec:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    400069f0:	b0000062 	adrp	x2, 40013000 <shell_cmd_help>
    400069f4:	912c8042 	add	x2, x2, #0xb20
{
    400069f8:	910003fd 	mov	x29, sp
    400069fc:	a90153f3 	stp	x19, x20, [sp, #16]
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40006a00:	f861d853 	ldr	x19, [x2, w1, sxtw #3]
    40006a04:	11000421 	add	w1, w1, #0x1
{
    40006a08:	a90363f7 	stp	x23, x24, [sp, #48]
	bool devices = false;
    40006a0c:	52800017 	mov	w23, #0x0                   	// #0
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40006a10:	f861d858 	ldr	x24, [x2, w1, sxtw #3]
{
    40006a14:	a9025bf5 	stp	x21, x22, [sp, #32]
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
    40006a18:	f0000076 	adrp	x22, 40015000 <prefix.1+0x2aa>
    40006a1c:	910de6d6 	add	x22, x22, #0x379
{
    40006a20:	aa0003f5 	mov	x21, x0
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40006a24:	eb13031f 	cmp	x24, x19
    40006a28:	540000e8 	b.hi	40006a44 <device_get_config_level+0x58>  // b.pmore
}
    40006a2c:	2a1703e0 	mov	w0, w23
    40006a30:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006a34:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006a38:	a94363f7 	ldp	x23, x24, [sp, #48]
    40006a3c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40006a40:	d65f03c0 	ret
    40006a44:	aa1303e0 	mov	x0, x19
    40006a48:	94001e42 	bl	4000e350 <z_device_ready>
    40006a4c:	72001c14 	ands	w20, w0, #0xff
    40006a50:	54000160 	b.eq	40006a7c <device_get_config_level+0x90>  // b.none
			devices = true;
    40006a54:	2a1403f7 	mov	w23, w20
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
    40006a58:	910123e1 	add	x1, sp, #0x48
    40006a5c:	d2800282 	mov	x2, #0x14                  	// #20
    40006a60:	aa1303e0 	mov	x0, x19
    40006a64:	97ffff84 	bl	40006874 <get_device_name>
    40006a68:	aa0003e3 	mov	x3, x0
    40006a6c:	aa1603e2 	mov	x2, x22
    40006a70:	aa1503e0 	mov	x0, x21
    40006a74:	52800101 	mov	w1, #0x8                   	// #8
    40006a78:	940008db 	bl	40008de4 <shell_fprintf>
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40006a7c:	9100c273 	add	x19, x19, #0x30
    40006a80:	17ffffe9 	b	40006a24 <device_get_config_level+0x38>

0000000040006a84 <cmd_device_levels>:
{
    40006a84:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
    40006a88:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006a8c:	910dfc42 	add	x2, x2, #0x37f
{
    40006a90:	910003fd 	mov	x29, sp
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
    40006a94:	52800101 	mov	w1, #0x8                   	// #8
{
    40006a98:	f9000bf3 	str	x19, [sp, #16]
    40006a9c:	aa0003f3 	mov	x19, x0
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
    40006aa0:	940008d1 	bl	40008de4 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_1);
    40006aa4:	aa1303e0 	mov	x0, x19
    40006aa8:	52800001 	mov	w1, #0x0                   	// #0
    40006aac:	97ffffd0 	bl	400069ec <device_get_config_level>
	if (ret == false) {
    40006ab0:	72001c1f 	tst	w0, #0xff
    40006ab4:	540000c1 	b.ne	40006acc <cmd_device_levels+0x48>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    40006ab8:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006abc:	910e3842 	add	x2, x2, #0x38e
    40006ac0:	aa1303e0 	mov	x0, x19
    40006ac4:	52800101 	mov	w1, #0x8                   	// #8
    40006ac8:	940008c7 	bl	40008de4 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 2:\n");
    40006acc:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006ad0:	910e5842 	add	x2, x2, #0x396
    40006ad4:	aa1303e0 	mov	x0, x19
    40006ad8:	52800101 	mov	w1, #0x8                   	// #8
    40006adc:	940008c2 	bl	40008de4 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_2);
    40006ae0:	aa1303e0 	mov	x0, x19
    40006ae4:	52800021 	mov	w1, #0x1                   	// #1
    40006ae8:	97ffffc1 	bl	400069ec <device_get_config_level>
	if (ret == false) {
    40006aec:	72001c1f 	tst	w0, #0xff
    40006af0:	540000c1 	b.ne	40006b08 <cmd_device_levels+0x84>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    40006af4:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006af8:	910e3842 	add	x2, x2, #0x38e
    40006afc:	aa1303e0 	mov	x0, x19
    40006b00:	52800101 	mov	w1, #0x8                   	// #8
    40006b04:	940008b8 	bl	40008de4 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "POST_KERNEL:\n");
    40006b08:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006b0c:	910e9442 	add	x2, x2, #0x3a5
    40006b10:	aa1303e0 	mov	x0, x19
    40006b14:	52800101 	mov	w1, #0x8                   	// #8
    40006b18:	940008b3 	bl	40008de4 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_POST_KERNEL);
    40006b1c:	aa1303e0 	mov	x0, x19
    40006b20:	52800041 	mov	w1, #0x2                   	// #2
    40006b24:	97ffffb2 	bl	400069ec <device_get_config_level>
	if (ret == false) {
    40006b28:	72001c1f 	tst	w0, #0xff
    40006b2c:	540000c1 	b.ne	40006b44 <cmd_device_levels+0xc0>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    40006b30:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006b34:	910e3842 	add	x2, x2, #0x38e
    40006b38:	aa1303e0 	mov	x0, x19
    40006b3c:	52800101 	mov	w1, #0x8                   	// #8
    40006b40:	940008a9 	bl	40008de4 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "APPLICATION:\n");
    40006b44:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006b48:	910ecc42 	add	x2, x2, #0x3b3
    40006b4c:	aa1303e0 	mov	x0, x19
    40006b50:	52800101 	mov	w1, #0x8                   	// #8
    40006b54:	940008a4 	bl	40008de4 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_APPLICATION);
    40006b58:	aa1303e0 	mov	x0, x19
    40006b5c:	52800061 	mov	w1, #0x3                   	// #3
    40006b60:	97ffffa3 	bl	400069ec <device_get_config_level>
	if (ret == false) {
    40006b64:	72001c1f 	tst	w0, #0xff
    40006b68:	540000c1 	b.ne	40006b80 <cmd_device_levels+0xfc>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    40006b6c:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006b70:	910e3842 	add	x2, x2, #0x38e
    40006b74:	aa1303e0 	mov	x0, x19
    40006b78:	52800101 	mov	w1, #0x8                   	// #8
    40006b7c:	9400089a 	bl	40008de4 <shell_fprintf>
}
    40006b80:	52800000 	mov	w0, #0x0                   	// #0
    40006b84:	f9400bf3 	ldr	x19, [sp, #16]
    40006b88:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40006b8c:	d65f03c0 	ret

0000000040006b90 <date_print>:

#define HELP_NONE      "[none]"
#define HELP_DATE_SET  "[Y-m-d] <H:M:S>"

static void date_print(const struct shell *shell, struct tm *tm)
{
    40006b90:	d10083ff 	sub	sp, sp, #0x20
    40006b94:	a9017bfd 	stp	x29, x30, [sp, #16]
    40006b98:	910043fd 	add	x29, sp, #0x10
	shell_print(shell,
    40006b9c:	b9400022 	ldr	w2, [x1]
    40006ba0:	29420c24 	ldp	w4, w3, [x1, #16]
    40006ba4:	b90003e2 	str	w2, [sp]
    40006ba8:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006bac:	91105c42 	add	x2, x2, #0x417
    40006bb0:	29409827 	ldp	w7, w6, [x1, #4]
    40006bb4:	11000484 	add	w4, w4, #0x1
    40006bb8:	b9400c25 	ldr	w5, [x1, #12]
    40006bbc:	111db063 	add	w3, w3, #0x76c
    40006bc0:	52800101 	mov	w1, #0x8                   	// #8
    40006bc4:	94000888 	bl	40008de4 <shell_fprintf>
		    tm->tm_mon + 1,
		    tm->tm_mday,
		    tm->tm_hour,
		    tm->tm_min,
		    tm->tm_sec);
}
    40006bc8:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40006bcc:	910083ff 	add	sp, sp, #0x20
    40006bd0:	d65f03c0 	ret

0000000040006bd4 <get_h_m_s>:
 * For user convenience of small adjustments to time the time argument will
 * accept H:M:S, :M:S or ::S where the missing field(s) will be filled in by
 * the previous time state.
 */
static int get_h_m_s(const struct shell *shell, struct tm *tm, char *time_str)
{
    40006bd4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40006bd8:	910003fd 	mov	x29, sp
    40006bdc:	a90153f3 	stp	x19, x20, [sp, #16]
    40006be0:	aa0203f4 	mov	x20, x2
    40006be4:	a9025bf5 	stp	x21, x22, [sp, #32]
    40006be8:	aa0003f5 	mov	x21, x0
    40006bec:	aa0103f6 	mov	x22, x1
	char *endptr;

	if (*time_str == ':') {
    40006bf0:	39400040 	ldrb	w0, [x2]
    40006bf4:	7100e81f 	cmp	w0, #0x3a
    40006bf8:	540002e1 	b.ne	40006c54 <get_h_m_s+0x80>  // b.any
		time_str++;
    40006bfc:	91000453 	add	x19, x2, #0x1
		} else {
			return -EINVAL;
		}
	}

	if (*time_str == ':') {
    40006c00:	39400260 	ldrb	w0, [x19]
    40006c04:	7100e81f 	cmp	w0, #0x3a
    40006c08:	540005a1 	b.ne	40006cbc <get_h_m_s+0xe8>  // b.any
		time_str++;
    40006c0c:	91000673 	add	x19, x19, #0x1
			return -EINVAL;
		}
	}

	endptr = NULL;
	tm->tm_sec = strtol(time_str, &endptr, 10);
    40006c10:	9100e3e1 	add	x1, sp, #0x38
    40006c14:	aa1303e0 	mov	x0, x19
    40006c18:	52800142 	mov	w2, #0xa                   	// #10
	endptr = NULL;
    40006c1c:	f9001fff 	str	xzr, [sp, #56]
	tm->tm_sec = strtol(time_str, &endptr, 10);
    40006c20:	94001804 	bl	4000cc30 <strtol>
    40006c24:	aa0003e1 	mov	x1, x0
	if ((endptr == time_str) || (*endptr != '\0')) {
    40006c28:	f9401fe0 	ldr	x0, [sp, #56]
	tm->tm_sec = strtol(time_str, &endptr, 10);
    40006c2c:	b90002c1 	str	w1, [x22]
	if ((endptr == time_str) || (*endptr != '\0')) {
    40006c30:	eb13001f 	cmp	x0, x19
    40006c34:	54000220 	b.eq	40006c78 <get_h_m_s+0xa4>  // b.none
    40006c38:	39400000 	ldrb	w0, [x0]
    40006c3c:	350001e0 	cbnz	w0, 40006c78 <get_h_m_s+0xa4>
		return -EINVAL;
	}

	/* Note range allows for a leap second */
	if ((tm->tm_sec < 0) || (tm->tm_sec > 60)) {
    40006c40:	7100f03f 	cmp	w1, #0x3c
    40006c44:	540001c9 	b.ls	40006c7c <get_h_m_s+0xa8>  // b.plast
		shell_error(shell, "Invalid second");
    40006c48:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006c4c:	91115842 	add	x2, x2, #0x456
    40006c50:	14000017 	b	40006cac <get_h_m_s+0xd8>
		tm->tm_hour = strtol(time_str, &endptr, 10);
    40006c54:	9100e3e1 	add	x1, sp, #0x38
    40006c58:	aa1403e0 	mov	x0, x20
    40006c5c:	52800142 	mov	w2, #0xa                   	// #10
		endptr = NULL;
    40006c60:	f9001fff 	str	xzr, [sp, #56]
		tm->tm_hour = strtol(time_str, &endptr, 10);
    40006c64:	940017f3 	bl	4000cc30 <strtol>
    40006c68:	b9000ac0 	str	w0, [x22, #8]
		if (endptr == time_str) {
    40006c6c:	f9401ff3 	ldr	x19, [sp, #56]
    40006c70:	eb14027f 	cmp	x19, x20
    40006c74:	540000c1 	b.ne	40006c8c <get_h_m_s+0xb8>  // b.any
		return -EINVAL;
    40006c78:	128002a0 	mov	w0, #0xffffffea            	// #-22
	}

	return 0;
}
    40006c7c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006c80:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006c84:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40006c88:	d65f03c0 	ret
		} else if (*endptr == ':') {
    40006c8c:	39400261 	ldrb	w1, [x19]
    40006c90:	7100e83f 	cmp	w1, #0x3a
    40006c94:	54ffff21 	b.ne	40006c78 <get_h_m_s+0xa4>  // b.any
			time_str = endptr + 1;
    40006c98:	91000673 	add	x19, x19, #0x1
			if ((tm->tm_hour < 0) || (tm->tm_hour > 23)) {
    40006c9c:	71005c1f 	cmp	w0, #0x17
    40006ca0:	54fffb09 	b.ls	40006c00 <get_h_m_s+0x2c>  // b.plast
				shell_error(shell, "Invalid hour");
    40006ca4:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006ca8:	9110e042 	add	x2, x2, #0x438
		shell_error(shell, "Invalid second");
    40006cac:	aa1503e0 	mov	x0, x21
    40006cb0:	52800021 	mov	w1, #0x1                   	// #1
    40006cb4:	9400084c 	bl	40008de4 <shell_fprintf>
    40006cb8:	17fffff0 	b	40006c78 <get_h_m_s+0xa4>
		tm->tm_min = strtol(time_str, &endptr, 10);
    40006cbc:	52800142 	mov	w2, #0xa                   	// #10
    40006cc0:	9100e3e1 	add	x1, sp, #0x38
    40006cc4:	aa1303e0 	mov	x0, x19
		endptr = NULL;
    40006cc8:	f9001fff 	str	xzr, [sp, #56]
		tm->tm_min = strtol(time_str, &endptr, 10);
    40006ccc:	940017d9 	bl	4000cc30 <strtol>
    40006cd0:	b90006c0 	str	w0, [x22, #4]
		if (endptr == time_str) {
    40006cd4:	f9401fe2 	ldr	x2, [sp, #56]
    40006cd8:	eb13005f 	cmp	x2, x19
    40006cdc:	54fffce0 	b.eq	40006c78 <get_h_m_s+0xa4>  // b.none
		} else if (*endptr == ':') {
    40006ce0:	39400041 	ldrb	w1, [x2]
    40006ce4:	7100e83f 	cmp	w1, #0x3a
    40006ce8:	54fffc81 	b.ne	40006c78 <get_h_m_s+0xa4>  // b.any
			time_str = endptr + 1;
    40006cec:	91000453 	add	x19, x2, #0x1
			if ((tm->tm_min < 0) || (tm->tm_min > 59)) {
    40006cf0:	7100ec1f 	cmp	w0, #0x3b
    40006cf4:	54fff8e9 	b.ls	40006c10 <get_h_m_s+0x3c>  // b.plast
				shell_error(shell, "Invalid minute");
    40006cf8:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006cfc:	91111842 	add	x2, x2, #0x446
    40006d00:	17ffffeb 	b	40006cac <get_h_m_s+0xd8>

0000000040006d04 <cmd_date_set>:

static int cmd_date_set(const struct shell *shell, size_t argc, char **argv)
{
    40006d04:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    40006d08:	910003fd 	mov	x29, sp
    40006d0c:	a90153f3 	stp	x19, x20, [sp, #16]
    40006d10:	aa0003f3 	mov	x19, x0
    40006d14:	aa0103f4 	mov	x20, x1
    40006d18:	a9025bf5 	stp	x21, x22, [sp, #32]
    40006d1c:	aa0203f6 	mov	x22, x2
    40006d20:	f9001bf7 	str	x23, [sp, #48]
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&clock_id, *(uintptr_t *)&ts, K_SYSCALL_CLOCK_GETTIME);
	}
#endif
	compiler_barrier();
	return z_impl_clock_gettime(clock_id, ts);
    40006d24:	52800020 	mov	w0, #0x1                   	// #1
    40006d28:	910123e1 	add	x1, sp, #0x48
    40006d2c:	94001a53 	bl	4000d678 <z_impl_clock_gettime>
	struct tm tm;
	int ret;

	clock_gettime(CLOCK_REALTIME, &tp);

	gmtime_r(&tp.tv_sec, &tm);
    40006d30:	910163e1 	add	x1, sp, #0x58
    40006d34:	910123e0 	add	x0, sp, #0x48
    40006d38:	940019e5 	bl	4000d4cc <gmtime_r>

	if (argc == 3) {
    40006d3c:	f1000e9f 	cmp	x20, #0x3
    40006d40:	540009e1 	b.ne	40006e7c <cmd_date_set+0x178>  // b.any
		ret = get_y_m_d(shell, &tm, argv[1]);
    40006d44:	f94006d4 	ldr	x20, [x22, #8]
	year = strtol(date_str, &endptr, 10);
    40006d48:	910103e1 	add	x1, sp, #0x40
    40006d4c:	52800142 	mov	w2, #0xa                   	// #10
	endptr = NULL;
    40006d50:	f90023ff 	str	xzr, [sp, #64]
	year = strtol(date_str, &endptr, 10);
    40006d54:	aa1403e0 	mov	x0, x20
    40006d58:	940017b6 	bl	4000cc30 <strtol>
	if ((endptr == date_str) || (*endptr != '-')) {
    40006d5c:	f94023e1 	ldr	x1, [sp, #64]
	year = strtol(date_str, &endptr, 10);
    40006d60:	aa0003f7 	mov	x23, x0
	if ((endptr == date_str) || (*endptr != '-')) {
    40006d64:	eb01029f 	cmp	x20, x1
    40006d68:	54000300 	b.eq	40006dc8 <cmd_date_set+0xc4>  // b.none
    40006d6c:	39400020 	ldrb	w0, [x1]
    40006d70:	7100b41f 	cmp	w0, #0x2d
    40006d74:	540002a1 	b.ne	40006dc8 <cmd_date_set+0xc4>  // b.any
	date_str = endptr + 1;
    40006d78:	91000434 	add	x20, x1, #0x1
	month = strtol(date_str, &endptr, 10);
    40006d7c:	52800142 	mov	w2, #0xa                   	// #10
    40006d80:	910103e1 	add	x1, sp, #0x40
    40006d84:	aa1403e0 	mov	x0, x20
	endptr = NULL;
    40006d88:	f90023ff 	str	xzr, [sp, #64]
	month = strtol(date_str, &endptr, 10);
    40006d8c:	940017a9 	bl	4000cc30 <strtol>
	if ((endptr == date_str) || (*endptr != '-')) {
    40006d90:	f94023e1 	ldr	x1, [sp, #64]
    40006d94:	eb01029f 	cmp	x20, x1
    40006d98:	54000180 	b.eq	40006dc8 <cmd_date_set+0xc4>  // b.none
    40006d9c:	39400022 	ldrb	w2, [x1]
    40006da0:	7100b45f 	cmp	w2, #0x2d
    40006da4:	54000121 	b.ne	40006dc8 <cmd_date_set+0xc4>  // b.any
	if ((month < 1) || (month > 12)) {
    40006da8:	51000414 	sub	w20, w0, #0x1
    40006dac:	71002e9f 	cmp	w20, #0xb
    40006db0:	540001e9 	b.ls	40006dec <cmd_date_set+0xe8>  // b.plast
		shell_error(shell, "Invalid month");
    40006db4:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006db8:	91119842 	add	x2, x2, #0x466
		shell_error(shell, "Invalid day");
    40006dbc:	aa1303e0 	mov	x0, x19
    40006dc0:	52800021 	mov	w1, #0x1                   	// #1
    40006dc4:	94000808 	bl	40008de4 <shell_fprintf>
		if (ret != 0) {
			shell_help(shell);
    40006dc8:	aa1303e0 	mov	x0, x19
    40006dcc:	940008b5 	bl	400090a0 <shell_help>
	tp.tv_nsec = 0;

	ret = clock_settime(CLOCK_REALTIME, &tp);
	if (ret != 0) {
		shell_error(shell, "Could not set date %d", ret);
		return -EINVAL;
    40006dd0:	128002b4 	mov	w20, #0xffffffea            	// #-22
	}

	date_print(shell, &tm);

	return 0;
}
    40006dd4:	2a1403e0 	mov	w0, w20
    40006dd8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006ddc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006de0:	f9401bf7 	ldr	x23, [sp, #48]
    40006de4:	a8c87bfd 	ldp	x29, x30, [sp], #128
    40006de8:	d65f03c0 	ret
	date_str = endptr + 1;
    40006dec:	91000435 	add	x21, x1, #0x1
	day = strtol(date_str, &endptr, 10);
    40006df0:	52800142 	mov	w2, #0xa                   	// #10
    40006df4:	910103e1 	add	x1, sp, #0x40
    40006df8:	aa1503e0 	mov	x0, x21
	endptr = NULL;
    40006dfc:	f90023ff 	str	xzr, [sp, #64]
	day = strtol(date_str, &endptr, 10);
    40006e00:	9400178c 	bl	4000cc30 <strtol>
	if ((endptr == date_str) || (*endptr != '\0')) {
    40006e04:	f94023e1 	ldr	x1, [sp, #64]
    40006e08:	eb0102bf 	cmp	x21, x1
    40006e0c:	54fffde0 	b.eq	40006dc8 <cmd_date_set+0xc4>  // b.none
    40006e10:	39400021 	ldrb	w1, [x1]
    40006e14:	35fffda1 	cbnz	w1, 40006dc8 <cmd_date_set+0xc4>
	if ((day < 1) || (day > 31)) {
    40006e18:	51000401 	sub	w1, w0, #0x1
    40006e1c:	7100783f 	cmp	w1, #0x1e
    40006e20:	54000089 	b.ls	40006e30 <cmd_date_set+0x12c>  // b.plast
		shell_error(shell, "Invalid day");
    40006e24:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006e28:	9111d442 	add	x2, x2, #0x475
    40006e2c:	17ffffe4 	b	40006dbc <cmd_date_set+0xb8>
		ret = get_h_m_s(shell, &tm, argv[2]);
    40006e30:	f9400ac2 	ldr	x2, [x22, #16]
	tm->tm_year = year - 1900;
    40006e34:	511db2f7 	sub	w23, w23, #0x76c
	tm->tm_mon = month - 1;
    40006e38:	290cd3e0 	stp	w0, w20, [sp, #100]
	tm->tm_year = year - 1900;
    40006e3c:	b9006ff7 	str	w23, [sp, #108]
		ret = get_h_m_s(shell, &tm, argv[2]);
    40006e40:	910163e1 	add	x1, sp, #0x58
    40006e44:	aa1303e0 	mov	x0, x19
    40006e48:	97ffff63 	bl	40006bd4 <get_h_m_s>
		if (ret != 0) {
    40006e4c:	35fffbe0 	cbnz	w0, 40006dc8 <cmd_date_set+0xc4>
	tp.tv_sec = timeutil_timegm(&tm);
    40006e50:	910163e0 	add	x0, sp, #0x58
    40006e54:	97ffec83 	bl	40002060 <timeutil_timegm>
    40006e58:	f90027e0 	str	x0, [sp, #72]
	if (tp.tv_sec == -1) {
    40006e5c:	b100041f 	cmn	x0, #0x1
    40006e60:	54000161 	b.ne	40006e8c <cmd_date_set+0x188>  // b.any
		shell_error(shell, "Failed to calculate seconds since Epoch");
    40006e64:	aa1303e0 	mov	x0, x19
    40006e68:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006e6c:	91120842 	add	x2, x2, #0x482
    40006e70:	52800021 	mov	w1, #0x1                   	// #1
    40006e74:	940007dc 	bl	40008de4 <shell_fprintf>
		return -EINVAL;
    40006e78:	17ffffd6 	b	40006dd0 <cmd_date_set+0xcc>
	} else if (argc == 2) {
    40006e7c:	f1000a9f 	cmp	x20, #0x2
    40006e80:	54fffa41 	b.ne	40006dc8 <cmd_date_set+0xc4>  // b.any
		ret = get_h_m_s(shell, &tm, argv[1]);
    40006e84:	f94006c2 	ldr	x2, [x22, #8]
    40006e88:	17ffffee 	b	40006e40 <cmd_date_set+0x13c>
	ret = clock_settime(CLOCK_REALTIME, &tp);
    40006e8c:	910123e1 	add	x1, sp, #0x48
    40006e90:	52800020 	mov	w0, #0x1                   	// #1
	tp.tv_nsec = 0;
    40006e94:	f9002bff 	str	xzr, [sp, #80]
	ret = clock_settime(CLOCK_REALTIME, &tp);
    40006e98:	94001a24 	bl	4000d728 <clock_settime>
    40006e9c:	2a0003f4 	mov	w20, w0
	if (ret != 0) {
    40006ea0:	34000100 	cbz	w0, 40006ec0 <cmd_date_set+0x1bc>
		shell_error(shell, "Could not set date %d", ret);
    40006ea4:	2a0003e3 	mov	w3, w0
    40006ea8:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006eac:	9112ac42 	add	x2, x2, #0x4ab
    40006eb0:	aa1303e0 	mov	x0, x19
    40006eb4:	52800021 	mov	w1, #0x1                   	// #1
    40006eb8:	940007cb 	bl	40008de4 <shell_fprintf>
    40006ebc:	17ffffc5 	b	40006dd0 <cmd_date_set+0xcc>
	date_print(shell, &tm);
    40006ec0:	910163e1 	add	x1, sp, #0x58
    40006ec4:	aa1303e0 	mov	x0, x19
    40006ec8:	97ffff32 	bl	40006b90 <date_print>
	return 0;
    40006ecc:	17ffffc2 	b	40006dd4 <cmd_date_set+0xd0>

0000000040006ed0 <cmd_date_get>:

static int cmd_date_get(const struct shell *shell, size_t argc, char **argv)
{
    40006ed0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40006ed4:	910003fd 	mov	x29, sp
    40006ed8:	f9000bf3 	str	x19, [sp, #16]
    40006edc:	aa0003f3 	mov	x19, x0
    40006ee0:	52800020 	mov	w0, #0x1                   	// #1
    40006ee4:	9100a3e1 	add	x1, sp, #0x28
    40006ee8:	940019e4 	bl	4000d678 <z_impl_clock_gettime>
	struct timespec tp;
	struct tm tm;

	clock_gettime(CLOCK_REALTIME, &tp);

	gmtime_r(&tp.tv_sec, &tm);
    40006eec:	9100e3e1 	add	x1, sp, #0x38
    40006ef0:	9100a3e0 	add	x0, sp, #0x28
    40006ef4:	94001976 	bl	4000d4cc <gmtime_r>

	date_print(shell, &tm);
    40006ef8:	9100e3e1 	add	x1, sp, #0x38
    40006efc:	aa1303e0 	mov	x0, x19
    40006f00:	97ffff24 	bl	40006b90 <date_print>

	return 0;
}
    40006f04:	52800000 	mov	w0, #0x0                   	// #0
    40006f08:	f9400bf3 	ldr	x19, [sp, #16]
    40006f0c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40006f10:	d65f03c0 	ret

0000000040006f14 <cmd_devmem>:
	return err;
}

/* The syntax of the command is similar to busybox's devmem */
static int cmd_devmem(const struct shell *sh, size_t argc, char **argv)
{
    40006f14:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40006f18:	910003fd 	mov	x29, sp
    40006f1c:	a90153f3 	stp	x19, x20, [sp, #16]
    40006f20:	aa0003f4 	mov	x20, x0
	mem_addr_t phys_addr, addr;
	uint32_t value = 0;
	uint8_t width;

	if (argc < 2 || argc > 4) {
    40006f24:	d1000820 	sub	x0, x1, #0x2
{
    40006f28:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (argc < 2 || argc > 4) {
    40006f2c:	f100081f 	cmp	x0, #0x2
    40006f30:	54000868 	b.hi	4000703c <cmd_devmem+0x128>  // b.pmore
    40006f34:	aa0203f5 	mov	x21, x2
		return -EINVAL;
	}

	phys_addr = strtoul(argv[1], NULL, 16);
    40006f38:	aa0103f6 	mov	x22, x1
    40006f3c:	52800202 	mov	w2, #0x10                  	// #16
    40006f40:	d2800001 	mov	x1, #0x0                   	// #0
    40006f44:	f94006a0 	ldr	x0, [x21, #8]
    40006f48:	9400179c 	bl	4000cdb8 <strtoul>
{
#ifdef CONFIG_MMU
	/* Pass along flags and add that we want supervisor mode
	 * read-write access.
	 */
	z_phys_map((uint8_t **)virt_addr, phys_addr, size,
    40006f4c:	aa0003e1 	mov	x1, x0
    40006f50:	aa0003f3 	mov	x19, x0
    40006f54:	52800143 	mov	w3, #0xa                   	// #10
    40006f58:	9100e3e0 	add	x0, sp, #0x38
    40006f5c:	d2802002 	mov	x2, #0x100                 	// #256
    40006f60:	940027da 	bl	40010ec8 <z_phys_map>

#if defined(CONFIG_MMU) || defined(CONFIG_PCIE)
	device_map((mm_reg_t *)&addr, phys_addr, 0x100, K_MEM_CACHE_NONE);

	shell_print(sh, "Mapped 0x%lx to 0x%lx\n", phys_addr, addr);
    40006f64:	f9401fe4 	ldr	x4, [sp, #56]
    40006f68:	aa1303e3 	mov	x3, x19
    40006f6c:	aa1403e0 	mov	x0, x20
    40006f70:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006f74:	9113c042 	add	x2, x2, #0x4f0
    40006f78:	52800101 	mov	w1, #0x8                   	// #8
    40006f7c:	9400079a 	bl	40008de4 <shell_fprintf>
#else
	addr = phys_addr;
#endif /* defined(CONFIG_MMU) || defined(CONFIG_PCIE) */

	if (argc < 3) {
    40006f80:	f1000adf 	cmp	x22, #0x2
    40006f84:	54000440 	b.eq	4000700c <cmd_devmem+0xf8>  // b.none
		width = 32;
	} else {
		width = strtoul(argv[2], NULL, 10);
    40006f88:	f9400aa0 	ldr	x0, [x21, #16]
    40006f8c:	52800142 	mov	w2, #0xa                   	// #10
    40006f90:	d2800001 	mov	x1, #0x0                   	// #0
    40006f94:	94001789 	bl	4000cdb8 <strtoul>
    40006f98:	12001c13 	and	w19, w0, #0xff
	}

	shell_fprintf(sh, SHELL_NORMAL, "Using data width %d\n", width);
    40006f9c:	2a1303e3 	mov	w3, w19
    40006fa0:	aa1403e0 	mov	x0, x20
    40006fa4:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006fa8:	91142042 	add	x2, x2, #0x508
    40006fac:	52800101 	mov	w1, #0x8                   	// #8
    40006fb0:	9400078d 	bl	40008de4 <shell_fprintf>

	if (argc <= 3) {
    40006fb4:	f10012df 	cmp	x22, #0x4
    40006fb8:	54000460 	b.eq	40007044 <cmd_devmem+0x130>  // b.none
	switch (width) {
    40006fbc:	7100427f 	cmp	w19, #0x10
		return memory_read(sh, addr, width);
    40006fc0:	f9401fe3 	ldr	x3, [sp, #56]
	switch (width) {
    40006fc4:	54000280 	b.eq	40007014 <cmd_devmem+0x100>  // b.none
    40006fc8:	7100827f 	cmp	w19, #0x20
    40006fcc:	540002a0 	b.eq	40007020 <cmd_devmem+0x10c>  // b.none
    40006fd0:	7100227f 	cmp	w19, #0x8
    40006fd4:	540002a1 	b.ne	40007028 <cmd_devmem+0x114>  // b.any
 */
static ALWAYS_INLINE uint8_t sys_read8(mem_addr_t addr)
{
	uint8_t val;

	__asm__ volatile("ldrb %w0, [%1]" : "=r" (val) : "r" (addr));
    40006fd8:	39400063 	ldrb	w3, [x3]
    40006fdc:	12001c63 	and	w3, w3, #0xff
{
	uint32_t val;

	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));

	__DMB();
    40006fe0:	d5033fbf 	dmb	sy
		shell_fprintf(sh, SHELL_NORMAL, "Read value 0x%x\n", value);
    40006fe4:	f0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40006fe8:	9114cc42 	add	x2, x2, #0x533
    40006fec:	aa1403e0 	mov	x0, x20
    40006ff0:	52800101 	mov	w1, #0x8                   	// #8
    40006ff4:	9400077c 	bl	40008de4 <shell_fprintf>
	int err = 0;
    40006ff8:	52800000 	mov	w0, #0x0                   	// #0
	value = strtoul(argv[3], NULL, 16);

	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);

	return memory_write(sh, addr, width, value);
}
    40006ffc:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007000:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40007004:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40007008:	d65f03c0 	ret
		width = 32;
    4000700c:	52800413 	mov	w19, #0x20                  	// #32
    40007010:	17ffffe3 	b	40006f9c <cmd_devmem+0x88>
	__asm__ volatile("ldrh %w0, [%1]" : "=r" (val) : "r" (addr));
    40007014:	79400063 	ldrh	w3, [x3]
    40007018:	12003c63 	and	w3, w3, #0xffff
	__DMB();
    4000701c:	17fffff1 	b	40006fe0 <cmd_devmem+0xcc>
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    40007020:	b9400063 	ldr	w3, [x3]
    40007024:	17ffffef 	b	40006fe0 <cmd_devmem+0xcc>
		shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
    40007028:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000702c:	91147442 	add	x2, x2, #0x51d
    40007030:	aa1403e0 	mov	x0, x20
    40007034:	52800101 	mov	w1, #0x8                   	// #8
    40007038:	9400076b 	bl	40008de4 <shell_fprintf>
		return -EINVAL;
    4000703c:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40007040:	17ffffef 	b	40006ffc <cmd_devmem+0xe8>
	value = strtoul(argv[3], NULL, 16);
    40007044:	f9400ea0 	ldr	x0, [x21, #24]
    40007048:	52800202 	mov	w2, #0x10                  	// #16
    4000704c:	d2800001 	mov	x1, #0x0                   	// #0
    40007050:	9400175a 	bl	4000cdb8 <strtoul>
    40007054:	aa0003f5 	mov	x21, x0
	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);
    40007058:	2a0003e3 	mov	w3, w0
    4000705c:	52800101 	mov	w1, #0x8                   	// #8
    40007060:	aa1403e0 	mov	x0, x20
    40007064:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40007068:	91151042 	add	x2, x2, #0x544
    4000706c:	9400075e 	bl	40008de4 <shell_fprintf>
	return memory_write(sh, addr, width, value);
    40007070:	92407ea1 	and	x1, x21, #0xffffffff
	switch (width) {
    40007074:	7100427f 	cmp	w19, #0x10
	return memory_write(sh, addr, width, value);
    40007078:	f9401fe0 	ldr	x0, [sp, #56]
	switch (width) {
    4000707c:	54000100 	b.eq	4000709c <cmd_devmem+0x188>  // b.none
    40007080:	7100827f 	cmp	w19, #0x20
    40007084:	54000120 	b.eq	400070a8 <cmd_devmem+0x194>  // b.none
    40007088:	7100227f 	cmp	w19, #0x8
    4000708c:	54fffce1 	b.ne	40007028 <cmd_devmem+0x114>  // b.any
	__DMB();
    40007090:	d5033fbf 	dmb	sy
	__asm__ volatile("strb %w0, [%1]" : : "r" (data), "r" (addr));
    40007094:	39000001 	strb	w1, [x0]
    40007098:	17ffffd8 	b	40006ff8 <cmd_devmem+0xe4>
	__DMB();
    4000709c:	d5033fbf 	dmb	sy
	__asm__ volatile("strh %w0, [%1]" : : "r" (data), "r" (addr));
    400070a0:	79000001 	strh	w1, [x0]
    400070a4:	17ffffd5 	b	40006ff8 <cmd_devmem+0xe4>
	return val;
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	__DMB();
    400070a8:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400070ac:	b9000015 	str	w21, [x0]
    400070b0:	17ffffd2 	b	40006ff8 <cmd_devmem+0xe4>

00000000400070b4 <set_bypass.isra.0>:
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
    400070b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400070b8:	910003fd 	mov	x29, sp
    400070bc:	a90153f3 	stp	x19, x20, [sp, #16]
	if (bypass && in_use) {
    400070c0:	d00000d3 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    400070c4:	396f2662 	ldrb	w2, [x19, #3017]
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
    400070c8:	f90013f5 	str	x21, [sp, #32]
    400070cc:	aa0003f4 	mov	x20, x0
    400070d0:	aa0103f5 	mov	x21, x1
	if (bypass && in_use) {
    400070d4:	b4000121 	cbz	x1, 400070f8 <set_bypass.isra.0+0x44>
    400070d8:	34000102 	cbz	w2, 400070f8 <set_bypass.isra.0+0x44>
}
    400070dc:	a94153f3 	ldp	x19, x20, [sp, #16]
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
    400070e0:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400070e4:	91156042 	add	x2, x2, #0x558
    400070e8:	52800021 	mov	w1, #0x1                   	// #1
}
    400070ec:	f94013f5 	ldr	x21, [sp, #32]
    400070f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
    400070f4:	1400073c 	b	40008de4 <shell_fprintf>
	in_use = !in_use;
    400070f8:	52000042 	eor	w2, w2, #0x1
    400070fc:	392f2662 	strb	w2, [x19, #3017]
	if (in_use) {
    40007100:	34000102 	cbz	w2, 40007120 <set_bypass.isra.0+0x6c>
		shell_print(sh, "Loading...\npress ctrl-x ctrl-q to escape");
    40007104:	aa1403e0 	mov	x0, x20
    40007108:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000710c:	91164c42 	add	x2, x2, #0x593
    40007110:	52800101 	mov	w1, #0x8                   	// #8
    40007114:	94000734 	bl	40008de4 <shell_fprintf>
		in_use = true;
    40007118:	52800020 	mov	w0, #0x1                   	// #1
    4000711c:	392f2660 	strb	w0, [x19, #3017]
	shell_set_bypass(sh, bypass);
    40007120:	aa1503e1 	mov	x1, x21
    40007124:	aa1403e0 	mov	x0, x20
}
    40007128:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000712c:	f94013f5 	ldr	x21, [sp, #32]
    40007130:	a8c37bfd 	ldp	x29, x30, [sp], #48
	shell_set_bypass(sh, bypass);
    40007134:	140007ea 	b	400090dc <shell_set_bypass>

0000000040007138 <bypass_cb>:
{
    40007138:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000713c:	910003fd 	mov	x29, sp
    40007140:	a90153f3 	stp	x19, x20, [sp, #16]
    40007144:	aa0003f4 	mov	x20, x0
	if (tail == CHAR_CAN && recv[0] == CHAR_DC1) {
    40007148:	d00000c3 	adrp	x3, 40021000 <k_sys_work_q+0x200>
    4000714c:	396f2c60 	ldrb	w0, [x3, #3019]
    40007150:	aa0303e4 	mov	x4, x3
    40007154:	7100601f 	cmp	w0, #0x18
    40007158:	54000081 	b.ne	40007168 <bypass_cb+0x30>  // b.any
    4000715c:	39400020 	ldrb	w0, [x1]
    40007160:	7100441f 	cmp	w0, #0x11
    40007164:	54000640 	b.eq	4000722c <bypass_cb+0xf4>  // b.none
		for (int i = 0; i < (len - 1); i++) {
    40007168:	d1000442 	sub	x2, x2, #0x1
    4000716c:	52800003 	mov	w3, #0x0                   	// #0
    40007170:	93407c60 	sxtw	x0, w3
    40007174:	eb23c05f 	cmp	x2, w3, sxtw
    40007178:	540004c8 	b.hi	40007210 <bypass_cb+0xd8>  // b.pmore
	tail = recv[len - 1];
    4000717c:	38626820 	ldrb	w0, [x1, x2]
    40007180:	d00000d3 	adrp	x19, 40021000 <k_sys_work_q+0x200>
	if (is_ascii(*recv)) {
    40007184:	39400021 	ldrb	w1, [x1]
	tail = recv[len - 1];
    40007188:	392f2c80 	strb	w0, [x4, #3019]
	return (data >= 0x30 && data <= 0x39) || (data >= 0x61 && data <= 0x66) ||
    4000718c:	5100c020 	sub	w0, w1, #0x30
    40007190:	12001c00 	and	w0, w0, #0xff
    40007194:	7100241f 	cmp	w0, #0x9
    40007198:	540000c9 	b.ls	400071b0 <bypass_cb+0x78>  // b.plast
	if (is_ascii(*recv)) {
    4000719c:	121a7820 	and	w0, w1, #0xffffffdf
    400071a0:	51010400 	sub	w0, w0, #0x41
    400071a4:	12001c00 	and	w0, w0, #0xff
    400071a8:	7100141f 	cmp	w0, #0x5
    400071ac:	540000e8 	b.hi	400071c8 <bypass_cb+0x90>  // b.pmore
		chunk[chunk_element] = *recv;
    400071b0:	b9480a60 	ldr	w0, [x19, #2056]
    400071b4:	d00000c2 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    400071b8:	912f1c42 	add	x2, x2, #0xbc7
    400071bc:	3820c841 	strb	w1, [x2, w0, sxtw]
		chunk_element++;
    400071c0:	11000400 	add	w0, w0, #0x1
    400071c4:	b9080a60 	str	w0, [x19, #2056]
	if (chunk_element == 2) {
    400071c8:	b9480a60 	ldr	w0, [x19, #2056]
    400071cc:	7100081f 	cmp	w0, #0x2
    400071d0:	54000641 	b.ne	40007298 <bypass_cb+0x160>  // b.any
		byte = (uint8_t)strtoul(chunk, NULL, 16);
    400071d4:	52800202 	mov	w2, #0x10                  	// #16
    400071d8:	d2800001 	mov	x1, #0x0                   	// #0
    400071dc:	d00000c0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    400071e0:	912f1c00 	add	x0, x0, #0xbc7
    400071e4:	940016f5 	bl	4000cdb8 <strtoul>
		chunk_element = 0;
    400071e8:	b9080a7f 	str	wzr, [x19, #2056]
		*bytes = byte;
    400071ec:	d00000c2 	adrp	x2, 40021000 <k_sys_work_q+0x200>
		byte = (uint8_t)strtoul(chunk, NULL, 16);
    400071f0:	f9416c41 	ldr	x1, [x2, #728]
    400071f4:	38001420 	strb	w0, [x1], #1
		bytes++;
    400071f8:	f9016c41 	str	x1, [x2, #728]
		sum++;
    400071fc:	d00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40007200:	b9480c20 	ldr	w0, [x1, #2060]
    40007204:	11000400 	add	w0, w0, #0x1
    40007208:	b9080c20 	str	w0, [x1, #2060]
		chunk_element = 0;
    4000720c:	14000023 	b	40007298 <bypass_cb+0x160>
			if (recv[i] == CHAR_CAN && recv[i + 1] == CHAR_DC1) {
    40007210:	38606820 	ldrb	w0, [x1, x0]
    40007214:	11000463 	add	w3, w3, #0x1
    40007218:	7100601f 	cmp	w0, #0x18
    4000721c:	54fffaa1 	b.ne	40007170 <bypass_cb+0x38>  // b.any
    40007220:	3863c820 	ldrb	w0, [x1, w3, sxtw]
    40007224:	7100441f 	cmp	w0, #0x11
    40007228:	54fffa41 	b.ne	40007170 <bypass_cb+0x38>  // b.any
		shell_print(sh, "Number of bytes read: %d", sum);
    4000722c:	d00000d3 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    40007230:	b9480e63 	ldr	w3, [x19, #2060]
    40007234:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40007238:	9116f442 	add	x2, x2, #0x5bd
    4000723c:	aa1403e0 	mov	x0, x20
    40007240:	52800101 	mov	w1, #0x8                   	// #8
    40007244:	940006e8 	bl	40008de4 <shell_fprintf>
		set_bypass(sh, NULL);
    40007248:	aa1403e0 	mov	x0, x20
    4000724c:	d2800001 	mov	x1, #0x0                   	// #0
    40007250:	97ffff99 	bl	400070b4 <set_bypass.isra.0>
		if (!littleendian) {
    40007254:	d00000c0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40007258:	396f2803 	ldrb	w3, [x0, #3018]
    4000725c:	350001e3 	cbnz	w3, 40007298 <bypass_cb+0x160>
    40007260:	d00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40007264:	f9417022 	ldr	x2, [x1, #736]
    40007268:	b9480e60 	ldr	w0, [x19, #2060]
			while (sum > 4) {
    4000726c:	7100101f 	cmp	w0, #0x4
    40007270:	540001ac 	b.gt	400072a4 <bypass_cb+0x16c>
    40007274:	34000063 	cbz	w3, 40007280 <bypass_cb+0x148>
    40007278:	f9017022 	str	x2, [x1, #736]
    4000727c:	b9080e60 	str	w0, [x19, #2060]
			if (sum % 4 == 0) {
    40007280:	72000402 	ands	w2, w0, #0x3
    40007284:	540001c1 	b.ne	400072bc <bypass_cb+0x184>  // b.any
				*data = __bswap_32(*data);
    40007288:	f9417021 	ldr	x1, [x1, #736]
    4000728c:	b9400020 	ldr	w0, [x1]
    40007290:	5ac00800 	rev	w0, w0
				*data = __bswap_16(*data);
    40007294:	b9000020 	str	w0, [x1]
}
    40007298:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000729c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400072a0:	d65f03c0 	ret
				*data = __bswap_32(*data);
    400072a4:	b9400043 	ldr	w3, [x2]
				sum = sum - 4;
    400072a8:	51001000 	sub	w0, w0, #0x4
    400072ac:	5ac00863 	rev	w3, w3
				*data = __bswap_32(*data);
    400072b0:	b8004443 	str	w3, [x2], #4
				sum = sum - 4;
    400072b4:	52800023 	mov	w3, #0x1                   	// #1
    400072b8:	17ffffed 	b	4000726c <bypass_cb+0x134>
			} else if (sum % 4 == 2) {
    400072bc:	6b0003e0 	negs	w0, w0
    400072c0:	12000400 	and	w0, w0, #0x3
    400072c4:	5a804440 	csneg	w0, w2, w0, mi  // mi = first
    400072c8:	7100081f 	cmp	w0, #0x2
    400072cc:	540000c1 	b.ne	400072e4 <bypass_cb+0x1ac>  // b.any
				*data = __bswap_16(*data);
    400072d0:	f9417021 	ldr	x1, [x1, #736]
    400072d4:	79400020 	ldrh	w0, [x1]
    400072d8:	5ac00400 	rev16	w0, w0
    400072dc:	12003c00 	and	w0, w0, #0xffff
    400072e0:	17ffffed 	b	40007294 <bypass_cb+0x15c>
			} else if (sum % 4 == 3) {
    400072e4:	71000c1f 	cmp	w0, #0x3
    400072e8:	54fffd81 	b.ne	40007298 <bypass_cb+0x160>  // b.any
				*data = __bswap_24(*data);
    400072ec:	f9417022 	ldr	x2, [x1, #736]
    400072f0:	b9400041 	ldr	w1, [x2]
    400072f4:	d3505c20 	ubfx	x0, x1, #16, #8
    400072f8:	53101c23 	ubfiz	w3, w1, #16, #8
    400072fc:	2a030000 	orr	w0, w0, w3
    40007300:	12181c21 	and	w1, w1, #0xff00
    40007304:	2a010000 	orr	w0, w0, w1
    40007308:	b9000040 	str	w0, [x2]
    4000730c:	17ffffe3 	b	40007298 <bypass_cb+0x160>

0000000040007310 <cmd_load>:
{
    40007310:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40007314:	910003fd 	mov	x29, sp
    40007318:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000731c:	aa0103f5 	mov	x21, x1
	chunk_element = 0;
    40007320:	d00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
{
    40007324:	aa0003f6 	mov	x22, x0
	littleendian = false;
    40007328:	d00000c0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
	chunk_element = 0;
    4000732c:	b908083f 	str	wzr, [x1, #2056]
	sum = 0;
    40007330:	d00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
{
    40007334:	a90153f3 	stp	x19, x20, [sp, #16]
    40007338:	aa0203f3 	mov	x19, x2
    4000733c:	a90363f7 	stp	x23, x24, [sp, #48]
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    40007340:	d0000077 	adrp	x23, 40015000 <prefix.1+0x2aa>
    40007344:	91175ef7 	add	x23, x23, #0x5d7
{
    40007348:	a9046bf9 	stp	x25, x26, [sp, #64]
		if (!strncmp(arg, "-e", 2)) {
    4000734c:	d0000079 	adrp	x25, 40015000 <prefix.1+0x2aa>
    40007350:	91176b39 	add	x25, x25, #0x5da
    40007354:	aa0003fa 	mov	x26, x0
	littleendian = false;
    40007358:	392f281f 	strb	wzr, [x0, #3018]
	sum = 0;
    4000735c:	b9080c3f 	str	wzr, [x1, #2060]
{
    40007360:	f9002bfb 	str	x27, [sp, #80]
	while (argc >= 2) {
    40007364:	f10006bf 	cmp	x21, #0x1
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    40007368:	f9400678 	ldr	x24, [x19, #8]
	while (argc >= 2) {
    4000736c:	540003a9 	b.ls	400073e0 <cmd_load+0xd0>  // b.plast
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    40007370:	aa1703e1 	mov	x1, x23
    40007374:	aa1803e0 	mov	x0, x24
    40007378:	d2800042 	mov	x2, #0x2                   	// #2
    4000737c:	940017bc 	bl	4000d26c <strncmp>
    40007380:	35000220 	cbnz	w0, 400073c4 <cmd_load+0xb4>
    40007384:	f9400660 	ldr	x0, [x19, #8]
    40007388:	39400800 	ldrb	w0, [x0, #2]
    4000738c:	7100001f 	cmp	w0, #0x0
    40007390:	1a9f07f4 	cset	w20, ne  // ne = any
    40007394:	93407e9b 	sxtw	x27, w20
    40007398:	8b34c314 	add	x20, x24, w20, sxtw
		if (!strncmp(arg, "-e", 2)) {
    4000739c:	aa1903e1 	mov	x1, x25
    400073a0:	aa1403e0 	mov	x0, x20
    400073a4:	d2800042 	mov	x2, #0x2                   	// #2
    400073a8:	940017b1 	bl	4000d26c <strncmp>
    400073ac:	35000100 	cbnz	w0, 400073cc <cmd_load+0xbc>
			littleendian = true;
    400073b0:	52800020 	mov	w0, #0x1                   	// #1
    400073b4:	392f2b40 	strb	w0, [x26, #3018]
		argv++;
    400073b8:	91002273 	add	x19, x19, #0x8
		argc--;
    400073bc:	d10006b5 	sub	x21, x21, #0x1
    400073c0:	17ffffe9 	b	40007364 <cmd_load+0x54>
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    400073c4:	52800014 	mov	w20, #0x0                   	// #0
    400073c8:	17fffff3 	b	40007394 <cmd_load+0x84>
		} else if (!strcmp(arg, "--")) {
    400073cc:	aa1703e1 	mov	x1, x23
    400073d0:	aa1403e0 	mov	x0, x20
    400073d4:	9400179d 	bl	4000d248 <strcmp>
    400073d8:	35000340 	cbnz	w0, 40007440 <cmd_load+0x130>
			argv++;
    400073dc:	91002273 	add	x19, x19, #0x8
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
    400073e0:	f9400660 	ldr	x0, [x19, #8]
    400073e4:	52800002 	mov	w2, #0x0                   	// #0
    400073e8:	d2800001 	mov	x1, #0x0                   	// #0
    400073ec:	94001611 	bl	4000cc30 <strtol>
    400073f0:	d00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
	data = (uint32_t *)strtol(argv[1], NULL, 0);
    400073f4:	52800002 	mov	w2, #0x0                   	// #0
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
    400073f8:	f9016c20 	str	x0, [x1, #728]
	data = (uint32_t *)strtol(argv[1], NULL, 0);
    400073fc:	d2800001 	mov	x1, #0x0                   	// #0
    40007400:	f9400660 	ldr	x0, [x19, #8]
    40007404:	9400160b 	bl	4000cc30 <strtol>
    40007408:	d00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000740c:	f9017020 	str	x0, [x1, #736]
	set_bypass(sh, bypass_cb);
    40007410:	aa1603e0 	mov	x0, x22
    40007414:	90000001 	adrp	x1, 40007000 <cmd_devmem+0xec>
    40007418:	9104e021 	add	x1, x1, #0x138
    4000741c:	97ffff26 	bl	400070b4 <set_bypass.isra.0>
}
    40007420:	52800000 	mov	w0, #0x0                   	// #0
    40007424:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007428:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000742c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40007430:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40007434:	f9402bfb 	ldr	x27, [sp, #80]
    40007438:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000743c:	d65f03c0 	ret
		} else if (arg[0] == '-' && arg[1]) {
    40007440:	387b6b00 	ldrb	w0, [x24, x27]
    40007444:	7100b41f 	cmp	w0, #0x2d
    40007448:	54fffcc1 	b.ne	400073e0 <cmd_load+0xd0>  // b.any
    4000744c:	39400680 	ldrb	w0, [x20, #1]
    40007450:	34fffc80 	cbz	w0, 400073e0 <cmd_load+0xd0>
			shell_print(sh, "Unknown option \"%s\"", arg);
    40007454:	aa1403e3 	mov	x3, x20
    40007458:	aa1603e0 	mov	x0, x22
    4000745c:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40007460:	91177442 	add	x2, x2, #0x5dd
    40007464:	52800101 	mov	w1, #0x8                   	// #8
    40007468:	9400065f 	bl	40008de4 <shell_fprintf>
    4000746c:	17ffffd3 	b	400073b8 <cmd_load+0xa8>

0000000040007470 <uart_irq_tx_disable>:
	if (api->irq_tx_disable != NULL) {
    40007470:	f9400801 	ldr	x1, [x0, #16]
    40007474:	f9402021 	ldr	x1, [x1, #64]
    40007478:	b4000061 	cbz	x1, 40007484 <uart_irq_tx_disable+0x14>
		api->irq_tx_disable(dev);
    4000747c:	aa0103f0 	mov	x16, x1
    40007480:	d61f0200 	br	x16
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_disable(dev);
}
    40007484:	d65f03c0 	ret

0000000040007488 <uninit>:

	return 0;
}

static int uninit(const struct shell_transport *transport)
{
    40007488:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000748c:	910003fd 	mov	x29, sp
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN)) {
		const struct device *dev = sh_uart->ctrl_blk->dev;
    40007490:	f9400400 	ldr	x0, [x0, #8]
    40007494:	f9400000 	ldr	x0, [x0]
{
    40007498:	f9000bf3 	str	x19, [sp, #16]
		const struct device *dev = sh_uart->ctrl_blk->dev;
    4000749c:	f9400013 	ldr	x19, [x0]

		uart_irq_tx_disable(dev);
    400074a0:	aa1303e0 	mov	x0, x19
    400074a4:	97fffff3 	bl	40007470 <uart_irq_tx_disable>
	if (api->irq_rx_disable != NULL) {
    400074a8:	f9400a60 	ldr	x0, [x19, #16]
    400074ac:	f9402c01 	ldr	x1, [x0, #88]
    400074b0:	b4000061 	cbz	x1, 400074bc <uninit+0x34>
		api->irq_rx_disable(dev);
    400074b4:	aa1303e0 	mov	x0, x19
    400074b8:	d63f0020 	blr	x1
	} else {
		k_timer_stop(sh_uart->timer);
	}

	return 0;
}
    400074bc:	52800000 	mov	w0, #0x0                   	// #0
    400074c0:	f9400bf3 	ldr	x19, [sp, #16]
    400074c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400074c8:	d65f03c0 	ret

00000000400074cc <enable>:

static int enable(const struct shell_transport *transport, bool blocking_tx)
{
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
    400074cc:	f9400400 	ldr	x0, [x0, #8]
{
    400074d0:	12001c21 	and	w1, w1, #0xff
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
    400074d4:	f9400000 	ldr	x0, [x0]
    400074d8:	39008001 	strb	w1, [x0, #32]

	if (blocking_tx) {
    400074dc:	34000101 	cbz	w1, 400074fc <enable+0x30>
{
    400074e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400074e4:	910003fd 	mov	x29, sp
#ifdef CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
    400074e8:	f9400000 	ldr	x0, [x0]
    400074ec:	97ffffe1 	bl	40007470 <uart_irq_tx_disable>
#endif
	}

	return 0;
}
    400074f0:	52800000 	mov	w0, #0x0                   	// #0
    400074f4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400074f8:	d65f03c0 	ret
    400074fc:	52800000 	mov	w0, #0x0                   	// #0
    40007500:	d65f03c0 	ret

0000000040007504 <read>:
	return 0;
}

static int read(const struct shell_transport *transport,
		void *data, size_t length, size_t *cnt)
{
    40007504:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40007508:	910003fd 	mov	x29, sp
	struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
    4000750c:	f9400400 	ldr	x0, [x0, #8]
    40007510:	f9400c00 	ldr	x0, [x0, #24]
{
    40007514:	f9000bf3 	str	x19, [sp, #16]
    40007518:	aa0303f3 	mov	x19, x3
	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
    4000751c:	97fff1dd 	bl	40003c90 <ring_buf_get>
    40007520:	2a0003e0 	mov	w0, w0
    40007524:	f9000260 	str	x0, [x19]

	return 0;
}
    40007528:	52800000 	mov	w0, #0x0                   	// #0
    4000752c:	f9400bf3 	ldr	x19, [sp, #16]
    40007530:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40007534:	d65f03c0 	ret

0000000040007538 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_SMP_SHELL */
};

static int enable_shell_uart(const struct device *arg)
{
    40007538:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000753c:	910003fd 	mov	x29, sp
    40007540:	f9000bf3 	str	x19, [sp, #16]
    40007544:	f0000053 	adrp	x19, 40012000 <__rodata_region_start>
    40007548:	91024273 	add	x19, x19, #0x90
    4000754c:	aa1303e0 	mov	x0, x19
    40007550:	94001b80 	bl	4000e350 <z_device_ready>
    40007554:	72001c1f 	tst	w0, #0xff
    40007558:	540001a0 	b.eq	4000758c <enable_shell_uart+0x54>  // b.none

	if (IS_ENABLED(CONFIG_MCUMGR_SMP_SHELL)) {
		smp_shell_init();
	}

	shell_init(&shell_uart, dev, cfg_flags, log_backend, level);
    4000755c:	b0000060 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    40007560:	b944a402 	ldr	w2, [x0, #1188]
    40007564:	aa1303e1 	mov	x1, x19
    40007568:	52800084 	mov	w4, #0x4                   	// #4
    4000756c:	52800023 	mov	w3, #0x1                   	// #1
    40007570:	f0000040 	adrp	x0, 40012000 <__rodata_region_start>
    40007574:	913cc000 	add	x0, x0, #0xf30
    40007578:	9400051c 	bl	400089e8 <shell_init>

	return 0;
    4000757c:	52800000 	mov	w0, #0x0                   	// #0
}
    40007580:	f9400bf3 	ldr	x19, [sp, #16]
    40007584:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40007588:	d65f03c0 	ret
		return -ENODEV;
    4000758c:	12800240 	mov	w0, #0xffffffed            	// #-19
    40007590:	17fffffc 	b	40007580 <enable_shell_uart+0x48>

0000000040007594 <write>:
{
    40007594:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40007598:	910003fd 	mov	x29, sp
    4000759c:	a9025bf5 	stp	x21, x22, [sp, #32]
    400075a0:	aa0303f6 	mov	x22, x3
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
    400075a4:	f9400415 	ldr	x21, [x0, #8]
{
    400075a8:	a90153f3 	stp	x19, x20, [sp, #16]
    400075ac:	aa0203f4 	mov	x20, x2
		!sh_uart->ctrl_blk->blocking_tx) {
    400075b0:	f94002a0 	ldr	x0, [x21]
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
    400075b4:	39408000 	ldrb	w0, [x0, #32]
{
    400075b8:	f9001bf7 	str	x23, [sp, #48]
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
    400075bc:	34000160 	cbz	w0, 400075e8 <write+0x54>
    400075c0:	aa0103f3 	mov	x19, x1
    400075c4:	8b020037 	add	x23, x1, x2
		for (size_t i = 0; i < length; i++) {
    400075c8:	eb17027f 	cmp	x19, x23
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
    400075cc:	f94002a0 	ldr	x0, [x21]
		for (size_t i = 0; i < length; i++) {
    400075d0:	54000361 	b.ne	4000763c <write+0xa8>  // b.any
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    400075d4:	a9408402 	ldp	x2, x1, [x0, #8]
		*cnt = length;
    400075d8:	f90002d4 	str	x20, [x22]
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    400075dc:	52800020 	mov	w0, #0x1                   	// #1
    400075e0:	d63f0040 	blr	x2
    400075e4:	14000010 	b	40007624 <write+0x90>
	*cnt = ring_buf_put(sh_uart->tx_ringbuf, data, length);
    400075e8:	f9400aa0 	ldr	x0, [x21, #16]
    400075ec:	97fff143 	bl	40003af8 <ring_buf_put>
    400075f0:	2a0003e0 	mov	w0, w0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    400075f4:	f94002a1 	ldr	x1, [x21]
    400075f8:	f90002c0 	str	x0, [x22]
    400075fc:	d2800020 	mov	x0, #0x1                   	// #1
    40007600:	91006021 	add	x1, x1, #0x18
    40007604:	97ffe663 	bl	40000f90 <__aarch64_swp8_acq_rel>
	if (atomic_set(&sh_uart->ctrl_blk->tx_busy, 1) == 0) {
    40007608:	b50000e0 	cbnz	x0, 40007624 <write+0x90>
		uart_irq_tx_enable(sh_uart->ctrl_blk->dev);
    4000760c:	f94002a0 	ldr	x0, [x21]
    40007610:	f9400000 	ldr	x0, [x0]
	if (api->irq_tx_enable != NULL) {
    40007614:	f9400801 	ldr	x1, [x0, #16]
    40007618:	f9401c21 	ldr	x1, [x1, #56]
    4000761c:	b4000041 	cbz	x1, 40007624 <write+0x90>
		api->irq_tx_enable(dev);
    40007620:	d63f0020 	blr	x1
}
    40007624:	52800000 	mov	w0, #0x0                   	// #0
    40007628:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000762c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40007630:	f9401bf7 	ldr	x23, [sp, #48]
    40007634:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40007638:	d65f03c0 	ret
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
    4000763c:	38401661 	ldrb	w1, [x19], #1
    40007640:	f9400000 	ldr	x0, [x0]
	api->poll_out(dev, out_char);
    40007644:	f9400802 	ldr	x2, [x0, #16]
    40007648:	f9400442 	ldr	x2, [x2, #8]
    4000764c:	d63f0040 	blr	x2
		for (size_t i = 0; i < length; i++) {
    40007650:	17ffffde 	b	400075c8 <write+0x34>

0000000040007654 <init>:
{
    40007654:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40007658:	910003fd 	mov	x29, sp
    4000765c:	a90153f3 	stp	x19, x20, [sp, #16]
    40007660:	aa0103f3 	mov	x19, x1
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
    40007664:	f9400414 	ldr	x20, [x0, #8]
	sh_uart->ctrl_blk->dev = (const struct device *)config;
    40007668:	f9400280 	ldr	x0, [x20]
	sh_uart->ctrl_blk->handler = evt_handler;
    4000766c:	a9000801 	stp	x1, x2, [x0]
 */
static inline void ring_buf_reset(struct ring_buf *buf)
{
	buf->head = 0;
	buf->tail = 0;
	memset(&buf->misc, 0, sizeof(buf->misc));
    40007670:	d2800102 	mov	x2, #0x8                   	// #8
    40007674:	52800001 	mov	w1, #0x0                   	// #0
	sh_uart->ctrl_blk->context = context;
    40007678:	f9000803 	str	x3, [x0, #16]
	buf->head = 0;
    4000767c:	f9400a80 	ldr	x0, [x20, #16]
    40007680:	f800841f 	str	xzr, [x0], #8
	memset(&buf->misc, 0, sizeof(buf->misc));
    40007684:	9400172c 	bl	4000d334 <memset>
	buf->head = 0;
    40007688:	f9400e80 	ldr	x0, [x20, #24]
	memset(&buf->misc, 0, sizeof(buf->misc));
    4000768c:	d2800102 	mov	x2, #0x8                   	// #8
    40007690:	52800001 	mov	w1, #0x0                   	// #0
	buf->head = 0;
    40007694:	f800841f 	str	xzr, [x0], #8
	memset(&buf->misc, 0, sizeof(buf->misc));
    40007698:	94001727 	bl	4000d334 <memset>
	sh_uart->ctrl_blk->tx_busy = 0;
    4000769c:	f9400280 	ldr	x0, [x20]
    400076a0:	f9000c1f 	str	xzr, [x0, #24]
	const struct uart_driver_api *api =
    400076a4:	f9400a60 	ldr	x0, [x19, #16]
	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    400076a8:	b4000100 	cbz	x0, 400076c8 <init+0x74>
    400076ac:	f9404803 	ldr	x3, [x0, #144]
    400076b0:	b40000c3 	cbz	x3, 400076c8 <init+0x74>
		api->irq_callback_set(dev, cb, user_data);
    400076b4:	90000001 	adrp	x1, 40007000 <cmd_devmem+0xec>
    400076b8:	911bb021 	add	x1, x1, #0x6ec
    400076bc:	aa1403e2 	mov	x2, x20
    400076c0:	aa1303e0 	mov	x0, x19
    400076c4:	d63f0060 	blr	x3
	if (api->irq_rx_enable != NULL) {
    400076c8:	f9400a60 	ldr	x0, [x19, #16]
    400076cc:	f9402801 	ldr	x1, [x0, #80]
    400076d0:	b4000061 	cbz	x1, 400076dc <init+0x88>
		api->irq_rx_enable(dev);
    400076d4:	aa1303e0 	mov	x0, x19
    400076d8:	d63f0020 	blr	x1
}
    400076dc:	52800000 	mov	w0, #0x0                   	// #0
    400076e0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400076e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400076e8:	d65f03c0 	ret

00000000400076ec <uart_callback>:
{
    400076ec:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    400076f0:	910003fd 	mov	x29, sp
    400076f4:	a90153f3 	stp	x19, x20, [sp, #16]
    400076f8:	a9025bf5 	stp	x21, x22, [sp, #32]
    400076fc:	aa0103f5 	mov	x21, x1
    40007700:	a90363f7 	stp	x23, x24, [sp, #48]
    40007704:	a9046bf9 	stp	x25, x26, [sp, #64]
    40007708:	aa0003fa 	mov	x26, x0
	if (api->irq_update == NULL) {
    4000770c:	f9400801 	ldr	x1, [x0, #16]
    40007710:	f9404421 	ldr	x1, [x1, #136]
    40007714:	b4000041 	cbz	x1, 4000771c <uart_callback+0x30>
	return api->irq_update(dev);
    40007718:	d63f0020 	blr	x1
	if (api->irq_rx_ready == NULL) {
    4000771c:	f9400b40 	ldr	x0, [x26, #16]
    40007720:	f9403401 	ldr	x1, [x0, #104]
    40007724:	b5000501 	cbnz	x1, 400077c4 <uart_callback+0xd8>
	return ((uint8_t *)data - (uint8_t *)__log_dynamic_start)/
    40007728:	90000357 	adrp	x23, 4006f000 <sys_work_q_stack+0xc10>
    4000772c:	913392f7 	add	x23, x23, #0xce4
    40007730:	90000354 	adrp	x20, 4006f000 <sys_work_q_stack+0xc10>
    40007734:	91334294 	add	x20, x20, #0xcd0
    40007738:	cb1402f4 	sub	x20, x23, x20
			LOG_WRN("RX ring buffer full.");
    4000773c:	d0000079 	adrp	x25, 40015000 <prefix.1+0x2aa>
    40007740:	9119ff39 	add	x25, x25, #0x67f
    40007744:	52800018 	mov	w24, #0x0                   	// #0
    40007748:	d342fe94 	lsr	x20, x20, #2
    4000774c:	531a2694 	ubfiz	w20, w20, #6, #10
    40007750:	321f0294 	orr	w20, w20, #0x2
		len = ring_buf_put_claim(sh_uart->rx_ringbuf, &data,
    40007754:	f9400ea0 	ldr	x0, [x21, #24]
    40007758:	910163e1 	add	x1, sp, #0x58
    4000775c:	b9401002 	ldr	w2, [x0, #16]
    40007760:	97fff0b5 	bl	40003a34 <ring_buf_put_claim>
    40007764:	2a0003f6 	mov	w22, w0
		if (len > 0) {
    40007768:	34000540 	cbz	w0, 40007810 <uart_callback+0x124>
	if (api->fifo_read == NULL) {
    4000776c:	f9400b40 	ldr	x0, [x26, #16]
			rd_len = uart_fifo_read(dev, data, len);
    40007770:	f9402fe1 	ldr	x1, [sp, #88]
    40007774:	f9401803 	ldr	x3, [x0, #48]
    40007778:	b4000483 	cbz	x3, 40007808 <uart_callback+0x11c>
	return api->fifo_read(dev, rx_data, size);
    4000777c:	2a1603e2 	mov	w2, w22
    40007780:	aa1a03e0 	mov	x0, x26
    40007784:	d63f0060 	blr	x3
    40007788:	2a0003f3 	mov	w19, w0
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
    4000778c:	f9400ea0 	ldr	x0, [x21, #24]
				new_data = true;
    40007790:	7100027f 	cmp	w19, #0x0
    40007794:	1a9f0718 	csinc	w24, w24, wzr, eq  // eq = none
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
    40007798:	2a1303e1 	mov	w1, w19
    4000779c:	97fff0bd 	bl	40003a90 <ring_buf_put_finish>
	} while (rd_len && (rd_len == len));
    400077a0:	7100027f 	cmp	w19, #0x0
    400077a4:	7a5312c0 	ccmp	w22, w19, #0x0, ne  // ne = any
    400077a8:	54fffd60 	b.eq	40007754 <uart_callback+0x68>  // b.none
	if (new_data) {
    400077ac:	34000138 	cbz	w24, 400077d0 <uart_callback+0xe4>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
    400077b0:	f94002a0 	ldr	x0, [x21]
    400077b4:	a9408402 	ldp	x2, x1, [x0, #8]
    400077b8:	52800000 	mov	w0, #0x0                   	// #0
    400077bc:	d63f0040 	blr	x2
}
    400077c0:	14000004 	b	400077d0 <uart_callback+0xe4>
	return api->irq_rx_ready(dev);
    400077c4:	aa1a03e0 	mov	x0, x26
    400077c8:	d63f0020 	blr	x1
	if (uart_irq_rx_ready(dev)) {
    400077cc:	35fffae0 	cbnz	w0, 40007728 <uart_callback+0x3c>
	if (api->irq_tx_ready == NULL) {
    400077d0:	f9400b40 	ldr	x0, [x26, #16]
    400077d4:	f9402401 	ldr	x1, [x0, #72]
    400077d8:	b50003e1 	cbnz	x1, 40007854 <uart_callback+0x168>
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (uint8_t **)&data,
    400077dc:	f9400aa0 	ldr	x0, [x21, #16]
    400077e0:	910163e1 	add	x1, sp, #0x58
    400077e4:	b9401002 	ldr	w2, [x0, #16]
    400077e8:	97fff0e4 	bl	40003b78 <ring_buf_get_claim>
    400077ec:	2a0003e2 	mov	w2, w0
	if (len) {
    400077f0:	35000440 	cbnz	w0, 40007878 <uart_callback+0x18c>
		uart_irq_tx_disable(dev);
    400077f4:	aa1a03e0 	mov	x0, x26
    400077f8:	97ffff1e 	bl	40007470 <uart_irq_tx_disable>
		sh_uart->ctrl_blk->tx_busy = 0;
    400077fc:	f94002a0 	ldr	x0, [x21]
    40007800:	f9000c1f 	str	xzr, [x0, #24]
    40007804:	14000026 	b	4000789c <uart_callback+0x1b0>
		return -ENOSYS;
    40007808:	12800af3 	mov	w19, #0xffffffa8            	// #-88
    4000780c:	17ffffe0 	b	4000778c <uart_callback+0xa0>
			LOG_WRN("RX ring buffer full.");
    40007810:	b94002e0 	ldr	w0, [x23]
    40007814:	721f041f 	tst	w0, #0x6
    40007818:	54000080 	b.eq	40007828 <uart_callback+0x13c>  // b.none
    4000781c:	2a1403e1 	mov	w1, w20
    40007820:	aa1903e0 	mov	x0, x25
    40007824:	97fff41f 	bl	400048a0 <log_0>
	if (api->fifo_read == NULL) {
    40007828:	f9400b40 	ldr	x0, [x26, #16]
    4000782c:	f9401803 	ldr	x3, [x0, #48]
    40007830:	b40000e3 	cbz	x3, 4000784c <uart_callback+0x160>
	return api->fifo_read(dev, rx_data, size);
    40007834:	91015fe1 	add	x1, sp, #0x57
    40007838:	aa1a03e0 	mov	x0, x26
    4000783c:	52800022 	mov	w2, #0x1                   	// #1
    40007840:	d63f0060 	blr	x3
    40007844:	2a0003f3 	mov	w19, w0
    40007848:	17ffffd6 	b	400077a0 <uart_callback+0xb4>
		return -ENOSYS;
    4000784c:	12800af3 	mov	w19, #0xffffffa8            	// #-88
    40007850:	17ffffd4 	b	400077a0 <uart_callback+0xb4>
	return api->irq_tx_ready(dev);
    40007854:	aa1a03e0 	mov	x0, x26
    40007858:	d63f0020 	blr	x1
	if (uart_irq_tx_ready(dev)) {
    4000785c:	35fffc00 	cbnz	w0, 400077dc <uart_callback+0xf0>
}
    40007860:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007864:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40007868:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000786c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40007870:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40007874:	d65f03c0 	ret
	if (api->fifo_fill == NULL) {
    40007878:	f9400b40 	ldr	x0, [x26, #16]
		len = uart_fifo_fill(dev, data, len);
    4000787c:	f9402fe1 	ldr	x1, [sp, #88]
    40007880:	f9401403 	ldr	x3, [x0, #40]
    40007884:	b4000163 	cbz	x3, 400078b0 <uart_callback+0x1c4>
	return api->fifo_fill(dev, tx_data, size);
    40007888:	aa1a03e0 	mov	x0, x26
    4000788c:	d63f0060 	blr	x3
    40007890:	2a0003e1 	mov	w1, w0
		err = ring_buf_get_finish(sh_uart->tx_ringbuf, len);
    40007894:	f9400aa0 	ldr	x0, [x21, #16]
    40007898:	97fff0df 	bl	40003c14 <ring_buf_get_finish>
	sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    4000789c:	f94002a0 	ldr	x0, [x21]
    400078a0:	a9408402 	ldp	x2, x1, [x0, #8]
    400078a4:	52800020 	mov	w0, #0x1                   	// #1
    400078a8:	d63f0040 	blr	x2
}
    400078ac:	17ffffed 	b	40007860 <uart_callback+0x174>
		return -ENOSYS;
    400078b0:	12800ae1 	mov	w1, #0xffffffa8            	// #-88
    400078b4:	17fffff8 	b	40007894 <uart_callback+0x1a8>

00000000400078b8 <shell_backend_uart_get_ptr>:
	 CONFIG_SHELL_BACKEND_SERIAL_INIT_PRIORITY);

const struct shell *shell_backend_uart_get_ptr(void)
{
	return &shell_uart;
}
    400078b8:	f0000040 	adrp	x0, 40012000 <__rodata_region_start>
    400078bc:	913cc000 	add	x0, x0, #0xf30
    400078c0:	d65f03c0 	ret

00000000400078c4 <atomic_or>:
 * @param value Value to OR.
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
    400078c4:	aa0003e2 	mov	x2, x0
    400078c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400078cc:	aa0103e0 	mov	x0, x1
    400078d0:	910003fd 	mov	x29, sp
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    400078d4:	aa0203e1 	mov	x1, x2
    400078d8:	97ffe5d2 	bl	40001020 <__aarch64_ldset8_acq_rel>
}
    400078dc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400078e0:	d65f03c0 	ret

00000000400078e4 <atomic_and>:
 * @param value Value to AND.
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
    400078e4:	aa0103e2 	mov	x2, x1
    400078e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    400078ec:	aa0003e1 	mov	x1, x0
{
    400078f0:	910003fd 	mov	x29, sp
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    400078f4:	aa2203e0 	mvn	x0, x2
    400078f8:	97ffe5be 	bl	40000ff0 <__aarch64_ldclr8_acq_rel>
}
    400078fc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007900:	d65f03c0 	ret

0000000040007904 <shell_signal_handle>:
typedef void (*shell_signal_handler_t)(const struct shell *shell);

static void shell_signal_handle(const struct shell *shell,
				enum shell_signal sig_idx,
				shell_signal_handler_t handler)
{
    40007904:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    40007908:	2a0103e1 	mov	w1, w1
{
    4000790c:	910003fd 	mov	x29, sp
    40007910:	a90153f3 	stp	x19, x20, [sp, #16]
    40007914:	aa0003f3 	mov	x19, x0
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    40007918:	d2800300 	mov	x0, #0x18                  	// #24
    4000791c:	9b007c21 	mul	x1, x1, x0
    40007920:	f9400a74 	ldr	x20, [x19, #16]
    40007924:	910aa021 	add	x1, x1, #0x2a8
{
    40007928:	f90013f5 	str	x21, [sp, #32]
    4000792c:	aa0203f5 	mov	x21, x2
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    40007930:	8b010294 	add	x20, x20, x1
		arch_syscall_invoke3(*(uintptr_t *)&sig, *(uintptr_t *)&signaled, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_CHECK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_check(sig, signaled, result);
    40007934:	aa1403e0 	mov	x0, x20
    40007938:	9100f3e2 	add	x2, sp, #0x3c
    4000793c:	9100e3e1 	add	x1, sp, #0x38
    40007940:	9400271a 	bl	400115a8 <z_impl_k_poll_signal_check>
	int set;
	int res;

	k_poll_signal_check(signal, &set, &res);

	if (set) {
    40007944:	b9403be0 	ldr	w0, [sp, #56]
    40007948:	340000a0 	cbz	w0, 4000795c <shell_signal_handle+0x58>
	z_impl_k_poll_signal_reset(sig);
    4000794c:	aa1403e0 	mov	x0, x20
    40007950:	94002714 	bl	400115a0 <z_impl_k_poll_signal_reset>
		k_poll_signal_reset(signal);
		handler(shell);
    40007954:	aa1303e0 	mov	x0, x19
    40007958:	d63f02a0 	blr	x21
	}
}
    4000795c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007960:	f94013f5 	ldr	x21, [sp, #32]
    40007964:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40007968:	d65f03c0 	ret

000000004000796c <z_shell_strlen>:
void z_shell_multiline_data_calc(struct shell_multiline_cons *cons,
				 uint16_t buff_pos, uint16_t buff_len);

static inline uint16_t z_shell_strlen(const char *str)
{
	return str == NULL ? 0U : (uint16_t)strlen(str);
    4000796c:	b40000e0 	cbz	x0, 40007988 <z_shell_strlen+0x1c>
{
    40007970:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40007974:	910003fd 	mov	x29, sp
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40007978:	94001624 	bl	4000d208 <strlen>
    4000797c:	12003c00 	and	w0, w0, #0xffff
}
    40007980:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007984:	d65f03c0 	ret
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40007988:	52800000 	mov	w0, #0x0                   	// #0
}
    4000798c:	d65f03c0 	ret

0000000040007990 <z_shell_raw_fprintf>:
extern "C" {
#endif

static inline void z_shell_raw_fprintf(const struct shell_fprintf *const ctx,
				       const char *fmt, ...)
{
    40007990:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40007994:	910003fd 	mov	x29, sp
    40007998:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_list args;

	va_start(args, fmt);
    4000799c:	910403e2 	add	x2, sp, #0x100
    400079a0:	a9030be2 	stp	x2, x2, [sp, #48]
    400079a4:	910343e2 	add	x2, sp, #0xd0
    400079a8:	f90023e2 	str	x2, [sp, #64]
    400079ac:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    400079b0:	b9004be2 	str	w2, [sp, #72]
    400079b4:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    400079b8:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    400079bc:	a9430fe2 	ldp	x2, x3, [sp, #48]
    400079c0:	a9010fe2 	stp	x2, x3, [sp, #16]
    400079c4:	a9440fe2 	ldp	x2, x3, [sp, #64]
    400079c8:	a9020fe2 	stp	x2, x3, [sp, #32]
    400079cc:	910043e2 	add	x2, sp, #0x10
{
    400079d0:	3d8017e0 	str	q0, [sp, #80]
    400079d4:	3d801be1 	str	q1, [sp, #96]
    400079d8:	3d801fe2 	str	q2, [sp, #112]
    400079dc:	3d8023e3 	str	q3, [sp, #128]
    400079e0:	3d8027e4 	str	q4, [sp, #144]
    400079e4:	3d802be5 	str	q5, [sp, #160]
    400079e8:	3d802fe6 	str	q6, [sp, #176]
    400079ec:	3d8033e7 	str	q7, [sp, #192]
    400079f0:	a90e17e4 	stp	x4, x5, [sp, #224]
    400079f4:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    400079f8:	940005cb 	bl	40009124 <z_shell_fprintf_fmt>
	va_end(args);
}
    400079fc:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40007a00:	d65f03c0 	ret

0000000040007a04 <shell_internal_help_print>:
{
    40007a04:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40007a08:	910003fd 	mov	x29, sp
	z_shell_help_cmd_print(shell, &shell->ctx->active_cmd);
    40007a0c:	f9400801 	ldr	x1, [x0, #16]
{
    40007a10:	f9000bf3 	str	x19, [sp, #16]
    40007a14:	aa0003f3 	mov	x19, x0
	z_shell_help_cmd_print(shell, &shell->ctx->active_cmd);
    40007a18:	91004021 	add	x1, x1, #0x10
    40007a1c:	94000ca2 	bl	4000aca4 <z_shell_help_cmd_print>
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
    40007a20:	aa1303e0 	mov	x0, x19
    40007a24:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40007a28:	911b0442 	add	x2, x2, #0x6c1
    40007a2c:	f9400a61 	ldr	x1, [x19, #16]
}
    40007a30:	f9400bf3 	ldr	x19, [sp, #16]
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
    40007a34:	91004021 	add	x1, x1, #0x10
}
    40007a38:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
    40007a3c:	14000c4c 	b	4000ab6c <z_shell_help_subcmd_print>

0000000040007a40 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
    40007a40:	14001da3 	b	4000f0cc <z_impl_k_mutex_lock>

0000000040007a44 <transport_evt_handler>:
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
    40007a44:	f9400821 	ldr	x1, [x1, #16]
    40007a48:	7100001f 	cmp	w0, #0x0
    40007a4c:	910aa022 	add	x2, x1, #0x2a8
    40007a50:	910bc021 	add	x1, x1, #0x2f0
    40007a54:	9a821020 	csel	x0, x1, x2, ne  // ne = any
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sig, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
    40007a58:	52800001 	mov	w1, #0x0                   	// #0
    40007a5c:	140026d8 	b	400115bc <z_impl_k_poll_signal_raise>

0000000040007a60 <kill_handler>:

static void kill_handler(const struct shell *shell)
{
    40007a60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40007a64:	910003fd 	mov	x29, sp
    40007a68:	a90153f3 	stp	x19, x20, [sp, #16]
    40007a6c:	aa0003f3 	mov	x19, x0
	return ret;
}

static inline bool z_flag_processing_get(const struct shell *sh)
{
	return sh->ctx->ctx.flags.processing == 1;
    40007a70:	f9400800 	ldr	x0, [x0, #16]
    40007a74:	b942a000 	ldr	w0, [x0, #672]
	if (z_flag_processing_get(shell)) {
    40007a78:	37000320 	tbnz	w0, #0, 40007adc <kill_handler+0x7c>
		z_shell_log_backend_disable(shell->log_backend);
    40007a7c:	f9401e60 	ldr	x0, [x19, #56]
    40007a80:	94000b55 	bl	4000a7d4 <z_shell_log_backend_disable>
	err = shell->iface->api->uninit(shell->iface);
    40007a84:	f9400660 	ldr	x0, [x19, #8]
    40007a88:	f9400001 	ldr	x1, [x0]
    40007a8c:	f9400421 	ldr	x1, [x1, #8]
    40007a90:	d63f0020 	blr	x1
    40007a94:	2a0003f4 	mov	w20, w0
	if (err != 0) {
    40007a98:	350000a0 	cbnz	w0, 40007aac <kill_handler+0x4c>
	z_shell_history_purge(shell->history);
    40007a9c:	f9400e60 	ldr	x0, [x19, #24]
    40007aa0:	94000e4b 	bl	4000b3cc <z_shell_history_purge>
	shell->ctx->state = state;
    40007aa4:	f9400a60 	ldr	x0, [x19, #16]
    40007aa8:	b900081f 	str	wzr, [x0, #8]
	int err = instance_uninit(shell);

	if (shell->ctx->uninit_cb) {
    40007aac:	f9400a60 	ldr	x0, [x19, #16]
    40007ab0:	f9403002 	ldr	x2, [x0, #96]
    40007ab4:	b4000082 	cbz	x2, 40007ac4 <kill_handler+0x64>
		shell->ctx->uninit_cb(shell, err);
    40007ab8:	2a1403e1 	mov	w1, w20
    40007abc:	aa1303e0 	mov	x0, x19
    40007ac0:	d63f0040 	blr	x2
	}

	shell->ctx->tid = NULL;
    40007ac4:	f9400a60 	ldr	x0, [x19, #16]
    40007ac8:	f901e41f 	str	xzr, [x0, #968]
	return z_impl_z_current_get();
    40007acc:	94002116 	bl	4000ff24 <z_impl_z_current_get>
	k_thread_abort(k_current_get());
}
    40007ad0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007ad4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_impl_k_thread_abort(thread);
    40007ad8:	140022ec 	b	40010688 <z_impl_k_thread_abort>
		return -EBUSY;
    40007adc:	128001f4 	mov	w20, #0xfffffff0            	// #-16
    40007ae0:	17fffff3 	b	40007aac <kill_handler+0x4c>

0000000040007ae4 <z_cursor_next_line_move.isra.0>:
/* Function forcing new line - cannot be replaced with function
 * cursor_down_move.
 */
static inline void z_cursor_next_line_move(const struct shell *sh)
{
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
    40007ae4:	d0000061 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40007ae8:	91096021 	add	x1, x1, #0x258
    40007aec:	17ffffa9 	b	40007990 <z_shell_raw_fprintf>

0000000040007af0 <z_flag_history_exit_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, history_exit, val, ret);
    40007af0:	910a8000 	add	x0, x0, #0x2a0
    40007af4:	72001c3f 	tst	w1, #0xff
    40007af8:	54000060 	b.eq	40007b04 <z_flag_history_exit_set.isra.0+0x14>  // b.none
    40007afc:	d2800081 	mov	x1, #0x4                   	// #4
    40007b00:	17ffff71 	b	400078c4 <atomic_or>
    40007b04:	12800081 	mov	w1, #0xfffffffb            	// #-5
    40007b08:	17ffff77 	b	400078e4 <atomic_and>

0000000040007b0c <history_handle>:
{
    40007b0c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40007b10:	910003fd 	mov	x29, sp
    40007b14:	a90153f3 	stp	x19, x20, [sp, #16]
    40007b18:	aa0003f3 	mov	x19, x0
    40007b1c:	12001c34 	and	w20, w1, #0xff
	return sh->ctx->ctx.flags.history_exit == 1;
    40007b20:	f9400800 	ldr	x0, [x0, #16]
    40007b24:	b942a001 	ldr	w1, [x0, #672]
	if (z_flag_history_exit_get(shell)) {
    40007b28:	361000a1 	tbz	w1, #2, 40007b3c <history_handle+0x30>
		z_flag_history_exit_set(shell, false);
    40007b2c:	52800001 	mov	w1, #0x0                   	// #0
    40007b30:	97fffff0 	bl	40007af0 <z_flag_history_exit_set.isra.0>
		z_shell_history_mode_exit(shell->history);
    40007b34:	f9400e60 	ldr	x0, [x19, #24]
    40007b38:	94000df8 	bl	4000b318 <z_shell_history_mode_exit>
 *
 * @return True if in browsing mode.
 */
static inline bool z_shell_history_active(struct shell_history *history)
{
	return (history->current) ? true : false;
    40007b3c:	f9400e60 	ldr	x0, [x19, #24]
	if (!z_shell_history_active(shell->history)) {
    40007b40:	f9400c00 	ldr	x0, [x0, #24]
    40007b44:	b5000160 	cbnz	x0, 40007b70 <history_handle+0x64>
		if (up) {
    40007b48:	34000554 	cbz	w20, 40007bf0 <history_handle+0xe4>
			uint16_t cmd_len = z_shell_strlen(shell->ctx->cmd_buff);
    40007b4c:	f9400a60 	ldr	x0, [x19, #16]
    40007b50:	9101d800 	add	x0, x0, #0x76
    40007b54:	97ffff86 	bl	4000796c <z_shell_strlen>
			if (cmd_len) {
    40007b58:	72003c1f 	tst	w0, #0xffff
    40007b5c:	f9400a60 	ldr	x0, [x19, #16]
    40007b60:	540004e0 	b.eq	40007bfc <history_handle+0xf0>  // b.none
				strcpy(shell->ctx->temp_buff,
    40007b64:	9101d801 	add	x1, x0, #0x76
    40007b68:	9105d800 	add	x0, x0, #0x176
    40007b6c:	94001584 	bl	4000d17c <strcpy>
	history_mode = z_shell_history_get(shell->history, up,
    40007b70:	a9410262 	ldp	x2, x0, [x19, #16]
    40007b74:	9100bbe3 	add	x3, sp, #0x2e
    40007b78:	2a1403e1 	mov	w1, w20
    40007b7c:	9101d842 	add	x2, x2, #0x76
    40007b80:	94000de8 	bl	4000b320 <z_shell_history_get>
	if (!history_mode) {
    40007b84:	72001c1f 	tst	w0, #0xff
    40007b88:	54000121 	b.ne	40007bac <history_handle+0xa0>  // b.any
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
    40007b8c:	f9400a60 	ldr	x0, [x19, #16]
    40007b90:	9105d801 	add	x1, x0, #0x176
    40007b94:	9101d800 	add	x0, x0, #0x76
    40007b98:	94001579 	bl	4000d17c <strcpy>
		len = z_shell_strlen(shell->ctx->cmd_buff);
    40007b9c:	f9400a60 	ldr	x0, [x19, #16]
    40007ba0:	9101d800 	add	x0, x0, #0x76
    40007ba4:	97ffff72 	bl	4000796c <z_shell_strlen>
    40007ba8:	79005fe0 	strh	w0, [sp, #46]
	z_shell_op_cursor_home_move(shell);
    40007bac:	aa1303e0 	mov	x0, x19
    40007bb0:	94000864 	bl	40009d40 <z_shell_op_cursor_home_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40007bb4:	f9400a60 	ldr	x0, [x19, #16]
    40007bb8:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
    40007bbc:	362800a0 	tbz	w0, #5, 40007bd0 <history_handle+0xc4>
    40007bc0:	f9401660 	ldr	x0, [x19, #40]
    40007bc4:	90000061 	adrp	x1, 40013000 <shell_cmd_help>
    40007bc8:	9102c021 	add	x1, x1, #0xb0
    40007bcc:	97ffff71 	bl	40007990 <z_shell_raw_fprintf>
	z_shell_print_cmd(shell);
    40007bd0:	aa1303e0 	mov	x0, x19
    40007bd4:	94000890 	bl	40009e14 <z_shell_print_cmd>
	shell->ctx->cmd_buff_pos = len;
    40007bd8:	f9400a60 	ldr	x0, [x19, #16]
    40007bdc:	79405fe1 	ldrh	w1, [sp, #46]
	shell->ctx->cmd_buff_len = len;
    40007be0:	7900e001 	strh	w1, [x0, #112]
	shell->ctx->cmd_buff_pos = len;
    40007be4:	7900e401 	strh	w1, [x0, #114]
	z_shell_op_cond_next_line(shell);
    40007be8:	aa1303e0 	mov	x0, x19
    40007bec:	940007c5 	bl	40009b00 <z_shell_op_cond_next_line>
}
    40007bf0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007bf4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40007bf8:	d65f03c0 	ret
				shell->ctx->temp_buff[0] = '\0';
    40007bfc:	3905d81f 	strb	wzr, [x0, #374]
    40007c00:	17ffffdc 	b	40007b70 <history_handle+0x64>

0000000040007c04 <z_flag_insert_mode_set.isra.0>:
static inline bool z_flag_insert_mode_set(const struct shell *sh, bool val)
    40007c04:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
    40007c08:	910a6000 	add	x0, x0, #0x298
    40007c0c:	72001c3f 	tst	w1, #0xff
static inline bool z_flag_insert_mode_set(const struct shell *sh, bool val)
    40007c10:	910003fd 	mov	x29, sp
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
    40007c14:	540000c0 	b.eq	40007c2c <z_flag_insert_mode_set.isra.0+0x28>  // b.none
    40007c18:	d2800021 	mov	x1, #0x1                   	// #1
    40007c1c:	97ffff2a 	bl	400078c4 <atomic_or>
}
    40007c20:	12000000 	and	w0, w0, #0x1
    40007c24:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007c28:	d65f03c0 	ret
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
    40007c2c:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    40007c30:	97ffff2d 	bl	400078e4 <atomic_and>
    40007c34:	17fffffb 	b	40007c20 <z_flag_insert_mode_set.isra.0+0x1c>

0000000040007c38 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
    40007c38:	14001d7a 	b	4000f220 <z_impl_k_mutex_unlock>

0000000040007c3c <shell_log_process>:
{
    40007c3c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40007c40:	910003fd 	mov	x29, sp
    40007c44:	a90153f3 	stp	x19, x20, [sp, #16]
    40007c48:	aa0003f3 	mov	x19, x0
    40007c4c:	f90013f5 	str	x21, [sp, #32]
	int signaled = 0;
    40007c50:	b9003bff 	str	wzr, [sp, #56]
			z_shell_cmd_line_erase(shell);
    40007c54:	aa1303e0 	mov	x0, x19
    40007c58:	94000857 	bl	40009db4 <z_shell_cmd_line_erase>
			processed = z_shell_log_backend_process(
    40007c5c:	f9401e60 	ldr	x0, [x19, #56]
    40007c60:	94000ae9 	bl	4000a804 <z_shell_log_backend_process>
    40007c64:	12001c14 	and	w20, w0, #0xff
		z_shell_print_prompt_and_cmd(shell);
    40007c68:	aa1303e0 	mov	x0, x19
		struct k_poll_signal *signal =
    40007c6c:	f9400a75 	ldr	x21, [x19, #16]
		z_shell_print_prompt_and_cmd(shell);
    40007c70:	94000a31 	bl	4000a534 <z_shell_print_prompt_and_cmd>
		if (shell->ctx->cmd_buff_len) {
    40007c74:	f9400a60 	ldr	x0, [x19, #16]
		struct k_poll_signal *signal =
    40007c78:	910aa2b5 	add	x21, x21, #0x2a8
		if (shell->ctx->cmd_buff_len) {
    40007c7c:	7940e000 	ldrh	w0, [x0, #112]
    40007c80:	34000060 	cbz	w0, 40007c8c <shell_log_process+0x50>
	return z_impl_k_sleep(timeout);
    40007c84:	d2800040 	mov	x0, #0x2                   	// #2
    40007c88:	94002232 	bl	40010550 <z_impl_k_sleep>
	z_impl_k_poll_signal_check(sig, signaled, result);
    40007c8c:	9100f3e2 	add	x2, sp, #0x3c
    40007c90:	9100e3e1 	add	x1, sp, #0x38
    40007c94:	aa1503e0 	mov	x0, x21
    40007c98:	94002644 	bl	400115a8 <z_impl_k_poll_signal_check>
	} while (processed && !signaled);
    40007c9c:	34000074 	cbz	w20, 40007ca8 <shell_log_process+0x6c>
    40007ca0:	b9403be0 	ldr	w0, [sp, #56]
    40007ca4:	34fffd80 	cbz	w0, 40007c54 <shell_log_process+0x18>
}
    40007ca8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007cac:	f94013f5 	ldr	x21, [sp, #32]
    40007cb0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40007cb4:	d65f03c0 	ret

0000000040007cb8 <execute>:
{
    40007cb8:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
    40007cbc:	910003fd 	mov	x29, sp
	char *cmd_buf = shell->ctx->cmd_buff;
    40007cc0:	f9400801 	ldr	x1, [x0, #16]
{
    40007cc4:	a90153f3 	stp	x19, x20, [sp, #16]
	char *cmd_buf = shell->ctx->cmd_buff;
    40007cc8:	9101d821 	add	x1, x1, #0x76
{
    40007ccc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40007cd0:	a90363f7 	stp	x23, x24, [sp, #48]
    40007cd4:	aa0003f7 	mov	x23, x0
    40007cd8:	a9046bf9 	stp	x25, x26, [sp, #64]
    40007cdc:	a90573fb 	stp	x27, x28, [sp, #80]
	char *cmd_buf = shell->ctx->cmd_buff;
    40007ce0:	f9003be1 	str	x1, [sp, #112]
	size_t argc = 0, args_left = SIZE_MAX;
    40007ce4:	a908ffff 	stp	xzr, xzr, [sp, #136]
	z_shell_op_cursor_end_move(shell);
    40007ce8:	9400081a 	bl	40009d50 <z_shell_op_cursor_end_move>
	if (!z_shell_cursor_in_empty_line(shell)) {
    40007cec:	aa1703e0 	mov	x0, x23
    40007cf0:	9400076e 	bl	40009aa8 <z_shell_cursor_in_empty_line>
    40007cf4:	72001c1f 	tst	w0, #0xff
    40007cf8:	54000061 	b.ne	40007d04 <execute+0x4c>  // b.any
		z_cursor_next_line_move(shell);
    40007cfc:	f94016e0 	ldr	x0, [x23, #40]
    40007d00:	97ffff79 	bl	40007ae4 <z_cursor_next_line_move.isra.0>
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
    40007d04:	f9400ae0 	ldr	x0, [x23, #16]
    40007d08:	d2800502 	mov	x2, #0x28                  	// #40
    40007d0c:	52800001 	mov	w1, #0x0                   	// #0
		z_shell_wildcard_prepare(shell);
    40007d10:	9103a3f4 	add	x20, sp, #0xe8
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
    40007d14:	91004000 	add	x0, x0, #0x10
    40007d18:	94001587 	bl	4000d334 <memset>
		z_shell_cmd_trim(shell);
    40007d1c:	aa1703e0 	mov	x0, x23
    40007d20:	940006d1 	bl	40009864 <z_shell_cmd_trim>
	z_shell_history_put(shell->history, line, length);
    40007d24:	a94102e1 	ldp	x1, x0, [x23, #16]
				z_shell_fprintf(shell, SHELL_ERROR,
    40007d28:	d000007c 	adrp	x28, 40015000 <prefix.1+0x2aa>
    40007d2c:	9128239c 	add	x28, x28, #0xa08
    40007d30:	aa1403f9 	mov	x25, x20
		help_entry.help = NULL;
    40007d34:	d2800015 	mov	x21, #0x0                   	// #0
	size_t argc = 0, args_left = SIZE_MAX;
    40007d38:	92800013 	mov	x19, #0xffffffffffffffff    	// #-1
	size_t cmd_with_handler_lvl = 0;
    40007d3c:	d2800016 	mov	x22, #0x0                   	// #0
		z_shell_wildcard_prepare(shell);
    40007d40:	52800018 	mov	w24, #0x0                   	// #0
    40007d44:	d280001a 	mov	x26, #0x0                   	// #0
    40007d48:	d280001b 	mov	x27, #0x0                   	// #0
	z_shell_history_put(shell->history, line, length);
    40007d4c:	7940e022 	ldrh	w2, [x1, #112]
    40007d50:	9101d821 	add	x1, x1, #0x76
    40007d54:	94000dad 	bl	4000b408 <z_shell_history_put>
		z_shell_wildcard_prepare(shell);
    40007d58:	aa1703e0 	mov	x0, x23
    40007d5c:	94000e22 	bl	4000b5e4 <z_shell_wildcard_prepare>
				z_shell_fprintf(shell, SHELL_ERROR,
    40007d60:	d0000060 	adrp	x0, 40015000 <prefix.1+0x2aa>
    40007d64:	911cc000 	add	x0, x0, #0x730
		z_shell_wildcard_prepare(shell);
    40007d68:	b9006fff 	str	wzr, [sp, #108]
				z_shell_fprintf(shell, SHELL_ERROR,
    40007d6c:	f9003fe0 	str	x0, [sp, #120]
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
    40007d70:	a94887e0 	ldp	x0, x1, [sp, #136]
    40007d74:	f100043f 	cmp	x1, #0x1
    40007d78:	54001720 	b.eq	4000805c <execute+0x3a4>  // b.none
    40007d7c:	f1002c1f 	cmp	x0, #0xb
    40007d80:	54001349 	b.ls	40007fe8 <execute+0x330>  // b.plast
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
    40007d84:	f9404be0 	ldr	x0, [sp, #144]
    40007d88:	f100081f 	cmp	x0, #0x2
    40007d8c:	54001301 	b.ne	40007fec <execute+0x334>  // b.any
		z_shell_fprintf(shell, SHELL_ERROR, "%s\n",
    40007d90:	aa1703e0 	mov	x0, x23
    40007d94:	d0000063 	adrp	x3, 40015000 <prefix.1+0x2aa>
    40007d98:	911d1063 	add	x3, x3, #0x744
    40007d9c:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40007da0:	910dec42 	add	x2, x2, #0x37b
    40007da4:	52800021 	mov	w1, #0x1                   	// #1
    40007da8:	940008b5 	bl	4000a07c <z_shell_fprintf>
		return -ENOEXEC;
    40007dac:	1400000b 	b	40007dd8 <execute+0x120>
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
    40007db0:	f9403be2 	ldr	x2, [sp, #112]
    40007db4:	aa1403e1 	mov	x1, x20
    40007db8:	52800043 	mov	w3, #0x2                   	// #2
    40007dbc:	910243e0 	add	x0, sp, #0x90
    40007dc0:	9400053b 	bl	400092ac <z_shell_make_argv>
    40007dc4:	12001c03 	and	w3, w0, #0xff
		if (argc == 0) {
    40007dc8:	f9404be1 	ldr	x1, [sp, #144]
		cmd_buf = (char *)argvp[1];
    40007dcc:	f9400680 	ldr	x0, [x20, #8]
    40007dd0:	f9003be0 	str	x0, [sp, #112]
		if (argc == 0) {
    40007dd4:	b5000141 	cbnz	x1, 40007dfc <execute+0x144>
			return -ENOEXEC;
    40007dd8:	128000f3 	mov	w19, #0xfffffff8            	// #-8
}
    40007ddc:	2a1303e0 	mov	w0, w19
    40007de0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007de4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40007de8:	a94363f7 	ldp	x23, x24, [sp, #48]
    40007dec:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40007df0:	a94573fb 	ldp	x27, x28, [sp, #80]
    40007df4:	a8d57bfd 	ldp	x29, x30, [sp], #336
    40007df8:	d65f03c0 	ret
		} else if ((argc == 1) && (quote != 0)) {
    40007dfc:	f100043f 	cmp	x1, #0x1
    40007e00:	540000e1 	b.ne	40007e1c <execute+0x164>  // b.any
    40007e04:	340000c3 	cbz	w3, 40007e1c <execute+0x164>
			z_shell_fprintf(shell, SHELL_ERROR,
    40007e08:	aa1703e0 	mov	x0, x23
    40007e0c:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40007e10:	911b3c42 	add	x2, x2, #0x6cf
    40007e14:	9400089a 	bl	4000a07c <z_shell_fprintf>
    40007e18:	17fffff0 	b	40007dd8 <execute+0x120>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
    40007e1c:	f94047e0 	ldr	x0, [sp, #136]
    40007e20:	b4000520 	cbz	x0, 40007ec4 <execute+0x20c>
		    z_shell_help_request(argvp[0])) {
    40007e24:	f9400280 	ldr	x0, [x20]
    40007e28:	94000bbf 	bl	4000ad24 <z_shell_help_request>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
    40007e2c:	72001c1f 	tst	w0, #0xff
    40007e30:	540002a0 	b.eq	40007e84 <execute+0x1cc>  // b.none
			if (help_entry.help) {
    40007e34:	b40001d5 	cbz	x21, 40007e6c <execute+0x1b4>
				shell->ctx->active_cmd = help_entry;
    40007e38:	f9400ae1 	ldr	x1, [x23, #16]
    40007e3c:	f90067f5 	str	x21, [sp, #200]
    40007e40:	91004020 	add	x0, x1, #0x10
    40007e44:	a94c0fe2 	ldp	x2, x3, [sp, #192]
    40007e48:	a9010c22 	stp	x2, x3, [x1, #16]
    40007e4c:	a94d0fe2 	ldp	x2, x3, [sp, #208]
    40007e50:	a9020c22 	stp	x2, x3, [x1, #32]
    40007e54:	f94073e1 	ldr	x1, [sp, #224]
    40007e58:	f9001001 	str	x1, [x0, #32]
			shell_internal_help_print(shell);
    40007e5c:	aa1703e0 	mov	x0, x23
			return SHELL_CMD_HELP_PRINTED;
    40007e60:	52800033 	mov	w19, #0x1                   	// #1
			shell_internal_help_print(shell);
    40007e64:	97fffee8 	bl	40007a04 <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
    40007e68:	17ffffdd 	b	40007ddc <execute+0x124>
			z_shell_fprintf(shell, SHELL_ERROR,
    40007e6c:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40007e70:	911b8c42 	add	x2, x2, #0x6e3
		z_shell_fprintf(shell, SHELL_ERROR,
    40007e74:	aa1703e0 	mov	x0, x23
    40007e78:	52800021 	mov	w1, #0x1                   	// #1
    40007e7c:	94000880 	bl	4000a07c <z_shell_fprintf>
		return false;
    40007e80:	17ffffd6 	b	40007dd8 <execute+0x120>
		if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {
    40007e84:	f94047e0 	ldr	x0, [sp, #136]
    40007e88:	b40001e0 	cbz	x0, 40007ec4 <execute+0x20c>
			status = z_shell_wildcard_process(shell, entry,
    40007e8c:	f9400282 	ldr	x2, [x20]
    40007e90:	aa1a03e1 	mov	x1, x26
    40007e94:	aa1703e0 	mov	x0, x23
    40007e98:	94000df1 	bl	4000b65c <z_shell_wildcard_process>
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
    40007e9c:	7100081f 	cmp	w0, #0x2
    40007ea0:	54000de0 	b.eq	4000805c <execute+0x3a4>  // b.none
			if (status != SHELL_WILDCARD_NOT_FOUND) {
    40007ea4:	71000c1f 	cmp	w0, #0x3
    40007ea8:	540000e0 	b.eq	40007ec4 <execute+0x20c>  // b.none
				++cmd_lvl;
    40007eac:	f94047e0 	ldr	x0, [sp, #136]
    40007eb0:	91000400 	add	x0, x0, #0x1
    40007eb4:	f90047e0 	str	x0, [sp, #136]
				wildcard_found = true;
    40007eb8:	52800020 	mov	w0, #0x1                   	// #1
    40007ebc:	b9006fe0 	str	w0, [sp, #108]
				continue;
    40007ec0:	17ffffac 	b	40007d70 <execute+0xb8>
		if (has_last_handler == false) {
    40007ec4:	350000d8 	cbnz	w24, 40007edc <execute+0x224>
			entry = z_shell_find_cmd(parent, argvp[0], &dloc);
    40007ec8:	f9400281 	ldr	x1, [x20]
    40007ecc:	910263e2 	add	x2, sp, #0x98
    40007ed0:	aa1b03e0 	mov	x0, x27
    40007ed4:	940005e8 	bl	40009674 <z_shell_find_cmd>
    40007ed8:	aa0003fa 	mov	x26, x0
		argvp++;
    40007edc:	91002294 	add	x20, x20, #0x8
		args_left--;
    40007ee0:	d1000673 	sub	x19, x19, #0x1
		if (entry) {
    40007ee4:	b400065a 	cbz	x26, 40007fac <execute+0x2f4>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && found && entry->handler) {
    40007ee8:	b9406fe1 	ldr	w1, [sp, #108]
    40007eec:	f9400f40 	ldr	x0, [x26, #24]
    40007ef0:	34000121 	cbz	w1, 40007f14 <execute+0x25c>
    40007ef4:	b4000380 	cbz	x0, 40007f64 <execute+0x2ac>
		z_shell_op_cursor_end_move(shell);
    40007ef8:	aa1703e0 	mov	x0, x23
    40007efc:	94000795 	bl	40009d50 <z_shell_op_cursor_end_move>
		z_shell_op_cond_next_line(shell);
    40007f00:	aa1703e0 	mov	x0, x23
    40007f04:	940006ff 	bl	40009b00 <z_shell_op_cond_next_line>
		z_shell_fprintf(shell, SHELL_ERROR,
    40007f08:	d0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40007f0c:	911c0442 	add	x2, x2, #0x701
    40007f10:	17ffffd9 	b	40007e74 <execute+0x1bc>
	if (entry->handler) {
    40007f14:	b4000280 	cbz	x0, 40007f64 <execute+0x2ac>
		*active_cmd = *entry;
    40007f18:	f9400ae1 	ldr	x1, [x23, #16]
    40007f1c:	a9400f42 	ldp	x2, x3, [x26]
    40007f20:	91004020 	add	x0, x1, #0x10
    40007f24:	a9010c22 	stp	x2, x3, [x1, #16]
    40007f28:	a9410f42 	ldp	x2, x3, [x26, #16]
    40007f2c:	a9020c22 	stp	x2, x3, [x1, #32]
    40007f30:	f9401341 	ldr	x1, [x26, #32]
    40007f34:	f9001001 	str	x1, [x0, #32]
		if ((entry->subcmd == NULL)
    40007f38:	f9400b40 	ldr	x0, [x26, #16]
		*handler_lvl = *lvl;
    40007f3c:	f94047f6 	ldr	x22, [sp, #136]
		if ((entry->subcmd == NULL)
    40007f40:	b5000120 	cbnz	x0, 40007f64 <execute+0x2ac>
		    && entry->args.optional == SHELL_OPT_ARG_RAW) {
    40007f44:	39408740 	ldrb	w0, [x26, #33]
    40007f48:	7103f81f 	cmp	w0, #0xfe
    40007f4c:	540000c1 	b.ne	40007f64 <execute+0x2ac>  // b.any
			*args_left = entry->args.mandatory - 1;
    40007f50:	39408353 	ldrb	w19, [x26, #32]
			*lvl = *lvl + 1;
    40007f54:	910006c0 	add	x0, x22, #0x1
    40007f58:	f90047e0 	str	x0, [sp, #136]
			*args_left = entry->args.mandatory - 1;
    40007f5c:	51000673 	sub	w19, w19, #0x1
    40007f60:	93407e73 	sxtw	x19, w19
	if (entry->help) {
    40007f64:	f9400740 	ldr	x0, [x26, #8]
    40007f68:	b4000100 	cbz	x0, 40007f88 <execute+0x2d0>
		*help_entry = *entry;
    40007f6c:	a9400f42 	ldp	x2, x3, [x26]
    40007f70:	aa0003f5 	mov	x21, x0
    40007f74:	a90c0fe2 	stp	x2, x3, [sp, #192]
    40007f78:	a9410f42 	ldp	x2, x3, [x26, #16]
    40007f7c:	a90d0fe2 	stp	x2, x3, [sp, #208]
    40007f80:	f9401341 	ldr	x1, [x26, #32]
    40007f84:	f90073e1 	str	x1, [sp, #224]
    40007f88:	aa1a03fb 	mov	x27, x26
		if (args_left || (argc == 2)) {
    40007f8c:	b5000093 	cbnz	x19, 40007f9c <execute+0x2e4>
    40007f90:	f9404be0 	ldr	x0, [sp, #144]
    40007f94:	f100081f 	cmp	x0, #0x2
    40007f98:	54ffeec1 	b.ne	40007d70 <execute+0xb8>  // b.any
			cmd_lvl++;
    40007f9c:	f94047e0 	ldr	x0, [sp, #136]
    40007fa0:	91000400 	add	x0, x0, #0x1
    40007fa4:	f90047e0 	str	x0, [sp, #136]
    40007fa8:	17ffff72 	b	40007d70 <execute+0xb8>
			if (cmd_lvl == 0 &&
    40007fac:	f94047e0 	ldr	x0, [sp, #136]
    40007fb0:	b5000180 	cbnz	x0, 40007fe0 <execute+0x328>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
}

static inline bool z_shell_in_select_mode(const struct shell *shell)
{
	return shell->ctx->selected_cmd == NULL ? false : true;
    40007fb4:	f9400ae0 	ldr	x0, [x23, #16]
    40007fb8:	f9401c00 	ldr	x0, [x0, #56]
    40007fbc:	b4000060 	cbz	x0, 40007fc8 <execute+0x310>
				(!z_shell_in_select_mode(shell) ||
    40007fc0:	f9400c00 	ldr	x0, [x0, #24]
    40007fc4:	b50000e0 	cbnz	x0, 40007fe0 <execute+0x328>
				z_shell_fprintf(shell, SHELL_ERROR,
    40007fc8:	f9403fe4 	ldr	x4, [sp, #120]
    40007fcc:	aa1c03e2 	mov	x2, x28
    40007fd0:	f94077e3 	ldr	x3, [sp, #232]
    40007fd4:	aa1703e0 	mov	x0, x23
    40007fd8:	52800021 	mov	w1, #0x1                   	// #1
    40007fdc:	94000828 	bl	4000a07c <z_shell_fprintf>
			has_last_handler = true;
    40007fe0:	52800038 	mov	w24, #0x1                   	// #1
    40007fe4:	17ffffea 	b	40007f8c <execute+0x2d4>
		&& args_left > 0) {
    40007fe8:	b5ffee53 	cbnz	x19, 40007db0 <execute+0xf8>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
    40007fec:	b9406fe0 	ldr	w0, [sp, #108]
    40007ff0:	34000120 	cbz	w0, 40008014 <execute+0x35c>
		z_shell_wildcard_finalize(shell);
    40007ff4:	aa1703e0 	mov	x0, x23
    40007ff8:	94000df8 	bl	4000b7d8 <z_shell_wildcard_finalize>
					shell->ctx->cmd_buff,
    40007ffc:	f9400ae2 	ldr	x2, [x23, #16]
		(void)z_shell_make_argv(&cmd_lvl,
    40008000:	aa1903e1 	mov	x1, x25
    40008004:	910223e0 	add	x0, sp, #0x88
    40008008:	52800183 	mov	w3, #0xc                   	// #12
    4000800c:	9101d842 	add	x2, x2, #0x76
    40008010:	940004a7 	bl	400092ac <z_shell_make_argv>
	if (shell->ctx->active_cmd.handler == NULL) {
    40008014:	f9400ae0 	ldr	x0, [x23, #16]
	argv[cmd_lvl] = NULL;
    40008018:	f94047f3 	ldr	x19, [sp, #136]
	if (shell->ctx->active_cmd.handler == NULL) {
    4000801c:	f9401401 	ldr	x1, [x0, #40]
	argv[cmd_lvl] = NULL;
    40008020:	f8337b3f 	str	xzr, [x25, x19, lsl #3]
	if (shell->ctx->active_cmd.handler == NULL) {
    40008024:	b5000241 	cbnz	x1, 4000806c <execute+0x3b4>
			if (help_entry->help == NULL) {
    40008028:	b4ffed95 	cbz	x21, 40007dd8 <execute+0x120>
			if (help_entry->help != shell->ctx->active_cmd.help) {
    4000802c:	f9400c01 	ldr	x1, [x0, #24]
    40008030:	eb15003f 	cmp	x1, x21
    40008034:	54fff140 	b.eq	40007e5c <execute+0x1a4>  // b.none
				shell->ctx->active_cmd = *help_entry;
    40008038:	f90067f5 	str	x21, [sp, #200]
    4000803c:	91004001 	add	x1, x0, #0x10
    40008040:	a94c0fe2 	ldp	x2, x3, [sp, #192]
    40008044:	a9010c02 	stp	x2, x3, [x0, #16]
    40008048:	a94d0fe2 	ldp	x2, x3, [sp, #208]
    4000804c:	a9020c02 	stp	x2, x3, [x0, #32]
    40008050:	f94073e0 	ldr	x0, [sp, #224]
    40008054:	f9001020 	str	x0, [x1, #32]
    40008058:	17ffff81 	b	40007e5c <execute+0x1a4>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
    4000805c:	f94047e0 	ldr	x0, [sp, #136]
    40008060:	f1002c1f 	cmp	x0, #0xb
    40008064:	54fffc49 	b.ls	40007fec <execute+0x334>  // b.plast
    40008068:	17ffff47 	b	40007d84 <execute+0xcc>
	if (shell->ctx->active_cmd.args.mandatory) {
    4000806c:	3940c002 	ldrb	w2, [x0, #48]
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
    40008070:	cb160273 	sub	x19, x19, x22
	if (shell->ctx->active_cmd.args.mandatory) {
    40008074:	34000282 	cbz	w2, 400080c4 <execute+0x40c>
		uint8_t opt8 = shell->ctx->active_cmd.args.optional;
    40008078:	3940c401 	ldrb	w1, [x0, #49]
				UINT16_MAX : opt8;
    4000807c:	529fffe3 	mov	w3, #0xffff                	// #65535
    40008080:	7103fc3f 	cmp	w1, #0xff
    40008084:	1a831021 	csel	w1, w1, w3, ne  // ne = any
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
    40008088:	eb22027f 	cmp	x19, w2, uxtb
    4000808c:	54000083 	b.cc	4000809c <execute+0x3e4>  // b.lo, b.ul, b.last
    40008090:	0b010042 	add	w2, w2, w1
	if (!arg_cnt_ok) {
    40008094:	eb02027f 	cmp	x19, x2
    40008098:	54000169 	b.ls	400080c4 <execute+0x40c>  // b.plast
		z_shell_fprintf(shell, SHELL_ERROR,
    4000809c:	f9400803 	ldr	x3, [x0, #16]
    400080a0:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    400080a4:	911da042 	add	x2, x2, #0x768
    400080a8:	52800021 	mov	w1, #0x1                   	// #1
    400080ac:	aa1703e0 	mov	x0, x23
		return -EINVAL;
    400080b0:	128002b3 	mov	w19, #0xffffffea            	// #-22
		z_shell_fprintf(shell, SHELL_ERROR,
    400080b4:	940007f2 	bl	4000a07c <z_shell_fprintf>
			shell_internal_help_print(shell);
    400080b8:	aa1703e0 	mov	x0, x23
    400080bc:	97fffe52 	bl	40007a04 <shell_internal_help_print>
	if (!ret_val) {
    400080c0:	17ffff47 	b	40007ddc <execute+0x124>
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, cmd_ctx, val, ret);
    400080c4:	d2810001 	mov	x1, #0x800                 	// #2048
    400080c8:	910a8000 	add	x0, x0, #0x2a0
    400080cc:	97fffdfe 	bl	400078c4 <atomic_or>
		k_mutex_unlock(&shell->ctx->wr_mtx);
    400080d0:	f9400ae0 	ldr	x0, [x23, #16]
    400080d4:	910ea000 	add	x0, x0, #0x3a8
    400080d8:	97fffed8 	bl	40007c38 <k_mutex_unlock.isra.0>
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
    400080dc:	f9400ae0 	ldr	x0, [x23, #16]
    400080e0:	8b160f22 	add	x2, x25, x22, lsl #3
    400080e4:	aa1303e1 	mov	x1, x19
    400080e8:	f9401403 	ldr	x3, [x0, #40]
    400080ec:	aa1703e0 	mov	x0, x23
    400080f0:	d63f0060 	blr	x3
    400080f4:	2a0003f3 	mov	w19, w0
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    400080f8:	f9400ae0 	ldr	x0, [x23, #16]
    400080fc:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40008100:	910ea000 	add	x0, x0, #0x3a8
    40008104:	97fffe4f 	bl	40007a40 <k_mutex_lock.constprop.0.isra.0>
    40008108:	f9400ae0 	ldr	x0, [x23, #16]
    4000810c:	12810001 	mov	w1, #0xfffff7ff            	// #-2049
    40008110:	910a8000 	add	x0, x0, #0x2a0
    40008114:	97fffdf4 	bl	400078e4 <atomic_and>
	return ret;
    40008118:	17ffff31 	b	40007ddc <execute+0x124>

000000004000811c <state_set.constprop.0>:
	shell->ctx->state = state;
    4000811c:	f9400801 	ldr	x1, [x0, #16]
    40008120:	52800042 	mov	w2, #0x2                   	// #2
    40008124:	b9000822 	str	w2, [x1, #8]
	if (state == SHELL_STATE_ACTIVE && !shell->ctx->bypass) {
    40008128:	f9403422 	ldr	x2, [x1, #104]
    4000812c:	b50002e2 	cbnz	x2, 40008188 <state_set.constprop.0+0x6c>
static inline void state_set(const struct shell *shell, enum shell_state state)
    40008130:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40008134:	910003fd 	mov	x29, sp
    40008138:	f9000bf3 	str	x19, [sp, #16]
    4000813c:	aa0003f3 	mov	x19, x0
	shell->ctx->cmd_buff_len = 0;
    40008140:	b900703f 	str	wzr, [x1, #112]
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
    40008144:	3901d83f 	strb	wzr, [x1, #118]
	return sh->ctx->ctx.flags.print_noinit == 1;
    40008148:	b942a021 	ldr	w1, [x1, #672]
		if (z_flag_print_noinit_get(shell)) {
    4000814c:	36600161 	tbz	w1, #12, 40008178 <state_set.constprop.0+0x5c>
			z_shell_fprintf(shell, SHELL_WARNING, "%s",
    40008150:	52800061 	mov	w1, #0x3                   	// #3
    40008154:	b0000063 	adrp	x3, 40015000 <prefix.1+0x2aa>
    40008158:	911e0c63 	add	x3, x3, #0x783
    4000815c:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40008160:	910dbc42 	add	x2, x2, #0x36f
    40008164:	940007c6 	bl	4000a07c <z_shell_fprintf>
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
    40008168:	f9400a60 	ldr	x0, [x19, #16]
    4000816c:	12820001 	mov	w1, #0xffffefff            	// #-4097
    40008170:	910a8000 	add	x0, x0, #0x2a0
    40008174:	97fffddc 	bl	400078e4 <atomic_and>
		z_shell_print_prompt_and_cmd(shell);
    40008178:	aa1303e0 	mov	x0, x19
}
    4000817c:	f9400bf3 	ldr	x19, [sp, #16]
    40008180:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_shell_print_prompt_and_cmd(shell);
    40008184:	140008ec 	b	4000a534 <z_shell_print_prompt_and_cmd>
    40008188:	d65f03c0 	ret

000000004000818c <shell_process>:

	return 0;
}

void shell_process(const struct shell *shell)
{
    4000818c:	a9a67bfd 	stp	x29, x30, [sp, #-416]!
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, processing, val, ret);
    40008190:	d2800021 	mov	x1, #0x1                   	// #1
    40008194:	910003fd 	mov	x29, sp
    40008198:	a90153f3 	stp	x19, x20, [sp, #16]
    4000819c:	aa0003f3 	mov	x19, x0
    400081a0:	f9400800 	ldr	x0, [x0, #16]
    400081a4:	a9025bf5 	stp	x21, x22, [sp, #32]
    400081a8:	910a8000 	add	x0, x0, #0x2a0
    400081ac:	a90363f7 	stp	x23, x24, [sp, #48]
    400081b0:	a9046bf9 	stp	x25, x26, [sp, #64]
    400081b4:	a90573fb 	stp	x27, x28, [sp, #80]
    400081b8:	97fffdc3 	bl	400078c4 <atomic_or>
	__ASSERT_NO_MSG(shell->ctx);

	/* atomically set the processing flag */
	z_flag_processing_set(shell, true);

	switch (shell->ctx->state) {
    400081bc:	f9400a60 	ldr	x0, [x19, #16]
    400081c0:	b9400800 	ldr	w0, [x0, #8]
    400081c4:	7100081f 	cmp	w0, #0x2
    400081c8:	54000321 	b.ne	4000822c <shell_process+0xa0>  // b.any
		switch (shell->ctx->receive_state) {
    400081cc:	90000060 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    400081d0:	9112a000 	add	x0, x0, #0x4a8
    400081d4:	f90043e0 	str	x0, [sp, #128]
	size_t count = 0;
    400081d8:	f90057ff 	str	xzr, [sp, #168]
		shell_bypass_cb_t bypass = shell->ctx->bypass;
    400081dc:	f9400a60 	ldr	x0, [x19, #16]
			(void)shell->iface->api->read(shell->iface, buf,
    400081e0:	9102a3e3 	add	x3, sp, #0xa8
		shell_bypass_cb_t bypass = shell->ctx->bypass;
    400081e4:	f9403414 	ldr	x20, [x0, #104]
			(void)shell->iface->api->read(shell->iface, buf,
    400081e8:	f9400660 	ldr	x0, [x19, #8]
    400081ec:	f9400001 	ldr	x1, [x0]
    400081f0:	f9401024 	ldr	x4, [x1, #32]
		if (bypass) {
    400081f4:	b4000314 	cbz	x20, 40008254 <shell_process+0xc8>
			(void)shell->iface->api->read(shell->iface, buf,
    400081f8:	d2800202 	mov	x2, #0x10                  	// #16
    400081fc:	9104e3e1 	add	x1, sp, #0x138
    40008200:	d63f0080 	blr	x4
			if (count) {
    40008204:	f94057e2 	ldr	x2, [sp, #168]
    40008208:	b4000122 	cbz	x2, 4000822c <shell_process+0xa0>
				bypass(shell, buf, count);
    4000820c:	aa1303e0 	mov	x0, x19
    40008210:	9104e3e1 	add	x1, sp, #0x138
    40008214:	d63f0280 	blr	x20
				if (!(volatile shell_bypass_cb_t *)shell->ctx->bypass) {
    40008218:	f9400a60 	ldr	x0, [x19, #16]
    4000821c:	f9403400 	ldr	x0, [x0, #104]
    40008220:	b5fffde0 	cbnz	x0, 400081dc <shell_process+0x50>
					state_set(shell, SHELL_STATE_ACTIVE);
    40008224:	aa1303e0 	mov	x0, x19
    40008228:	97ffffbd 	bl	4000811c <state_set.constprop.0>
    4000822c:	f9400a60 	ldr	x0, [x19, #16]
    40008230:	b27f7be1 	mov	x1, #0xfffffffe            	// #4294967294
		break;
	}

	/* atomically clear the processing flag */
	z_flag_processing_set(shell, false);
}
    40008234:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008238:	910a8000 	add	x0, x0, #0x2a0
    4000823c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008240:	a94363f7 	ldp	x23, x24, [sp, #48]
    40008244:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40008248:	a94573fb 	ldp	x27, x28, [sp, #80]
    4000824c:	a8da7bfd 	ldp	x29, x30, [sp], #416
    40008250:	17fffda5 	b	400078e4 <atomic_and>
		(void)shell->iface->api->read(shell->iface, &data,
    40008254:	91029fe1 	add	x1, sp, #0xa7
    40008258:	d2800022 	mov	x2, #0x1                   	// #1
    4000825c:	d63f0080 	blr	x4
		if (count == 0) {
    40008260:	f94057e0 	ldr	x0, [sp, #168]
    40008264:	b4fffe40 	cbz	x0, 4000822c <shell_process+0xa0>
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
    40008268:	39c29fe2 	ldrsb	w2, [sp, #167]
		if (ascii_filter(data) != 0) {
    4000826c:	39429fe1 	ldrb	w1, [sp, #167]
		switch (shell->ctx->receive_state) {
    40008270:	f9400a60 	ldr	x0, [x19, #16]
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
    40008274:	37fffb42 	tbnz	w2, #31, 400081dc <shell_process+0x50>
		switch (shell->ctx->receive_state) {
    40008278:	b9400c02 	ldr	w2, [x0, #12]
    4000827c:	71000c5f 	cmp	w2, #0x3
    40008280:	54003668 	b.hi	4000894c <shell_process+0x7c0>  // b.pmore
    40008284:	f94043e3 	ldr	x3, [sp, #128]
    40008288:	78625862 	ldrh	w2, [x3, w2, uxtw #1]
    4000828c:	10000063 	adr	x3, 40008298 <shell_process+0x10c>
    40008290:	8b22a862 	add	x2, x3, w2, sxth #2
    40008294:	d61f0040 	br	x2
	if ((data != '\r') && (data != '\n')) {
    40008298:	7100343f 	cmp	w1, #0xd
    4000829c:	7a4a1824 	ccmp	w1, #0xa, #0x4, ne  // ne = any
    400082a0:	54000220 	b.eq	400082e4 <shell_process+0x158>  // b.none
	sh->ctx->ctx.flags.last_nl = val;
    400082a4:	79454002 	ldrh	w2, [x0, #672]
    400082a8:	12155c42 	and	w2, w2, #0xfffff807
    400082ac:	79054002 	strh	w2, [x0, #672]
			switch (data) {
    400082b0:	7100243f 	cmp	w1, #0x9
    400082b4:	54000680 	b.eq	40008384 <shell_process+0x1f8>  // b.none
    400082b8:	54000448 	b.hi	40008340 <shell_process+0x1b4>  // b.pmore
    400082bc:	34fff901 	cbz	w1, 400081dc <shell_process+0x50>
    400082c0:	7100203f 	cmp	w1, #0x8
    400082c4:	54002840 	b.eq	400087cc <shell_process+0x640>  // b.none
    400082c8:	51008022 	sub	w2, w1, #0x20
				if (isprint((int) data)) {
    400082cc:	7101785f 	cmp	w2, #0x5e
    400082d0:	540028c8 	b.hi	400087e8 <shell_process+0x65c>  // b.pmore
					z_flag_history_exit_set(shell, true);
    400082d4:	52800021 	mov	w1, #0x1                   	// #1
    400082d8:	97fffe06 	bl	40007af0 <z_flag_history_exit_set.isra.0>
					z_shell_op_char_insert(shell, data);
    400082dc:	39429fe1 	ldrb	w1, [sp, #167]
    400082e0:	140000a4 	b	40008570 <shell_process+0x3e4>
	return sh->ctx->ctx.flags.last_nl;
    400082e4:	b942a002 	ldr	w2, [x0, #672]
	if ((z_flag_last_nl_get(shell) == 0U) ||
    400082e8:	f27d1c5f 	tst	x2, #0x7f8
    400082ec:	540000a0 	b.eq	40008300 <shell_process+0x174>  // b.none
    400082f0:	b942a002 	ldr	w2, [x0, #672]
    400082f4:	d3432842 	ubfx	x2, x2, #3, #8
    400082f8:	6b02003f 	cmp	w1, w2
    400082fc:	54fffda1 	b.ne	400082b0 <shell_process+0x124>  // b.any
	sh->ctx->ctx.flags.last_nl = val;
    40008300:	79454002 	ldrh	w2, [x0, #672]
    40008304:	331d1c22 	bfi	w2, w1, #3, #8
				if (!shell->ctx->cmd_buff_len) {
    40008308:	7940e001 	ldrh	w1, [x0, #112]
    4000830c:	79054002 	strh	w2, [x0, #672]
    40008310:	35000121 	cbnz	w1, 40008334 <shell_process+0x1a8>
	z_flag_history_exit_set(shell, false);
    40008314:	97fffdf7 	bl	40007af0 <z_flag_history_exit_set.isra.0>
	z_shell_history_mode_exit(shell->history);
    40008318:	f9400e60 	ldr	x0, [x19, #24]
    4000831c:	94000bff 	bl	4000b318 <z_shell_history_mode_exit>
					z_cursor_next_line_move(shell);
    40008320:	f9401660 	ldr	x0, [x19, #40]
    40008324:	97fffdf0 	bl	40007ae4 <z_cursor_next_line_move.isra.0>
		state_set(shell, SHELL_STATE_ACTIVE);
    40008328:	aa1303e0 	mov	x0, x19
    4000832c:	97ffff7c 	bl	4000811c <state_set.constprop.0>
		break;
    40008330:	17ffffab 	b	400081dc <shell_process+0x50>
					(void)execute(shell);
    40008334:	aa1303e0 	mov	x0, x19
    40008338:	97fffe60 	bl	40007cb8 <execute>
				state_set(shell, SHELL_STATE_ACTIVE);
    4000833c:	17fffffb 	b	40008328 <shell_process+0x19c>
    40008340:	71006c3f 	cmp	w1, #0x1b
    40008344:	540001a0 	b.eq	40008378 <shell_process+0x1ec>  // b.none
    40008348:	7101fc3f 	cmp	w1, #0x7f
    4000834c:	54fffbe1 	b.ne	400082c8 <shell_process+0x13c>  // b.any
	return sh->ctx->cfg.flags.echo == 1;
    40008350:	b9429801 	ldr	w1, [x0, #664]
				if (z_flag_echo_get(shell)) {
    40008354:	360ff441 	tbz	w1, #1, 400081dc <shell_process+0x50>
					z_flag_history_exit_set(shell, true);
    40008358:	52800021 	mov	w1, #0x1                   	// #1
    4000835c:	97fffde5 	bl	40007af0 <z_flag_history_exit_set.isra.0>
	return sh->ctx->cfg.flags.mode_delete == 1;
    40008360:	f9400a60 	ldr	x0, [x19, #16]
    40008364:	b9429800 	ldr	w0, [x0, #664]
					if (z_flag_mode_delete_get(shell)) {
    40008368:	371823a0 	tbnz	w0, #3, 400087dc <shell_process+0x650>
		z_shell_op_char_delete(shell);
    4000836c:	aa1303e0 	mov	x0, x19
    40008370:	94000844 	bl	4000a480 <z_shell_op_char_delete>
		break;
    40008374:	17ffff9a 	b	400081dc <shell_process+0x50>
	shell->ctx->receive_state = state;
    40008378:	52800021 	mov	w1, #0x1                   	// #1
    4000837c:	b9000c01 	str	w1, [x0, #12]
}
    40008380:	17ffff97 	b	400081dc <shell_process+0x50>
	return sh->ctx->cfg.flags.echo == 1;
    40008384:	b9429801 	ldr	w1, [x0, #664]
				if (z_flag_echo_get(shell) &&
    40008388:	360ff2a1 	tbz	w1, #1, 400081dc <shell_process+0x50>
					z_flag_history_exit_set(shell, true);
    4000838c:	52800021 	mov	w1, #0x1                   	// #1
    40008390:	97fffdd8 	bl	40007af0 <z_flag_history_exit_set.isra.0>
			shell->ctx->cmd_buff_len;
    40008394:	f9400a60 	ldr	x0, [x19, #16]
	if (compl_space == 0U) {
    40008398:	7940e001 	ldrh	w1, [x0, #112]
    4000839c:	7103fc3f 	cmp	w1, #0xff
    400083a0:	54fff1e0 	b.eq	400081dc <shell_process+0x50>  // b.none
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
    400083a4:	7940e402 	ldrh	w2, [x0, #114]
    400083a8:	9101d801 	add	x1, x0, #0x76
    400083ac:	9105d800 	add	x0, x0, #0x176
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    400083b0:	9104e3f6 	add	x22, sp, #0x138
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
    400083b4:	940013d8 	bl	4000d314 <memcpy>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    400083b8:	f9400a62 	ldr	x2, [x19, #16]
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    400083bc:	aa1603e1 	mov	x1, x22
    400083c0:	52800183 	mov	w3, #0xc                   	// #12
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    400083c4:	7940e440 	ldrh	w0, [x2, #114]
    400083c8:	8b000040 	add	x0, x2, x0
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    400083cc:	9105d842 	add	x2, x2, #0x176
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    400083d0:	3905d81f 	strb	wzr, [x0, #374]
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    400083d4:	9102e3e0 	add	x0, sp, #0xb8
    400083d8:	940003b5 	bl	400092ac <z_shell_make_argv>
	if (*argc > CONFIG_SHELL_ARGC_MAX) {
    400083dc:	f9405fe1 	ldr	x1, [sp, #184]
    400083e0:	f100303f 	cmp	x1, #0xc
    400083e4:	54ffefc8 	b.hi	400081dc <shell_process+0x50>  // b.pmore
	(*argv)[*argc] = NULL;
    400083e8:	f8217adf 	str	xzr, [x22, x1, lsl #3]
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
    400083ec:	b4000181 	cbz	x1, 4000841c <shell_process+0x290>
	int space = isspace((int)shell->ctx->cmd_buff[
    400083f0:	f9400a62 	ldr	x2, [x19, #16]
						shell->ctx->cmd_buff_pos - 1]);
    400083f4:	7940e440 	ldrh	w0, [x2, #114]
    400083f8:	51000400 	sub	w0, w0, #0x1
	int space = isspace((int)shell->ctx->cmd_buff[
    400083fc:	8b20c040 	add	x0, x2, w0, sxtw
    40008400:	3941d800 	ldrb	w0, [x0, #118]
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    40008404:	51002402 	sub	w2, w0, #0x9
    40008408:	7100801f 	cmp	w0, #0x20
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
    4000840c:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    40008410:	540007c9 	b.ls	40008508 <shell_process+0x37c>  // b.plast
    40008414:	f100043f 	cmp	x1, #0x1
    40008418:	54000761 	b.ne	40008504 <shell_process+0x378>  // b.any
		*cmd = selected_cmd_get(shell);
    4000841c:	d2800014 	mov	x20, #0x0                   	// #0
		*complete_arg_idx = Z_SHELL_CMD_ROOT_LVL;
    40008420:	f9005bff 	str	xzr, [sp, #176]
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
    40008424:	f9405be0 	ldr	x0, [sp, #176]
	*cnt = 0;
    40008428:	d2800015 	mov	x21, #0x0                   	// #0
	*longest = 0U;
    4000842c:	5280001a 	mov	w26, #0x0                   	// #0
	size_t first = 0;
    40008430:	d2800017 	mov	x23, #0x0                   	// #0
	size_t idx = 0;
    40008434:	d2800018 	mov	x24, #0x0                   	// #0
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
    40008438:	f8607adb 	ldr	x27, [x22, x0, lsl #3]
	incompl_cmd_len = z_shell_strlen(incompl_cmd);
    4000843c:	aa1b03e0 	mov	x0, x27
    40008440:	97fffd4b 	bl	4000796c <z_shell_strlen>
    40008444:	92403c19 	and	x25, x0, #0xffff
	while ((candidate = z_shell_cmd_get(cmd, idx, &dloc)) != NULL) {
    40008448:	910443e2 	add	x2, sp, #0x110
    4000844c:	aa1803e1 	mov	x1, x24
    40008450:	aa1403e0 	mov	x0, x20
    40008454:	94000462 	bl	400095dc <z_shell_cmd_get>
    40008458:	aa0003fc 	mov	x28, x0
    4000845c:	b5000680 	cbnz	x0, 4000852c <shell_process+0x3a0>
	if (cnt == 1) {
    40008460:	f10006bf 	cmp	x21, #0x1
    40008464:	54000941 	b.ne	4000858c <shell_process+0x400>  // b.any
	uint16_t arg_len = z_shell_strlen(arg);
    40008468:	f9405be0 	ldr	x0, [sp, #176]
    4000846c:	f8607ac0 	ldr	x0, [x22, x0, lsl #3]
    40008470:	97fffd3f 	bl	4000796c <z_shell_strlen>
    40008474:	12003c16 	and	w22, w0, #0xffff
	match = z_shell_cmd_get(cmd, subcmd_idx, &shell->ctx->active_cmd);
    40008478:	f9400a62 	ldr	x2, [x19, #16]
    4000847c:	aa1703e1 	mov	x1, x23
    40008480:	aa1403e0 	mov	x0, x20
    40008484:	91004042 	add	x2, x2, #0x10
    40008488:	94000455 	bl	400095dc <z_shell_cmd_get>
    4000848c:	aa0003f4 	mov	x20, x0
	cmd_len = z_shell_strlen(match->syntax);
    40008490:	f9400000 	ldr	x0, [x0]
    40008494:	97fffd36 	bl	4000796c <z_shell_strlen>
    40008498:	12003c02 	and	w2, w0, #0xffff
	if (cmd_len != arg_len) {
    4000849c:	6b2022df 	cmp	w22, w0, uxth
    400084a0:	540000c0 	b.eq	400084b8 <shell_process+0x32c>  // b.none
		z_shell_op_completion_insert(shell,
    400084a4:	f9400281 	ldr	x1, [x20]
    400084a8:	4b160042 	sub	w2, w2, w22
    400084ac:	aa1303e0 	mov	x0, x19
    400084b0:	8b362021 	add	x1, x1, w22, uxth
    400084b4:	940007f2 	bl	4000a47c <z_shell_op_completion_insert>
	if (!isspace((int) shell->ctx->cmd_buff[
    400084b8:	f9400a60 	ldr	x0, [x19, #16]
    400084bc:	7940e401 	ldrh	w1, [x0, #114]
    400084c0:	8b010001 	add	x1, x0, x1
    400084c4:	3941d821 	ldrb	w1, [x1, #118]
    400084c8:	51002422 	sub	w2, w1, #0x9
    400084cc:	7100803f 	cmp	w1, #0x20
    400084d0:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    400084d4:	54000549 	b.ls	4000857c <shell_process+0x3f0>  // b.plast
	return sh->ctx->cfg.flags.insert_mode == 1;
    400084d8:	b9429801 	ldr	w1, [x0, #664]
		if (z_flag_insert_mode_get(shell)) {
    400084dc:	36000481 	tbz	w1, #0, 4000856c <shell_process+0x3e0>
			z_flag_insert_mode_set(shell, false);
    400084e0:	52800001 	mov	w1, #0x0                   	// #0
    400084e4:	97fffdc8 	bl	40007c04 <z_flag_insert_mode_set.isra.0>
			z_shell_op_char_insert(shell, ' ');
    400084e8:	aa1303e0 	mov	x0, x19
    400084ec:	52800401 	mov	w1, #0x20                  	// #32
    400084f0:	940007ba 	bl	4000a3d8 <z_shell_op_char_insert>
			z_flag_insert_mode_set(shell, true);
    400084f4:	f9400a60 	ldr	x0, [x19, #16]
    400084f8:	52800021 	mov	w1, #0x1                   	// #1
				z_flag_insert_mode_set(shell, !status);
    400084fc:	97fffdc2 	bl	40007c04 <z_flag_insert_mode_set.isra.0>
				break;
    40008500:	17ffff37 	b	400081dc <shell_process+0x50>
	search_argc = space ? *argc : *argc - 1;
    40008504:	d1000421 	sub	x1, x1, #0x1
	*cmd = z_shell_get_last_command(selected_cmd_get(shell), search_argc,
    40008508:	910303e4 	add	x4, sp, #0xc0
    4000850c:	9102c3e3 	add	x3, sp, #0xb0
    40008510:	aa1603e2 	mov	x2, x22
    40008514:	52800005 	mov	w5, #0x0                   	// #0
    40008518:	d2800000 	mov	x0, #0x0                   	// #0
    4000851c:	94000476 	bl	400096f4 <z_shell_get_last_command>
    40008520:	aa0003f4 	mov	x20, x0
	if ((*cmd == NULL) && (search_argc != 0)) {
    40008524:	b5fff800 	cbnz	x0, 40008424 <shell_process+0x298>
    40008528:	17ffff2d 	b	400081dc <shell_process+0x50>
	return (strncmp(candidate, str, len) == 0) ? true : false;
    4000852c:	f9400380 	ldr	x0, [x28]
    40008530:	aa1903e2 	mov	x2, x25
    40008534:	aa1b03e1 	mov	x1, x27
    40008538:	9400134d 	bl	4000d26c <strncmp>
		if (is_candidate) {
    4000853c:	35000140 	cbnz	w0, 40008564 <shell_process+0x3d8>
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
    40008540:	f9400380 	ldr	x0, [x28]
    40008544:	94001331 	bl	4000d208 <strlen>
    40008548:	eb3a201f 	cmp	x0, w26, uxth
    4000854c:	92403f41 	and	x1, x26, #0xffff
    40008550:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
				*first_idx = idx;
    40008554:	f10002bf 	cmp	x21, #0x0
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
    40008558:	12003c1a 	and	w26, w0, #0xffff
				*first_idx = idx;
    4000855c:	9a9812f7 	csel	x23, x23, x24, ne  // ne = any
			(*cnt)++;
    40008560:	910006b5 	add	x21, x21, #0x1
		idx++;
    40008564:	91000718 	add	x24, x24, #0x1
    40008568:	17ffffb8 	b	40008448 <shell_process+0x2bc>
			z_shell_op_char_insert(shell, ' ');
    4000856c:	52800401 	mov	w1, #0x20                  	// #32
					z_shell_op_char_insert(shell, data);
    40008570:	aa1303e0 	mov	x0, x19
    40008574:	94000799 	bl	4000a3d8 <z_shell_op_char_insert>
    40008578:	17ffff19 	b	400081dc <shell_process+0x50>
		z_shell_op_cursor_move(shell, 1);
    4000857c:	aa1303e0 	mov	x0, x19
    40008580:	52800021 	mov	w1, #0x1                   	// #1
    40008584:	94000596 	bl	40009bdc <z_shell_op_cursor_move>
    40008588:	17ffff15 	b	400081dc <shell_process+0x50>
	} else if (cnt > 1) {
    4000858c:	54ffe289 	b.ls	400081dc <shell_process+0x50>  // b.plast
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
    40008590:	f9405be0 	ldr	x0, [sp, #176]
	longest_option += z_shell_strlen(tab);
    40008594:	90000078 	adrp	x24, 40014000 <shell_m_sub_colors+0x50>
    40008598:	91337b18 	add	x24, x24, #0xcde
		shell->ctx->vt100_ctx.printed_cmd = 0;
    4000859c:	aa1703fb 	mov	x27, x23
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
    400085a0:	f8607adc 	ldr	x28, [x22, x0, lsl #3]
	size_t str_len = z_shell_strlen(str);
    400085a4:	aa1c03e0 	mov	x0, x28
    400085a8:	97fffcf1 	bl	4000796c <z_shell_strlen>
    400085ac:	92403c00 	and	x0, x0, #0xffff
    400085b0:	a90683f5 	stp	x21, x0, [sp, #104]
		shell->ctx->vt100_ctx.printed_cmd = 0;
    400085b4:	f9400a60 	ldr	x0, [x19, #16]
    400085b8:	7900b01f 	strh	wzr, [x0, #88]
		z_shell_fprintf(shell, SHELL_OPTION, "%s", option);
    400085bc:	b0000060 	adrp	x0, 40015000 <prefix.1+0x2aa>
    400085c0:	910dbc00 	add	x0, x0, #0x36f
    400085c4:	f9003fe0 	str	x0, [sp, #120]
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
    400085c8:	f9400a62 	ldr	x2, [x19, #16]
    400085cc:	aa1b03e1 	mov	x1, x27
    400085d0:	aa1403e0 	mov	x0, x20
		idx++;
    400085d4:	9100077b 	add	x27, x27, #0x1
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
    400085d8:	91004042 	add	x2, x2, #0x10
    400085dc:	94000400 	bl	400095dc <z_shell_cmd_get>
    400085e0:	aa0003f9 	mov	x25, x0
		if (str && match->syntax &&
    400085e4:	b50007dc 	cbnz	x28, 400086dc <shell_process+0x550>
		tab_item_print(shell, match->syntax, longest);
    400085e8:	f9400323 	ldr	x3, [x25]
	if (option == NULL) {
    400085ec:	b5000863 	cbnz	x3, 400086f8 <shell_process+0x56c>
		shell->ctx->vt100_ctx.printed_cmd = 0;
    400085f0:	f9400a60 	ldr	x0, [x19, #16]
    400085f4:	7900b01f 	strh	wzr, [x0, #88]
	while (cnt) {
    400085f8:	f94037e0 	ldr	x0, [sp, #104]
    400085fc:	f1000400 	subs	x0, x0, #0x1
    40008600:	f90037e0 	str	x0, [sp, #104]
    40008604:	54fffe21 	b.ne	400085c8 <shell_process+0x43c>  // b.any
	z_cursor_next_line_move(shell);
    40008608:	f9401660 	ldr	x0, [x19, #40]
	size_t idx = first + 1;
    4000860c:	910006fa 	add	x26, x23, #0x1
	z_cursor_next_line_move(shell);
    40008610:	97fffd35 	bl	40007ae4 <z_cursor_next_line_move.isra.0>
	z_shell_print_prompt_and_cmd(shell);
    40008614:	aa1303e0 	mov	x0, x19
    40008618:	940007c7 	bl	4000a534 <z_shell_print_prompt_and_cmd>
	uint16_t arg_len = z_shell_strlen(arg);
    4000861c:	f9405be0 	ldr	x0, [sp, #176]
    40008620:	f8607ac0 	ldr	x0, [x22, x0, lsl #3]
	uint16_t common = UINT16_MAX;
    40008624:	529ffff6 	mov	w22, #0xffff                	// #65535
	uint16_t arg_len = z_shell_strlen(arg);
    40008628:	97fffcd1 	bl	4000796c <z_shell_strlen>
    4000862c:	12003c19 	and	w25, w0, #0xffff
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
    40008630:	aa1703e1 	mov	x1, x23
    40008634:	9103a3e2 	add	x2, sp, #0xe8
    40008638:	aa1403e0 	mov	x0, x20
    4000863c:	940003e8 	bl	400095dc <z_shell_cmd_get>
    40008640:	aa0003f7 	mov	x23, x0
	strncpy(shell->ctx->temp_buff, match->syntax,
    40008644:	d2801fe2 	mov	x2, #0xff                  	// #255
    40008648:	f9400a60 	ldr	x0, [x19, #16]
	uint16_t arg_len = z_shell_strlen(arg);
    4000864c:	2a1903f8 	mov	w24, w25
	strncpy(shell->ctx->temp_buff, match->syntax,
    40008650:	f94002e1 	ldr	x1, [x23]
    40008654:	9105d800 	add	x0, x0, #0x176
    40008658:	940012d2 	bl	4000d1a0 <strncpy>
	*str = match->syntax;
    4000865c:	f94002f7 	ldr	x23, [x23]
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
    40008660:	9100075b 	add	x27, x26, #0x1
    40008664:	910443e2 	add	x2, sp, #0x110
    40008668:	aa1a03e1 	mov	x1, x26
    4000866c:	aa1403e0 	mov	x0, x20
    40008670:	940003db 	bl	400095dc <z_shell_cmd_get>
		if (match2 == NULL) {
    40008674:	b4000a00 	cbz	x0, 400087b4 <shell_process+0x628>
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
    40008678:	f9400a61 	ldr	x1, [x19, #16]
    4000867c:	f9400003 	ldr	x3, [x0]
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    40008680:	9105d821 	add	x1, x1, #0x176
	size_t common = 0;
    40008684:	d2800000 	mov	x0, #0x0                   	// #0
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    40008688:	38606824 	ldrb	w4, [x1, x0]
    4000868c:	38606862 	ldrb	w2, [x3, x0]
    40008690:	6b04005f 	cmp	w2, w4
    40008694:	540000c1 	b.ne	400086ac <shell_process+0x520>  // b.any
    40008698:	340000a2 	cbz	w2, 400086ac <shell_process+0x520>
		common++;
    4000869c:	91000400 	add	x0, x0, #0x1
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    400086a0:	d29fffe2 	mov	x2, #0xffff                	// #65535
    400086a4:	eb02001f 	cmp	x0, x2
    400086a8:	54ffff01 	b.ne	40008688 <shell_process+0x4fc>  // b.any
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
    400086ac:	2a0003e2 	mov	w2, w0
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
    400086b0:	34000079 	cbz	w25, 400086bc <shell_process+0x530>
    400086b4:	6b19001f 	cmp	w0, w25
    400086b8:	540000eb 	b.lt	400086d4 <shell_process+0x548>  // b.tstop
			common = (curr_common < common) ? curr_common : common;
    400086bc:	6b0202df 	cmp	w22, w2
			--cnt;
    400086c0:	d10006b5 	sub	x21, x21, #0x1
			common = (curr_common < common) ? curr_common : common;
    400086c4:	1a82d2d6 	csel	w22, w22, w2, le
	while (cnt > 1) {
    400086c8:	f10006bf 	cmp	x21, #0x1
			common = (curr_common < common) ? curr_common : common;
    400086cc:	12003ed6 	and	w22, w22, #0xffff
	while (cnt > 1) {
    400086d0:	54000720 	b.eq	400087b4 <shell_process+0x628>  // b.none
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
    400086d4:	aa1b03fa 	mov	x26, x27
    400086d8:	17ffffe2 	b	40008660 <shell_process+0x4d4>
		if (str && match->syntax &&
    400086dc:	f9400000 	ldr	x0, [x0]
    400086e0:	b4fff840 	cbz	x0, 400085e8 <shell_process+0x45c>
	return (strncmp(candidate, str, len) == 0) ? true : false;
    400086e4:	f9403be2 	ldr	x2, [sp, #112]
    400086e8:	aa1c03e1 	mov	x1, x28
    400086ec:	940012e0 	bl	4000d26c <strncmp>
		if (str && match->syntax &&
    400086f0:	34fff7c0 	cbz	w0, 400085e8 <shell_process+0x45c>
    400086f4:	17ffffb5 	b	400085c8 <shell_process+0x43c>
	longest_option += z_shell_strlen(tab);
    400086f8:	aa1803e0 	mov	x0, x24
    400086fc:	f90047e3 	str	x3, [sp, #136]
    40008700:	97fffc9b 	bl	4000796c <z_shell_strlen>
    40008704:	0b202340 	add	w0, w26, w0, uxth
    40008708:	12003c02 	and	w2, w0, #0xffff
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
    4000870c:	f9400a60 	ldr	x0, [x19, #16]
    40008710:	79409401 	ldrh	w1, [x0, #74]
			- z_shell_strlen(tab)) / longest_option;
    40008714:	aa1803e0 	mov	x0, x24
	longest_option += z_shell_strlen(tab);
    40008718:	29130be1 	stp	w1, w2, [sp, #152]
			- z_shell_strlen(tab)) / longest_option;
    4000871c:	97fffc94 	bl	4000796c <z_shell_strlen>
    40008720:	12003c05 	and	w5, w0, #0xffff
	diff = longest_option - z_shell_strlen(option);
    40008724:	f94047e3 	ldr	x3, [sp, #136]
			- z_shell_strlen(tab)) / longest_option;
    40008728:	b90097e5 	str	w5, [sp, #148]
	diff = longest_option - z_shell_strlen(option);
    4000872c:	aa0303e0 	mov	x0, x3
    40008730:	97fffc8f 	bl	4000796c <z_shell_strlen>
    40008734:	b9409fe2 	ldr	w2, [sp, #156]
			- z_shell_strlen(tab)) / longest_option;
    40008738:	295287e5 	ldp	w5, w1, [sp, #148]
	diff = longest_option - z_shell_strlen(option);
    4000873c:	4b202059 	sub	w25, w2, w0, uxth
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
    40008740:	f9400a60 	ldr	x0, [x19, #16]
	diff = longest_option - z_shell_strlen(option);
    40008744:	12003f39 	and	w25, w25, #0xffff
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
    40008748:	f94047e3 	ldr	x3, [sp, #136]
    4000874c:	7940b004 	ldrh	w4, [x0, #88]
    40008750:	11000486 	add	w6, w4, #0x1
    40008754:	7900b006 	strh	w6, [x0, #88]
			- z_shell_strlen(tab)) / longest_option;
    40008758:	4b050020 	sub	w0, w1, w5
    4000875c:	1ac20c00 	sdiv	w0, w0, w2
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
    40008760:	12003c00 	and	w0, w0, #0xffff
    40008764:	1ac00881 	udiv	w1, w4, w0
    40008768:	1b009020 	msub	w0, w1, w0, w4
    4000876c:	72003c1f 	tst	w0, #0xffff
    40008770:	54000181 	b.ne	400087a0 <shell_process+0x614>  // b.any
		z_shell_fprintf(shell, SHELL_OPTION, "\n%s%s", tab, option);
    40008774:	aa0303e4 	mov	x4, x3
    40008778:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000877c:	911f1c42 	add	x2, x2, #0x7c7
    40008780:	aa1803e3 	mov	x3, x24
    40008784:	aa1303e0 	mov	x0, x19
    40008788:	528000c1 	mov	w1, #0x6                   	// #6
    4000878c:	9400063c 	bl	4000a07c <z_shell_fprintf>
	z_shell_op_cursor_horiz_move(shell, diff);
    40008790:	2a1903e1 	mov	w1, w25
    40008794:	aa1303e0 	mov	x0, x19
    40008798:	940004b4 	bl	40009a68 <z_shell_op_cursor_horiz_move>
    4000879c:	17ffff97 	b	400085f8 <shell_process+0x46c>
		z_shell_fprintf(shell, SHELL_OPTION, "%s", option);
    400087a0:	f9403fe2 	ldr	x2, [sp, #120]
    400087a4:	aa1303e0 	mov	x0, x19
    400087a8:	528000c1 	mov	w1, #0x6                   	// #6
    400087ac:	94000634 	bl	4000a07c <z_shell_fprintf>
    400087b0:	17fffff8 	b	40008790 <shell_process+0x604>
	if (common) {
    400087b4:	34ffd156 	cbz	w22, 400081dc <shell_process+0x50>
		z_shell_op_completion_insert(shell, &completion[arg_len],
    400087b8:	4b1902c2 	sub	w2, w22, w25
    400087bc:	8b3822e1 	add	x1, x23, w24, uxth
    400087c0:	aa1303e0 	mov	x0, x19
    400087c4:	9400072e 	bl	4000a47c <z_shell_op_completion_insert>
    400087c8:	17fffe85 	b	400081dc <shell_process+0x50>
	return sh->ctx->cfg.flags.echo == 1;
    400087cc:	b9429801 	ldr	w1, [x0, #664]
				if (z_flag_echo_get(shell)) {
    400087d0:	360fd061 	tbz	w1, #1, 400081dc <shell_process+0x50>
					z_flag_history_exit_set(shell, true);
    400087d4:	52800021 	mov	w1, #0x1                   	// #1
    400087d8:	97fffcc6 	bl	40007af0 <z_flag_history_exit_set.isra.0>
						z_shell_op_char_backspace(shell);
    400087dc:	aa1303e0 	mov	x0, x19
    400087e0:	94000745 	bl	4000a4f4 <z_shell_op_char_backspace>
    400087e4:	17fffe7e 	b	400081dc <shell_process+0x50>
    400087e8:	b9429802 	ldr	w2, [x0, #664]
				} else if (z_flag_echo_get(shell)) {
    400087ec:	360fcf82 	tbz	w2, #1, 400081dc <shell_process+0x50>
	switch (data) {
    400087f0:	51000421 	sub	w1, w1, #0x1
    400087f4:	7100583f 	cmp	w1, #0x16
    400087f8:	54ffcf28 	b.hi	400081dc <shell_process+0x50>  // b.pmore
    400087fc:	90000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40008800:	9112c042 	add	x2, x2, #0x4b0
    40008804:	78615841 	ldrh	w1, [x2, w1, uxtw #1]
    40008808:	10000062 	adr	x2, 40008814 <shell_process+0x688>
    4000880c:	8b21a841 	add	x1, x2, w1, sxth #2
    40008810:	d61f0020 	br	x1
		z_shell_op_left_arrow(shell);
    40008814:	aa1303e0 	mov	x0, x19
    40008818:	94000553 	bl	40009d64 <z_shell_op_left_arrow>
		break;
    4000881c:	17fffe70 	b	400081dc <shell_process+0x50>
		z_shell_op_cursor_end_move(shell);
    40008820:	aa1303e0 	mov	x0, x19
    40008824:	9400054b 	bl	40009d50 <z_shell_op_cursor_end_move>
		if (!z_shell_cursor_in_empty_line(shell)) {
    40008828:	aa1303e0 	mov	x0, x19
    4000882c:	9400049f 	bl	40009aa8 <z_shell_cursor_in_empty_line>
    40008830:	72001c1f 	tst	w0, #0xff
    40008834:	54000061 	b.ne	40008840 <shell_process+0x6b4>  // b.any
			z_cursor_next_line_move(shell);
    40008838:	f9401660 	ldr	x0, [x19, #40]
    4000883c:	97fffcaa 	bl	40007ae4 <z_cursor_next_line_move.isra.0>
		z_flag_history_exit_set(shell, true);
    40008840:	f9400a60 	ldr	x0, [x19, #16]
    40008844:	52800021 	mov	w1, #0x1                   	// #1
    40008848:	97fffcaa 	bl	40007af0 <z_flag_history_exit_set.isra.0>
    4000884c:	17fffeb7 	b	40008328 <shell_process+0x19c>
		z_shell_op_right_arrow(shell);
    40008850:	aa1303e0 	mov	x0, x19
    40008854:	9400054a 	bl	40009d7c <z_shell_op_right_arrow>
		break;
    40008858:	17fffe61 	b	400081dc <shell_process+0x50>
		z_shell_op_delete_from_cursor(shell);
    4000885c:	aa1303e0 	mov	x0, x19
    40008860:	9400054f 	bl	40009d9c <z_shell_op_delete_from_cursor>
		break;
    40008864:	17fffe5e 	b	400081dc <shell_process+0x50>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40008868:	b9429800 	ldr	w0, [x0, #664]
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
    4000886c:	362800c0 	tbz	w0, #5, 40008884 <shell_process+0x6f8>
    40008870:	f9401660 	ldr	x0, [x19, #40]
    40008874:	f0000041 	adrp	x1, 40013000 <shell_cmd_help>
    40008878:	9102c021 	add	x1, x1, #0xb0
    4000887c:	91001421 	add	x1, x1, #0x5
    40008880:	97fffc44 	bl	40007990 <z_shell_raw_fprintf>
    40008884:	f9400a60 	ldr	x0, [x19, #16]
    40008888:	b9429800 	ldr	w0, [x0, #664]
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
    4000888c:	362800c0 	tbz	w0, #5, 400088a4 <shell_process+0x718>
    40008890:	f9401660 	ldr	x0, [x19, #40]
    40008894:	f0000041 	adrp	x1, 40013000 <shell_cmd_help>
    40008898:	9102c021 	add	x1, x1, #0xb0
    4000889c:	91002821 	add	x1, x1, #0xa
    400088a0:	97fffc3c 	bl	40007990 <z_shell_raw_fprintf>
		z_shell_print_prompt_and_cmd(shell);
    400088a4:	aa1303e0 	mov	x0, x19
    400088a8:	94000723 	bl	4000a534 <z_shell_print_prompt_and_cmd>
		break;
    400088ac:	17fffe4c 	b	400081dc <shell_process+0x50>
		history_handle(shell, false);
    400088b0:	52800001 	mov	w1, #0x0                   	// #0
		history_handle(shell, true);
    400088b4:	aa1303e0 	mov	x0, x19
    400088b8:	97fffc95 	bl	40007b0c <history_handle>
		break;
    400088bc:	17fffe48 	b	400081dc <shell_process+0x50>
		history_handle(shell, true);
    400088c0:	52800021 	mov	w1, #0x1                   	// #1
    400088c4:	17fffffc 	b	400088b4 <shell_process+0x728>
		z_shell_op_cursor_home_move(shell);
    400088c8:	aa1303e0 	mov	x0, x19
    400088cc:	9400051d 	bl	40009d40 <z_shell_op_cursor_home_move>
		cmd_buffer_clear(shell);
    400088d0:	f9400a60 	ldr	x0, [x19, #16]
		z_flag_history_exit_set(shell, true);
    400088d4:	52800021 	mov	w1, #0x1                   	// #1
	shell->ctx->cmd_buff_len = 0;
    400088d8:	b900701f 	str	wzr, [x0, #112]
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
    400088dc:	3901d81f 	strb	wzr, [x0, #118]
		z_flag_history_exit_set(shell, true);
    400088e0:	97fffc84 	bl	40007af0 <z_flag_history_exit_set.isra.0>
    400088e4:	f9400a60 	ldr	x0, [x19, #16]
    400088e8:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
    400088ec:	362fc780 	tbz	w0, #5, 400081dc <shell_process+0x50>
    400088f0:	f9401660 	ldr	x0, [x19, #40]
    400088f4:	f0000041 	adrp	x1, 40013000 <shell_cmd_help>
    400088f8:	9102c021 	add	x1, x1, #0xb0
    400088fc:	97fffc25 	bl	40007990 <z_shell_raw_fprintf>
    40008900:	17fffe37 	b	400081dc <shell_process+0x50>
		z_shell_op_word_remove(shell);
    40008904:	aa1303e0 	mov	x0, x19
    40008908:	940005fa 	bl	4000a0f0 <z_shell_op_word_remove>
		z_flag_history_exit_set(shell, true);
    4000890c:	f9400a60 	ldr	x0, [x19, #16]
    40008910:	52800021 	mov	w1, #0x1                   	// #1
    40008914:	97fffc77 	bl	40007af0 <z_flag_history_exit_set.isra.0>
		break;
    40008918:	17fffe31 	b	400081dc <shell_process+0x50>
			if (data == '[') {
    4000891c:	71016c3f 	cmp	w1, #0x5b
    40008920:	54000061 	b.ne	4000892c <shell_process+0x7a0>  // b.any
	shell->ctx->receive_state = state;
    40008924:	52800041 	mov	w1, #0x2                   	// #2
    40008928:	17fffe95 	b	4000837c <shell_process+0x1f0>
	return sh->ctx->cfg.flags.echo == 1;
    4000892c:	b9429800 	ldr	w0, [x0, #664]
			} else if (z_flag_echo_get(shell)) {
    40008930:	360800c0 	tbz	w0, #1, 40008948 <shell_process+0x7bc>
	if (data == SHELL_VT100_ASCII_ALT_B) {
    40008934:	7101883f 	cmp	w1, #0x62
    40008938:	540000e1 	b.ne	40008954 <shell_process+0x7c8>  // b.any
		z_shell_op_cursor_word_move(shell, -1);
    4000893c:	12800001 	mov	w1, #0xffffffff            	// #-1
		z_shell_op_cursor_word_move(shell, 1);
    40008940:	aa1303e0 	mov	x0, x19
    40008944:	940004cb 	bl	40009c70 <z_shell_op_cursor_word_move>
	shell->ctx->receive_state = state;
    40008948:	f9400a60 	ldr	x0, [x19, #16]
    4000894c:	b9000c1f 	str	wzr, [x0, #12]
}
    40008950:	17fffe23 	b	400081dc <shell_process+0x50>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
    40008954:	7101983f 	cmp	w1, #0x66
    40008958:	54ffff81 	b.ne	40008948 <shell_process+0x7bc>  // b.any
		z_shell_op_cursor_word_move(shell, 1);
    4000895c:	52800021 	mov	w1, #0x1                   	// #1
    40008960:	17fffff8 	b	40008940 <shell_process+0x7b4>
    40008964:	b9429802 	ldr	w2, [x0, #664]
	shell->ctx->receive_state = state;
    40008968:	b9000c1f 	str	wzr, [x0, #12]
			if (!z_flag_echo_get(shell)) {
    4000896c:	360fc382 	tbz	w2, #1, 400081dc <shell_process+0x50>
			switch (data) {
    40008970:	5100c421 	sub	w1, w1, #0x31
    40008974:	71006c3f 	cmp	w1, #0x1b
    40008978:	54ffc328 	b.hi	400081dc <shell_process+0x50>  // b.pmore
    4000897c:	90000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40008980:	91138042 	add	x2, x2, #0x4e0
    40008984:	78615841 	ldrh	w1, [x2, w1, uxtw #1]
    40008988:	10000062 	adr	x2, 40008994 <shell_process+0x808>
    4000898c:	8b21a841 	add	x1, x2, w1, sxth #2
    40008990:	d61f0020 	br	x1
	shell->ctx->receive_state = state;
    40008994:	52800061 	mov	w1, #0x3                   	// #3
    40008998:	b9000c01 	str	w1, [x0, #12]
		z_shell_op_cursor_end_move(shell);
    4000899c:	aa1303e0 	mov	x0, x19
    400089a0:	940004ec 	bl	40009d50 <z_shell_op_cursor_end_move>
		break;
    400089a4:	17fffe0e 	b	400081dc <shell_process+0x50>
	shell->ctx->receive_state = state;
    400089a8:	52800061 	mov	w1, #0x3                   	// #3
    400089ac:	b9000c01 	str	w1, [x0, #12]
		z_shell_op_cursor_home_move(shell);
    400089b0:	aa1303e0 	mov	x0, x19
    400089b4:	940004e3 	bl	40009d40 <z_shell_op_cursor_home_move>
		break;
    400089b8:	17fffe09 	b	400081dc <shell_process+0x50>
	shell->ctx->receive_state = state;
    400089bc:	52800061 	mov	w1, #0x3                   	// #3
    400089c0:	b9000c01 	str	w1, [x0, #12]
	return sh->ctx->cfg.flags.insert_mode == 1;
    400089c4:	b9429801 	ldr	w1, [x0, #664]
    400089c8:	12000021 	and	w1, w1, #0x1
				z_flag_insert_mode_set(shell, !status);
    400089cc:	52000021 	eor	w1, w1, #0x1
    400089d0:	17fffecb 	b	400084fc <shell_process+0x370>
	shell->ctx->receive_state = state;
    400089d4:	52800061 	mov	w1, #0x3                   	// #3
    400089d8:	b9000c01 	str	w1, [x0, #12]
	return sh->ctx->cfg.flags.echo == 1;
    400089dc:	b9429800 	ldr	w0, [x0, #664]
				if (z_flag_echo_get(shell)) {
    400089e0:	360fbfe0 	tbz	w0, #1, 400081dc <shell_process+0x50>
    400089e4:	17fffe62 	b	4000836c <shell_process+0x1e0>

00000000400089e8 <shell_init>:
{
    400089e8:	d10183ff 	sub	sp, sp, #0x60
    400089ec:	a9017bfd 	stp	x29, x30, [sp, #16]
    400089f0:	910043fd 	add	x29, sp, #0x10
    400089f4:	a90253f3 	stp	x19, x20, [sp, #32]
    400089f8:	aa0003f3 	mov	x19, x0
	if (shell->ctx->tid) {
    400089fc:	f9400800 	ldr	x0, [x0, #16]
{
    40008a00:	a90463f7 	stp	x23, x24, [sp, #64]
    40008a04:	aa0103f7 	mov	x23, x1
    40008a08:	a9035bf5 	stp	x21, x22, [sp, #48]
	if (shell->ctx->tid) {
    40008a0c:	f941e401 	ldr	x1, [x0, #968]
{
    40008a10:	f9002bf9 	str	x25, [sp, #80]
	if (shell->ctx->tid) {
    40008a14:	b5000a21 	cbnz	x1, 40008b58 <shell_init+0x170>
    40008a18:	12001c79 	and	w25, w3, #0xff
    40008a1c:	2a0403f6 	mov	w22, w4
static int instance_init(const struct shell *sh,
    40008a20:	2a0203f4 	mov	w20, w2
	memset(sh->ctx, 0, sizeof(*sh->ctx));
    40008a24:	d2807a02 	mov	x2, #0x3d0                 	// #976
    40008a28:	94001243 	bl	4000d334 <memset>
	sh->ctx->prompt = sh->default_prompt;
    40008a2c:	f9400a60 	ldr	x0, [x19, #16]
    40008a30:	f9400261 	ldr	x1, [x19]
    40008a34:	f9000001 	str	x1, [x0]
	z_shell_history_init(shell->history);
    40008a38:	f9400e60 	ldr	x0, [x19, #24]
    40008a3c:	94000acd 	bl	4000b570 <z_shell_history_init>
	k_mutex_init(&sh->ctx->wr_mtx);
    40008a40:	f9400a60 	ldr	x0, [x19, #16]
    40008a44:	910ea000 	add	x0, x0, #0x3a8
	return z_impl_k_mutex_init(mutex);
    40008a48:	d2806118 	mov	x24, #0x308                 	// #776
    40008a4c:	d2805515 	mov	x21, #0x2a8                 	// #680
    40008a50:	9400199a 	bl	4000f0b8 <z_impl_k_mutex_init>
		k_poll_signal_init(&sh->ctx->signals[i]);
    40008a54:	f9400a60 	ldr	x0, [x19, #16]
    40008a58:	8b150000 	add	x0, x0, x21
	z_impl_k_poll_signal_init(sig);
    40008a5c:	940022ce 	bl	40011594 <z_impl_k_poll_signal_init>
		k_poll_event_init(&sh->ctx->events[i],
    40008a60:	f9400a60 	ldr	x0, [x19, #16]
    40008a64:	52800002 	mov	w2, #0x0                   	// #0
    40008a68:	52800021 	mov	w1, #0x1                   	// #1
    40008a6c:	8b150003 	add	x3, x0, x21
    40008a70:	8b180000 	add	x0, x0, x24
	for (int i = 0; i < SHELL_SIGNALS; i++) {
    40008a74:	910062b5 	add	x21, x21, #0x18
		k_poll_event_init(&sh->ctx->events[i],
    40008a78:	9400227e 	bl	40011470 <k_poll_event_init>
	for (int i = 0; i < SHELL_SIGNALS; i++) {
    40008a7c:	9100a318 	add	x24, x24, #0x28
    40008a80:	f10c22bf 	cmp	x21, #0x308
    40008a84:	54fffe81 	b.ne	40008a54 <shell_init+0x6c>  // b.any
		sh->stats->log_lost_cnt = 0;
    40008a88:	f9401a60 	ldr	x0, [x19, #48]
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, tx_rdy, val, ret);
    40008a8c:	d2800041 	mov	x1, #0x2                   	// #2
	sh->ctx->cfg.flags = cfg_flags;
    40008a90:	121d7a94 	and	w20, w20, #0xfffffffb
		sh->stats->log_lost_cnt = 0;
    40008a94:	f900001f 	str	xzr, [x0]
    40008a98:	f9400a60 	ldr	x0, [x19, #16]
    40008a9c:	910a8000 	add	x0, x0, #0x2a0
    40008aa0:	97fffb89 	bl	400078c4 <atomic_or>
	sh->ctx->vt100_ctx.cons.terminal_wid =
    40008aa4:	f9400a60 	ldr	x0, [x19, #16]
	sh->ctx->vt100_ctx.cons.terminal_hei =
    40008aa8:	52800301 	mov	w1, #0x18                  	// #24
    40008aac:	72a00a01 	movk	w1, #0x50, lsl #16
    40008ab0:	b9004801 	str	w1, [x0, #72]
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
    40008ab4:	f9400000 	ldr	x0, [x0]
    40008ab8:	97fffbad 	bl	4000796c <z_shell_strlen>
    40008abc:	f9400a61 	ldr	x1, [x19, #16]
	int ret = sh->iface->api->init(sh->iface, transport_config,
    40008ac0:	aa1303e3 	mov	x3, x19
    40008ac4:	f0ffffe2 	adrp	x2, 40007000 <cmd_devmem+0xec>
    40008ac8:	91291042 	add	x2, x2, #0xa44
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
    40008acc:	39013020 	strb	w0, [x1, #76]
	int ret = sh->iface->api->init(sh->iface, transport_config,
    40008ad0:	f9400660 	ldr	x0, [x19, #8]
	sh->ctx->cfg.flags = cfg_flags;
    40008ad4:	b9029834 	str	w20, [x1, #664]
	int ret = sh->iface->api->init(sh->iface, transport_config,
    40008ad8:	f9400001 	ldr	x1, [x0]
    40008adc:	f9400024 	ldr	x4, [x1]
    40008ae0:	aa1703e1 	mov	x1, x23
    40008ae4:	d63f0080 	blr	x4
    40008ae8:	2a0003f4 	mov	w20, w0
	if (ret == 0) {
    40008aec:	35000260 	cbnz	w0, 40008b38 <shell_init+0x150>
	shell->ctx->state = state;
    40008af0:	f9400a60 	ldr	x0, [x19, #16]
    40008af4:	52800021 	mov	w1, #0x1                   	// #1
    40008af8:	b9000801 	str	w1, [x0, #8]
	k_tid_t tid = k_thread_create(shell->thread,
    40008afc:	a9450660 	ldp	x0, x1, [x19, #80]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    40008b00:	b90003ff 	str	wzr, [sp]
    40008b04:	2a1603e6 	mov	w6, w22
    40008b08:	f90007ff 	str	xzr, [sp, #8]
    40008b0c:	92401f25 	and	x5, x25, #0xff
    40008b10:	aa1303e4 	mov	x4, x19
    40008b14:	528001c7 	mov	w7, #0xe                   	// #14
    40008b18:	d2810002 	mov	x2, #0x800                 	// #2048
    40008b1c:	90000003 	adrp	x3, 40008000 <execute+0x348>
    40008b20:	912fa063 	add	x3, x3, #0xbe8
    40008b24:	9400183b 	bl	4000ec10 <z_impl_k_thread_create>
	shell->ctx->tid = tid;
    40008b28:	f9400a61 	ldr	x1, [x19, #16]
    40008b2c:	f901e420 	str	x0, [x1, #968]
	k_thread_name_set(tid, shell->thread_name);
    40008b30:	f9402661 	ldr	x1, [x19, #72]
	return z_impl_k_thread_name_set(thread, str);
    40008b34:	940017b2 	bl	4000e9fc <z_impl_k_thread_name_set>
}
    40008b38:	2a1403e0 	mov	w0, w20
    40008b3c:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40008b40:	a94253f3 	ldp	x19, x20, [sp, #32]
    40008b44:	a9435bf5 	ldp	x21, x22, [sp, #48]
    40008b48:	a94463f7 	ldp	x23, x24, [sp, #64]
    40008b4c:	f9402bf9 	ldr	x25, [sp, #80]
    40008b50:	910183ff 	add	sp, sp, #0x60
    40008b54:	d65f03c0 	ret
		return -EALREADY;
    40008b58:	12800ef4 	mov	w20, #0xffffff88            	// #-120
    40008b5c:	17fffff7 	b	40008b38 <shell_init+0x150>

0000000040008b60 <shell_uninit>:
				&shell->ctx->signals[SHELL_SIGNAL_KILL];
    40008b60:	f9400800 	ldr	x0, [x0, #16]
		shell->ctx->uninit_cb = cb;
    40008b64:	f9003001 	str	x1, [x0, #96]
	return z_impl_k_poll_signal_raise(sig, result);
    40008b68:	52800001 	mov	w1, #0x0                   	// #0
    40008b6c:	910b6000 	add	x0, x0, #0x2d8
    40008b70:	14002293 	b	400115bc <z_impl_k_poll_signal_raise>

0000000040008b74 <shell_start>:
{
    40008b74:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40008b78:	910003fd 	mov	x29, sp
    40008b7c:	f9000bf3 	str	x19, [sp, #16]
    40008b80:	aa0003f3 	mov	x19, x0
	return shell->ctx->state;
    40008b84:	f9400800 	ldr	x0, [x0, #16]
	if (state_get(shell) != SHELL_STATE_INITIALIZED) {
    40008b88:	b9400801 	ldr	w1, [x0, #8]
    40008b8c:	7100043f 	cmp	w1, #0x1
    40008b90:	54000281 	b.ne	40008be0 <shell_start+0x6c>  // b.any
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40008b94:	910ea000 	add	x0, x0, #0x3a8
    40008b98:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40008b9c:	97fffba9 	bl	40007a40 <k_mutex_lock.constprop.0.isra.0>
		z_shell_vt100_color_set(shell, SHELL_NORMAL);
    40008ba0:	aa1303e0 	mov	x0, x19
    40008ba4:	52800101 	mov	w1, #0x8                   	// #8
    40008ba8:	940004d7 	bl	40009f04 <z_shell_vt100_color_set>
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n\n");
    40008bac:	f9401660 	ldr	x0, [x19, #40]
    40008bb0:	b0000061 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40008bb4:	91095c21 	add	x1, x1, #0x257
    40008bb8:	97fffb76 	bl	40007990 <z_shell_raw_fprintf>
	state_set(shell, SHELL_STATE_ACTIVE);
    40008bbc:	aa1303e0 	mov	x0, x19
    40008bc0:	97fffd57 	bl	4000811c <state_set.constprop.0>
	k_mutex_unlock(&shell->ctx->wr_mtx);
    40008bc4:	f9400a60 	ldr	x0, [x19, #16]
    40008bc8:	910ea000 	add	x0, x0, #0x3a8
    40008bcc:	97fffc1b 	bl	40007c38 <k_mutex_unlock.isra.0>
	return 0;
    40008bd0:	52800000 	mov	w0, #0x0                   	// #0
}
    40008bd4:	f9400bf3 	ldr	x19, [sp, #16]
    40008bd8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40008bdc:	d65f03c0 	ret
		return -ENOTSUP;
    40008be0:	128010a0 	mov	w0, #0xffffff7a            	// #-134
    40008be4:	17fffffc 	b	40008bd4 <shell_start+0x60>

0000000040008be8 <shell_thread>:
{
    40008be8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40008bec:	910003fd 	mov	x29, sp
    40008bf0:	a90153f3 	stp	x19, x20, [sp, #16]
    40008bf4:	aa0003f3 	mov	x19, x0
    40008bf8:	aa0203f4 	mov	x20, x2
	err = shell->iface->api->enable(shell->iface, false);
    40008bfc:	f9400400 	ldr	x0, [x0, #8]
{
    40008c00:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008c04:	aa0103f5 	mov	x21, x1
	err = shell->iface->api->enable(shell->iface, false);
    40008c08:	f9400001 	ldr	x1, [x0]
    40008c0c:	f9400822 	ldr	x2, [x1, #16]
    40008c10:	52800001 	mov	w1, #0x0                   	// #0
    40008c14:	d63f0040 	blr	x2
	if (err != 0) {
    40008c18:	35000760 	cbnz	w0, 40008d04 <shell_thread+0x11c>
	if (IS_ENABLED(CONFIG_SHELL_LOG_BACKEND) && log_backend
    40008c1c:	b40000b5 	cbz	x21, 40008c30 <shell_thread+0x48>
		z_shell_log_backend_enable(shell->log_backend, (void *)shell,
    40008c20:	f9401e60 	ldr	x0, [x19, #56]
    40008c24:	2a1403e2 	mov	w2, w20
    40008c28:	aa1303e1 	mov	x1, x19
    40008c2c:	940006cf 	bl	4000a768 <z_shell_log_backend_enable>
	err = shell_start(shell);
    40008c30:	aa1303e0 	mov	x0, x19
    40008c34:	97ffffd0 	bl	40008b74 <shell_start>
	if (err != 0) {
    40008c38:	35000660 	cbnz	w0, 40008d04 <shell_thread+0x11c>
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
    40008c3c:	f0fffff6 	adrp	x22, 40007000 <cmd_devmem+0xec>
    40008c40:	912982d6 	add	x22, x22, #0xa60
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
    40008c44:	90000015 	adrp	x21, 40008000 <execute+0x348>
    40008c48:	910632b5 	add	x21, x21, #0x18c
		err = k_poll(shell->ctx->events, SHELL_SIGNAL_TXDONE,
    40008c4c:	f9400a60 	ldr	x0, [x19, #16]
    40008c50:	910c2000 	add	x0, x0, #0x308
	return z_impl_k_poll(events, num_events, timeout);
    40008c54:	52800061 	mov	w1, #0x3                   	// #3
    40008c58:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    40008c5c:	9400220e 	bl	40011494 <z_impl_k_poll>
    40008c60:	2a0003f4 	mov	w20, w0
		if (err != 0) {
    40008c64:	f9400a60 	ldr	x0, [x19, #16]
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40008c68:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40008c6c:	910ea000 	add	x0, x0, #0x3a8
		if (err != 0) {
    40008c70:	340001d4 	cbz	w20, 40008ca8 <shell_thread+0xc0>
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40008c74:	97fffb73 	bl	40007a40 <k_mutex_lock.constprop.0.isra.0>
			z_shell_fprintf(shell, SHELL_ERROR,
    40008c78:	2a1403e3 	mov	w3, w20
    40008c7c:	aa1303e0 	mov	x0, x19
    40008c80:	52800021 	mov	w1, #0x1                   	// #1
    40008c84:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40008c88:	911f3442 	add	x2, x2, #0x7cd
    40008c8c:	940004fc 	bl	4000a07c <z_shell_fprintf>
			k_mutex_unlock(&shell->ctx->wr_mtx);
    40008c90:	f9400a60 	ldr	x0, [x19, #16]
}
    40008c94:	a94153f3 	ldp	x19, x20, [sp, #16]
			k_mutex_unlock(&shell->ctx->wr_mtx);
    40008c98:	910ea000 	add	x0, x0, #0x3a8
}
    40008c9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008ca0:	a8c37bfd 	ldp	x29, x30, [sp], #48
			k_mutex_unlock(&shell->ctx->wr_mtx);
    40008ca4:	17fffbe5 	b	40007c38 <k_mutex_unlock.isra.0>
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40008ca8:	97fffb66 	bl	40007a40 <k_mutex_lock.constprop.0.isra.0>
		if (shell->iface->api->update) {
    40008cac:	f9400660 	ldr	x0, [x19, #8]
    40008cb0:	f9400001 	ldr	x1, [x0]
    40008cb4:	f9401421 	ldr	x1, [x1, #40]
    40008cb8:	b4000041 	cbz	x1, 40008cc0 <shell_thread+0xd8>
			shell->iface->api->update(shell->iface);
    40008cbc:	d63f0020 	blr	x1
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
    40008cc0:	aa1603e2 	mov	x2, x22
    40008cc4:	aa1303e0 	mov	x0, x19
    40008cc8:	52800041 	mov	w1, #0x2                   	// #2
    40008ccc:	97fffb0e 	bl	40007904 <shell_signal_handle>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
    40008cd0:	aa1503e2 	mov	x2, x21
    40008cd4:	aa1303e0 	mov	x0, x19
    40008cd8:	52800001 	mov	w1, #0x0                   	// #0
    40008cdc:	97fffb0a 	bl	40007904 <shell_signal_handle>
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
    40008ce0:	aa1303e0 	mov	x0, x19
    40008ce4:	52800021 	mov	w1, #0x1                   	// #1
    40008ce8:	f0ffffe2 	adrp	x2, 40007000 <cmd_devmem+0xec>
    40008cec:	9130f042 	add	x2, x2, #0xc3c
    40008cf0:	97fffb05 	bl	40007904 <shell_signal_handle>
		k_mutex_unlock(&shell->ctx->wr_mtx);
    40008cf4:	f9400a60 	ldr	x0, [x19, #16]
    40008cf8:	910ea000 	add	x0, x0, #0x3a8
    40008cfc:	97fffbcf 	bl	40007c38 <k_mutex_unlock.isra.0>
    40008d00:	17ffffd3 	b	40008c4c <shell_thread+0x64>
}
    40008d04:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008d08:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008d0c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40008d10:	d65f03c0 	ret

0000000040008d14 <shell_vfprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_vfprintf(const struct shell *sh, enum shell_vt100_color color,
		   const char *fmt, va_list args)
{
    40008d14:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40008d18:	910003fd 	mov	x29, sp
    40008d1c:	a90153f3 	stp	x19, x20, [sp, #16]
    40008d20:	aa0003f3 	mov	x19, x0
	return shell->ctx->state;
    40008d24:	f9400800 	ldr	x0, [x0, #16]
{
    40008d28:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008d2c:	2a0103f5 	mov	w21, w1
			(k_current_get() != sh->ctx->tid));
	__ASSERT_NO_MSG(sh->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	/* Sending a message to a non-active shell leads to a dead lock. */
	if (state_get(sh) != SHELL_STATE_ACTIVE) {
    40008d30:	b9400801 	ldr	w1, [x0, #8]
    40008d34:	7100083f 	cmp	w1, #0x2
    40008d38:	540000e0 	b.eq	40008d54 <shell_vfprintf+0x40>  // b.none
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
		z_shell_print_prompt_and_cmd(sh);
	}
	z_transport_buffer_flush(sh);
	k_mutex_unlock(&sh->ctx->wr_mtx);
}
    40008d3c:	a94153f3 	ldp	x19, x20, [sp, #16]
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
    40008d40:	910a8000 	add	x0, x0, #0x2a0
    40008d44:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008d48:	d2820001 	mov	x1, #0x1000                	// #4096
    40008d4c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40008d50:	17fffadd 	b	400078c4 <atomic_or>
	k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
    40008d54:	910ea000 	add	x0, x0, #0x3a8
    40008d58:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40008d5c:	aa0203f6 	mov	x22, x2
    40008d60:	aa0303f4 	mov	x20, x3
    40008d64:	97fffb37 	bl	40007a40 <k_mutex_lock.constprop.0.isra.0>
	return sh->ctx->ctx.flags.cmd_ctx == 1;
    40008d68:	f9400a60 	ldr	x0, [x19, #16]
    40008d6c:	b942a001 	ldr	w1, [x0, #672]
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
    40008d70:	375800a1 	tbnz	w1, #11, 40008d84 <shell_vfprintf+0x70>
    40008d74:	f9403400 	ldr	x0, [x0, #104]
    40008d78:	b5000060 	cbnz	x0, 40008d84 <shell_vfprintf+0x70>
		z_shell_cmd_line_erase(sh);
    40008d7c:	aa1303e0 	mov	x0, x19
    40008d80:	9400040d 	bl	40009db4 <z_shell_cmd_line_erase>
	z_shell_vfprintf(sh, color, fmt, args);
    40008d84:	a9400680 	ldp	x0, x1, [x20]
    40008d88:	a90307e0 	stp	x0, x1, [sp, #48]
    40008d8c:	9100c3e3 	add	x3, sp, #0x30
    40008d90:	a9410680 	ldp	x0, x1, [x20, #16]
    40008d94:	aa1603e2 	mov	x2, x22
    40008d98:	a90407e0 	stp	x0, x1, [sp, #64]
    40008d9c:	2a1503e1 	mov	w1, w21
    40008da0:	aa1303e0 	mov	x0, x19
    40008da4:	94000489 	bl	40009fc8 <z_shell_vfprintf>
    40008da8:	f9400a60 	ldr	x0, [x19, #16]
    40008dac:	b942a001 	ldr	w1, [x0, #672]
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
    40008db0:	375800a1 	tbnz	w1, #11, 40008dc4 <shell_vfprintf+0xb0>
    40008db4:	f9403400 	ldr	x0, [x0, #104]
    40008db8:	b5000060 	cbnz	x0, 40008dc4 <shell_vfprintf+0xb0>
		z_shell_print_prompt_and_cmd(sh);
    40008dbc:	aa1303e0 	mov	x0, x19
    40008dc0:	940005dd 	bl	4000a534 <z_shell_print_prompt_and_cmd>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
    40008dc4:	f9401660 	ldr	x0, [x19, #40]
    40008dc8:	940000c8 	bl	400090e8 <z_shell_fprintf_buffer_flush>
	k_mutex_unlock(&sh->ctx->wr_mtx);
    40008dcc:	f9400a60 	ldr	x0, [x19, #16]
}
    40008dd0:	a94153f3 	ldp	x19, x20, [sp, #16]
	k_mutex_unlock(&sh->ctx->wr_mtx);
    40008dd4:	910ea000 	add	x0, x0, #0x3a8
}
    40008dd8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008ddc:	a8c57bfd 	ldp	x29, x30, [sp], #80
	k_mutex_unlock(&sh->ctx->wr_mtx);
    40008de0:	17fffb96 	b	40007c38 <k_mutex_unlock.isra.0>

0000000040008de4 <shell_fprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_fprintf(const struct shell *shell, enum shell_vt100_color color,
		   const char *fmt, ...)
{
    40008de4:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40008de8:	910003fd 	mov	x29, sp
    40008dec:	a90d93e3 	stp	x3, x4, [sp, #216]
	va_list args;

	va_start(args, fmt);
    40008df0:	910403e3 	add	x3, sp, #0x100
    40008df4:	a9030fe3 	stp	x3, x3, [sp, #48]
    40008df8:	910343e3 	add	x3, sp, #0xd0
    40008dfc:	f90023e3 	str	x3, [sp, #64]
    40008e00:	128004e3 	mov	w3, #0xffffffd8            	// #-40
    40008e04:	b9004be3 	str	w3, [sp, #72]
    40008e08:	12800fe3 	mov	w3, #0xffffff80            	// #-128
    40008e0c:	b9004fe3 	str	w3, [sp, #76]
	shell_vfprintf(shell, color, fmt, args);
    40008e10:	910043e3 	add	x3, sp, #0x10
{
    40008e14:	a90e9be5 	stp	x5, x6, [sp, #232]
	shell_vfprintf(shell, color, fmt, args);
    40008e18:	a94317e4 	ldp	x4, x5, [sp, #48]
    40008e1c:	a90117e4 	stp	x4, x5, [sp, #16]
    40008e20:	a94417e4 	ldp	x4, x5, [sp, #64]
    40008e24:	a90217e4 	stp	x4, x5, [sp, #32]
{
    40008e28:	3d8017e0 	str	q0, [sp, #80]
    40008e2c:	3d801be1 	str	q1, [sp, #96]
    40008e30:	3d801fe2 	str	q2, [sp, #112]
    40008e34:	3d8023e3 	str	q3, [sp, #128]
    40008e38:	3d8027e4 	str	q4, [sp, #144]
    40008e3c:	3d802be5 	str	q5, [sp, #160]
    40008e40:	3d802fe6 	str	q6, [sp, #176]
    40008e44:	3d8033e7 	str	q7, [sp, #192]
    40008e48:	f9007fe7 	str	x7, [sp, #248]
	shell_vfprintf(shell, color, fmt, args);
    40008e4c:	97ffffb2 	bl	40008d14 <shell_vfprintf>
	va_end(args);
}
    40008e50:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40008e54:	d65f03c0 	ret

0000000040008e58 <cmd_help>:
{
	sh->ctx->bypass = bypass;
}

static int cmd_help(const struct shell *shell, size_t argc, char **argv)
{
    40008e58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

#if defined(CONFIG_SHELL_TAB)
	shell_print(shell, "Please press the <Tab> button to see all available "
    40008e5c:	52800101 	mov	w1, #0x8                   	// #8
    40008e60:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40008e64:	911f9042 	add	x2, x2, #0x7e4
{
    40008e68:	910003fd 	mov	x29, sp
    40008e6c:	f9000bf3 	str	x19, [sp, #16]
    40008e70:	aa0003f3 	mov	x19, x0
	shell_print(shell, "Please press the <Tab> button to see all available "
    40008e74:	97ffffdc 	bl	40008de4 <shell_fprintf>
			   "commands.");
#endif

#if defined(CONFIG_SHELL_TAB_AUTOCOMPLETION)
	shell_print(shell,
    40008e78:	aa1303e0 	mov	x0, x19
    40008e7c:	52800101 	mov	w1, #0x8                   	// #8
    40008e80:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40008e84:	91208842 	add	x2, x2, #0x822
    40008e88:	97ffffd7 	bl	40008de4 <shell_fprintf>
		"You can also use the <Tab> button to prompt or auto-complete"
		" all commands or its subcommands.");
#endif

#if defined(CONFIG_SHELL_HELP)
	shell_print(shell,
    40008e8c:	aa1303e0 	mov	x0, x19
    40008e90:	52800101 	mov	w1, #0x8                   	// #8
    40008e94:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40008e98:	91220442 	add	x2, x2, #0x881
    40008e9c:	97ffffd2 	bl	40008de4 <shell_fprintf>
		"You can try to call commands with <-h> or <--help> parameter"
		" for more information.");
#endif

#if defined(CONFIG_SHELL_METAKEYS)
	shell_print(shell,
    40008ea0:	aa1303e0 	mov	x0, x19
    40008ea4:	52800101 	mov	w1, #0x8                   	// #8
    40008ea8:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40008eac:	91235442 	add	x2, x2, #0x8d5
    40008eb0:	97ffffcd 	bl	40008de4 <shell_fprintf>
		"Please refer to shell documentation for more details.");
#endif

	if (IS_ENABLED(CONFIG_SHELL_HELP)) {
		/* For NULL argument function will print all root commands */
		z_shell_help_subcmd_print(shell, NULL,
    40008eb4:	aa1303e0 	mov	x0, x19
    40008eb8:	d2800001 	mov	x1, #0x0                   	// #0
    40008ebc:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40008ec0:	9125bc42 	add	x2, x2, #0x96f
    40008ec4:	9400072a 	bl	4000ab6c <z_shell_help_subcmd_print>
			shell_print(shell, "  %s", entry->syntax);
		}
	}

	return 0;
}
    40008ec8:	52800000 	mov	w0, #0x0                   	// #0
    40008ecc:	f9400bf3 	ldr	x19, [sp, #16]
    40008ed0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40008ed4:	d65f03c0 	ret

0000000040008ed8 <shell_hexdump_line>:
{
    40008ed8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40008edc:	910003fd 	mov	x29, sp
    40008ee0:	a90363f7 	stp	x23, x24, [sp, #48]
			shell_fprintf(shell, SHELL_NORMAL, "   ");
    40008ee4:	90000077 	adrp	x23, 40014000 <shell_m_sub_colors+0x50>
    40008ee8:	913376f7 	add	x23, x23, #0xcdd
			shell_fprintf(shell, SHELL_NORMAL, "%02x ",
    40008eec:	90000078 	adrp	x24, 40014000 <shell_m_sub_colors+0x50>
    40008ef0:	911a4718 	add	x24, x24, #0x691
{
    40008ef4:	a90153f3 	stp	x19, x20, [sp, #16]
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
    40008ef8:	d2800014 	mov	x20, #0x0                   	// #0
{
    40008efc:	aa0003f3 	mov	x19, x0
    40008f00:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008f04:	aa0203f5 	mov	x21, x2
    40008f08:	aa0303f6 	mov	x22, x3
	shell_fprintf(shell, SHELL_NORMAL, "%08X: ", offset);
    40008f0c:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40008f10:	91261442 	add	x2, x2, #0x985
    40008f14:	2a0103e3 	mov	w3, w1
    40008f18:	52800101 	mov	w1, #0x8                   	// #8
    40008f1c:	97ffffb2 	bl	40008de4 <shell_fprintf>
		if (i < len) {
    40008f20:	eb1402df 	cmp	x22, x20
    40008f24:	54000649 	b.ls	40008fec <shell_hexdump_line+0x114>  // b.plast
			shell_fprintf(shell, SHELL_NORMAL, "%02x ",
    40008f28:	38746aa3 	ldrb	w3, [x21, x20]
    40008f2c:	aa1803e2 	mov	x2, x24
    40008f30:	aa1303e0 	mov	x0, x19
    40008f34:	52800101 	mov	w1, #0x8                   	// #8
    40008f38:	97ffffab 	bl	40008de4 <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
    40008f3c:	f1003e9f 	cmp	x20, #0xf
    40008f40:	54000421 	b.ne	40008fc4 <shell_hexdump_line+0xec>  // b.any
			shell_fprintf(shell, SHELL_NORMAL, " ");
    40008f44:	90000077 	adrp	x23, 40014000 <shell_m_sub_colors+0x50>
    40008f48:	91337ef7 	add	x23, x23, #0xcdf
			shell_fprintf(shell, SHELL_NORMAL, "%c",
    40008f4c:	b0000078 	adrp	x24, 40015000 <prefix.1+0x2aa>
    40008f50:	9126b318 	add	x24, x24, #0x9ac
	shell_fprintf(shell, SHELL_NORMAL, "|");
    40008f54:	d2800014 	mov	x20, #0x0                   	// #0
    40008f58:	aa1303e0 	mov	x0, x19
    40008f5c:	90000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40008f60:	91338442 	add	x2, x2, #0xce1
    40008f64:	52800101 	mov	w1, #0x8                   	// #8
    40008f68:	97ffff9f 	bl	40008de4 <shell_fprintf>
		if (i < len) {
    40008f6c:	eb16029f 	cmp	x20, x22
    40008f70:	540005a2 	b.cs	40009024 <shell_hexdump_line+0x14c>  // b.hs, b.nlast
			char c = data[i];
    40008f74:	38746aa0 	ldrb	w0, [x21, x20]
			shell_fprintf(shell, SHELL_NORMAL, "%c",
    40008f78:	528005c3 	mov	w3, #0x2e                  	// #46
    40008f7c:	aa1803e2 	mov	x2, x24
	return (int)((((unsigned)c) >= ' ') &&
    40008f80:	51008001 	sub	w1, w0, #0x20
    40008f84:	71017c3f 	cmp	w1, #0x5f
    40008f88:	52800101 	mov	w1, #0x8                   	// #8
    40008f8c:	1a833003 	csel	w3, w0, w3, cc  // cc = lo, ul, last
    40008f90:	aa1303e0 	mov	x0, x19
    40008f94:	97ffff94 	bl	40008de4 <shell_fprintf>
	for (i = 0; i < SHELL_HEXDUMP_BYTES_IN_LINE; i++) {
    40008f98:	f1003e9f 	cmp	x20, #0xf
    40008f9c:	54000321 	b.ne	40009000 <shell_hexdump_line+0x128>  // b.any
	shell_print(shell, "|");
    40008fa0:	aa1303e0 	mov	x0, x19
    40008fa4:	b0000062 	adrp	x2, 40015000 <prefix.1+0x2aa>
    40008fa8:	91263042 	add	x2, x2, #0x98c
    40008fac:	52800101 	mov	w1, #0x8                   	// #8
}
    40008fb0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008fb4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008fb8:	a94363f7 	ldp	x23, x24, [sp, #48]
    40008fbc:	a8c47bfd 	ldp	x29, x30, [sp], #64
	shell_print(shell, "|");
    40008fc0:	17ffff89 	b	40008de4 <shell_fprintf>
		if (i > 0 && !(i % 8)) {
    40008fc4:	11000680 	add	w0, w20, #0x1
    40008fc8:	f240081f 	tst	x0, #0x7
    40008fcc:	540000c1 	b.ne	40008fe4 <shell_hexdump_line+0x10c>  // b.any
			shell_fprintf(shell, SHELL_NORMAL, " ");
    40008fd0:	90000062 	adrp	x2, 40014000 <shell_m_sub_colors+0x50>
    40008fd4:	91337c42 	add	x2, x2, #0xcdf
    40008fd8:	aa1303e0 	mov	x0, x19
    40008fdc:	52800101 	mov	w1, #0x8                   	// #8
    40008fe0:	97ffff81 	bl	40008de4 <shell_fprintf>
    40008fe4:	91000694 	add	x20, x20, #0x1
    40008fe8:	17ffffce 	b	40008f20 <shell_hexdump_line+0x48>
			shell_fprintf(shell, SHELL_NORMAL, "   ");
    40008fec:	aa1703e2 	mov	x2, x23
    40008ff0:	aa1303e0 	mov	x0, x19
    40008ff4:	52800101 	mov	w1, #0x8                   	// #8
    40008ff8:	97ffff7b 	bl	40008de4 <shell_fprintf>
    40008ffc:	17ffffd0 	b	40008f3c <shell_hexdump_line+0x64>
		if (i > 0 && !(i % 8)) {
    40009000:	11000680 	add	w0, w20, #0x1
    40009004:	f240081f 	tst	x0, #0x7
    40009008:	540000a1 	b.ne	4000901c <shell_hexdump_line+0x144>  // b.any
			shell_fprintf(shell, SHELL_NORMAL, " ");
    4000900c:	aa1703e2 	mov	x2, x23
    40009010:	aa1303e0 	mov	x0, x19
    40009014:	52800101 	mov	w1, #0x8                   	// #8
    40009018:	97ffff73 	bl	40008de4 <shell_fprintf>
    4000901c:	91000694 	add	x20, x20, #0x1
    40009020:	17ffffd3 	b	40008f6c <shell_hexdump_line+0x94>
			shell_fprintf(shell, SHELL_NORMAL, " ");
    40009024:	aa1703e2 	mov	x2, x23
    40009028:	aa1303e0 	mov	x0, x19
    4000902c:	52800101 	mov	w1, #0x8                   	// #8
    40009030:	97ffff6d 	bl	40008de4 <shell_fprintf>
    40009034:	17ffffd9 	b	40008f98 <shell_hexdump_line+0xc0>

0000000040009038 <shell_hexdump>:
{
    40009038:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000903c:	910003fd 	mov	x29, sp
    40009040:	a90153f3 	stp	x19, x20, [sp, #16]
    40009044:	aa0203f3 	mov	x19, x2
	const uint8_t *p = data;
    40009048:	aa0103f4 	mov	x20, x1
{
    4000904c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009050:	aa0003f6 	mov	x22, x0
    40009054:	aa0103f5 	mov	x21, x1
    40009058:	a90363f7 	stp	x23, x24, [sp, #48]
		line_len = MIN(len, SHELL_HEXDUMP_BYTES_IN_LINE);
    4000905c:	d2800218 	mov	x24, #0x10                  	// #16
	while (len) {
    40009060:	b50000d3 	cbnz	x19, 40009078 <shell_hexdump+0x40>
}
    40009064:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009068:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000906c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40009070:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40009074:	d65f03c0 	ret
		line_len = MIN(len, SHELL_HEXDUMP_BYTES_IN_LINE);
    40009078:	f100427f 	cmp	x19, #0x10
		shell_hexdump_line(shell, p - data, p, line_len);
    4000907c:	aa1403e2 	mov	x2, x20
		line_len = MIN(len, SHELL_HEXDUMP_BYTES_IN_LINE);
    40009080:	9a989277 	csel	x23, x19, x24, ls  // ls = plast
		shell_hexdump_line(shell, p - data, p, line_len);
    40009084:	4b150281 	sub	w1, w20, w21
    40009088:	aa1703e3 	mov	x3, x23
    4000908c:	aa1603e0 	mov	x0, x22
		len -= line_len;
    40009090:	cb170273 	sub	x19, x19, x23
		p += line_len;
    40009094:	8b170294 	add	x20, x20, x23
		shell_hexdump_line(shell, p - data, p, line_len);
    40009098:	97ffff90 	bl	40008ed8 <shell_hexdump_line>
		p += line_len;
    4000909c:	17fffff1 	b	40009060 <shell_hexdump+0x28>

00000000400090a0 <shell_help>:
{
    400090a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    400090a4:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
{
    400090a8:	910003fd 	mov	x29, sp
    400090ac:	f9000bf3 	str	x19, [sp, #16]
    400090b0:	aa0003f3 	mov	x19, x0
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    400090b4:	f9400800 	ldr	x0, [x0, #16]
    400090b8:	910ea000 	add	x0, x0, #0x3a8
    400090bc:	97fffa61 	bl	40007a40 <k_mutex_lock.constprop.0.isra.0>
	shell_internal_help_print(shell);
    400090c0:	aa1303e0 	mov	x0, x19
    400090c4:	97fffa50 	bl	40007a04 <shell_internal_help_print>
	k_mutex_unlock(&shell->ctx->wr_mtx);
    400090c8:	f9400a60 	ldr	x0, [x19, #16]
}
    400090cc:	f9400bf3 	ldr	x19, [sp, #16]
	k_mutex_unlock(&shell->ctx->wr_mtx);
    400090d0:	910ea000 	add	x0, x0, #0x3a8
}
    400090d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	k_mutex_unlock(&shell->ctx->wr_mtx);
    400090d8:	17fffad8 	b	40007c38 <k_mutex_unlock.isra.0>

00000000400090dc <shell_set_bypass>:
	sh->ctx->bypass = bypass;
    400090dc:	f9400800 	ldr	x0, [x0, #16]
    400090e0:	f9003401 	str	x1, [x0, #104]
}
    400090e4:	d65f03c0 	ret

00000000400090e8 <z_shell_fprintf_buffer_flush>:
	}
}


void z_shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
    400090e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400090ec:	910003fd 	mov	x29, sp
    400090f0:	f9000bf3 	str	x19, [sp, #16]
    400090f4:	aa0003f3 	mov	x19, x0
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
    400090f8:	f9400001 	ldr	x1, [x0]
    400090fc:	f9400803 	ldr	x3, [x0, #16]
    40009100:	f9401000 	ldr	x0, [x0, #32]
    40009104:	f9400002 	ldr	x2, [x0]
    40009108:	f9400e60 	ldr	x0, [x19, #24]
    4000910c:	d63f0060 	blr	x3
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
    40009110:	f9401260 	ldr	x0, [x19, #32]
}
    40009114:	f9400bf3 	ldr	x19, [sp, #16]
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
    40009118:	f900001f 	str	xzr, [x0]
}
    4000911c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40009120:	d65f03c0 	ret

0000000040009124 <z_shell_fprintf_fmt>:
{
    40009124:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40009128:	910003fd 	mov	x29, sp
	(void)cbvprintf(out_func, (void *)sh_fprintf, fmt, args);
    4000912c:	a9401444 	ldp	x4, x5, [x2]
    40009130:	a90217e4 	stp	x4, x5, [sp, #32]
    40009134:	a9410c42 	ldp	x2, x3, [x2, #16]
{
    40009138:	f9000bf3 	str	x19, [sp, #16]
    4000913c:	aa0003f3 	mov	x19, x0
	(void)cbvprintf(out_func, (void *)sh_fprintf, fmt, args);
    40009140:	a9030fe2 	stp	x2, x3, [sp, #48]
    40009144:	aa0103e2 	mov	x2, x1
    40009148:	910083e3 	add	x3, sp, #0x20
    4000914c:	aa0003e1 	mov	x1, x0
    40009150:	90000000 	adrp	x0, 40009000 <shell_hexdump_line+0x128>
    40009154:	91061000 	add	x0, x0, #0x184
    40009158:	97ffe5b5 	bl	4000282c <cbvprintf>
	if (sh_fprintf->ctrl_blk->autoflush) {
    4000915c:	f9401260 	ldr	x0, [x19, #32]
    40009160:	39402000 	ldrb	w0, [x0, #8]
    40009164:	340000a0 	cbz	w0, 40009178 <z_shell_fprintf_fmt+0x54>
		z_shell_fprintf_buffer_flush(sh_fprintf);
    40009168:	aa1303e0 	mov	x0, x19
}
    4000916c:	f9400bf3 	ldr	x19, [sp, #16]
    40009170:	a8c47bfd 	ldp	x29, x30, [sp], #64
		z_shell_fprintf_buffer_flush(sh_fprintf);
    40009174:	17ffffdd 	b	400090e8 <z_shell_fprintf_buffer_flush>
}
    40009178:	f9400bf3 	ldr	x19, [sp, #16]
    4000917c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40009180:	d65f03c0 	ret

0000000040009184 <out_func>:
{
    40009184:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009188:	910003fd 	mov	x29, sp
    4000918c:	a90153f3 	stp	x19, x20, [sp, #16]
    40009190:	2a0003f4 	mov	w20, w0
    40009194:	aa0103f3 	mov	x19, x1
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
    40009198:	f9400c20 	ldr	x0, [x1, #24]
    4000919c:	b9402000 	ldr	w0, [x0, #32]
    400091a0:	7100081f 	cmp	w0, #0x2
    400091a4:	540000a1 	b.ne	400091b8 <out_func+0x34>  // b.any
    400091a8:	71002a9f 	cmp	w20, #0xa
    400091ac:	54000061 	b.ne	400091b8 <out_func+0x34>  // b.any
		(void)out_func('\r', ctx);
    400091b0:	528001a0 	mov	w0, #0xd                   	// #13
    400091b4:	97fffff4 	bl	40009184 <out_func>
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (uint8_t)c;
    400091b8:	f9401260 	ldr	x0, [x19, #32]
    400091bc:	f9400261 	ldr	x1, [x19]
    400091c0:	f9400000 	ldr	x0, [x0]
    400091c4:	38206834 	strb	w20, [x1, x0]
	sh_fprintf->ctrl_blk->buffer_cnt++;
    400091c8:	f9401261 	ldr	x1, [x19, #32]
    400091cc:	f9400020 	ldr	x0, [x1]
    400091d0:	91000400 	add	x0, x0, #0x1
    400091d4:	f9000020 	str	x0, [x1]
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
    400091d8:	f9400661 	ldr	x1, [x19, #8]
    400091dc:	eb01001f 	cmp	x0, x1
    400091e0:	54000061 	b.ne	400091ec <out_func+0x68>  // b.any
		z_shell_fprintf_buffer_flush(sh_fprintf);
    400091e4:	aa1303e0 	mov	x0, x19
    400091e8:	97ffffc0 	bl	400090e8 <z_shell_fprintf_buffer_flush>
}
    400091ec:	52800000 	mov	w0, #0x0                   	// #0
    400091f0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400091f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400091f8:	d65f03c0 	ret

00000000400091fc <z_shell_strlen>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
    400091fc:	b40000e0 	cbz	x0, 40009218 <z_shell_strlen+0x1c>
{
    40009200:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009204:	910003fd 	mov	x29, sp
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40009208:	94001000 	bl	4000d208 <strlen>
    4000920c:	12003c00 	and	w0, w0, #0xffff
}
    40009210:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40009214:	d65f03c0 	ret
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40009218:	52800000 	mov	w0, #0x0                   	// #0
}
    4000921c:	d65f03c0 	ret

0000000040009220 <z_column_span_with_buffer_offsets_get>:
/* Calculates column number of given position in buffer */
static uint32_t col_num_with_buffer_offset_get(struct shell_multiline_cons *cons,
					    uint16_t buffer_pos)
{
	/* columns are counted from 1 */
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
    40009220:	39403003 	ldrb	w3, [x0, #12]
    40009224:	79401404 	ldrh	w4, [x0, #10]
    40009228:	0b222062 	add	w2, w3, w2, uxth
    4000922c:	0b212061 	add	w1, w3, w1, uxth
    40009230:	1ac40840 	udiv	w0, w2, w4
    40009234:	1ac40823 	udiv	w3, w1, w4
    40009238:	1b048800 	msub	w0, w0, w4, w2
    4000923c:	1b048463 	msub	w3, w3, w4, w1
					      uint16_t offset1,
					      uint16_t offset2)
{
	return col_num_with_buffer_offset_get(cons, offset2)
			- col_num_with_buffer_offset_get(cons, offset1);
}
    40009240:	4b030000 	sub	w0, w0, w3
    40009244:	d65f03c0 	ret

0000000040009248 <z_row_span_with_buffer_offsets_get>:
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
    40009248:	39403003 	ldrb	w3, [x0, #12]
    4000924c:	79401404 	ldrh	w4, [x0, #10]
    40009250:	0b212061 	add	w1, w3, w1, uxth
    40009254:	0b222060 	add	w0, w3, w2, uxth
    40009258:	1ac40821 	udiv	w1, w1, w4
    4000925c:	1ac40800 	udiv	w0, w0, w4
					   uint16_t offset1,
					   uint16_t offset2)
{
	return line_num_with_buffer_offset_get(cons, offset2)
		- line_num_with_buffer_offset_get(cons, offset1);
}
    40009260:	4b010000 	sub	w0, w0, w1
    40009264:	d65f03c0 	ret

0000000040009268 <z_shell_multiline_data_calc>:
				 uint16_t buff_pos, uint16_t buff_len)
{
	/* Current cursor position in command.
	 * +1 -> because home position is (1, 1)
	 */
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    40009268:	39403004 	ldrb	w4, [x0, #12]
    4000926c:	79401405 	ldrh	w5, [x0, #10]
    40009270:	0b212081 	add	w1, w4, w1, uxth
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;

	/* Extreme position when cursor is at the end of command. */
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    40009274:	0b222082 	add	w2, w4, w2, uxth
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    40009278:	1ac50826 	udiv	w6, w1, w5
    4000927c:	1b0584c3 	msub	w3, w6, w5, w1
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
    40009280:	110004c6 	add	w6, w6, #0x1
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    40009284:	1ac50841 	udiv	w1, w2, w5
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
    40009288:	79000806 	strh	w6, [x0, #4]
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    4000928c:	11000463 	add	w3, w3, #0x1
    40009290:	79000003 	strh	w3, [x0]
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    40009294:	11000423 	add	w3, w1, #0x1
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
    40009298:	1b058821 	msub	w1, w1, w5, w2
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    4000929c:	79000c03 	strh	w3, [x0, #6]
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
    400092a0:	11000421 	add	w1, w1, #0x1
    400092a4:	79000401 	strh	w1, [x0, #2]
}
    400092a8:	d65f03c0 	ret

00000000400092ac <z_shell_make_argv>:
}


char z_shell_make_argv(size_t *argc, const char **argv, char *cmd,
		       uint8_t max_argc)
{
    400092ac:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    400092b0:	910003fd 	mov	x29, sp
    400092b4:	a90153f3 	stp	x19, x20, [sp, #16]
    400092b8:	aa0203f3 	mov	x19, x2
    400092bc:	a9025bf5 	stp	x21, x22, [sp, #32]
    400092c0:	aa0003f5 	mov	x21, x0
    400092c4:	aa0103f6 	mov	x22, x1
    400092c8:	a90363f7 	stp	x23, x24, [sp, #48]
    400092cc:	12001c77 	and	w23, w3, #0xff
	char quote = 0;
    400092d0:	52800018 	mov	w24, #0x0                   	// #0
{
    400092d4:	a9046bf9 	stp	x25, x26, [sp, #64]
	char c;

	*argc = 0;
    400092d8:	f900001f 	str	xzr, [x0]
{
    400092dc:	f9002bfb 	str	x27, [sp, #80]
	do {
		c = *cmd;
    400092e0:	39400260 	ldrb	w0, [x19]
		if (c == '\0') {
    400092e4:	340011a0 	cbz	w0, 40009518 <z_shell_make_argv+0x26c>
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    400092e8:	51002401 	sub	w1, w0, #0x9
    400092ec:	7100801f 	cmp	w0, #0x20
			break;
		}

		if (isspace((int) c)) {
    400092f0:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    400092f4:	54000068 	b.hi	40009300 <z_shell_make_argv+0x54>  // b.pmore
			*cmd++ = '\0';
    400092f8:	3800167f 	strb	wzr, [x19], #1
			continue;
    400092fc:	17fffff9 	b	400092e0 <z_shell_make_argv+0x34>
		}

		argv[(*argc)++] = cmd;
    40009300:	f94002a1 	ldr	x1, [x21]
    40009304:	91000420 	add	x0, x1, #0x1
    40009308:	f90002a0 	str	x0, [x21]
    4000930c:	f8217ad3 	str	x19, [x22, x1, lsl #3]
		if (*argc == max_argc) {
    40009310:	eb37001f 	cmp	x0, w23, uxtb
    40009314:	54001020 	b.eq	40009518 <z_shell_make_argv+0x26c>  // b.none
	char quote = 0;
    40009318:	52800018 	mov	w24, #0x0                   	// #0
		c = *cmd;
    4000931c:	39400274 	ldrb	w20, [x19]
		if (c == '\0') {
    40009320:	34fffe14 	cbz	w20, 400092e0 <z_shell_make_argv+0x34>
		if (!quote) {
    40009324:	35000338 	cbnz	w24, 40009388 <z_shell_make_argv+0xdc>
			switch (c) {
    40009328:	71009e9f 	cmp	w20, #0x27
    4000932c:	540000a0 	b.eq	40009340 <z_shell_make_argv+0x94>  // b.none
    40009330:	7101729f 	cmp	w20, #0x5c
    40009334:	540001a0 	b.eq	40009368 <z_shell_make_argv+0xbc>  // b.none
    40009338:	71008a9f 	cmp	w20, #0x22
    4000933c:	540003c1 	b.ne	400093b4 <z_shell_make_argv+0x108>  // b.any
				continue;
    40009340:	2a1403f8 	mov	w24, w20
    40009344:	aa1303f4 	mov	x20, x19
						z_shell_strlen(cmd));
    40009348:	aa1303e0 	mov	x0, x19
    4000934c:	97ffffac 	bl	400091fc <z_shell_strlen>
				memmove(cmd, cmd + 1,
    40009350:	91000661 	add	x1, x19, #0x1
    40009354:	92403c02 	and	x2, x0, #0xffff
    40009358:	aa1303e0 	mov	x0, x19
    4000935c:	94000fdf 	bl	4000d2d8 <memmove>
				continue;
    40009360:	aa1403f3 	mov	x19, x20
    40009364:	17ffffee 	b	4000931c <z_shell_make_argv+0x70>
				memmove(cmd, cmd + 1,
    40009368:	91000674 	add	x20, x19, #0x1
						z_shell_strlen(cmd));
    4000936c:	aa1303e0 	mov	x0, x19
    40009370:	97ffffa3 	bl	400091fc <z_shell_strlen>
				memmove(cmd, cmd + 1,
    40009374:	aa1403e1 	mov	x1, x20
    40009378:	92403c02 	and	x2, x0, #0xffff
    4000937c:	aa1303e0 	mov	x0, x19
    40009380:	94000fd6 	bl	4000d2d8 <memmove>
				continue;
    40009384:	17fffff7 	b	40009360 <z_shell_make_argv+0xb4>
		if (quote == c) {
    40009388:	6b18029f 	cmp	w20, w24
    4000938c:	54000141 	b.ne	400093b4 <z_shell_make_argv+0x108>  // b.any
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
    40009390:	aa1303e0 	mov	x0, x19
    40009394:	97ffff9a 	bl	400091fc <z_shell_strlen>
    40009398:	91000661 	add	x1, x19, #0x1
    4000939c:	92403c02 	and	x2, x0, #0xffff
			continue;
    400093a0:	aa1303f4 	mov	x20, x19
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
    400093a4:	aa1303e0 	mov	x0, x19
			quote = 0;
    400093a8:	52800018 	mov	w24, #0x0                   	// #0
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
    400093ac:	94000fcb 	bl	4000d2d8 <memmove>
			continue;
    400093b0:	17ffffec 	b	40009360 <z_shell_make_argv+0xb4>
		if (quote && c == '\\') {
    400093b4:	7101729f 	cmp	w20, #0x5c
    400093b8:	7a400b04 	ccmp	w24, #0x0, #0x4, eq  // eq = none
    400093bc:	54000a00 	b.eq	400094fc <z_shell_make_argv+0x250>  // b.none
			char t = *(cmd + 1);
    400093c0:	aa1303f4 	mov	x20, x19
    400093c4:	38401e81 	ldrb	w1, [x20, #1]!
			if (t == quote) {
    400093c8:	6b01031f 	cmp	w24, w1
    400093cc:	54fffd00 	b.eq	4000936c <z_shell_make_argv+0xc0>  // b.none
			if (t == '0') {
    400093d0:	7100c03f 	cmp	w1, #0x30
    400093d4:	540003c1 	b.ne	4000944c <z_shell_make_argv+0x1a0>  // b.any
    400093d8:	d2800040 	mov	x0, #0x2                   	// #2
				uint8_t v = 0U;
    400093dc:	52800019 	mov	w25, #0x0                   	// #0
					t = *(cmd + i);
    400093e0:	38606a61 	ldrb	w1, [x19, x0]
    400093e4:	12001c1a 	and	w26, w0, #0xff
					if (t >= '0' && t <= '7') {
    400093e8:	5100c022 	sub	w2, w1, #0x30
    400093ec:	12001c43 	and	w3, w2, #0xff
    400093f0:	71001c7f 	cmp	w3, #0x7
    400093f4:	54000288 	b.hi	40009444 <z_shell_make_argv+0x198>  // b.pmore
						v = (v << 3) | (t - '0');
    400093f8:	2a190c59 	orr	w25, w2, w25, lsl #3
				for (i = 2U; i < (2 + 3); i++) {
    400093fc:	91000400 	add	x0, x0, #0x1
						v = (v << 3) | (t - '0');
    40009400:	12001f39 	and	w25, w25, #0xff
				for (i = 2U; i < (2 + 3); i++) {
    40009404:	f100141f 	cmp	x0, #0x5
    40009408:	54fffec1 	b.ne	400093e0 <z_shell_make_argv+0x134>  // b.any
    4000940c:	2a0003fa 	mov	w26, w0
						z_shell_strlen(cmd) - (i - 2));
    40009410:	aa1303e0 	mov	x0, x19
    40009414:	97ffff7a 	bl	400091fc <z_shell_strlen>
    40009418:	12003c02 	and	w2, w0, #0xffff
					memmove(cmd, cmd + (i - 1),
    4000941c:	5100075b 	sub	w27, w26, #0x1
						z_shell_strlen(cmd) - (i - 2));
    40009420:	11000842 	add	w2, w2, #0x2
    40009424:	4b1a0042 	sub	w2, w2, w26
					memmove(cmd, cmd + (i - 1),
    40009428:	8b3bc27b 	add	x27, x19, w27, sxtw
    4000942c:	aa1b03e1 	mov	x1, x27
    40009430:	93407c42 	sxtw	x2, w2
					memmove(cmd, cmd + (i - 1),
    40009434:	aa1303e0 	mov	x0, x19
    40009438:	94000fa8 	bl	4000d2d8 <memmove>
					*cmd++ = v;
    4000943c:	39000279 	strb	w25, [x19]
					continue;
    40009440:	17ffffc8 	b	40009360 <z_shell_make_argv+0xb4>
				if (i > 2) {
    40009444:	71000b5f 	cmp	w26, #0x2
    40009448:	54fffe41 	b.ne	40009410 <z_shell_make_argv+0x164>  // b.any
			if (t == 'x') {
    4000944c:	7101e03f 	cmp	w1, #0x78
    40009450:	54000601 	b.ne	40009510 <z_shell_make_argv+0x264>  // b.any
    40009454:	d2800040 	mov	x0, #0x2                   	// #2
				uint8_t v = 0U;
    40009458:	52800019 	mov	w25, #0x0                   	// #0
					t = *(cmd + i);
    4000945c:	38606a62 	ldrb	w2, [x19, x0]
    40009460:	12001c03 	and	w3, w0, #0xff
					if (t >= '0' && t <= '9') {
    40009464:	5100c041 	sub	w1, w2, #0x30
    40009468:	12001c24 	and	w4, w1, #0xff
    4000946c:	7100249f 	cmp	w4, #0x9
    40009470:	54000248 	b.hi	400094b8 <z_shell_make_argv+0x20c>  // b.pmore
						v = (v << 4) | (t - '0');
    40009474:	2a191022 	orr	w2, w1, w25, lsl #4
						v = (v << 4) | (t - 'A' + 10);
    40009478:	12001c59 	and	w25, w2, #0xff
				for (i = 2U; i < (2 + 2); i++) {
    4000947c:	f1000c1f 	cmp	x0, #0x3
    40009480:	54000181 	b.ne	400094b0 <z_shell_make_argv+0x204>  // b.any
    40009484:	5280009b 	mov	w27, #0x4                   	// #4
						z_shell_strlen(cmd) - (i - 2));
    40009488:	aa1303e0 	mov	x0, x19
    4000948c:	97ffff5c 	bl	400091fc <z_shell_strlen>
    40009490:	12003c02 	and	w2, w0, #0xffff
					memmove(cmd, cmd + (i - 1),
    40009494:	5100077a 	sub	w26, w27, #0x1
						z_shell_strlen(cmd) - (i - 2));
    40009498:	11000842 	add	w2, w2, #0x2
    4000949c:	4b1b0042 	sub	w2, w2, w27
					memmove(cmd, cmd + (i - 1),
    400094a0:	8b3ac27a 	add	x26, x19, w26, sxtw
    400094a4:	aa1a03e1 	mov	x1, x26
    400094a8:	93407c42 	sxtw	x2, w2
    400094ac:	17ffffe2 	b	40009434 <z_shell_make_argv+0x188>
    400094b0:	d2800060 	mov	x0, #0x3                   	// #3
    400094b4:	17ffffea 	b	4000945c <z_shell_make_argv+0x1b0>
					} else if ((t >= 'a') &&
    400094b8:	51018441 	sub	w1, w2, #0x61
    400094bc:	12001c21 	and	w1, w1, #0xff
    400094c0:	7100143f 	cmp	w1, #0x5
    400094c4:	54000088 	b.hi	400094d4 <z_shell_make_argv+0x228>  // b.pmore
						v = (v << 4) | (t - 'a' + 10);
    400094c8:	51015c42 	sub	w2, w2, #0x57
						v = (v << 4) | (t - 'A' + 10);
    400094cc:	2a191042 	orr	w2, w2, w25, lsl #4
    400094d0:	17ffffea 	b	40009478 <z_shell_make_argv+0x1cc>
					} else if ((t >= 'A') && (t <= 'F')) {
    400094d4:	51010441 	sub	w1, w2, #0x41
    400094d8:	12001c21 	and	w1, w1, #0xff
    400094dc:	7100143f 	cmp	w1, #0x5
    400094e0:	54000068 	b.hi	400094ec <z_shell_make_argv+0x240>  // b.pmore
						v = (v << 4) | (t - 'A' + 10);
    400094e4:	5100dc42 	sub	w2, w2, #0x37
    400094e8:	17fffff9 	b	400094cc <z_shell_make_argv+0x220>
				if (i > 2) {
    400094ec:	7100087f 	cmp	w3, #0x2
    400094f0:	54000100 	b.eq	40009510 <z_shell_make_argv+0x264>  // b.none
    400094f4:	5280007b 	mov	w27, #0x3                   	// #3
    400094f8:	17ffffe4 	b	40009488 <z_shell_make_argv+0x1dc>
		if (!quote && isspace((int) c)) {
    400094fc:	350000b8 	cbnz	w24, 40009510 <z_shell_make_argv+0x264>
    40009500:	51002680 	sub	w0, w20, #0x9
    40009504:	7100829f 	cmp	w20, #0x20
    40009508:	7a441800 	ccmp	w0, #0x4, #0x0, ne  // ne = any
    4000950c:	54ffeea9 	b.ls	400092e0 <z_shell_make_argv+0x34>  // b.plast
		cmd += 1;
    40009510:	91000674 	add	x20, x19, #0x1
    40009514:	17ffff93 	b	40009360 <z_shell_make_argv+0xb4>
		}
		quote = make_argv(&cmd, c);
	} while (true);

	return quote;
}
    40009518:	2a1803e0 	mov	w0, w24
    4000951c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009520:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009524:	a94363f7 	ldp	x23, x24, [sp, #48]
    40009528:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000952c:	f9402bfb 	ldr	x27, [sp, #80]
    40009530:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40009534:	d65f03c0 	ret

0000000040009538 <z_shell_pattern_remove>:

void z_shell_pattern_remove(char *buff, uint16_t *buff_len, const char *pattern)
{
    40009538:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000953c:	910003fd 	mov	x29, sp
    40009540:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009544:	aa0103f5 	mov	x21, x1
	char *pattern_addr = strstr(buff, pattern);
    40009548:	aa0203e1 	mov	x1, x2
{
    4000954c:	aa0003f6 	mov	x22, x0
    40009550:	a90153f3 	stp	x19, x20, [sp, #16]
    40009554:	aa0203f4 	mov	x20, x2
	char *pattern_addr = strstr(buff, pattern);
    40009558:	94000ee9 	bl	4000d0fc <strstr>
    4000955c:	aa0003f3 	mov	x19, x0
	uint16_t shift;
	uint16_t pattern_len = z_shell_strlen(pattern);
    40009560:	aa1403e0 	mov	x0, x20
    40009564:	97ffff26 	bl	400091fc <z_shell_strlen>

	if (!pattern_addr) {
    40009568:	b4000333 	cbz	x19, 400095cc <z_shell_pattern_remove+0x94>
    4000956c:	12003c14 	and	w20, w0, #0xffff
		return;
	}

	if (pattern_addr > buff) {
    40009570:	eb1302df 	cmp	x22, x19
    40009574:	540000e2 	b.cs	40009590 <z_shell_pattern_remove+0x58>  // b.hs, b.nlast
		if (*(pattern_addr - 1) == ' ') {
    40009578:	385ff260 	ldurb	w0, [x19, #-1]
    4000957c:	7100801f 	cmp	w0, #0x20
    40009580:	54000081 	b.ne	40009590 <z_shell_pattern_remove+0x58>  // b.any
			pattern_len++; /* space needs to be removed as well */
    40009584:	11000694 	add	w20, w20, #0x1
			pattern_addr--; /* set pointer to space */
    40009588:	d1000673 	sub	x19, x19, #0x1
			pattern_len++; /* space needs to be removed as well */
    4000958c:	12003e94 	and	w20, w20, #0xffff
		}
	}

	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    40009590:	aa1303e0 	mov	x0, x19
    40009594:	97ffff1a 	bl	400091fc <z_shell_strlen>
    40009598:	12003c02 	and	w2, w0, #0xffff
	*buff_len -= pattern_len;
    4000959c:	794002a0 	ldrh	w0, [x21]
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    400095a0:	4b140042 	sub	w2, w2, w20

	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    400095a4:	8b342261 	add	x1, x19, w20, uxth
	*buff_len -= pattern_len;
    400095a8:	4b140000 	sub	w0, w0, w20
    400095ac:	790002a0 	strh	w0, [x21]
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    400095b0:	aa1303e0 	mov	x0, x19
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    400095b4:	11000442 	add	w2, w2, #0x1
}
    400095b8:	a94153f3 	ldp	x19, x20, [sp, #16]
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    400095bc:	92403c42 	and	x2, x2, #0xffff
}
    400095c0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400095c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    400095c8:	14000f44 	b	4000d2d8 <memmove>
}
    400095cc:	a94153f3 	ldp	x19, x20, [sp, #16]
    400095d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400095d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400095d8:	d65f03c0 	ret

00000000400095dc <z_shell_cmd_get>:

const struct shell_static_entry *z_shell_cmd_get(
					const struct shell_static_entry *parent,
					size_t idx,
					struct shell_static_entry *dloc)
{
    400095dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400095e0:	aa0003e3 	mov	x3, x0
    400095e4:	aa0103e0 	mov	x0, x1
    400095e8:	910003fd 	mov	x29, sp
    400095ec:	f9000bf3 	str	x19, [sp, #16]
	const struct shell_static_entry *res = NULL;

	if (parent == NULL) {
    400095f0:	b5000203 	cbnz	x3, 40009630 <z_shell_cmd_get+0x54>
	return ((uint8_t *)__shell_root_cmds_end -
    400095f4:	b0000042 	adrp	x2, 40012000 <__rodata_region_start>
    400095f8:	913e4042 	add	x2, x2, #0xf90
    400095fc:	d0000041 	adrp	x1, 40013000 <shell_cmd_help>
    40009600:	91028021 	add	x1, x1, #0xa0
    40009604:	cb020021 	sub	x1, x1, x2
		return  (idx < shell_root_cmd_count()) ?
				shell_root_cmd_get(idx)->u.entry : NULL;
    40009608:	d3448c21 	ubfx	x1, x1, #4, #32
    4000960c:	eb00003f 	cmp	x1, x0
    40009610:	54000249 	b.ls	40009658 <z_shell_cmd_get+0x7c>  // b.plast
    40009614:	d37c7c00 	ubfiz	x0, x0, #4, #32
    40009618:	8b000040 	add	x0, x2, x0
    4000961c:	f9400413 	ldr	x19, [x0, #8]
			}
		}
	}

	return res;
}
    40009620:	aa1303e0 	mov	x0, x19
    40009624:	f9400bf3 	ldr	x19, [sp, #16]
    40009628:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000962c:	d65f03c0 	ret
	if (parent->subcmd) {
    40009630:	f9400861 	ldr	x1, [x3, #16]
    40009634:	b4000121 	cbz	x1, 40009658 <z_shell_cmd_get+0x7c>
    40009638:	aa0203f3 	mov	x19, x2
			parent->subcmd->u.dynamic_get(idx, dloc);
    4000963c:	f9400422 	ldr	x2, [x1, #8]
		if (parent->subcmd->is_dynamic) {
    40009640:	39400021 	ldrb	w1, [x1]
    40009644:	340000e1 	cbz	w1, 40009660 <z_shell_cmd_get+0x84>
			parent->subcmd->u.dynamic_get(idx, dloc);
    40009648:	aa1303e1 	mov	x1, x19
    4000964c:	d63f0040 	blr	x2
			if (dloc->syntax != NULL) {
    40009650:	f9400260 	ldr	x0, [x19]
    40009654:	b5fffe60 	cbnz	x0, 40009620 <z_shell_cmd_get+0x44>
	const struct shell_static_entry *res = NULL;
    40009658:	d2800013 	mov	x19, #0x0                   	// #0
    4000965c:	17fffff1 	b	40009620 <z_shell_cmd_get+0x44>
			if (parent->subcmd->u.entry[idx].syntax != NULL) {
    40009660:	d2800501 	mov	x1, #0x28                  	// #40
    40009664:	9b017c00 	mul	x0, x0, x1
    40009668:	8b000053 	add	x19, x2, x0
    4000966c:	f8606840 	ldr	x0, [x2, x0]
    40009670:	17fffff9 	b	40009654 <z_shell_cmd_get+0x78>

0000000040009674 <z_shell_find_cmd>:
 */
const struct shell_static_entry *z_shell_find_cmd(
					const struct shell_static_entry *parent,
					const char *cmd_str,
					struct shell_static_entry *dloc)
{
    40009674:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40009678:	910003fd 	mov	x29, sp
    4000967c:	a90153f3 	stp	x19, x20, [sp, #16]
    40009680:	aa0003f3 	mov	x19, x0
    40009684:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009688:	aa0203f6 	mov	x22, x2
    4000968c:	f9001bf7 	str	x23, [sp, #48]
    40009690:	aa0103f7 	mov	x23, x1
	 * dynamic commands at the same time (current and subcommand) they
	 * will operate on the same memory region what can cause undefined
	 * behaviour.
	 * Hence we need a separate memory for each of them.
	 */
	if (parent) {
    40009694:	b40000c0 	cbz	x0, 400096ac <z_shell_find_cmd+0x38>
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
		parent = &parent_cpy;
    40009698:	910123f3 	add	x19, sp, #0x48
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
    4000969c:	aa0003e1 	mov	x1, x0
    400096a0:	d2800502 	mov	x2, #0x28                  	// #40
    400096a4:	910123e0 	add	x0, sp, #0x48
    400096a8:	94000f1b 	bl	4000d314 <memcpy>
		parent = &parent_cpy;
    400096ac:	d2800015 	mov	x21, #0x0                   	// #0
	}

	while ((entry = z_shell_cmd_get(parent, idx++, dloc)) != NULL) {
    400096b0:	aa1503e1 	mov	x1, x21
    400096b4:	aa1603e2 	mov	x2, x22
    400096b8:	aa1303e0 	mov	x0, x19
    400096bc:	910006b5 	add	x21, x21, #0x1
    400096c0:	97ffffc7 	bl	400095dc <z_shell_cmd_get>
    400096c4:	aa0003f4 	mov	x20, x0
    400096c8:	b40000a0 	cbz	x0, 400096dc <z_shell_find_cmd+0x68>
		if (strcmp(cmd_str, entry->syntax) == 0) {
    400096cc:	f9400281 	ldr	x1, [x20]
    400096d0:	aa1703e0 	mov	x0, x23
    400096d4:	94000edd 	bl	4000d248 <strcmp>
    400096d8:	35fffec0 	cbnz	w0, 400096b0 <z_shell_find_cmd+0x3c>
			return entry;
		}
	}

	return NULL;
}
    400096dc:	aa1403e0 	mov	x0, x20
    400096e0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400096e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400096e8:	f9401bf7 	ldr	x23, [sp, #48]
    400096ec:	a8c77bfd 	ldp	x29, x30, [sp], #112
    400096f0:	d65f03c0 	ret

00000000400096f4 <z_shell_get_last_command>:
					size_t argc,
					const char *argv[],
					size_t *match_arg,
					struct shell_static_entry *dloc,
					bool only_static)
{
    400096f4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400096f8:	910003fd 	mov	x29, sp
    400096fc:	a90153f3 	stp	x19, x20, [sp, #16]
    40009700:	aa0303f3 	mov	x19, x3
    40009704:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009708:	aa0203f5 	mov	x21, x2
    4000970c:	aa0403f6 	mov	x22, x4
    40009710:	a90363f7 	stp	x23, x24, [sp, #48]
    40009714:	aa0103f7 	mov	x23, x1
    40009718:	12001cb8 	and	w24, w5, #0xff
	const struct shell_static_entry *prev_entry = NULL;

	*match_arg = Z_SHELL_CMD_ROOT_LVL;
    4000971c:	f900007f 	str	xzr, [x3]

		if (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {
			/* ignore wildcard argument */
			if (z_shell_has_wildcard(argv[*match_arg])) {
				(*match_arg)++;
				continue;
    40009720:	aa0003f4 	mov	x20, x0
	while (*match_arg < argc) {
    40009724:	f9400260 	ldr	x0, [x19]
    40009728:	eb17001f 	cmp	x0, x23
    4000972c:	540002e2 	b.cs	40009788 <z_shell_get_last_command+0x94>  // b.hs, b.nlast
			if (z_shell_has_wildcard(argv[*match_arg])) {
    40009730:	f8607aa0 	ldr	x0, [x21, x0, lsl #3]
    40009734:	94000793 	bl	4000b580 <z_shell_has_wildcard>
    40009738:	72001c1f 	tst	w0, #0xff
    4000973c:	f9400260 	ldr	x0, [x19]
    40009740:	540000a0 	b.eq	40009754 <z_shell_get_last_command+0x60>  // b.none
				(*match_arg)++;
    40009744:	91000400 	add	x0, x0, #0x1
    40009748:	f9000260 	str	x0, [x19]
				continue;
    4000974c:	aa1403e0 	mov	x0, x20
    40009750:	17fffff4 	b	40009720 <z_shell_get_last_command+0x2c>
			}
		}

		prev_entry = entry;
		entry = z_shell_find_cmd(entry, argv[*match_arg], dloc);
    40009754:	f8607aa1 	ldr	x1, [x21, x0, lsl #3]
    40009758:	aa1603e2 	mov	x2, x22
    4000975c:	aa1403e0 	mov	x0, x20
    40009760:	97ffffc5 	bl	40009674 <z_shell_find_cmd>
		if (entry) {
    40009764:	b4000120 	cbz	x0, 40009788 <z_shell_get_last_command+0x94>
			(*match_arg)++;
    40009768:	f9400261 	ldr	x1, [x19]
		} else {
			entry = prev_entry;
			break;
		}

		if (only_static && (entry == dloc)) {
    4000976c:	7100031f 	cmp	w24, #0x0
    40009770:	fa4012c0 	ccmp	x22, x0, #0x0, ne  // ne = any
			(*match_arg)++;
    40009774:	91000422 	add	x2, x1, #0x1
    40009778:	f9000262 	str	x2, [x19]
		if (only_static && (entry == dloc)) {
    4000977c:	54fffd21 	b.ne	40009720 <z_shell_get_last_command+0x2c>  // b.any
			(*match_arg)--;
			return NULL;
    40009780:	d2800014 	mov	x20, #0x0                   	// #0
			(*match_arg)--;
    40009784:	f9000261 	str	x1, [x19]
		}
	}

	return entry;
}
    40009788:	aa1403e0 	mov	x0, x20
    4000978c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009790:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009794:	a94363f7 	ldp	x23, x24, [sp, #48]
    40009798:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000979c:	d65f03c0 	ret

00000000400097a0 <z_shell_spaces_trim>:




void z_shell_spaces_trim(char *str)
{
    400097a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400097a4:	910003fd 	mov	x29, sp
    400097a8:	a90153f3 	stp	x19, x20, [sp, #16]
    400097ac:	a9025bf5 	stp	x21, x22, [sp, #32]
    400097b0:	aa0003f6 	mov	x22, x0
	uint16_t len = z_shell_strlen(str);
    400097b4:	97fffe92 	bl	400091fc <z_shell_strlen>
	uint16_t shift = 0U;

	if (!str) {
    400097b8:	b50004f6 	cbnz	x22, 40009854 <z_shell_spaces_trim+0xb4>

				break;
			}
		}
	}
}
    400097bc:	a94153f3 	ldp	x19, x20, [sp, #16]
    400097c0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400097c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400097c8:	d65f03c0 	ret
				if (shift > 0) {
    400097cc:	34000135 	cbz	w21, 400097f0 <z_shell_spaces_trim+0x50>
						len - j + 1);
    400097d0:	11000662 	add	w2, w19, #0x1
					len -= shift;
    400097d4:	4b150273 	sub	w19, w19, w21
    400097d8:	12003e73 	and	w19, w19, #0xffff
						len - j + 1);
    400097dc:	4b040042 	sub	w2, w2, w4
					shift = 0U;
    400097e0:	52800015 	mov	w21, #0x0                   	// #0
					memmove(&str[i + 1],
    400097e4:	8b34c2c0 	add	x0, x22, w20, sxtw
    400097e8:	93407c42 	sxtw	x2, w2
    400097ec:	94000ebb 	bl	4000d2d8 <memmove>
	for (uint16_t i = 0; i < len - 1; i++) {
    400097f0:	12003e81 	and	w1, w20, #0xffff
    400097f4:	51000660 	sub	w0, w19, #0x1
    400097f8:	6b00003f 	cmp	w1, w0
    400097fc:	54fffe0a 	b.ge	400097bc <z_shell_spaces_trim+0x1c>  // b.tcont
		if (isspace((int)str[i])) {
    40009800:	92403c20 	and	x0, x1, #0xffff
    40009804:	11000434 	add	w20, w1, #0x1
    40009808:	38606ac0 	ldrb	w0, [x22, x0]
    4000980c:	51002402 	sub	w2, w0, #0x9
    40009810:	7100801f 	cmp	w0, #0x20
    40009814:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    40009818:	54fffec8 	b.hi	400097f0 <z_shell_spaces_trim+0x50>  // b.pmore
			for (uint16_t j = i + 1; j < len; j++) {
    4000981c:	92403e80 	and	x0, x20, #0xffff
    40009820:	12003c04 	and	w4, w0, #0xffff
    40009824:	6b20227f 	cmp	w19, w0, uxth
    40009828:	54fffe49 	b.ls	400097f0 <z_shell_spaces_trim+0x50>  // b.plast
				if (isspace((int)str[j])) {
    4000982c:	38606ac3 	ldrb	w3, [x22, x0]
    40009830:	8b0002c1 	add	x1, x22, x0
    40009834:	91000400 	add	x0, x0, #0x1
    40009838:	51002462 	sub	w2, w3, #0x9
    4000983c:	7100807f 	cmp	w3, #0x20
    40009840:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    40009844:	54fffc48 	b.hi	400097cc <z_shell_spaces_trim+0x2c>  // b.pmore
					shift++;
    40009848:	110006b5 	add	w21, w21, #0x1
    4000984c:	12003eb5 	and	w21, w21, #0xffff
			for (uint16_t j = i + 1; j < len; j++) {
    40009850:	17fffff4 	b	40009820 <z_shell_spaces_trim+0x80>
    40009854:	12003c13 	and	w19, w0, #0xffff
	for (uint16_t i = 0; i < len - 1; i++) {
    40009858:	52800001 	mov	w1, #0x0                   	// #0
	uint16_t shift = 0U;
    4000985c:	52800015 	mov	w21, #0x0                   	// #0
    40009860:	17ffffe5 	b	400097f4 <z_shell_spaces_trim+0x54>

0000000040009864 <z_shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void z_shell_cmd_trim(const struct shell *shell)
{
    40009864:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40009868:	910003fd 	mov	x29, sp
    4000986c:	a90153f3 	stp	x19, x20, [sp, #16]
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
    40009870:	f9400813 	ldr	x19, [x0, #16]
{
    40009874:	f90013f5 	str	x21, [sp, #32]
    40009878:	aa0003f5 	mov	x21, x0
	if (buff[0] == '\0') {
    4000987c:	3941da60 	ldrb	w0, [x19, #118]
    40009880:	350001a0 	cbnz	w0, 400098b4 <z_shell_cmd_trim+0x50>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    40009884:	f9400aa0 	ldr	x0, [x21, #16]
}
    40009888:	a94153f3 	ldp	x19, x20, [sp, #16]
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    4000988c:	7940e001 	ldrh	w1, [x0, #112]
    40009890:	7900e401 	strh	w1, [x0, #114]
}
    40009894:	f94013f5 	ldr	x21, [sp, #32]
    40009898:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000989c:	d65f03c0 	ret
		*buff_len -= 1U;
    400098a0:	12003c41 	and	w1, w2, #0xffff
    400098a4:	7900e261 	strh	w1, [x19, #112]
		if (*buff_len == 0U) {
    400098a8:	35000081 	cbnz	w1, 400098b8 <z_shell_cmd_trim+0x54>
			buff[0] = '\0';
    400098ac:	3901da7f 	strb	wzr, [x19, #118]
			return;
    400098b0:	17fffff5 	b	40009884 <z_shell_cmd_trim+0x20>
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
    400098b4:	9101da60 	add	x0, x19, #0x76
	while (isspace((int) buff[*buff_len - 1U])) {
    400098b8:	7940e261 	ldrh	w1, [x19, #112]
    400098bc:	51000423 	sub	w3, w1, #0x1
    400098c0:	51000422 	sub	w2, w1, #0x1
    400098c4:	38636803 	ldrb	w3, [x0, x3]
    400098c8:	51002464 	sub	w4, w3, #0x9
    400098cc:	7100807f 	cmp	w3, #0x20
    400098d0:	7a441880 	ccmp	w4, #0x4, #0x0, ne  // ne = any
    400098d4:	54fffe69 	b.ls	400098a0 <z_shell_cmd_trim+0x3c>  // b.plast
	buff[*buff_len] = '\0';
    400098d8:	92403c21 	and	x1, x1, #0xffff
	uint16_t i = 0U;
    400098dc:	52800002 	mov	w2, #0x0                   	// #0
	buff[*buff_len] = '\0';
    400098e0:	3821681f 	strb	wzr, [x0, x1]
	while (isspace((int) buff[i++])) {
    400098e4:	2a0203f4 	mov	w20, w2
    400098e8:	11000442 	add	w2, w2, #0x1
    400098ec:	92403e83 	and	x3, x20, #0xffff
    400098f0:	12003c42 	and	w2, w2, #0xffff
    400098f4:	8b342001 	add	x1, x0, w20, uxth
    400098f8:	38636803 	ldrb	w3, [x0, x3]
    400098fc:	51002464 	sub	w4, w3, #0x9
    40009900:	7100807f 	cmp	w3, #0x20
    40009904:	7a441880 	ccmp	w4, #0x4, #0x0, ne  // ne = any
    40009908:	54fffee9 	b.ls	400098e4 <z_shell_cmd_trim+0x80>  // b.plast
	if (--i > 0) {
    4000990c:	34fffbd4 	cbz	w20, 40009884 <z_shell_cmd_trim+0x20>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
    40009910:	7940e262 	ldrh	w2, [x19, #112]
    40009914:	11000442 	add	w2, w2, #0x1
    40009918:	4b140042 	sub	w2, w2, w20
    4000991c:	94000e6f 	bl	4000d2d8 <memmove>
		*buff_len = *buff_len - i;
    40009920:	7940e260 	ldrh	w0, [x19, #112]
    40009924:	4b140014 	sub	w20, w0, w20
    40009928:	7900e274 	strh	w20, [x19, #112]
    4000992c:	17ffffd6 	b	40009884 <z_shell_cmd_trim+0x20>

0000000040009930 <z_shell_raw_fprintf>:
{
    40009930:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40009934:	910003fd 	mov	x29, sp
    40009938:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    4000993c:	910403e2 	add	x2, sp, #0x100
    40009940:	a9030be2 	stp	x2, x2, [sp, #48]
    40009944:	910343e2 	add	x2, sp, #0xd0
    40009948:	f90023e2 	str	x2, [sp, #64]
    4000994c:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    40009950:	b9004be2 	str	w2, [sp, #72]
    40009954:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    40009958:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    4000995c:	a9430fe2 	ldp	x2, x3, [sp, #48]
    40009960:	a9010fe2 	stp	x2, x3, [sp, #16]
    40009964:	a9440fe2 	ldp	x2, x3, [sp, #64]
    40009968:	a9020fe2 	stp	x2, x3, [sp, #32]
    4000996c:	910043e2 	add	x2, sp, #0x10
{
    40009970:	3d8017e0 	str	q0, [sp, #80]
    40009974:	3d801be1 	str	q1, [sp, #96]
    40009978:	3d801fe2 	str	q2, [sp, #112]
    4000997c:	3d8023e3 	str	q3, [sp, #128]
    40009980:	3d8027e4 	str	q4, [sp, #144]
    40009984:	3d802be5 	str	q5, [sp, #160]
    40009988:	3d802fe6 	str	q6, [sp, #176]
    4000998c:	3d8033e7 	str	q7, [sp, #192]
    40009990:	a90e17e4 	stp	x4, x5, [sp, #224]
    40009994:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40009998:	97fffde3 	bl	40009124 <z_shell_fprintf_fmt>
}
    4000999c:	a8d07bfd 	ldp	x29, x30, [sp], #256
    400099a0:	d65f03c0 	ret

00000000400099a4 <z_clear_eos>:
	return sh->ctx->cfg.flags.use_vt100 == 1;
    400099a4:	f9400801 	ldr	x1, [x0, #16]
    400099a8:	b9429821 	ldr	w1, [x1, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
    400099ac:	362800a1 	tbz	w1, #5, 400099c0 <z_clear_eos+0x1c>
    400099b0:	f9401400 	ldr	x0, [x0, #40]
    400099b4:	d0000041 	adrp	x1, 40013000 <shell_cmd_help>
    400099b8:	91030021 	add	x1, x1, #0xc0
    400099bc:	17ffffdd 	b	40009930 <z_shell_raw_fprintf>
}
    400099c0:	d65f03c0 	ret

00000000400099c4 <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
    400099c4:	90000061 	adrp	x1, 40015000 <prefix.1+0x2aa>
    400099c8:	91096021 	add	x1, x1, #0x258
    400099cc:	17ffffd9 	b	40009930 <z_shell_raw_fprintf>

00000000400099d0 <full_line_cmd>:

/* Function returns true if command length is equal to multiplicity of terminal
 * width.
 */
static inline bool full_line_cmd(const struct shell *shell)
{
    400099d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400099d4:	910003fd 	mov	x29, sp
    400099d8:	a90153f3 	stp	x19, x20, [sp, #16]
    400099dc:	aa0003f3 	mov	x19, x0
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
    400099e0:	f9400800 	ldr	x0, [x0, #16]
    400099e4:	7940e014 	ldrh	w20, [x0, #112]
    400099e8:	f9400000 	ldr	x0, [x0]
	return str == NULL ? 0U : (uint16_t)strlen(str);
    400099ec:	b40001a0 	cbz	x0, 40009a20 <full_line_cmd+0x50>
    400099f0:	94000e06 	bl	4000d208 <strlen>
    400099f4:	12003c01 	and	w1, w0, #0xffff
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    400099f8:	f9400a60 	ldr	x0, [x19, #16]
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
    400099fc:	0b140021 	add	w1, w1, w20
}
    40009a00:	a94153f3 	ldp	x19, x20, [sp, #16]
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40009a04:	79409402 	ldrh	w2, [x0, #74]
}
    40009a08:	a8c27bfd 	ldp	x29, x30, [sp], #32
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40009a0c:	1ac20820 	udiv	w0, w1, w2
    40009a10:	1b028401 	msub	w1, w0, w2, w1
    40009a14:	7100003f 	cmp	w1, #0x0
}
    40009a18:	1a9f17e0 	cset	w0, eq  // eq = none
    40009a1c:	d65f03c0 	ret
    40009a20:	52800001 	mov	w1, #0x0                   	// #0
    40009a24:	17fffff5 	b	400099f8 <full_line_cmd+0x28>

0000000040009a28 <z_shell_op_cursor_vert_move>:
	char dir = delta > 0 ? 'A' : 'B';
    40009a28:	7100003f 	cmp	w1, #0x0
    40009a2c:	5400018c 	b.gt	40009a5c <z_shell_op_cursor_vert_move+0x34>
	if (delta == 0) {
    40009a30:	540001a0 	b.eq	40009a64 <z_shell_op_cursor_vert_move+0x3c>  // b.none
	char dir = delta > 0 ? 'A' : 'B';
    40009a34:	52800843 	mov	w3, #0x42                  	// #66
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40009a38:	f9400802 	ldr	x2, [x0, #16]
    40009a3c:	b9429842 	ldr	w2, [x2, #664]
	Z_SHELL_VT100_CMD(shell, "\e[%d%c", delta, dir);
    40009a40:	36280122 	tbz	w2, #5, 40009a64 <z_shell_op_cursor_vert_move+0x3c>
    40009a44:	f9401400 	ldr	x0, [x0, #40]
    40009a48:	7100003f 	cmp	w1, #0x0
    40009a4c:	5a81a422 	cneg	w2, w1, lt  // lt = tstop
    40009a50:	90000061 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40009a54:	9126a021 	add	x1, x1, #0x9a8
    40009a58:	17ffffb6 	b	40009930 <z_shell_raw_fprintf>
	char dir = delta > 0 ? 'A' : 'B';
    40009a5c:	52800823 	mov	w3, #0x41                  	// #65
    40009a60:	17fffff6 	b	40009a38 <z_shell_op_cursor_vert_move+0x10>
}
    40009a64:	d65f03c0 	ret

0000000040009a68 <z_shell_op_cursor_horiz_move>:
	char dir = delta > 0 ? 'C' : 'D';
    40009a68:	7100003f 	cmp	w1, #0x0
    40009a6c:	5400018c 	b.gt	40009a9c <z_shell_op_cursor_horiz_move+0x34>
	if (delta == 0) {
    40009a70:	540001a0 	b.eq	40009aa4 <z_shell_op_cursor_horiz_move+0x3c>  // b.none
	char dir = delta > 0 ? 'C' : 'D';
    40009a74:	52800883 	mov	w3, #0x44                  	// #68
    40009a78:	f9400802 	ldr	x2, [x0, #16]
    40009a7c:	b9429842 	ldr	w2, [x2, #664]
	Z_SHELL_VT100_CMD(shell, "\e[%d%c", delta, dir);
    40009a80:	36280122 	tbz	w2, #5, 40009aa4 <z_shell_op_cursor_horiz_move+0x3c>
    40009a84:	f9401400 	ldr	x0, [x0, #40]
    40009a88:	7100003f 	cmp	w1, #0x0
    40009a8c:	5a81a422 	cneg	w2, w1, lt  // lt = tstop
    40009a90:	90000061 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40009a94:	9126a021 	add	x1, x1, #0x9a8
    40009a98:	17ffffa6 	b	40009930 <z_shell_raw_fprintf>
	char dir = delta > 0 ? 'C' : 'D';
    40009a9c:	52800863 	mov	w3, #0x43                  	// #67
    40009aa0:	17fffff6 	b	40009a78 <z_shell_op_cursor_horiz_move+0x10>
}
    40009aa4:	d65f03c0 	ret

0000000040009aa8 <z_shell_cursor_in_empty_line>:

/* Function returns true if cursor is at beginning of an empty line. */
bool z_shell_cursor_in_empty_line(const struct shell *shell)
{
    40009aa8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009aac:	910003fd 	mov	x29, sp
    40009ab0:	a90153f3 	stp	x19, x20, [sp, #16]
    40009ab4:	aa0003f3 	mov	x19, x0
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
    40009ab8:	f9400800 	ldr	x0, [x0, #16]
    40009abc:	7940e414 	ldrh	w20, [x0, #114]
    40009ac0:	f9400000 	ldr	x0, [x0]
    40009ac4:	b40001a0 	cbz	x0, 40009af8 <z_shell_cursor_in_empty_line+0x50>
    40009ac8:	94000dd0 	bl	4000d208 <strlen>
    40009acc:	12003c01 	and	w1, w0, #0xffff
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40009ad0:	f9400a60 	ldr	x0, [x19, #16]
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
    40009ad4:	0b140021 	add	w1, w1, w20
}
    40009ad8:	a94153f3 	ldp	x19, x20, [sp, #16]
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40009adc:	79409402 	ldrh	w2, [x0, #74]
}
    40009ae0:	a8c27bfd 	ldp	x29, x30, [sp], #32
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40009ae4:	1ac20820 	udiv	w0, w1, w2
    40009ae8:	1b028401 	msub	w1, w0, w2, w1
    40009aec:	7100003f 	cmp	w1, #0x0
}
    40009af0:	1a9f17e0 	cset	w0, eq  // eq = none
    40009af4:	d65f03c0 	ret
    40009af8:	52800001 	mov	w1, #0x0                   	// #0
    40009afc:	17fffff5 	b	40009ad0 <z_shell_cursor_in_empty_line+0x28>

0000000040009b00 <z_shell_op_cond_next_line>:

void z_shell_op_cond_next_line(const struct shell *shell)
{
    40009b00:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009b04:	910003fd 	mov	x29, sp
    40009b08:	f9000bf3 	str	x19, [sp, #16]
    40009b0c:	aa0003f3 	mov	x19, x0
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
    40009b10:	97ffffe6 	bl	40009aa8 <z_shell_cursor_in_empty_line>
    40009b14:	72001c1f 	tst	w0, #0xff
    40009b18:	540000a0 	b.eq	40009b2c <z_shell_op_cond_next_line+0x2c>  // b.none
		z_cursor_next_line_move(shell);
    40009b1c:	f9401660 	ldr	x0, [x19, #40]
	}
}
    40009b20:	f9400bf3 	ldr	x19, [sp, #16]
    40009b24:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_cursor_next_line_move(shell);
    40009b28:	17ffffa7 	b	400099c4 <z_cursor_next_line_move.isra.0>
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
    40009b2c:	aa1303e0 	mov	x0, x19
    40009b30:	97ffffa8 	bl	400099d0 <full_line_cmd>
    40009b34:	72001c1f 	tst	w0, #0xff
    40009b38:	54ffff21 	b.ne	40009b1c <z_shell_op_cond_next_line+0x1c>  // b.any
}
    40009b3c:	f9400bf3 	ldr	x19, [sp, #16]
    40009b40:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40009b44:	d65f03c0 	ret

0000000040009b48 <z_shell_op_cursor_position_synchronize>:

void z_shell_op_cursor_position_synchronize(const struct shell *shell)
{
    40009b48:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40009b4c:	910003fd 	mov	x29, sp
    40009b50:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    40009b54:	f9400815 	ldr	x21, [x0, #16]
{
    40009b58:	a90153f3 	stp	x19, x20, [sp, #16]
    40009b5c:	aa0003f3 	mov	x19, x0
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    40009b60:	910102b4 	add	x20, x21, #0x40
	bool last_line;

	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    40009b64:	7940e2a2 	ldrh	w2, [x21, #112]
    40009b68:	aa1403e0 	mov	x0, x20
    40009b6c:	7940e6a1 	ldrh	w1, [x21, #114]
{
    40009b70:	f9001bf7 	str	x23, [sp, #48]
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    40009b74:	97fffdbd 	bl	40009268 <z_shell_multiline_data_calc>
				    shell->ctx->cmd_buff_len);
	last_line = (cons->cur_y == cons->cur_y_end);
    40009b78:	79400a97 	ldrh	w23, [x20, #4]
    40009b7c:	79400e96 	ldrh	w22, [x20, #6]

	/* In case cursor reaches the bottom line of a terminal, it will
	 * be moved to the next line.
	 */
	if (full_line_cmd(shell)) {
    40009b80:	aa1303e0 	mov	x0, x19
    40009b84:	97ffff93 	bl	400099d0 <full_line_cmd>
    40009b88:	72001c1f 	tst	w0, #0xff
    40009b8c:	54000060 	b.eq	40009b98 <z_shell_op_cursor_position_synchronize+0x50>  // b.none
		z_cursor_next_line_move(shell);
    40009b90:	f9401660 	ldr	x0, [x19, #40]
    40009b94:	97ffff8c 	bl	400099c4 <z_cursor_next_line_move.isra.0>
	}

	if (last_line) {
    40009b98:	6b1602ff 	cmp	w23, w22
    40009b9c:	54000141 	b.ne	40009bc4 <z_shell_op_cursor_position_synchronize+0x7c>  // b.any
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
	} else {
		z_shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
    40009ba0:	79400680 	ldrh	w0, [x20, #2]
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
    40009ba4:	794082a1 	ldrh	w1, [x21, #64]
	}
}
    40009ba8:	a9425bf5 	ldp	x21, x22, [sp, #32]
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
    40009bac:	4b000021 	sub	w1, w1, w0
    40009bb0:	aa1303e0 	mov	x0, x19
}
    40009bb4:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009bb8:	f9401bf7 	ldr	x23, [sp, #48]
    40009bbc:	a8c47bfd 	ldp	x29, x30, [sp], #64
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
    40009bc0:	17ffffaa 	b	40009a68 <z_shell_op_cursor_horiz_move>
		z_shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
    40009bc4:	79400a80 	ldrh	w0, [x20, #4]
    40009bc8:	79400e81 	ldrh	w1, [x20, #6]
    40009bcc:	4b000021 	sub	w1, w1, w0
    40009bd0:	aa1303e0 	mov	x0, x19
    40009bd4:	97ffff95 	bl	40009a28 <z_shell_op_cursor_vert_move>
    40009bd8:	17fffff2 	b	40009ba0 <z_shell_op_cursor_position_synchronize+0x58>

0000000040009bdc <z_shell_op_cursor_move>:

void z_shell_op_cursor_move(const struct shell *shell, int16_t val)
{
    40009bdc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40009be0:	910003fd 	mov	x29, sp
    40009be4:	a90153f3 	stp	x19, x20, [sp, #16]
    40009be8:	aa0003f3 	mov	x19, x0
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    40009bec:	f9400800 	ldr	x0, [x0, #16]
{
    40009bf0:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
	int32_t row_span;
	int32_t col_span;

	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    40009bf4:	91010000 	add	x0, x0, #0x40
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
    40009bf8:	79406403 	ldrh	w3, [x0, #50]
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    40009bfc:	79406002 	ldrh	w2, [x0, #48]
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
    40009c00:	0b21a061 	add	w1, w3, w1, sxth
    40009c04:	12003c34 	and	w20, w1, #0xffff
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    40009c08:	2a0303e1 	mov	w1, w3
    40009c0c:	97fffd97 	bl	40009268 <z_shell_multiline_data_calc>
				    shell->ctx->cmd_buff_len);

	/* Calculate the new cursor. */
	row_span = z_row_span_with_buffer_offsets_get(
						&shell->ctx->vt100_ctx.cons,
    40009c10:	f9400a60 	ldr	x0, [x19, #16]
	row_span = z_row_span_with_buffer_offsets_get(
    40009c14:	2a1403e2 	mov	w2, w20
    40009c18:	91010000 	add	x0, x0, #0x40
    40009c1c:	79406401 	ldrh	w1, [x0, #50]
    40009c20:	97fffd8a 	bl	40009248 <z_row_span_with_buffer_offsets_get>
    40009c24:	2a0003f6 	mov	w22, w0
						shell->ctx->cmd_buff_pos,
						new_pos);
	col_span = z_column_span_with_buffer_offsets_get(
						&shell->ctx->vt100_ctx.cons,
    40009c28:	f9400a60 	ldr	x0, [x19, #16]
	col_span = z_column_span_with_buffer_offsets_get(
    40009c2c:	2a1403e2 	mov	w2, w20
    40009c30:	91010000 	add	x0, x0, #0x40
    40009c34:	79406401 	ldrh	w1, [x0, #50]
    40009c38:	97fffd7a 	bl	40009220 <z_column_span_with_buffer_offsets_get>
    40009c3c:	2a0003f5 	mov	w21, w0
						shell->ctx->cmd_buff_pos,
						new_pos);

	z_shell_op_cursor_vert_move(shell, -row_span);
    40009c40:	4b1603e1 	neg	w1, w22
    40009c44:	aa1303e0 	mov	x0, x19
    40009c48:	97ffff78 	bl	40009a28 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(shell, col_span);
    40009c4c:	2a1503e1 	mov	w1, w21
    40009c50:	aa1303e0 	mov	x0, x19
    40009c54:	97ffff85 	bl	40009a68 <z_shell_op_cursor_horiz_move>
	shell->ctx->cmd_buff_pos = new_pos;
    40009c58:	f9400a60 	ldr	x0, [x19, #16]
}
    40009c5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
	shell->ctx->cmd_buff_pos = new_pos;
    40009c60:	7900e414 	strh	w20, [x0, #114]
}
    40009c64:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009c68:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40009c6c:	d65f03c0 	ret

0000000040009c70 <z_shell_op_cursor_word_move>:

	return ret;
}

void z_shell_op_cursor_word_move(const struct shell *shell, int16_t val)
{
    40009c70:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40009c74:	13003c21 	sxth	w1, w1
    40009c78:	910003fd 	mov	x29, sp
    40009c7c:	a90153f3 	stp	x19, x20, [sp, #16]
    40009c80:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009c84:	aa0003f5 	mov	x21, x0
	int16_t shift;
	int16_t sign;

	if (val < 0) {
    40009c88:	36f80581 	tbz	w1, #31, 40009d38 <z_shell_op_cursor_word_move+0xc8>
		val = -val;
    40009c8c:	4b0103e1 	neg	w1, w1
		sign = -1;
    40009c90:	12800014 	mov	w20, #0xffffffff            	// #-1
		val = -val;
    40009c94:	13003c21 	sxth	w1, w1
		sign = -1;
    40009c98:	12003c33 	and	w19, w1, #0xffff
    40009c9c:	12003e96 	and	w22, w20, #0xffff
    40009ca0:	1400001d 	b	40009d14 <z_shell_op_cursor_word_move+0xa4>
	} else {
		sign = 1;
	}

	while (val--) {
		shift = shift_calc(shell->ctx->cmd_buff,
    40009ca4:	f9400aa0 	ldr	x0, [x21, #16]
	bool found = false;
    40009ca8:	52800003 	mov	w3, #0x0                   	// #0
		shift = shift_calc(shell->ctx->cmd_buff,
    40009cac:	9101d806 	add	x6, x0, #0x76
    40009cb0:	7940e405 	ldrh	w5, [x0, #114]
    40009cb4:	7940e007 	ldrh	w7, [x0, #112]
    40009cb8:	2a0503e2 	mov	w2, w5
		idx = pos + ret * sign;
    40009cbc:	4b050041 	sub	w1, w2, w5
		if (((idx == 0U) && (sign < 0)) ||
    40009cc0:	7100005f 	cmp	w2, #0x0
    40009cc4:	7a400a80 	ccmp	w20, #0x0, #0x0, eq  // eq = none
    40009cc8:	13003c21 	sxth	w1, w1
    40009ccc:	540001cb 	b.lt	40009d04 <z_shell_op_cursor_word_move+0x94>  // b.tstop
		    ((idx == len) && (sign > 0))) {
    40009cd0:	7100029f 	cmp	w20, #0x0
		if (((idx == 0U) && (sign < 0)) ||
    40009cd4:	7a42c0e0 	ccmp	w7, w2, #0x0, gt
    40009cd8:	54000160 	b.eq	40009d04 <z_shell_op_cursor_word_move+0x94>  // b.none
		if (isalnum((int)str[idx]) != 0) {
    40009cdc:	92403c40 	and	x0, x2, #0xffff
    40009ce0:	386068c0 	ldrb	w0, [x6, x0]
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    40009ce4:	321b0004 	orr	w4, w0, #0x20
    40009ce8:	51018484 	sub	w4, w4, #0x61
	return (int)(isalpha(chr) || isdigit(chr));
    40009cec:	7100649f 	cmp	w4, #0x19
    40009cf0:	540001c9 	b.ls	40009d28 <z_shell_op_cursor_word_move+0xb8>  // b.plast
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    40009cf4:	5100c000 	sub	w0, w0, #0x30
	return (int)(isalpha(chr) || isdigit(chr));
    40009cf8:	7100241f 	cmp	w0, #0x9
    40009cfc:	54000169 	b.ls	40009d28 <z_shell_op_cursor_word_move+0xb8>  // b.plast
			if (found) {
    40009d00:	34000163 	cbz	w3, 40009d2c <z_shell_op_cursor_word_move+0xbc>
				   shell->ctx->cmd_buff_pos,
				   shell->ctx->cmd_buff_len, sign);
		z_shell_op_cursor_move(shell, sign * shift);
    40009d04:	aa1503e0 	mov	x0, x21
    40009d08:	97ffffb5 	bl	40009bdc <z_shell_op_cursor_move>
    40009d0c:	51000661 	sub	w1, w19, #0x1
    40009d10:	12003c33 	and	w19, w1, #0xffff
	while (val--) {
    40009d14:	35fffc93 	cbnz	w19, 40009ca4 <z_shell_op_cursor_word_move+0x34>
	}
}
    40009d18:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009d1c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009d20:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40009d24:	d65f03c0 	ret
			found = true;
    40009d28:	52800023 	mov	w3, #0x1                   	// #1
	while (1) {
    40009d2c:	0b0202c2 	add	w2, w22, w2
    40009d30:	12003c42 	and	w2, w2, #0xffff
		idx = pos + ret * sign;
    40009d34:	17ffffe2 	b	40009cbc <z_shell_op_cursor_word_move+0x4c>
		sign = 1;
    40009d38:	52800034 	mov	w20, #0x1                   	// #1
    40009d3c:	17ffffd7 	b	40009c98 <z_shell_op_cursor_word_move+0x28>

0000000040009d40 <z_shell_op_cursor_home_move>:
	z_cursor_restore(shell);
}

void z_shell_op_cursor_home_move(const struct shell *shell)
{
	z_shell_op_cursor_move(shell, -shell->ctx->cmd_buff_pos);
    40009d40:	f9400801 	ldr	x1, [x0, #16]
    40009d44:	7940e421 	ldrh	w1, [x1, #114]
    40009d48:	4b0103e1 	neg	w1, w1
    40009d4c:	17ffffa4 	b	40009bdc <z_shell_op_cursor_move>

0000000040009d50 <z_shell_op_cursor_end_move>:
}

void z_shell_op_cursor_end_move(const struct shell *shell)
{
	z_shell_op_cursor_move(shell, shell->ctx->cmd_buff_len -
    40009d50:	f9400802 	ldr	x2, [x0, #16]
    40009d54:	7940e041 	ldrh	w1, [x2, #112]
    40009d58:	7940e442 	ldrh	w2, [x2, #114]
    40009d5c:	4b020021 	sub	w1, w1, w2
    40009d60:	17ffff9f 	b	40009bdc <z_shell_op_cursor_move>

0000000040009d64 <z_shell_op_left_arrow>:
						shell->ctx->cmd_buff_pos);
}

void z_shell_op_left_arrow(const struct shell *shell)
{
	if (shell->ctx->cmd_buff_pos > 0) {
    40009d64:	f9400801 	ldr	x1, [x0, #16]
    40009d68:	7940e421 	ldrh	w1, [x1, #114]
    40009d6c:	34000061 	cbz	w1, 40009d78 <z_shell_op_left_arrow+0x14>
		z_shell_op_cursor_move(shell, -1);
    40009d70:	12800001 	mov	w1, #0xffffffff            	// #-1
    40009d74:	17ffff9a 	b	40009bdc <z_shell_op_cursor_move>
	}
}
    40009d78:	d65f03c0 	ret

0000000040009d7c <z_shell_op_right_arrow>:

void z_shell_op_right_arrow(const struct shell *shell)
{
	if (shell->ctx->cmd_buff_pos < shell->ctx->cmd_buff_len) {
    40009d7c:	f9400801 	ldr	x1, [x0, #16]
    40009d80:	7940e422 	ldrh	w2, [x1, #114]
    40009d84:	7940e021 	ldrh	w1, [x1, #112]
    40009d88:	6b01005f 	cmp	w2, w1
    40009d8c:	54000062 	b.cs	40009d98 <z_shell_op_right_arrow+0x1c>  // b.hs, b.nlast
		z_shell_op_cursor_move(shell, 1);
    40009d90:	52800021 	mov	w1, #0x1                   	// #1
    40009d94:	17ffff92 	b	40009bdc <z_shell_op_cursor_move>
	}
}
    40009d98:	d65f03c0 	ret

0000000040009d9c <z_shell_op_delete_from_cursor>:
	reprint_from_cursor(shell, --diff, true);
}

void z_shell_op_delete_from_cursor(const struct shell *shell)
{
	shell->ctx->cmd_buff_len = shell->ctx->cmd_buff_pos;
    40009d9c:	f9400802 	ldr	x2, [x0, #16]
    40009da0:	7940e441 	ldrh	w1, [x2, #114]
    40009da4:	7900e041 	strh	w1, [x2, #112]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos] = '\0';
    40009da8:	8b21c041 	add	x1, x2, w1, sxtw
    40009dac:	3901d83f 	strb	wzr, [x1, #118]

	z_clear_eos(shell);
    40009db0:	17fffefd 	b	400099a4 <z_clear_eos>

0000000040009db4 <z_shell_cmd_line_erase>:
{
	data_insert(shell, compl, compl_len);
}

void z_shell_cmd_line_erase(const struct shell *shell)
{
    40009db4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009db8:	910003fd 	mov	x29, sp
    40009dbc:	f9000bf3 	str	x19, [sp, #16]
    40009dc0:	aa0003f3 	mov	x19, x0
	z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
    40009dc4:	f9400800 	ldr	x0, [x0, #16]
    40009dc8:	91010000 	add	x0, x0, #0x40
    40009dcc:	79406002 	ldrh	w2, [x0, #48]
    40009dd0:	79406401 	ldrh	w1, [x0, #50]
    40009dd4:	97fffd25 	bl	40009268 <z_shell_multiline_data_calc>
				    shell->ctx->cmd_buff_pos,
				    shell->ctx->cmd_buff_len);
	z_shell_op_cursor_horiz_move(shell,
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
    40009dd8:	f9400a60 	ldr	x0, [x19, #16]
	z_shell_op_cursor_horiz_move(shell,
    40009ddc:	52800021 	mov	w1, #0x1                   	// #1
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
    40009de0:	79408000 	ldrh	w0, [x0, #64]
	z_shell_op_cursor_horiz_move(shell,
    40009de4:	4b000021 	sub	w1, w1, w0
    40009de8:	aa1303e0 	mov	x0, x19
    40009dec:	97ffff1f 	bl	40009a68 <z_shell_op_cursor_horiz_move>
	z_shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
    40009df0:	f9400a60 	ldr	x0, [x19, #16]
    40009df4:	79408801 	ldrh	w1, [x0, #68]
    40009df8:	aa1303e0 	mov	x0, x19
    40009dfc:	51000421 	sub	w1, w1, #0x1
    40009e00:	97ffff0a 	bl	40009a28 <z_shell_op_cursor_vert_move>

	z_clear_eos(shell);
    40009e04:	aa1303e0 	mov	x0, x19
}
    40009e08:	f9400bf3 	ldr	x19, [sp, #16]
    40009e0c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_clear_eos(shell);
    40009e10:	17fffee5 	b	400099a4 <z_clear_eos>

0000000040009e14 <z_shell_print_cmd>:
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
}

void z_shell_print_cmd(const struct shell *shell)
{
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", shell->ctx->cmd_buff);
    40009e14:	f9400802 	ldr	x2, [x0, #16]
    40009e18:	90000061 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40009e1c:	910dbc21 	add	x1, x1, #0x36f
    40009e20:	f9401400 	ldr	x0, [x0, #40]
    40009e24:	9101d842 	add	x2, x2, #0x76
    40009e28:	17fffec2 	b	40009930 <z_shell_raw_fprintf>

0000000040009e2c <z_shell_write>:
	}
}

void z_shell_write(const struct shell *shell, const void *data,
		 size_t length)
{
    40009e2c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40009e30:	910003fd 	mov	x29, sp
    40009e34:	a90153f3 	stp	x19, x20, [sp, #16]
    40009e38:	aa0003f4 	mov	x20, x0
    40009e3c:	aa0203f3 	mov	x19, x2
    40009e40:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009e44:	aa0103f6 	mov	x22, x1
	__ASSERT_NO_MSG(shell && data);

	size_t offset = 0;
    40009e48:	d2800015 	mov	x21, #0x0                   	// #0
{
    40009e4c:	f9001bf7 	str	x23, [sp, #48]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    40009e50:	929fffb7 	mov	x23, #0xffffffffffff0002    	// #-65534
    40009e54:	f2a00017 	movk	x23, #0x0, lsl #16
	size_t tmp_cnt;

	while (length) {
    40009e58:	b50000d3 	cbnz	x19, 40009e70 <z_shell_write+0x44>
		if (tmp_cnt == 0 &&
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
			shell_pend_on_txdone(shell);
		}
	}
}
    40009e5c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009e60:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009e64:	f9401bf7 	ldr	x23, [sp, #48]
    40009e68:	a8c77bfd 	ldp	x29, x30, [sp], #112
    40009e6c:	d65f03c0 	ret
		int err = shell->iface->api->write(shell->iface,
    40009e70:	f9400680 	ldr	x0, [x20, #8]
    40009e74:	aa1303e2 	mov	x2, x19
    40009e78:	910103e3 	add	x3, sp, #0x40
    40009e7c:	f9400001 	ldr	x1, [x0]
    40009e80:	f9400c24 	ldr	x4, [x1, #24]
    40009e84:	8b1502c1 	add	x1, x22, x21
    40009e88:	d63f0080 	blr	x4
		offset += tmp_cnt;
    40009e8c:	f94023e0 	ldr	x0, [sp, #64]
    40009e90:	8b0002b5 	add	x21, x21, x0
		length -= tmp_cnt;
    40009e94:	cb000273 	sub	x19, x19, x0
		if (tmp_cnt == 0 &&
    40009e98:	b5fffe00 	cbnz	x0, 40009e58 <z_shell_write+0x2c>
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
    40009e9c:	f9400a83 	ldr	x3, [x20, #16]
    40009ea0:	b9400860 	ldr	w0, [x3, #8]
		if (tmp_cnt == 0 &&
    40009ea4:	71000c1f 	cmp	w0, #0x3
    40009ea8:	54fffd80 	b.eq	40009e58 <z_shell_write+0x2c>  // b.none
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
    40009eac:	7100081f 	cmp	w0, #0x2
    40009eb0:	540001c8 	b.hi	40009ee8 <z_shell_write+0xbc>  // b.pmore
		k_poll_event_init(&event,
    40009eb4:	910bc063 	add	x3, x3, #0x2f0
    40009eb8:	910123e0 	add	x0, sp, #0x48
    40009ebc:	52800002 	mov	w2, #0x0                   	// #0
    40009ec0:	52800021 	mov	w1, #0x1                   	// #1
    40009ec4:	94001d6b 	bl	40011470 <k_poll_event_init>
    40009ec8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    40009ecc:	910123e0 	add	x0, sp, #0x48
    40009ed0:	52800021 	mov	w1, #0x1                   	// #1
    40009ed4:	94001d70 	bl	40011494 <z_impl_k_poll>
		k_poll_signal_reset(&shell->ctx->signals[SHELL_SIGNAL_TXDONE]);
    40009ed8:	f9400a80 	ldr	x0, [x20, #16]
    40009edc:	910bc000 	add	x0, x0, #0x2f0
	z_impl_k_poll_signal_reset(sig);
    40009ee0:	94001db0 	bl	400115a0 <z_impl_k_poll_signal_reset>
    40009ee4:	17ffffdd 	b	40009e58 <z_shell_write+0x2c>
	return sh->ctx->ctx.flags.tx_rdy == 1;
    40009ee8:	b942a060 	ldr	w0, [x3, #672]
		while (!z_flag_tx_rdy_get(shell)) {
    40009eec:	360fffe0 	tbz	w0, #1, 40009ee8 <z_shell_write+0xbc>
    40009ef0:	910a8061 	add	x1, x3, #0x2a0
    40009ef4:	aa1703e0 	mov	x0, x23
    40009ef8:	97ffdc3e 	bl	40000ff0 <__aarch64_ldclr8_acq_rel>
	return ret;
    40009efc:	17ffffd7 	b	40009e58 <z_shell_write+0x2c>

0000000040009f00 <z_shell_print_stream>:

/* Function shall be only used by the fprintf module. */
void z_shell_print_stream(const void *user_ctx, const char *data, size_t len)
{
	z_shell_write((const struct shell *) user_ctx, data, len);
    40009f00:	17ffffcb 	b	40009e2c <z_shell_write>

0000000040009f04 <z_shell_vt100_color_set>:
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
}

void z_shell_vt100_color_set(const struct shell *shell,
			     enum shell_vt100_color color)
{
    40009f04:	2a0103e2 	mov	w2, w1
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	if (color >= VT100_COLOR_END) {
    40009f08:	7100203f 	cmp	w1, #0x8
    40009f0c:	54000288 	b.hi	40009f5c <z_shell_vt100_color_set+0x58>  // b.pmore
		return;
	}

	if (shell->ctx->vt100_ctx.col.col == color) {
    40009f10:	f9400801 	ldr	x1, [x0, #16]
    40009f14:	b9405023 	ldr	w3, [x1, #80]
    40009f18:	6b02007f 	cmp	w3, w2
    40009f1c:	54000200 	b.eq	40009f5c <z_shell_vt100_color_set+0x58>  // b.none
		return;
	}

	shell->ctx->vt100_ctx.col.col = color;
    40009f20:	b9005022 	str	w2, [x1, #80]

	if (color != SHELL_NORMAL) {
    40009f24:	7100205f 	cmp	w2, #0x8
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40009f28:	b9429821 	ldr	w1, [x1, #664]
    40009f2c:	540000c0 	b.eq	40009f44 <z_shell_vt100_color_set+0x40>  // b.none
		Z_SHELL_VT100_CMD(shell, "\e[1;3%dm", color);
    40009f30:	36280161 	tbz	w1, #5, 40009f5c <z_shell_vt100_color_set+0x58>
    40009f34:	f9401400 	ldr	x0, [x0, #40]
    40009f38:	90000061 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40009f3c:	9126bc21 	add	x1, x1, #0x9af
    40009f40:	17fffe7c 	b	40009930 <z_shell_raw_fprintf>
	} else {
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_MODESOFF);
    40009f44:	362800c1 	tbz	w1, #5, 40009f5c <z_shell_vt100_color_set+0x58>
    40009f48:	f9401400 	ldr	x0, [x0, #40]
    40009f4c:	d0000041 	adrp	x1, 40013000 <shell_cmd_help>
    40009f50:	91030021 	add	x1, x1, #0xc0
    40009f54:	91001421 	add	x1, x1, #0x5
    40009f58:	17fffe76 	b	40009930 <z_shell_raw_fprintf>
	}
}
    40009f5c:	d65f03c0 	ret

0000000040009f60 <z_shell_vt100_colors_restore>:

void z_shell_vt100_colors_restore(const struct shell *shell,
				  const struct shell_vt100_colors *color)
{
    40009f60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009f64:	910003fd 	mov	x29, sp
    40009f68:	a90153f3 	stp	x19, x20, [sp, #16]
    40009f6c:	aa0103f4 	mov	x20, x1
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	z_shell_vt100_color_set(shell, color->col);
    40009f70:	b9400021 	ldr	w1, [x1]
{
    40009f74:	aa0003f3 	mov	x19, x0
	z_shell_vt100_color_set(shell, color->col);
    40009f78:	97ffffe3 	bl	40009f04 <z_shell_vt100_color_set>
	vt100_bgcolor_set(shell, color->bgcol);
    40009f7c:	b9400682 	ldr	w2, [x20, #4]
	if ((bgcolor == SHELL_NORMAL) ||
    40009f80:	71001c5f 	cmp	w2, #0x7
    40009f84:	540001c8 	b.hi	40009fbc <z_shell_vt100_colors_restore+0x5c>  // b.pmore
	    (shell->ctx->vt100_ctx.col.bgcol == bgcolor)) {
    40009f88:	f9400a60 	ldr	x0, [x19, #16]
	if ((bgcolor == SHELL_NORMAL) ||
    40009f8c:	b9405401 	ldr	w1, [x0, #84]
    40009f90:	6b01005f 	cmp	w2, w1
    40009f94:	54000140 	b.eq	40009fbc <z_shell_vt100_colors_restore+0x5c>  // b.none
	shell->ctx->vt100_ctx.col.bgcol = bgcolor;
    40009f98:	b9005402 	str	w2, [x0, #84]
    40009f9c:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
    40009fa0:	362800e0 	tbz	w0, #5, 40009fbc <z_shell_vt100_colors_restore+0x5c>
    40009fa4:	f9401660 	ldr	x0, [x19, #40]
    40009fa8:	90000061 	adrp	x1, 40015000 <prefix.1+0x2aa>
    40009fac:	9126e021 	add	x1, x1, #0x9b8
}
    40009fb0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009fb4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
    40009fb8:	17fffe5e 	b	40009930 <z_shell_raw_fprintf>
}
    40009fbc:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009fc0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40009fc4:	d65f03c0 	ret

0000000040009fc8 <z_shell_vfprintf>:

void z_shell_vfprintf(const struct shell *shell, enum shell_vt100_color color,
		      const char *fmt, va_list args)
{
    40009fc8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40009fcc:	910003fd 	mov	x29, sp
    40009fd0:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009fd4:	2a0103f6 	mov	w22, w1
    40009fd8:	aa0203f5 	mov	x21, x2
	return sh->ctx->cfg.flags.use_colors == 1;
    40009fdc:	f9400801 	ldr	x1, [x0, #16]
    40009fe0:	a90153f3 	stp	x19, x20, [sp, #16]
    40009fe4:	aa0003f3 	mov	x19, x0
    40009fe8:	aa0303f4 	mov	x20, x3
    40009fec:	b9429820 	ldr	w0, [x1, #664]
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
    40009ff0:	36200340 	tbz	w0, #4, 4000a058 <z_shell_vfprintf+0x90>
	    z_flag_use_colors_get(shell)	  &&
    40009ff4:	b9405020 	ldr	w0, [x1, #80]
    40009ff8:	6b16001f 	cmp	w0, w22
    40009ffc:	540002e0 	b.eq	4000a058 <z_shell_vfprintf+0x90>  // b.none
			     enum shell_vt100_color color);

static inline void z_shell_vt100_colors_store(const struct shell *sh,
					      struct shell_vt100_colors *color)
{
	memcpy(color, &sh->ctx->vt100_ctx.col, sizeof(*color));
    4000a000:	d2800102 	mov	x2, #0x8                   	// #8
    4000a004:	91014021 	add	x1, x1, #0x50
    4000a008:	910163e0 	add	x0, sp, #0x58
    4000a00c:	94000cc2 	bl	4000d314 <memcpy>
	    (color != shell->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		z_shell_vt100_colors_store(shell, &col);
		z_shell_vt100_color_set(shell, color);
    4000a010:	2a1603e1 	mov	w1, w22
    4000a014:	aa1303e0 	mov	x0, x19
    4000a018:	97ffffbb 	bl	40009f04 <z_shell_vt100_color_set>

		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
    4000a01c:	a9400680 	ldp	x0, x1, [x20]
    4000a020:	a90307e0 	stp	x0, x1, [sp, #48]
    4000a024:	9100c3e2 	add	x2, sp, #0x30
    4000a028:	a9410680 	ldp	x0, x1, [x20, #16]
    4000a02c:	a90407e0 	stp	x0, x1, [sp, #64]
    4000a030:	f9401660 	ldr	x0, [x19, #40]
    4000a034:	aa1503e1 	mov	x1, x21
    4000a038:	97fffc3b 	bl	40009124 <z_shell_fprintf_fmt>

		z_shell_vt100_colors_restore(shell, &col);
    4000a03c:	910163e1 	add	x1, sp, #0x58
    4000a040:	aa1303e0 	mov	x0, x19
    4000a044:	97ffffc7 	bl	40009f60 <z_shell_vt100_colors_restore>
	} else {
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
	}
}
    4000a048:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a04c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a050:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000a054:	d65f03c0 	ret
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
    4000a058:	a9400680 	ldp	x0, x1, [x20]
    4000a05c:	a90307e0 	stp	x0, x1, [sp, #48]
    4000a060:	9100c3e2 	add	x2, sp, #0x30
    4000a064:	a9410680 	ldp	x0, x1, [x20, #16]
    4000a068:	a90407e0 	stp	x0, x1, [sp, #64]
    4000a06c:	f9401660 	ldr	x0, [x19, #40]
    4000a070:	aa1503e1 	mov	x1, x21
    4000a074:	97fffc2c 	bl	40009124 <z_shell_fprintf_fmt>
}
    4000a078:	17fffff4 	b	4000a048 <z_shell_vfprintf+0x80>

000000004000a07c <z_shell_fprintf>:

void z_shell_fprintf(const struct shell *sh,
		     enum shell_vt100_color color,
		     const char *fmt, ...)
{
    4000a07c:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    4000a080:	910003fd 	mov	x29, sp
    4000a084:	a90d93e3 	stp	x3, x4, [sp, #216]
	__ASSERT(z_flag_panic_mode_get(sh) || !k_is_in_isr(),
		 "Thread context required.");

	va_list args;

	va_start(args, fmt);
    4000a088:	910403e3 	add	x3, sp, #0x100
    4000a08c:	a9030fe3 	stp	x3, x3, [sp, #48]
    4000a090:	910343e3 	add	x3, sp, #0xd0
    4000a094:	f90023e3 	str	x3, [sp, #64]
    4000a098:	128004e3 	mov	w3, #0xffffffd8            	// #-40
    4000a09c:	b9004be3 	str	w3, [sp, #72]
    4000a0a0:	12800fe3 	mov	w3, #0xffffff80            	// #-128
    4000a0a4:	b9004fe3 	str	w3, [sp, #76]
	z_shell_vfprintf(sh, color, fmt, args);
    4000a0a8:	910043e3 	add	x3, sp, #0x10
{
    4000a0ac:	a90e9be5 	stp	x5, x6, [sp, #232]
	z_shell_vfprintf(sh, color, fmt, args);
    4000a0b0:	a94317e4 	ldp	x4, x5, [sp, #48]
    4000a0b4:	a90117e4 	stp	x4, x5, [sp, #16]
    4000a0b8:	a94417e4 	ldp	x4, x5, [sp, #64]
    4000a0bc:	a90217e4 	stp	x4, x5, [sp, #32]
{
    4000a0c0:	3d8017e0 	str	q0, [sp, #80]
    4000a0c4:	3d801be1 	str	q1, [sp, #96]
    4000a0c8:	3d801fe2 	str	q2, [sp, #112]
    4000a0cc:	3d8023e3 	str	q3, [sp, #128]
    4000a0d0:	3d8027e4 	str	q4, [sp, #144]
    4000a0d4:	3d802be5 	str	q5, [sp, #160]
    4000a0d8:	3d802fe6 	str	q6, [sp, #176]
    4000a0dc:	3d8033e7 	str	q7, [sp, #192]
    4000a0e0:	f9007fe7 	str	x7, [sp, #248]
	z_shell_vfprintf(sh, color, fmt, args);
    4000a0e4:	97ffffb9 	bl	40009fc8 <z_shell_vfprintf>
	va_end(args);
}
    4000a0e8:	a8d07bfd 	ldp	x29, x30, [sp], #256
    4000a0ec:	d65f03c0 	ret

000000004000a0f0 <z_shell_op_word_remove>:
{
    4000a0f0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000a0f4:	910003fd 	mov	x29, sp
    4000a0f8:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a0fc:	aa0003f3 	mov	x19, x0
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    4000a100:	f9400800 	ldr	x0, [x0, #16]
	if ((shell->ctx->cmd_buff_len == 0) ||
    4000a104:	7940e002 	ldrh	w2, [x0, #112]
{
    4000a108:	f90013f5 	str	x21, [sp, #32]
	if ((shell->ctx->cmd_buff_len == 0) ||
    4000a10c:	340008a2 	cbz	w2, 4000a220 <z_shell_op_word_remove+0x130>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    4000a110:	7940e403 	ldrh	w3, [x0, #114]
	if ((shell->ctx->cmd_buff_len == 0) ||
    4000a114:	34000863 	cbz	w3, 4000a220 <z_shell_op_word_remove+0x130>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    4000a118:	1101d463 	add	w3, w3, #0x75
	char *str_start = &shell->ctx->cmd_buff[0];
    4000a11c:	9101d801 	add	x1, x0, #0x76
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    4000a120:	8b23c003 	add	x3, x0, w3, sxtw
    4000a124:	aa0303e0 	mov	x0, x3
    4000a128:	4b000074 	sub	w20, w3, w0
	while ((str >= str_start) && (*str == ' ')) {
    4000a12c:	eb01001f 	cmp	x0, x1
    4000a130:	12003e94 	and	w20, w20, #0xffff
    4000a134:	54000183 	b.cc	4000a164 <z_shell_op_word_remove+0x74>  // b.lo, b.ul, b.last
    4000a138:	39400004 	ldrb	w4, [x0]
    4000a13c:	7100809f 	cmp	w4, #0x20
    4000a140:	540006c0 	b.eq	4000a218 <z_shell_op_word_remove+0x128>  // b.none
	while ((str >= str_start) && (*str != ' ')) {
    4000a144:	39400003 	ldrb	w3, [x0]
    4000a148:	7100807f 	cmp	w3, #0x20
    4000a14c:	540000c0 	b.eq	4000a164 <z_shell_op_word_remove+0x74>  // b.none
		++chars_to_delete;
    4000a150:	11000694 	add	w20, w20, #0x1
		--str;
    4000a154:	d1000400 	sub	x0, x0, #0x1
		++chars_to_delete;
    4000a158:	12003e94 	and	w20, w20, #0xffff
	while ((str >= str_start) && (*str != ' ')) {
    4000a15c:	eb00003f 	cmp	x1, x0
    4000a160:	54ffff29 	b.ls	4000a144 <z_shell_op_word_remove+0x54>  // b.plast
		shell->ctx->cmd_buff_len - chars_to_delete);
    4000a164:	4b140042 	sub	w2, w2, w20
	memmove(str + 1, str + 1 + chars_to_delete,
    4000a168:	92403e81 	and	x1, x20, #0xffff
    4000a16c:	91000415 	add	x21, x0, #0x1
    4000a170:	91000421 	add	x1, x1, #0x1
    4000a174:	8b010001 	add	x1, x0, x1
    4000a178:	93407c42 	sxtw	x2, w2
    4000a17c:	aa1503e0 	mov	x0, x21
    4000a180:	94000c56 	bl	4000d2d8 <memmove>
	shell->ctx->cmd_buff_len -= chars_to_delete;
    4000a184:	f9400a61 	ldr	x1, [x19, #16]
    4000a188:	7940e020 	ldrh	w0, [x1, #112]
    4000a18c:	4b140000 	sub	w0, w0, w20
    4000a190:	12003c00 	and	w0, w0, #0xffff
    4000a194:	7900e020 	strh	w0, [x1, #112]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    4000a198:	8b20c020 	add	x0, x1, w0, sxtw
	z_shell_op_cursor_move(shell, -chars_to_delete);
    4000a19c:	4b1403e1 	neg	w1, w20
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    4000a1a0:	3901d81f 	strb	wzr, [x0, #118]
	z_shell_op_cursor_move(shell, -chars_to_delete);
    4000a1a4:	aa1303e0 	mov	x0, x19
    4000a1a8:	97fffe8d 	bl	40009bdc <z_shell_op_cursor_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    4000a1ac:	f9400a60 	ldr	x0, [x19, #16]
    4000a1b0:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
    4000a1b4:	362800c0 	tbz	w0, #5, 4000a1cc <z_shell_op_word_remove+0xdc>
    4000a1b8:	f9401660 	ldr	x0, [x19, #40]
    4000a1bc:	b0000041 	adrp	x1, 40013000 <shell_cmd_help>
    4000a1c0:	91030021 	add	x1, x1, #0xc0
    4000a1c4:	91002821 	add	x1, x1, #0xa
    4000a1c8:	97fffdda 	bl	40009930 <z_shell_raw_fprintf>
	z_shell_fprintf(shell, SHELL_NORMAL, "%s", str + 1);
    4000a1cc:	aa1503e3 	mov	x3, x21
    4000a1d0:	f0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000a1d4:	910dbc42 	add	x2, x2, #0x36f
    4000a1d8:	52800101 	mov	w1, #0x8                   	// #8
    4000a1dc:	aa1303e0 	mov	x0, x19
    4000a1e0:	97ffffa7 	bl	4000a07c <z_shell_fprintf>
	z_clear_eos(shell);
    4000a1e4:	aa1303e0 	mov	x0, x19
    4000a1e8:	97fffdef 	bl	400099a4 <z_clear_eos>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    4000a1ec:	f9400a60 	ldr	x0, [x19, #16]
    4000a1f0:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
    4000a1f4:	36280160 	tbz	w0, #5, 4000a220 <z_shell_op_word_remove+0x130>
}
    4000a1f8:	f94013f5 	ldr	x21, [sp, #32]
    4000a1fc:	b0000041 	adrp	x1, 40013000 <shell_cmd_help>
    4000a200:	91030021 	add	x1, x1, #0xc0
    4000a204:	f9401660 	ldr	x0, [x19, #40]
    4000a208:	91003821 	add	x1, x1, #0xe
    4000a20c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a210:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000a214:	17fffdc7 	b	40009930 <z_shell_raw_fprintf>
		--str;
    4000a218:	d1000400 	sub	x0, x0, #0x1
    4000a21c:	17ffffc3 	b	4000a128 <z_shell_op_word_remove+0x38>
}
    4000a220:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a224:	f94013f5 	ldr	x21, [sp, #32]
    4000a228:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000a22c:	d65f03c0 	ret

000000004000a230 <reprint_from_cursor>:
{
    4000a230:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000a234:	910003fd 	mov	x29, sp
    4000a238:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a23c:	aa0003f3 	mov	x19, x0
    4000a240:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000a244:	12003c36 	and	w22, w1, #0xffff
    4000a248:	f9001bf7 	str	x23, [sp, #48]
	if (data_removed) {
    4000a24c:	72001c57 	ands	w23, w2, #0xff
    4000a250:	54000040 	b.eq	4000a258 <reprint_from_cursor+0x28>  // b.none
		z_clear_eos(shell);
    4000a254:	97fffdd4 	bl	400099a4 <z_clear_eos>
	return sh->ctx->cfg.flags.obscure == 1;
    4000a258:	f9400a60 	ldr	x0, [x19, #16]
    4000a25c:	b9429801 	ldr	w1, [x0, #664]
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
    4000a260:	7940e403 	ldrh	w3, [x0, #114]
    4000a264:	9101d863 	add	x3, x3, #0x76
    4000a268:	8b030000 	add	x0, x0, x3
	if (z_flag_obscure_get(shell)) {
    4000a26c:	361003e1 	tbz	w1, #2, 4000a2e8 <reprint_from_cursor+0xb8>
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
    4000a270:	f0000055 	adrp	x21, 40015000 <prefix.1+0x2aa>
    4000a274:	910562b5 	add	x21, x21, #0x158
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
    4000a278:	94000be4 	bl	4000d208 <strlen>
		while (len--) {
    4000a27c:	2a0003f4 	mov	w20, w0
    4000a280:	350002b4 	cbnz	w20, 4000a2d4 <reprint_from_cursor+0xa4>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    4000a284:	f9400a60 	ldr	x0, [x19, #16]
    4000a288:	7940e001 	ldrh	w1, [x0, #112]
    4000a28c:	7900e401 	strh	w1, [x0, #114]
	if (full_line_cmd(shell)) {
    4000a290:	aa1303e0 	mov	x0, x19
    4000a294:	97fffdcf 	bl	400099d0 <full_line_cmd>
    4000a298:	72001c1f 	tst	w0, #0xff
    4000a29c:	540000e0 	b.eq	4000a2b8 <reprint_from_cursor+0x88>  // b.none
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
    4000a2a0:	710002df 	cmp	w22, #0x0
    4000a2a4:	7a401ae4 	ccmp	w23, #0x0, #0x4, ne  // ne = any
    4000a2a8:	54000041 	b.ne	4000a2b0 <reprint_from_cursor+0x80>  // b.any
    4000a2ac:	35000077 	cbnz	w23, 4000a2b8 <reprint_from_cursor+0x88>
			z_cursor_next_line_move(shell);
    4000a2b0:	f9401660 	ldr	x0, [x19, #40]
    4000a2b4:	97fffdc4 	bl	400099c4 <z_cursor_next_line_move.isra.0>
	z_shell_op_cursor_move(shell, -diff);
    4000a2b8:	4b1603e1 	neg	w1, w22
    4000a2bc:	aa1303e0 	mov	x0, x19
}
    4000a2c0:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a2c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a2c8:	f9401bf7 	ldr	x23, [sp, #48]
    4000a2cc:	a8c47bfd 	ldp	x29, x30, [sp], #64
	z_shell_op_cursor_move(shell, -diff);
    4000a2d0:	17fffe43 	b	40009bdc <z_shell_op_cursor_move>
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
    4000a2d4:	f9401660 	ldr	x0, [x19, #40]
    4000a2d8:	aa1503e1 	mov	x1, x21
    4000a2dc:	51000694 	sub	w20, w20, #0x1
    4000a2e0:	97fffd94 	bl	40009930 <z_shell_raw_fprintf>
    4000a2e4:	17ffffe7 	b	4000a280 <reprint_from_cursor+0x50>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s",
    4000a2e8:	aa0003e3 	mov	x3, x0
    4000a2ec:	f0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000a2f0:	910dbc42 	add	x2, x2, #0x36f
    4000a2f4:	aa1303e0 	mov	x0, x19
    4000a2f8:	52800101 	mov	w1, #0x8                   	// #8
    4000a2fc:	97ffff60 	bl	4000a07c <z_shell_fprintf>
    4000a300:	17ffffe1 	b	4000a284 <reprint_from_cursor+0x54>

000000004000a304 <data_insert>:
{
    4000a304:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000a308:	910003fd 	mov	x29, sp
    4000a30c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a310:	12003c54 	and	w20, w2, #0xffff
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    4000a314:	f9400813 	ldr	x19, [x0, #16]
{
    4000a318:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000a31c:	aa0003f5 	mov	x21, x0
    4000a320:	a90363f7 	stp	x23, x24, [sp, #48]
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    4000a324:	7940e260 	ldrh	w0, [x19, #112]
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
    4000a328:	0b222002 	add	w2, w0, w2, uxth
    4000a32c:	7103fc5f 	cmp	w2, #0xff
    4000a330:	540003ac 	b.gt	4000a3a4 <data_insert+0xa0>
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    4000a334:	7940e663 	ldrh	w3, [x19, #114]
    4000a338:	aa0103f6 	mov	x22, x1
	memmove(curr_pos + len, curr_pos, after);
    4000a33c:	92403e97 	and	x23, x20, #0xffff
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    4000a340:	4b030000 	sub	w0, w0, w3
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    4000a344:	92403c63 	and	x3, x3, #0xffff
    4000a348:	9101d863 	add	x3, x3, #0x76
	memmove(curr_pos + len, curr_pos, after);
    4000a34c:	92403c02 	and	x2, x0, #0xffff
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    4000a350:	8b030273 	add	x19, x19, x3
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    4000a354:	12003c18 	and	w24, w0, #0xffff
	memmove(curr_pos + len, curr_pos, after);
    4000a358:	aa1303e1 	mov	x1, x19
    4000a35c:	8b342260 	add	x0, x19, w20, uxth
    4000a360:	94000bde 	bl	4000d2d8 <memmove>
	memcpy(curr_pos, data, len);
    4000a364:	aa1703e2 	mov	x2, x23
    4000a368:	aa1603e1 	mov	x1, x22
    4000a36c:	aa1303e0 	mov	x0, x19
    4000a370:	94000be9 	bl	4000d314 <memcpy>
	shell->ctx->cmd_buff_len += len;
    4000a374:	f9400aa2 	ldr	x2, [x21, #16]
    4000a378:	7940e041 	ldrh	w1, [x2, #112]
    4000a37c:	0b010281 	add	w1, w20, w1
    4000a380:	12003c21 	and	w1, w1, #0xffff
    4000a384:	7900e041 	strh	w1, [x2, #112]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    4000a388:	8b21c041 	add	x1, x2, w1, sxtw
    4000a38c:	3901d83f 	strb	wzr, [x1, #118]
	return sh->ctx->cfg.flags.echo == 1;
    4000a390:	b9429840 	ldr	w0, [x2, #664]
	if (!z_flag_echo_get(shell)) {
    4000a394:	37080120 	tbnz	w0, #1, 4000a3b8 <data_insert+0xb4>
		shell->ctx->cmd_buff_pos += len;
    4000a398:	7940e440 	ldrh	w0, [x2, #114]
    4000a39c:	0b000294 	add	w20, w20, w0
    4000a3a0:	7900e454 	strh	w20, [x2, #114]
}
    4000a3a4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a3a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a3ac:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000a3b0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000a3b4:	d65f03c0 	ret
	reprint_from_cursor(shell, after, false);
    4000a3b8:	2a1803e1 	mov	w1, w24
    4000a3bc:	aa1503e0 	mov	x0, x21
}
    4000a3c0:	a94153f3 	ldp	x19, x20, [sp, #16]
	reprint_from_cursor(shell, after, false);
    4000a3c4:	52800002 	mov	w2, #0x0                   	// #0
}
    4000a3c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a3cc:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000a3d0:	a8c47bfd 	ldp	x29, x30, [sp], #64
	reprint_from_cursor(shell, after, false);
    4000a3d4:	17ffff97 	b	4000a230 <reprint_from_cursor>

000000004000a3d8 <z_shell_op_char_insert>:
{
    4000a3d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000a3dc:	910003fd 	mov	x29, sp
    4000a3e0:	f9000bf3 	str	x19, [sp, #16]
    4000a3e4:	aa0003f3 	mov	x19, x0
	return sh->ctx->cfg.flags.insert_mode == 1;
    4000a3e8:	f9400800 	ldr	x0, [x0, #16]
    4000a3ec:	3900bfe1 	strb	w1, [sp, #47]
    4000a3f0:	b9429801 	ldr	w1, [x0, #664]
	if (z_flag_insert_mode_get(shell) &&
    4000a3f4:	360003a1 	tbz	w1, #0, 4000a468 <z_shell_op_char_insert+0x90>
	    (shell->ctx->cmd_buff_len != shell->ctx->cmd_buff_pos)) {
    4000a3f8:	7940e401 	ldrh	w1, [x0, #114]
	if (z_flag_insert_mode_get(shell) &&
    4000a3fc:	7940e002 	ldrh	w2, [x0, #112]
    4000a400:	6b01005f 	cmp	w2, w1
    4000a404:	54000320 	b.eq	4000a468 <z_shell_op_char_insert+0x90>  // b.none
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
    4000a408:	11000423 	add	w3, w1, #0x1
    4000a40c:	8b21c001 	add	x1, x0, w1, sxtw
		char_replace(shell, data);
    4000a410:	3940bfe2 	ldrb	w2, [sp, #47]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
    4000a414:	7900e403 	strh	w3, [x0, #114]
    4000a418:	3901d822 	strb	w2, [x1, #118]
	return sh->ctx->cfg.flags.echo == 1;
    4000a41c:	b9429801 	ldr	w1, [x0, #664]
	if (!z_flag_echo_get(shell)) {
    4000a420:	360801e1 	tbz	w1, #1, 4000a45c <z_shell_op_char_insert+0x84>
	return sh->ctx->cfg.flags.obscure == 1;
    4000a424:	b9429800 	ldr	w0, [x0, #664]
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
    4000a428:	f0000041 	adrp	x1, 40015000 <prefix.1+0x2aa>
    4000a42c:	9126b021 	add	x1, x1, #0x9ac
		data = '*';
    4000a430:	f27e001f 	tst	x0, #0x4
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
    4000a434:	52800540 	mov	w0, #0x2a                  	// #42
    4000a438:	1a800042 	csel	w2, w2, w0, eq  // eq = none
    4000a43c:	f9401660 	ldr	x0, [x19, #40]
    4000a440:	97fffd3c 	bl	40009930 <z_shell_raw_fprintf>
	if (z_shell_cursor_in_empty_line(shell)) {
    4000a444:	aa1303e0 	mov	x0, x19
    4000a448:	97fffd98 	bl	40009aa8 <z_shell_cursor_in_empty_line>
    4000a44c:	72001c1f 	tst	w0, #0xff
    4000a450:	54000060 	b.eq	4000a45c <z_shell_op_char_insert+0x84>  // b.none
		z_cursor_next_line_move(shell);
    4000a454:	f9401660 	ldr	x0, [x19, #40]
    4000a458:	97fffd5b 	bl	400099c4 <z_cursor_next_line_move.isra.0>
}
    4000a45c:	f9400bf3 	ldr	x19, [sp, #16]
    4000a460:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000a464:	d65f03c0 	ret
		data_insert(shell, &data, 1);
    4000a468:	9100bfe1 	add	x1, sp, #0x2f
    4000a46c:	aa1303e0 	mov	x0, x19
    4000a470:	52800022 	mov	w2, #0x1                   	// #1
    4000a474:	97ffffa4 	bl	4000a304 <data_insert>
}
    4000a478:	17fffff9 	b	4000a45c <z_shell_op_char_insert+0x84>

000000004000a47c <z_shell_op_completion_insert>:
	data_insert(shell, compl, compl_len);
    4000a47c:	17ffffa2 	b	4000a304 <data_insert>

000000004000a480 <z_shell_op_char_delete>:
{
    4000a480:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a484:	910003fd 	mov	x29, sp
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    4000a488:	f9400801 	ldr	x1, [x0, #16]
{
    4000a48c:	a90153f3 	stp	x19, x20, [sp, #16]
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    4000a490:	7940e422 	ldrh	w2, [x1, #114]
    4000a494:	7940e033 	ldrh	w19, [x1, #112]
    4000a498:	4b020273 	sub	w19, w19, w2
	if (diff == 0U) {
    4000a49c:	72003e73 	ands	w19, w19, #0xffff
    4000a4a0:	54000240 	b.eq	4000a4e8 <z_shell_op_char_delete+0x68>  // b.none
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    4000a4a4:	92403c42 	and	x2, x2, #0xffff
    4000a4a8:	aa0003f4 	mov	x20, x0
    4000a4ac:	9101d842 	add	x2, x2, #0x76
    4000a4b0:	8b020020 	add	x0, x1, x2
	memmove(str, str + 1, diff);
    4000a4b4:	92403e62 	and	x2, x19, #0xffff
    4000a4b8:	91000401 	add	x1, x0, #0x1
    4000a4bc:	94000b87 	bl	4000d2d8 <memmove>
	--shell->ctx->cmd_buff_len;
    4000a4c0:	f9400a81 	ldr	x1, [x20, #16]
	reprint_from_cursor(shell, --diff, true);
    4000a4c4:	52800022 	mov	w2, #0x1                   	// #1
	--shell->ctx->cmd_buff_len;
    4000a4c8:	7940e020 	ldrh	w0, [x1, #112]
    4000a4cc:	51000400 	sub	w0, w0, #0x1
    4000a4d0:	7900e020 	strh	w0, [x1, #112]
	reprint_from_cursor(shell, --diff, true);
    4000a4d4:	51000661 	sub	w1, w19, #0x1
    4000a4d8:	aa1403e0 	mov	x0, x20
}
    4000a4dc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a4e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	reprint_from_cursor(shell, --diff, true);
    4000a4e4:	17ffff53 	b	4000a230 <reprint_from_cursor>
}
    4000a4e8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a4ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a4f0:	d65f03c0 	ret

000000004000a4f4 <z_shell_op_char_backspace>:
	if ((shell->ctx->cmd_buff_len == 0) ||
    4000a4f4:	f9400801 	ldr	x1, [x0, #16]
    4000a4f8:	7940e022 	ldrh	w2, [x1, #112]
    4000a4fc:	340001a2 	cbz	w2, 4000a530 <z_shell_op_char_backspace+0x3c>
    4000a500:	7940e421 	ldrh	w1, [x1, #114]
    4000a504:	34000161 	cbz	w1, 4000a530 <z_shell_op_char_backspace+0x3c>
{
    4000a508:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	z_shell_op_cursor_move(shell, -1);
    4000a50c:	12800001 	mov	w1, #0xffffffff            	// #-1
{
    4000a510:	910003fd 	mov	x29, sp
    4000a514:	f9000bf3 	str	x19, [sp, #16]
    4000a518:	aa0003f3 	mov	x19, x0
	z_shell_op_cursor_move(shell, -1);
    4000a51c:	97fffdb0 	bl	40009bdc <z_shell_op_cursor_move>
	z_shell_op_char_delete(shell);
    4000a520:	aa1303e0 	mov	x0, x19
}
    4000a524:	f9400bf3 	ldr	x19, [sp, #16]
    4000a528:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_shell_op_char_delete(shell);
    4000a52c:	17ffffd5 	b	4000a480 <z_shell_op_char_delete>
    4000a530:	d65f03c0 	ret

000000004000a534 <z_shell_print_prompt_and_cmd>:
{
    4000a534:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    4000a538:	f0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000a53c:	910dbc42 	add	x2, x2, #0x36f
{
    4000a540:	910003fd 	mov	x29, sp
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    4000a544:	f9400801 	ldr	x1, [x0, #16]
    4000a548:	f9400023 	ldr	x3, [x1]
{
    4000a54c:	f9000bf3 	str	x19, [sp, #16]
    4000a550:	aa0003f3 	mov	x19, x0
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    4000a554:	52800041 	mov	w1, #0x2                   	// #2
    4000a558:	97fffec9 	bl	4000a07c <z_shell_fprintf>
	return sh->ctx->cfg.flags.echo == 1;
    4000a55c:	f9400a60 	ldr	x0, [x19, #16]
    4000a560:	b9429800 	ldr	w0, [x0, #664]
	if (z_flag_echo_get(shell)) {
    4000a564:	360800e0 	tbz	w0, #1, 4000a580 <z_shell_print_prompt_and_cmd+0x4c>
		z_shell_print_cmd(shell);
    4000a568:	aa1303e0 	mov	x0, x19
    4000a56c:	97fffe2a 	bl	40009e14 <z_shell_print_cmd>
		z_shell_op_cursor_position_synchronize(shell);
    4000a570:	aa1303e0 	mov	x0, x19
}
    4000a574:	f9400bf3 	ldr	x19, [sp, #16]
    4000a578:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_shell_op_cursor_position_synchronize(shell);
    4000a57c:	17fffd73 	b	40009b48 <z_shell_op_cursor_position_synchronize>
}
    4000a580:	f9400bf3 	ldr	x19, [sp, #16]
    4000a584:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a588:	d65f03c0 	ret

000000004000a58c <msg_from_fifo.isra.0>:
{
	z_shell_print_stream(ctx, data, length);
	return length;
}

static struct log_msg *msg_from_fifo(const struct shell_log_backend *backend)
    4000a58c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a590:	910003fd 	mov	x29, sp
	return z_impl_k_msgq_get(msgq, data, timeout);
    4000a594:	d2800002 	mov	x2, #0x0                   	// #0
    4000a598:	910043e1 	add	x1, sp, #0x10
    4000a59c:	94001262 	bl	4000ef24 <z_impl_k_msgq_get>
	struct shell_log_backend_msg msg;
	int err;

	err = k_msgq_get(backend->msgq, &msg, K_NO_WAIT);

	return (err == 0) ? msg.msg : NULL;
    4000a5a0:	7100001f 	cmp	w0, #0x0
}
    4000a5a4:	f9400be0 	ldr	x0, [sp, #16]
    4000a5a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a5ac:	9a9f0000 	csel	x0, x0, xzr, eq  // eq = none
    4000a5b0:	d65f03c0 	ret

000000004000a5b4 <put>:

	return true;
}

static void put(const struct log_backend *const backend, struct log_msg *msg)
{
    4000a5b4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4000a5b8:	910003fd 	mov	x29, sp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    4000a5bc:	f9400400 	ldr	x0, [x0, #8]
{
    4000a5c0:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a5c4:	aa0103f4 	mov	x20, x1
    4000a5c8:	a9025bf5 	stp	x21, x22, [sp, #32]
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    4000a5cc:	f9400013 	ldr	x19, [x0]
	return sh->ctx->cfg.flags.use_colors == 1;
    4000a5d0:	f9400a60 	ldr	x0, [x19, #16]
{
    4000a5d4:	f9001bf7 	str	x23, [sp, #48]
    4000a5d8:	b9429815 	ldr	w21, [x0, #664]
	bool colors = IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
			z_flag_use_colors_get(shell);
	struct k_poll_signal *signal;

	log_msg_get(msg);
    4000a5dc:	aa0103e0 	mov	x0, x1
    4000a5e0:	97ffea44 	bl	40004ef0 <log_msg_get>

	switch (shell->log_backend->control_block->state) {
    4000a5e4:	f9401e60 	ldr	x0, [x19, #56]
    4000a5e8:	d34412b5 	ubfx	x21, x21, #4, #1
    4000a5ec:	f9400c00 	ldr	x0, [x0, #24]
    4000a5f0:	b9400800 	ldr	w0, [x0, #8]
    4000a5f4:	7100041f 	cmp	w0, #0x1
    4000a5f8:	54000120 	b.eq	4000a61c <put+0x68>  // b.none
    4000a5fc:	71000c1f 	cmp	w0, #0x3
    4000a600:	540006c0 	b.eq	4000a6d8 <put+0x124>  // b.none

	case SHELL_LOG_BACKEND_DISABLED:
		__fallthrough;
	default:
		/* Discard message. */
		log_msg_put(msg);
    4000a604:	aa1403e0 	mov	x0, x20
	}
}
    4000a608:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a60c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a610:	f9401bf7 	ldr	x23, [sp, #48]
    4000a614:	a8c67bfd 	ldp	x29, x30, [sp], #96
		log_msg_put(msg);
    4000a618:	17ffeab6 	b	400050f0 <log_msg_put>
	struct shell_log_backend_msg t_msg = {
    4000a61c:	f90023f4 	str	x20, [sp, #64]
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
    4000a620:	d2800155 	mov	x21, #0xa                   	// #10
	return z_impl_k_uptime_ticks();
    4000a624:	94001928 	bl	40010ac4 <z_impl_k_uptime_ticks>
    4000a628:	9b157c00 	mul	x0, x0, x21
	return (uint32_t)k_uptime_get();
    4000a62c:	b9004be0 	str	w0, [sp, #72]
		err = k_msgq_put(shell->log_backend->msgq, &t_msg,
    4000a630:	f9401e61 	ldr	x1, [x19, #56]
				 K_MSEC(shell->log_backend->timeout));
    4000a634:	b9402022 	ldr	w2, [x1, #32]
		err = k_msgq_put(shell->log_backend->msgq, &t_msg,
    4000a638:	f9400420 	ldr	x0, [x1, #8]
		t += off;
    4000a63c:	91002442 	add	x2, x2, #0x9
			return t / ((uint64_t)from_hz / to_hz);
    4000a640:	9ad50842 	udiv	x2, x2, x21
	return z_impl_k_msgq_put(msgq, data, timeout);
    4000a644:	910103e1 	add	x1, sp, #0x40
    4000a648:	940011f2 	bl	4000ee10 <z_impl_k_msgq_put>
		switch (err) {
    4000a64c:	31008c1f 	cmn	w0, #0x23
    4000a650:	54000160 	b.eq	4000a67c <put+0xc8>  // b.none
    4000a654:	31002c1f 	cmn	w0, #0xb
    4000a658:	54000120 	b.eq	4000a67c <put+0xc8>  // b.none
			signal = &shell->ctx->signals[SHELL_SIGNAL_LOG_MSG];
    4000a65c:	f9400a60 	ldr	x0, [x19, #16]
    4000a660:	910b0000 	add	x0, x0, #0x2c0
}
    4000a664:	a94153f3 	ldp	x19, x20, [sp, #16]
	return z_impl_k_poll_signal_raise(sig, result);
    4000a668:	52800001 	mov	w1, #0x0                   	// #0
    4000a66c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a670:	f9401bf7 	ldr	x23, [sp, #48]
    4000a674:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000a678:	14001bd1 	b	400115bc <z_impl_k_poll_signal_raise>
	struct k_msgq *msgq = shell->log_backend->msgq;
    4000a67c:	f9401e60 	ldr	x0, [x19, #56]
	uint32_t timeout = shell->log_backend->timeout;
    4000a680:	b9402017 	ldr	w23, [x0, #32]
	struct k_msgq *msgq = shell->log_backend->msgq;
    4000a684:	f9400416 	ldr	x22, [x0, #8]
	return z_impl_k_uptime_ticks();
    4000a688:	9400190f 	bl	40010ac4 <z_impl_k_uptime_ticks>
    4000a68c:	1b157c14 	mul	w20, w0, w21
	return z_impl_k_msgq_peek(msgq, data);
    4000a690:	910143e1 	add	x1, sp, #0x50
    4000a694:	aa1603e0 	mov	x0, x22
    4000a698:	9400126e 	bl	4000f050 <z_impl_k_msgq_peek>
		if (err == 0 && ((now - msg.timestamp) > timeout)) {
    4000a69c:	35fffca0 	cbnz	w0, 4000a630 <put+0x7c>
    4000a6a0:	b9405be0 	ldr	w0, [sp, #88]
    4000a6a4:	4b000280 	sub	w0, w20, w0
    4000a6a8:	6b0002ff 	cmp	w23, w0
    4000a6ac:	54fffc22 	b.cs	4000a630 <put+0x7c>  // b.hs, b.nlast
	return z_impl_k_msgq_get(msgq, data, timeout);
    4000a6b0:	d2800002 	mov	x2, #0x0                   	// #0
    4000a6b4:	910143e1 	add	x1, sp, #0x50
    4000a6b8:	aa1603e0 	mov	x0, x22
    4000a6bc:	9400121a 	bl	4000ef24 <z_impl_k_msgq_get>
			log_msg_put(msg.msg);
    4000a6c0:	f9402be0 	ldr	x0, [sp, #80]
    4000a6c4:	97ffea8b 	bl	400050f0 <log_msg_put>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    4000a6c8:	f9401a61 	ldr	x1, [x19, #48]
    4000a6cc:	d2800020 	mov	x0, #0x1                   	// #1
    4000a6d0:	97ffda3c 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
		err = k_msgq_peek(msgq, &msg);
    4000a6d4:	17ffffef 	b	4000a690 <put+0xdc>
		z_shell_cmd_line_erase(shell);
    4000a6d8:	aa1303e0 	mov	x0, x19
    4000a6dc:	97fffdb6 	bl	40009db4 <z_shell_cmd_line_erase>
		msg_process(shell->log_backend->log_output, msg, colors);
    4000a6e0:	f9401e60 	ldr	x0, [x19, #56]
	log_output_msg_process(log_output, msg, flags);
    4000a6e4:	11003aa2 	add	w2, w21, #0xe
    4000a6e8:	aa1403e1 	mov	x1, x20
    4000a6ec:	f9400800 	ldr	x0, [x0, #16]
    4000a6f0:	97ffecbf 	bl	400059ec <log_output_msg_process>
	log_msg_put(msg);
    4000a6f4:	17ffffc4 	b	4000a604 <put+0x50>

000000004000a6f8 <dropped>:
		z_shell_log_backend_disable(shell->log_backend);
	}
}

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
    4000a6f8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a6fc:	910003fd 	mov	x29, sp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    4000a700:	f9400400 	ldr	x0, [x0, #8]
{
    4000a704:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a708:	2a0103f3 	mov	w19, w1
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    4000a70c:	f9400000 	ldr	x0, [x0]
	const struct shell_log_backend *log_backend = shell->log_backend;
    4000a710:	a9435001 	ldp	x1, x20, [x0, #48]
    4000a714:	aa1303e0 	mov	x0, x19
    4000a718:	97ffda2a 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
    4000a71c:	f9400e81 	ldr	x1, [x20, #24]
    4000a720:	aa1303e0 	mov	x0, x19
    4000a724:	97ffda27 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>

	atomic_add(&shell->stats->log_lost_cnt, cnt);
	atomic_add(&log_backend->control_block->dropped_cnt, cnt);
}
    4000a728:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a72c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a730:	d65f03c0 	ret

000000004000a734 <z_shell_log_backend_output_func>:
{
    4000a734:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a738:	aa0003e3 	mov	x3, x0
    4000a73c:	aa0203e0 	mov	x0, x2
    4000a740:	910003fd 	mov	x29, sp
	z_shell_print_stream(ctx, data, length);
    4000a744:	aa0103e2 	mov	x2, x1
{
    4000a748:	f9000bf3 	str	x19, [sp, #16]
    4000a74c:	aa0103f3 	mov	x19, x1
	z_shell_print_stream(ctx, data, length);
    4000a750:	aa0303e1 	mov	x1, x3
    4000a754:	97fffdeb 	bl	40009f00 <z_shell_print_stream>
}
    4000a758:	2a1303e0 	mov	w0, w19
    4000a75c:	f9400bf3 	ldr	x19, [sp, #16]
    4000a760:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a764:	d65f03c0 	ret

000000004000a768 <z_shell_log_backend_enable>:
{
    4000a768:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000a76c:	910003fd 	mov	x29, sp
    4000a770:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a774:	aa0003f3 	mov	x19, x0
    4000a778:	aa0103f4 	mov	x20, x1
    4000a77c:	f90013f5 	str	x21, [sp, #32]
    4000a780:	2a0203f5 	mov	w21, w2
		while ((msg = msg_from_fifo(backend)) != NULL) {
    4000a784:	f9400660 	ldr	x0, [x19, #8]
    4000a788:	97ffff81 	bl	4000a58c <msg_from_fifo.isra.0>
    4000a78c:	b5000200 	cbnz	x0, 4000a7cc <z_shell_log_backend_enable+0x64>
		log_backend_enable(backend->backend, ctx, init_log_level);
    4000a790:	f9400260 	ldr	x0, [x19]
    4000a794:	2a1503e2 	mov	w2, w21
    4000a798:	aa1403e1 	mov	x1, x20
    4000a79c:	97ffe94f 	bl	40004cd8 <log_backend_enable>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *output,
				      void *ctx)
{
	output->control_block->ctx = ctx;
    4000a7a0:	f9400a60 	ldr	x0, [x19, #16]
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
    4000a7a4:	52800021 	mov	w1, #0x1                   	// #1
}
    4000a7a8:	f94013f5 	ldr	x21, [sp, #32]
    4000a7ac:	f9400400 	ldr	x0, [x0, #8]
    4000a7b0:	f9000414 	str	x20, [x0, #8]
		backend->control_block->dropped_cnt = 0;
    4000a7b4:	f9400e60 	ldr	x0, [x19, #24]
}
    4000a7b8:	a94153f3 	ldp	x19, x20, [sp, #16]
		backend->control_block->dropped_cnt = 0;
    4000a7bc:	f900001f 	str	xzr, [x0]
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
    4000a7c0:	b9000801 	str	w1, [x0, #8]
}
    4000a7c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000a7c8:	d65f03c0 	ret
			log_msg_put(msg);
    4000a7cc:	97ffea49 	bl	400050f0 <log_msg_put>
    4000a7d0:	17ffffed 	b	4000a784 <z_shell_log_backend_enable+0x1c>

000000004000a7d4 <z_shell_log_backend_disable>:
{
    4000a7d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a7d8:	910003fd 	mov	x29, sp
    4000a7dc:	f9000bf3 	str	x19, [sp, #16]
    4000a7e0:	aa0003f3 	mov	x19, x0
	log_backend_disable(backend->backend);
    4000a7e4:	f9400000 	ldr	x0, [x0]
    4000a7e8:	97ffe94f 	bl	40004d24 <log_backend_disable>
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
    4000a7ec:	f9400e60 	ldr	x0, [x19, #24]
    4000a7f0:	52800041 	mov	w1, #0x2                   	// #2
}
    4000a7f4:	f9400bf3 	ldr	x19, [sp, #16]
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
    4000a7f8:	b9000801 	str	w1, [x0, #8]
}
    4000a7fc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a800:	d65f03c0 	ret

000000004000a804 <z_shell_log_backend_process>:
{
    4000a804:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000a808:	910003fd 	mov	x29, sp
    4000a80c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a810:	aa0003f3 	mov	x19, x0
			(const struct shell *)backend->backend->cb->ctx;
    4000a814:	f9400000 	ldr	x0, [x0]
{
    4000a818:	a9025bf5 	stp	x21, x22, [sp, #32]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    4000a81c:	f9400e61 	ldr	x1, [x19, #24]
	const struct shell *shell =
    4000a820:	f9400400 	ldr	x0, [x0, #8]
    4000a824:	f9400015 	ldr	x21, [x0]
    4000a828:	f9400aa0 	ldr	x0, [x21, #16]
    4000a82c:	b9429814 	ldr	w20, [x0, #664]
    4000a830:	d2800000 	mov	x0, #0x0                   	// #0
    4000a834:	d3441294 	ubfx	x20, x20, #4, #1
    4000a838:	97ffd9d6 	bl	40000f90 <__aarch64_swp8_acq_rel>
	if (dropped) {
    4000a83c:	34000240 	cbz	w0, 4000a884 <z_shell_log_backend_process+0x80>
    4000a840:	aa0003f6 	mov	x22, x0
		if (colors) {
    4000a844:	34000134 	cbz	w20, 4000a868 <z_shell_log_backend_process+0x64>
	memcpy(color, &sh->ctx->vt100_ctx.col, sizeof(*color));
    4000a848:	f9400aa1 	ldr	x1, [x21, #16]
    4000a84c:	d2800102 	mov	x2, #0x8                   	// #8
    4000a850:	9100e3e0 	add	x0, sp, #0x38
    4000a854:	91014021 	add	x1, x1, #0x50
    4000a858:	94000aaf 	bl	4000d314 <memcpy>
			z_shell_vt100_color_set(shell, SHELL_VT100_COLOR_RED);
    4000a85c:	aa1503e0 	mov	x0, x21
    4000a860:	52800021 	mov	w1, #0x1                   	// #1
    4000a864:	97fffda8 	bl	40009f04 <z_shell_vt100_color_set>
		log_output_dropped_process(backend->log_output, dropped);
    4000a868:	f9400a60 	ldr	x0, [x19, #16]
    4000a86c:	2a1603e1 	mov	w1, w22
    4000a870:	97ffecc1 	bl	40005b74 <log_output_dropped_process>
		if (colors) {
    4000a874:	34000094 	cbz	w20, 4000a884 <z_shell_log_backend_process+0x80>
			z_shell_vt100_colors_restore(shell, &col);
    4000a878:	9100e3e1 	add	x1, sp, #0x38
    4000a87c:	aa1503e0 	mov	x0, x21
    4000a880:	97fffdb8 	bl	40009f60 <z_shell_vt100_colors_restore>
	struct log_msg *msg = msg_from_fifo(backend);
    4000a884:	f9400660 	ldr	x0, [x19, #8]
    4000a888:	97ffff41 	bl	4000a58c <msg_from_fifo.isra.0>
    4000a88c:	aa0003f3 	mov	x19, x0
	if (!msg) {
    4000a890:	b40001a0 	cbz	x0, 4000a8c4 <z_shell_log_backend_process+0xc0>
	log_output_msg_process(log_output, msg, flags);
    4000a894:	aa0003e1 	mov	x1, x0
    4000a898:	11003a82 	add	w2, w20, #0xe
	msg_process(shell->log_backend->log_output, msg, colors);
    4000a89c:	f9401ea0 	ldr	x0, [x21, #56]
	log_output_msg_process(log_output, msg, flags);
    4000a8a0:	f9400800 	ldr	x0, [x0, #16]
    4000a8a4:	97ffec52 	bl	400059ec <log_output_msg_process>
	log_msg_put(msg);
    4000a8a8:	aa1303e0 	mov	x0, x19
    4000a8ac:	97ffea11 	bl	400050f0 <log_msg_put>
	return true;
    4000a8b0:	52800020 	mov	w0, #0x1                   	// #1
}
    4000a8b4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a8b8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a8bc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000a8c0:	d65f03c0 	ret
		return false;
    4000a8c4:	52800000 	mov	w0, #0x0                   	// #0
    4000a8c8:	17fffffb 	b	4000a8b4 <z_shell_log_backend_process+0xb0>

000000004000a8cc <panic>:
{
    4000a8cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a8d0:	910003fd 	mov	x29, sp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    4000a8d4:	f9400400 	ldr	x0, [x0, #8]
{
    4000a8d8:	f9000bf3 	str	x19, [sp, #16]
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    4000a8dc:	f9400013 	ldr	x19, [x0]
	err = shell->iface->api->enable(shell->iface, true);
    4000a8e0:	f9400660 	ldr	x0, [x19, #8]
    4000a8e4:	f9400001 	ldr	x1, [x0]
    4000a8e8:	f9400822 	ldr	x2, [x1, #16]
    4000a8ec:	52800021 	mov	w1, #0x1                   	// #1
    4000a8f0:	d63f0040 	blr	x2
	if (err == 0) {
    4000a8f4:	350003a0 	cbnz	w0, 4000a968 <panic+0x9c>
		shell->log_backend->control_block->state =
    4000a8f8:	f9401e60 	ldr	x0, [x19, #56]
    4000a8fc:	52800061 	mov	w1, #0x3                   	// #3
    4000a900:	f9400c00 	ldr	x0, [x0, #24]
    4000a904:	b9000801 	str	w1, [x0, #8]
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4000a908:	d2840000 	mov	x0, #0x2000                	// #8192
    4000a90c:	f9400a61 	ldr	x1, [x19, #16]
    4000a910:	910a8021 	add	x1, x1, #0x2a0
    4000a914:	97ffd9c3 	bl	40001020 <__aarch64_ldset8_acq_rel>
		z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
    4000a918:	f9400a60 	ldr	x0, [x19, #16]
    4000a91c:	91010000 	add	x0, x0, #0x40
    4000a920:	79406002 	ldrh	w2, [x0, #48]
    4000a924:	79406401 	ldrh	w1, [x0, #50]
    4000a928:	97fffa50 	bl	40009268 <z_shell_multiline_data_calc>
		z_shell_op_cursor_vert_move(shell, -1);
    4000a92c:	aa1303e0 	mov	x0, x19
    4000a930:	12800001 	mov	w1, #0xffffffff            	// #-1
    4000a934:	97fffc3d 	bl	40009a28 <z_shell_op_cursor_vert_move>
					   -shell->ctx->vt100_ctx.cons.cur_x);
    4000a938:	f9400a60 	ldr	x0, [x19, #16]
    4000a93c:	79408001 	ldrh	w1, [x0, #64]
		z_shell_op_cursor_horiz_move(shell,
    4000a940:	aa1303e0 	mov	x0, x19
    4000a944:	4b0103e1 	neg	w1, w1
    4000a948:	97fffc48 	bl	40009a68 <z_shell_op_cursor_horiz_move>
			while (z_shell_log_backend_process(
    4000a94c:	f9401e60 	ldr	x0, [x19, #56]
    4000a950:	97ffffad 	bl	4000a804 <z_shell_log_backend_process>
    4000a954:	72001c1f 	tst	w0, #0xff
    4000a958:	54ffffa1 	b.ne	4000a94c <panic+0x80>  // b.any
}
    4000a95c:	f9400bf3 	ldr	x19, [sp, #16]
    4000a960:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a964:	d65f03c0 	ret
		z_shell_log_backend_disable(shell->log_backend);
    4000a968:	f9401e60 	ldr	x0, [x19, #56]
}
    4000a96c:	f9400bf3 	ldr	x19, [sp, #16]
    4000a970:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_shell_log_backend_disable(shell->log_backend);
    4000a974:	17ffff98 	b	4000a7d4 <z_shell_log_backend_disable>

000000004000a978 <z_shell_raw_fprintf>:
{
    4000a978:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    4000a97c:	910003fd 	mov	x29, sp
    4000a980:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    4000a984:	910403e2 	add	x2, sp, #0x100
    4000a988:	a9030be2 	stp	x2, x2, [sp, #48]
    4000a98c:	910343e2 	add	x2, sp, #0xd0
    4000a990:	f90023e2 	str	x2, [sp, #64]
    4000a994:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    4000a998:	b9004be2 	str	w2, [sp, #72]
    4000a99c:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    4000a9a0:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    4000a9a4:	a9430fe2 	ldp	x2, x3, [sp, #48]
    4000a9a8:	a9010fe2 	stp	x2, x3, [sp, #16]
    4000a9ac:	a9440fe2 	ldp	x2, x3, [sp, #64]
    4000a9b0:	a9020fe2 	stp	x2, x3, [sp, #32]
    4000a9b4:	910043e2 	add	x2, sp, #0x10
{
    4000a9b8:	3d8017e0 	str	q0, [sp, #80]
    4000a9bc:	3d801be1 	str	q1, [sp, #96]
    4000a9c0:	3d801fe2 	str	q2, [sp, #112]
    4000a9c4:	3d8023e3 	str	q3, [sp, #128]
    4000a9c8:	3d8027e4 	str	q4, [sp, #144]
    4000a9cc:	3d802be5 	str	q5, [sp, #160]
    4000a9d0:	3d802fe6 	str	q6, [sp, #176]
    4000a9d4:	3d8033e7 	str	q7, [sp, #192]
    4000a9d8:	a90e17e4 	stp	x4, x5, [sp, #224]
    4000a9dc:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    4000a9e0:	97fff9d1 	bl	40009124 <z_shell_fprintf_fmt>
}
    4000a9e4:	a8d07bfd 	ldp	x29, x30, [sp], #256
    4000a9e8:	d65f03c0 	ret

000000004000a9ec <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
    4000a9ec:	f0000041 	adrp	x1, 40015000 <prefix.1+0x2aa>
    4000a9f0:	91096021 	add	x1, x1, #0x258
    4000a9f4:	17ffffe1 	b	4000a978 <z_shell_raw_fprintf>

000000004000a9f8 <formatted_text_print.constprop.0>:
				 size_t terminal_offset, bool offset_first_line)
{
	size_t offset = 0;
	size_t length;

	if (str == NULL) {
    4000a9f8:	b4000b81 	cbz	x1, 4000ab68 <formatted_text_print.constprop.0+0x170>
static void formatted_text_print(const struct shell *shell, const char *str,
    4000a9fc:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000aa00:	910003fd 	mov	x29, sp
    4000aa04:	a90153f3 	stp	x19, x20, [sp, #16]
    4000aa08:	aa0003f3 	mov	x19, x0
    4000aa0c:	d2800014 	mov	x20, #0x0                   	// #0
    4000aa10:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000aa14:	aa0103f5 	mov	x21, x1
    4000aa18:	a90363f7 	stp	x23, x24, [sp, #48]
    4000aa1c:	aa0203f7 	mov	x23, x2
    4000aa20:	f90023f9 	str	x25, [sp, #64]
		z_shell_op_cursor_horiz_move(shell, terminal_offset);
	}


	/* Skipping whitespace. */
	while (isspace((int) *(str + offset))) {
    4000aa24:	38746aa0 	ldrb	w0, [x21, x20]
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    4000aa28:	51002401 	sub	w1, w0, #0x9
    4000aa2c:	7100801f 	cmp	w0, #0x20
    4000aa30:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    4000aa34:	54000329 	b.ls	4000aa98 <formatted_text_print.constprop.0+0xa0>  // b.plast
    4000aa38:	aa1503e0 	mov	x0, x21
    4000aa3c:	940009f3 	bl	4000d208 <strlen>
		size_t idx = 0;

		length = z_shell_strlen(str) - offset;

		if (length <=
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
    4000aa40:	f9400a61 	ldr	x1, [x19, #16]
		length = z_shell_strlen(str) - offset;
    4000aa44:	92403c00 	and	x0, x0, #0xffff
    4000aa48:	cb140000 	sub	x0, x0, x20
		if (length <=
    4000aa4c:	8b1402b8 	add	x24, x21, x20
			for (idx = 0; idx < length; idx++) {
    4000aa50:	d2800016 	mov	x22, #0x0                   	// #0
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
    4000aa54:	79409422 	ldrh	w2, [x1, #74]
    4000aa58:	cb170041 	sub	x1, x2, x23
		if (length <=
    4000aa5c:	eb01001f 	cmp	x0, x1
    4000aa60:	54000229 	b.ls	4000aaa4 <formatted_text_print.constprop.0+0xac>  // b.plast
		length = shell->ctx->vt100_ctx.cons.terminal_wid
				- terminal_offset;

		while (true) {
			/* Determining line break. */
			if (isspace((int) (*(str + offset + idx)))) {
    4000aa64:	38766b00 	ldrb	w0, [x24, x22]
    4000aa68:	51002403 	sub	w3, w0, #0x9
    4000aa6c:	7100801f 	cmp	w0, #0x20
    4000aa70:	7a441860 	ccmp	w3, #0x4, #0x0, ne  // ne = any
    4000aa74:	54000088 	b.hi	4000aa84 <formatted_text_print.constprop.0+0x8c>  // b.pmore
				length = idx;
				if (*(str + offset + idx) == '\n') {
    4000aa78:	7100281f 	cmp	w0, #0xa
    4000aa7c:	540004e0 	b.eq	4000ab18 <formatted_text_print.constprop.0+0x120>  // b.none
    4000aa80:	aa1603e1 	mov	x1, x22
					break;
				}
			}

			if ((idx + terminal_offset) >=
    4000aa84:	8b1602e0 	add	x0, x23, x22
    4000aa88:	eb00005f 	cmp	x2, x0
    4000aa8c:	54000449 	b.ls	4000ab14 <formatted_text_print.constprop.0+0x11c>  // b.plast
			    shell->ctx->vt100_ctx.cons.terminal_wid) {
				/* End of line reached. */
				break;
			}

			++idx;
    4000aa90:	910006d6 	add	x22, x22, #0x1
			if (isspace((int) (*(str + offset + idx)))) {
    4000aa94:	17fffff4 	b	4000aa64 <formatted_text_print.constprop.0+0x6c>
		++offset;
    4000aa98:	91000694 	add	x20, x20, #0x1
    4000aa9c:	17ffffe2 	b	4000aa24 <formatted_text_print.constprop.0+0x2c>
			for (idx = 0; idx < length; idx++) {
    4000aaa0:	910006d6 	add	x22, x22, #0x1
    4000aaa4:	eb16001f 	cmp	x0, x22
    4000aaa8:	54000220 	b.eq	4000aaec <formatted_text_print.constprop.0+0xf4>  // b.none
				if (*(str + offset + idx) == '\n') {
    4000aaac:	38766b01 	ldrb	w1, [x24, x22]
    4000aab0:	8b160299 	add	x25, x20, x22
    4000aab4:	7100283f 	cmp	w1, #0xa
    4000aab8:	54ffff41 	b.ne	4000aaa0 <formatted_text_print.constprop.0+0xa8>  // b.any
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
    4000aabc:	f9401660 	ldr	x0, [x19, #40]
					offset += idx + 1;
    4000aac0:	91000734 	add	x20, x25, #0x1
    4000aac4:	97fff989 	bl	400090e8 <z_shell_fprintf_buffer_flush>
					z_shell_write(shell, str + offset, idx);
    4000aac8:	aa1803e1 	mov	x1, x24
    4000aacc:	aa1603e2 	mov	x2, x22
    4000aad0:	aa1303e0 	mov	x0, x19
    4000aad4:	97fffcd6 	bl	40009e2c <z_shell_write>
					z_cursor_next_line_move(shell);
    4000aad8:	f9401660 	ldr	x0, [x19, #40]
    4000aadc:	97ffffc4 	bl	4000a9ec <z_cursor_next_line_move.isra.0>
					z_shell_op_cursor_horiz_move(shell,
    4000aae0:	2a1703e1 	mov	w1, w23
    4000aae4:	aa1303e0 	mov	x0, x19
    4000aae8:	97fffbe0 	bl	40009a68 <z_shell_op_cursor_horiz_move>
			z_shell_raw_fprintf(shell->fprintf_ctx, str + offset);
    4000aaec:	f9401660 	ldr	x0, [x19, #40]
    4000aaf0:	8b1402a1 	add	x1, x21, x20
    4000aaf4:	97ffffa1 	bl	4000a978 <z_shell_raw_fprintf>
		z_cursor_next_line_move(shell);
		z_shell_op_cursor_horiz_move(shell, terminal_offset);

	}
	z_cursor_next_line_move(shell);
}
    4000aaf8:	a9425bf5 	ldp	x21, x22, [sp, #32]
	z_cursor_next_line_move(shell);
    4000aafc:	f9401660 	ldr	x0, [x19, #40]
}
    4000ab00:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ab04:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000ab08:	f94023f9 	ldr	x25, [sp, #64]
    4000ab0c:	a8c57bfd 	ldp	x29, x30, [sp], #80
	z_cursor_next_line_move(shell);
    4000ab10:	17ffffb7 	b	4000a9ec <z_cursor_next_line_move.isra.0>
    4000ab14:	aa0103f6 	mov	x22, x1
    4000ab18:	f9401660 	ldr	x0, [x19, #40]
		offset += length;
    4000ab1c:	8b160294 	add	x20, x20, x22
    4000ab20:	97fff972 	bl	400090e8 <z_shell_fprintf_buffer_flush>
		z_shell_write(shell, str + offset, length);
    4000ab24:	aa1603e2 	mov	x2, x22
    4000ab28:	aa1803e1 	mov	x1, x24
    4000ab2c:	aa1303e0 	mov	x0, x19
    4000ab30:	97fffcbf 	bl	40009e2c <z_shell_write>
		while (isspace((int) (*(str + offset)))) {
    4000ab34:	38746aa0 	ldrb	w0, [x21, x20]
    4000ab38:	51002401 	sub	w1, w0, #0x9
    4000ab3c:	7100801f 	cmp	w0, #0x20
    4000ab40:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    4000ab44:	540000e9 	b.ls	4000ab60 <formatted_text_print.constprop.0+0x168>  // b.plast
		z_cursor_next_line_move(shell);
    4000ab48:	f9401660 	ldr	x0, [x19, #40]
    4000ab4c:	97ffffa8 	bl	4000a9ec <z_cursor_next_line_move.isra.0>
		z_shell_op_cursor_horiz_move(shell, terminal_offset);
    4000ab50:	2a1703e1 	mov	w1, w23
    4000ab54:	aa1303e0 	mov	x0, x19
    4000ab58:	97fffbc4 	bl	40009a68 <z_shell_op_cursor_horiz_move>
	while (true) {
    4000ab5c:	17ffffb7 	b	4000aa38 <formatted_text_print.constprop.0+0x40>
			++offset;
    4000ab60:	91000694 	add	x20, x20, #0x1
    4000ab64:	17fffff4 	b	4000ab34 <formatted_text_print.constprop.0+0x13c>
    4000ab68:	d65f03c0 	ret

000000004000ab6c <z_shell_help_subcmd_print>:
 * help string
 */
void z_shell_help_subcmd_print(const struct shell *shell,
			       const struct shell_static_entry *parent,
			       const char *description)
{
    4000ab6c:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    4000ab70:	910003fd 	mov	x29, sp
    4000ab74:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ab78:	aa0003f4 	mov	x20, x0
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry dloc;
	uint16_t longest = 0U;
    4000ab7c:	52800013 	mov	w19, #0x0                   	// #0
{
    4000ab80:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000ab84:	aa0203f5 	mov	x21, x2
    4000ab88:	a90363f7 	stp	x23, x24, [sp, #48]
    4000ab8c:	aa0103f7 	mov	x23, x1
	size_t idx = 0;
    4000ab90:	d2800001 	mov	x1, #0x0                   	// #0
{
    4000ab94:	a9046bf9 	stp	x25, x26, [sp, #64]
    4000ab98:	f9002bfb 	str	x27, [sp, #80]

	/* Searching for the longest subcommand to print. */
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    4000ab9c:	91000436 	add	x22, x1, #0x1
    4000aba0:	9101a3e2 	add	x2, sp, #0x68
    4000aba4:	aa1703e0 	mov	x0, x23
    4000aba8:	97fffa8d 	bl	400095dc <z_shell_cmd_get>
    4000abac:	b5000300 	cbnz	x0, 4000ac0c <z_shell_help_subcmd_print+0xa0>
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
	}

	/* No help to print */
	if (longest == 0) {
    4000abb0:	34000213 	cbz	w19, 4000abf0 <z_shell_help_subcmd_print+0x84>
		return;
	}

	if (description != NULL) {
    4000abb4:	b40000b5 	cbz	x21, 4000abc8 <z_shell_help_subcmd_print+0x5c>
		z_shell_fprintf(shell, SHELL_NORMAL, description);
    4000abb8:	aa1503e2 	mov	x2, x21
    4000abbc:	aa1403e0 	mov	x0, x20
    4000abc0:	52800101 	mov	w1, #0x8                   	// #8
    4000abc4:	97fffd2e 	bl	4000a07c <z_shell_fprintf>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    4000abc8:	f0000055 	adrp	x21, 40015000 <prefix.1+0x2aa>
    4000abcc:	912766b5 	add	x21, x21, #0x9d9
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
    4000abd0:	f0000058 	adrp	x24, 40015000 <prefix.1+0x2aa>
    4000abd4:	91270718 	add	x24, x24, #0x9c1
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    4000abd8:	d2800001 	mov	x1, #0x0                   	// #0
	}

	/* Printing subcommands and help string (if exists). */
	idx = 0;

	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    4000abdc:	91000439 	add	x25, x1, #0x1
    4000abe0:	9101a3e2 	add	x2, sp, #0x68
    4000abe4:	aa1703e0 	mov	x0, x23
    4000abe8:	97fffa7d 	bl	400095dc <z_shell_cmd_get>
    4000abec:	b5000260 	cbnz	x0, 4000ac38 <z_shell_help_subcmd_print+0xcc>
		help_item_print(shell, entry->syntax, longest, entry->help);
	}
}
    4000abf0:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000abf4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000abf8:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000abfc:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000ac00:	f9402bfb 	ldr	x27, [sp, #80]
    4000ac04:	a8c97bfd 	ldp	x29, x30, [sp], #144
    4000ac08:	d65f03c0 	ret
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
    4000ac0c:	f9400000 	ldr	x0, [x0]
	return str == NULL ? 0U : (uint16_t)strlen(str);
    4000ac10:	b4000100 	cbz	x0, 4000ac30 <z_shell_help_subcmd_print+0xc4>
    4000ac14:	9400097d 	bl	4000d208 <strlen>
    4000ac18:	12003c03 	and	w3, w0, #0xffff
    4000ac1c:	6b13007f 	cmp	w3, w19
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    4000ac20:	aa1603e1 	mov	x1, x22
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
    4000ac24:	1a938063 	csel	w3, w3, w19, hi  // hi = pmore
    4000ac28:	12003c73 	and	w19, w3, #0xffff
    4000ac2c:	17ffffdc 	b	4000ab9c <z_shell_help_subcmd_print+0x30>
    4000ac30:	52800003 	mov	w3, #0x0                   	// #0
    4000ac34:	17fffffa 	b	4000ac1c <z_shell_help_subcmd_print+0xb0>
		help_item_print(shell, entry->syntax, longest, entry->help);
    4000ac38:	a940681b 	ldp	x27, x26, [x0]
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    4000ac3c:	aa1503e0 	mov	x0, x21
    4000ac40:	94000972 	bl	4000d208 <strlen>
    4000ac44:	aa0003f6 	mov	x22, x0
	if ((item_name == NULL) || (item_name[0] == '\0')) {
    4000ac48:	b40001db 	cbz	x27, 4000ac80 <z_shell_help_subcmd_print+0x114>
    4000ac4c:	39400360 	ldrb	w0, [x27]
    4000ac50:	34000180 	cbz	w0, 4000ac80 <z_shell_help_subcmd_print+0x114>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
    4000ac54:	aa1503e6 	mov	x6, x21
    4000ac58:	aa1b03e5 	mov	x5, x27
    4000ac5c:	2a1303e4 	mov	w4, w19
    4000ac60:	aa1503e3 	mov	x3, x21
    4000ac64:	aa1803e2 	mov	x2, x24
    4000ac68:	aa1403e0 	mov	x0, x20
    4000ac6c:	52800101 	mov	w1, #0x8                   	// #8
    4000ac70:	97fffd03 	bl	4000a07c <z_shell_fprintf>
	if (item_help == NULL) {
    4000ac74:	b50000ba 	cbnz	x26, 4000ac88 <z_shell_help_subcmd_print+0x11c>
		z_cursor_next_line_move(shell);
    4000ac78:	f9401680 	ldr	x0, [x20, #40]
    4000ac7c:	97ffff5c 	bl	4000a9ec <z_cursor_next_line_move.isra.0>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    4000ac80:	aa1903e1 	mov	x1, x25
    4000ac84:	17ffffd6 	b	4000abdc <z_shell_help_subcmd_print+0x70>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    4000ac88:	11000662 	add	w2, w19, #0x1
	formatted_text_print(shell, item_help, offset, false);
    4000ac8c:	aa1a03e1 	mov	x1, x26
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    4000ac90:	0b160442 	add	w2, w2, w22, lsl #1
	formatted_text_print(shell, item_help, offset, false);
    4000ac94:	aa1403e0 	mov	x0, x20
    4000ac98:	92403c42 	and	x2, x2, #0xffff
    4000ac9c:	97ffff57 	bl	4000a9f8 <formatted_text_print.constprop.0>
    4000aca0:	17fffff8 	b	4000ac80 <z_shell_help_subcmd_print+0x114>

000000004000aca4 <z_shell_help_cmd_print>:

void z_shell_help_cmd_print(const struct shell *shell,
			    const struct shell_static_entry *cmd)
{
    4000aca4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000aca8:	910003fd 	mov	x29, sp
    4000acac:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000acb0:	aa0003f5 	mov	x21, x0
	static const char cmd_sep[] = " - "; /* commands separator */
	uint16_t field_width;

	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
    4000acb4:	f9400020 	ldr	x0, [x1]
{
    4000acb8:	a90153f3 	stp	x19, x20, [sp, #16]
    4000acbc:	aa0103f4 	mov	x20, x1
    4000acc0:	b40002e0 	cbz	x0, 4000ad1c <z_shell_help_cmd_print+0x78>
    4000acc4:	94000951 	bl	4000d208 <strlen>
    4000acc8:	12003c13 	and	w19, w0, #0xffff
    4000accc:	f0000056 	adrp	x22, 40015000 <prefix.1+0x2aa>
    4000acd0:	912756d6 	add	x22, x22, #0x9d5
    4000acd4:	aa1603e0 	mov	x0, x22
    4000acd8:	9400094c 	bl	4000d208 <strlen>

	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
    4000acdc:	f9400283 	ldr	x3, [x20]
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
    4000ace0:	0b000273 	add	w19, w19, w0
	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
    4000ace4:	aa1603e4 	mov	x4, x22
    4000ace8:	aa1503e0 	mov	x0, x21
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
    4000acec:	12003e73 	and	w19, w19, #0xffff
	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
    4000acf0:	52800101 	mov	w1, #0x8                   	// #8
    4000acf4:	f0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000acf8:	911f2042 	add	x2, x2, #0x7c8
    4000acfc:	97fffce0 	bl	4000a07c <z_shell_fprintf>

	formatted_text_print(shell, cmd->help, field_width, false);
    4000ad00:	92403e62 	and	x2, x19, #0xffff
    4000ad04:	aa1503e0 	mov	x0, x21
    4000ad08:	f9400681 	ldr	x1, [x20, #8]
}
    4000ad0c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ad10:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000ad14:	a8c37bfd 	ldp	x29, x30, [sp], #48
	formatted_text_print(shell, cmd->help, field_width, false);
    4000ad18:	17ffff38 	b	4000a9f8 <formatted_text_print.constprop.0>
    4000ad1c:	52800013 	mov	w19, #0x0                   	// #0
    4000ad20:	17ffffeb 	b	4000accc <z_shell_help_cmd_print+0x28>

000000004000ad24 <z_shell_help_request>:

bool z_shell_help_request(const char *str)
{
    4000ad24:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!IS_ENABLED(CONFIG_SHELL_HELP_OPT_PARSE)) {
		return false;
	}

	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
    4000ad28:	f0000041 	adrp	x1, 40015000 <prefix.1+0x2aa>
    4000ad2c:	91272c21 	add	x1, x1, #0x9cb
{
    4000ad30:	910003fd 	mov	x29, sp
    4000ad34:	f9000bf3 	str	x19, [sp, #16]
    4000ad38:	aa0003f3 	mov	x19, x0
	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
    4000ad3c:	94000943 	bl	4000d248 <strcmp>
    4000ad40:	34000140 	cbz	w0, 4000ad68 <z_shell_help_request+0x44>
    4000ad44:	aa1303e0 	mov	x0, x19
    4000ad48:	f0000041 	adrp	x1, 40015000 <prefix.1+0x2aa>
    4000ad4c:	91273821 	add	x1, x1, #0x9ce
    4000ad50:	9400093e 	bl	4000d248 <strcmp>
    4000ad54:	7100001f 	cmp	w0, #0x0
    4000ad58:	1a9f17e0 	cset	w0, eq  // eq = none
		return true;
	}

	return false;
}
    4000ad5c:	f9400bf3 	ldr	x19, [sp, #16]
    4000ad60:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000ad64:	d65f03c0 	ret
		return true;
    4000ad68:	52800020 	mov	w0, #0x1                   	// #1
    4000ad6c:	17fffffc 	b	4000ad5c <z_shell_help_request+0x38>

000000004000ad70 <cmd_shell_stats_reset>:
				 size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell->stats->log_lost_cnt = 0;
    4000ad70:	f9401800 	ldr	x0, [x0, #48]
    4000ad74:	f900001f 	str	xzr, [x0]

	return 0;
}
    4000ad78:	52800000 	mov	w0, #0x0                   	// #0
    4000ad7c:	d65f03c0 	ret

000000004000ad80 <z_shell_raw_fprintf>:
{
    4000ad80:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    4000ad84:	910003fd 	mov	x29, sp
    4000ad88:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    4000ad8c:	910403e2 	add	x2, sp, #0x100
    4000ad90:	a9030be2 	stp	x2, x2, [sp, #48]
    4000ad94:	910343e2 	add	x2, sp, #0xd0
    4000ad98:	f90023e2 	str	x2, [sp, #64]
    4000ad9c:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    4000ada0:	b9004be2 	str	w2, [sp, #72]
    4000ada4:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    4000ada8:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    4000adac:	a9430fe2 	ldp	x2, x3, [sp, #48]
    4000adb0:	a9010fe2 	stp	x2, x3, [sp, #16]
    4000adb4:	a9440fe2 	ldp	x2, x3, [sp, #64]
    4000adb8:	a9020fe2 	stp	x2, x3, [sp, #32]
    4000adbc:	910043e2 	add	x2, sp, #0x10
{
    4000adc0:	3d8017e0 	str	q0, [sp, #80]
    4000adc4:	3d801be1 	str	q1, [sp, #96]
    4000adc8:	3d801fe2 	str	q2, [sp, #112]
    4000adcc:	3d8023e3 	str	q3, [sp, #128]
    4000add0:	3d8027e4 	str	q4, [sp, #144]
    4000add4:	3d802be5 	str	q5, [sp, #160]
    4000add8:	3d802fe6 	str	q6, [sp, #176]
    4000addc:	3d8033e7 	str	q7, [sp, #192]
    4000ade0:	a90e17e4 	stp	x4, x5, [sp, #224]
    4000ade4:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    4000ade8:	97fff8cf 	bl	40009124 <z_shell_fprintf_fmt>
}
    4000adec:	a8d07bfd 	ldp	x29, x30, [sp], #256
    4000adf0:	d65f03c0 	ret

000000004000adf4 <cmd_resize_default>:

static int cmd_resize_default(const struct shell *shell,
			      size_t argc, char **argv)
{
    4000adf4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000adf8:	910003fd 	mov	x29, sp
    4000adfc:	f9000bf3 	str	x19, [sp, #16]
    4000ae00:	aa0003f3 	mov	x19, x0
	return sh->ctx->cfg.flags.use_vt100 == 1;
    4000ae04:	f9400800 	ldr	x0, [x0, #16]
    4000ae08:	b9429800 	ldr	w0, [x0, #664]
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
    4000ae0c:	362800a0 	tbz	w0, #5, 4000ae20 <cmd_resize_default+0x2c>
    4000ae10:	f9401660 	ldr	x0, [x19, #40]
    4000ae14:	b0000041 	adrp	x1, 40013000 <shell_cmd_help>
    4000ae18:	91034821 	add	x1, x1, #0xd2
    4000ae1c:	97ffffd9 	bl	4000ad80 <z_shell_raw_fprintf>
	shell->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
    4000ae20:	f9400a60 	ldr	x0, [x19, #16]
    4000ae24:	52800301 	mov	w1, #0x18                  	// #24
    4000ae28:	72a00a01 	movk	w1, #0x50, lsl #16

	return 0;
}
    4000ae2c:	f9400bf3 	ldr	x19, [sp, #16]
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
    4000ae30:	b9004801 	str	w1, [x0, #72]
}
    4000ae34:	52800000 	mov	w0, #0x0                   	// #0
    4000ae38:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000ae3c:	d65f03c0 	ret

000000004000ae40 <cmd_shell_stats_show>:
{
    4000ae40:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_print(shell, "Lost logs: %lu", shell->stats->log_lost_cnt);
    4000ae44:	f0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000ae48:	91277042 	add	x2, x2, #0x9dc
{
    4000ae4c:	910003fd 	mov	x29, sp
	shell_print(shell, "Lost logs: %lu", shell->stats->log_lost_cnt);
    4000ae50:	f9401801 	ldr	x1, [x0, #48]
    4000ae54:	f9400023 	ldr	x3, [x1]
    4000ae58:	52800101 	mov	w1, #0x8                   	// #8
    4000ae5c:	97fff7e2 	bl	40008de4 <shell_fprintf>
}
    4000ae60:	52800000 	mov	w0, #0x0                   	// #0
    4000ae64:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000ae68:	d65f03c0 	ret

000000004000ae6c <cmd_history>:
{
    4000ae6c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000ae70:	910003fd 	mov	x29, sp
    4000ae74:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ae78:	aa0003f3 	mov	x19, x0
    4000ae7c:	52800014 	mov	w20, #0x0                   	// #0
    4000ae80:	f90013f5 	str	x21, [sp, #32]
			shell_print(shell, "[%3d] %s",
    4000ae84:	d0000055 	adrp	x21, 40014000 <shell_m_sub_colors+0x50>
    4000ae88:	9124c6b5 	add	x21, x21, #0x931
		z_shell_history_get(shell->history, true,
    4000ae8c:	a9410262 	ldp	x2, x0, [x19, #16]
    4000ae90:	9100fbe3 	add	x3, sp, #0x3e
    4000ae94:	52800021 	mov	w1, #0x1                   	// #1
    4000ae98:	9105d842 	add	x2, x2, #0x176
    4000ae9c:	94000121 	bl	4000b320 <z_shell_history_get>
		if (len) {
    4000aea0:	79407fe0 	ldrh	w0, [sp, #62]
    4000aea4:	f9400a64 	ldr	x4, [x19, #16]
    4000aea8:	34000120 	cbz	w0, 4000aecc <cmd_history+0x60>
			shell_print(shell, "[%3d] %s",
    4000aeac:	2a1403e3 	mov	w3, w20
    4000aeb0:	9105d884 	add	x4, x4, #0x176
    4000aeb4:	aa1503e2 	mov	x2, x21
    4000aeb8:	aa1303e0 	mov	x0, x19
    4000aebc:	52800101 	mov	w1, #0x8                   	// #8
    4000aec0:	11000694 	add	w20, w20, #0x1
    4000aec4:	97fff7c8 	bl	40008de4 <shell_fprintf>
		z_shell_history_get(shell->history, true,
    4000aec8:	17fffff1 	b	4000ae8c <cmd_history+0x20>
	shell->ctx->temp_buff[0] = '\0';
    4000aecc:	3905d89f 	strb	wzr, [x4, #374]
}
    4000aed0:	52800000 	mov	w0, #0x0                   	// #0
    4000aed4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000aed8:	f94013f5 	ldr	x21, [sp, #32]
    4000aedc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000aee0:	d65f03c0 	ret

000000004000aee4 <cmd_echo>:
{
    4000aee4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	if (argc == 2) {
    4000aee8:	f100083f 	cmp	x1, #0x2
{
    4000aeec:	910003fd 	mov	x29, sp
	if (argc == 2) {
    4000aef0:	54000161 	b.ne	4000af1c <cmd_echo+0x38>  // b.any
		shell_error(shell, "%s:%s%s", argv[0],
    4000aef4:	a9401443 	ldp	x3, x5, [x2]
    4000aef8:	f0000044 	adrp	x4, 40015000 <prefix.1+0x2aa>
    4000aefc:	9127c084 	add	x4, x4, #0x9f0
    4000af00:	52800021 	mov	w1, #0x1                   	// #1
    4000af04:	f0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000af08:	91281442 	add	x2, x2, #0xa05
    4000af0c:	97fff7b6 	bl	40008de4 <shell_fprintf>
    4000af10:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
    4000af14:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000af18:	d65f03c0 	ret
	return sh->ctx->cfg.flags.echo == 1;
    4000af1c:	f9400801 	ldr	x1, [x0, #16]
	shell_print(shell, "Echo status: %s",
    4000af20:	d0000043 	adrp	x3, 40014000 <shell_m_sub_colors+0x50>
    4000af24:	911c0063 	add	x3, x3, #0x700
    4000af28:	b9429822 	ldr	w2, [x1, #664]
    4000af2c:	f0000041 	adrp	x1, 40015000 <prefix.1+0x2aa>
    4000af30:	9127b021 	add	x1, x1, #0x9ec
    4000af34:	f27f005f 	tst	x2, #0x2
    4000af38:	f0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000af3c:	91283842 	add	x2, x2, #0xa0e
    4000af40:	9a811063 	csel	x3, x3, x1, ne  // ne = any
    4000af44:	52800101 	mov	w1, #0x8                   	// #8
    4000af48:	97fff7a7 	bl	40008de4 <shell_fprintf>
	return 0;
    4000af4c:	52800000 	mov	w0, #0x0                   	// #0
    4000af50:	17fffff1 	b	4000af14 <cmd_echo+0x30>

000000004000af54 <cmd_clear>:
{
    4000af54:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000af58:	910003fd 	mov	x29, sp
    4000af5c:	f9000bf3 	str	x19, [sp, #16]
    4000af60:	aa0003f3 	mov	x19, x0
	return sh->ctx->cfg.flags.use_vt100 == 1;
    4000af64:	f9400800 	ldr	x0, [x0, #16]
    4000af68:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
    4000af6c:	362800c0 	tbz	w0, #5, 4000af84 <cmd_clear+0x30>
    4000af70:	f9401660 	ldr	x0, [x19, #40]
    4000af74:	b0000041 	adrp	x1, 40013000 <shell_cmd_help>
    4000af78:	91034821 	add	x1, x1, #0xd2
    4000af7c:	91001c21 	add	x1, x1, #0x7
    4000af80:	97ffff80 	bl	4000ad80 <z_shell_raw_fprintf>
    4000af84:	f9400a60 	ldr	x0, [x19, #16]
    4000af88:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
    4000af8c:	362800c0 	tbz	w0, #5, 4000afa4 <cmd_clear+0x50>
    4000af90:	f9401660 	ldr	x0, [x19, #40]
    4000af94:	b0000041 	adrp	x1, 40013000 <shell_cmd_help>
    4000af98:	91034821 	add	x1, x1, #0xd2
    4000af9c:	91003021 	add	x1, x1, #0xc
    4000afa0:	97ffff78 	bl	4000ad80 <z_shell_raw_fprintf>
}
    4000afa4:	52800000 	mov	w0, #0x0                   	// #0
    4000afa8:	f9400bf3 	ldr	x19, [sp, #16]
    4000afac:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000afb0:	d65f03c0 	ret

000000004000afb4 <cmd_resize>:

static int cmd_resize(const struct shell *shell, size_t argc, char **argv)
{
    4000afb4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	int err;

	if (argc != 1) {
    4000afb8:	f100043f 	cmp	x1, #0x1
{
    4000afbc:	910003fd 	mov	x29, sp
    4000afc0:	a90153f3 	stp	x19, x20, [sp, #16]
    4000afc4:	f90013f5 	str	x21, [sp, #32]
	if (argc != 1) {
    4000afc8:	540001c0 	b.eq	4000b000 <cmd_resize+0x4c>  // b.none
		shell_error(shell, "%s:%s%s", argv[0],
    4000afcc:	a9401443 	ldp	x3, x5, [x2]
    4000afd0:	f0000044 	adrp	x4, 40015000 <prefix.1+0x2aa>
    4000afd4:	9127c084 	add	x4, x4, #0x9f0
    4000afd8:	f0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000afdc:	91281442 	add	x2, x2, #0xa05
    4000afe0:	52800021 	mov	w1, #0x1                   	// #1
			    SHELL_MSG_UNKNOWN_PARAMETER, argv[1]);
		return -EINVAL;
    4000afe4:	128002b4 	mov	w20, #0xffffffea            	// #-22
		shell_error(shell, "%s:%s%s", argv[0],
    4000afe8:	97fff77f 	bl	40008de4 <shell_fprintf>
			   " screen size");
		return -ENOEXEC;
	}

	return 0;
}
    4000afec:	2a1403e0 	mov	w0, w20
    4000aff0:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000aff4:	f94013f5 	ldr	x21, [sp, #32]
    4000aff8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000affc:	d65f03c0 	ret
    4000b000:	aa0003f3 	mov	x19, x0
    4000b004:	f9400800 	ldr	x0, [x0, #16]
    4000b008:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
    4000b00c:	362800c0 	tbz	w0, #5, 4000b024 <cmd_resize+0x70>
    4000b010:	f9401660 	ldr	x0, [x19, #40]
    4000b014:	90000041 	adrp	x1, 40013000 <shell_cmd_help>
    4000b018:	91034821 	add	x1, x1, #0xd2
    4000b01c:	91004821 	add	x1, x1, #0x12
    4000b020:	97ffff58 	bl	4000ad80 <z_shell_raw_fprintf>
	z_shell_op_cursor_vert_move(shell, -SHELL_MAX_TERMINAL_SIZE);
    4000b024:	aa1303e0 	mov	x0, x19
    4000b028:	12801f21 	mov	w1, #0xffffff06            	// #-250
    4000b02c:	97fffa7f 	bl	40009a28 <z_shell_op_cursor_vert_move>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
    4000b030:	52807d15 	mov	w21, #0x3e8                 	// #1000
	z_shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
    4000b034:	aa1303e0 	mov	x0, x19
    4000b038:	52801f41 	mov	w1, #0xfa                  	// #250
    4000b03c:	97fffa8b 	bl	40009a68 <z_shell_op_cursor_horiz_move>
	char c = 0;
    4000b040:	3900dfff 	strb	wzr, [sp, #55]
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    4000b044:	f9400a60 	ldr	x0, [x19, #16]
    4000b048:	d2802002 	mov	x2, #0x100                 	// #256
    4000b04c:	52800001 	mov	w1, #0x0                   	// #0
	uint16_t buff_idx = 0U;
    4000b050:	52800014 	mov	w20, #0x0                   	// #0
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    4000b054:	9105d800 	add	x0, x0, #0x176
    4000b058:	940008b7 	bl	4000d334 <memset>
	z_shell_raw_fprintf(shell->fprintf_ctx, cmd_get_terminal_size);
    4000b05c:	f9401660 	ldr	x0, [x19, #40]
    4000b060:	d0000041 	adrp	x1, 40015000 <prefix.1+0x2aa>
    4000b064:	91383021 	add	x1, x1, #0xe0c
    4000b068:	97ffff46 	bl	4000ad80 <z_shell_raw_fprintf>
    4000b06c:	f9401660 	ldr	x0, [x19, #40]
    4000b070:	97fff81e 	bl	400090e8 <z_shell_fprintf_buffer_flush>
			(void)shell->iface->api->read(shell->iface, &c,
    4000b074:	f9400660 	ldr	x0, [x19, #8]
    4000b078:	9100e3e3 	add	x3, sp, #0x38
    4000b07c:	d2800022 	mov	x2, #0x1                   	// #1
    4000b080:	f9400001 	ldr	x1, [x0]
    4000b084:	f9401024 	ldr	x4, [x1, #32]
    4000b088:	9100dfe1 	add	x1, sp, #0x37
    4000b08c:	d63f0080 	blr	x4
			if (cnt == 0) {
    4000b090:	f9401fe0 	ldr	x0, [sp, #56]
    4000b094:	b5000100 	cbnz	x0, 4000b0b4 <cmd_resize+0x100>
	z_impl_k_busy_wait(usec_to_wait);
    4000b098:	52807d00 	mov	w0, #0x3e8                 	// #1000
	for (uint16_t i = 0; i < 1000; i++) {
    4000b09c:	510006b5 	sub	w21, w21, #0x1
    4000b0a0:	9400168a 	bl	40010ac8 <z_impl_k_busy_wait>
    4000b0a4:	72003eb5 	ands	w21, w21, #0xffff
    4000b0a8:	54fffe61 	b.ne	4000b074 <cmd_resize+0xc0>  // b.any
		ret_val = -ENOTSUP;
    4000b0ac:	128010b4 	mov	w20, #0xffffff7a            	// #-134
    4000b0b0:	1400002c 	b	4000b160 <cmd_resize+0x1ac>
			if ((c != SHELL_VT100_ASCII_ESC) &&
    4000b0b4:	3940dfe1 	ldrb	w1, [sp, #55]
			    (shell->ctx->temp_buff[0] !=
    4000b0b8:	f9400a60 	ldr	x0, [x19, #16]
			if ((c != SHELL_VT100_ASCII_ESC) &&
    4000b0bc:	71006c3f 	cmp	w1, #0x1b
    4000b0c0:	54000920 	b.eq	4000b1e4 <cmd_resize+0x230>  // b.none
    4000b0c4:	3945d802 	ldrb	w2, [x0, #374]
    4000b0c8:	71006c5f 	cmp	w2, #0x1b
    4000b0cc:	54fffd41 	b.ne	4000b074 <cmd_resize+0xc0>  // b.any
			if (c == 'R') { /* End of response from the terminal. */
    4000b0d0:	7101483f 	cmp	w1, #0x52
    4000b0d4:	54000881 	b.ne	4000b1e4 <cmd_resize+0x230>  // b.any
				shell->ctx->temp_buff[buff_idx] = '\0';
    4000b0d8:	8b34c014 	add	x20, x0, w20, sxtw
    4000b0dc:	3905da9f 	strb	wzr, [x20, #374]
				if (shell->ctx->temp_buff[1] != '[') {
    4000b0e0:	3945dc01 	ldrb	w1, [x0, #375]
    4000b0e4:	71016c3f 	cmp	w1, #0x5b
    4000b0e8:	54000640 	b.eq	4000b1b0 <cmd_resize+0x1fc>  // b.none
				shell->ctx->temp_buff[0] = 0;
    4000b0ec:	3905d81f 	strb	wzr, [x0, #374]
				return -ENOMEM;
    4000b0f0:	17ffffef 	b	4000b0ac <cmd_resize+0xf8>
					*y = *y * 10U +
    4000b0f4:	1b061042 	madd	w2, w2, w6, w4
					if (buff_idx >=
    4000b0f8:	91000421 	add	x1, x1, #0x1
    4000b0fc:	f103f83f 	cmp	x1, #0xfe
					*y = *y * 10U +
    4000b100:	5100c042 	sub	w2, w2, #0x30
    4000b104:	12003c42 	and	w2, w2, #0xffff
					if (buff_idx >=
    4000b108:	54fffd20 	b.eq	4000b0ac <cmd_resize+0xf8>  // b.none
				while (shell->ctx->temp_buff[buff_idx] != ';') {
    4000b10c:	386168a4 	ldrb	w4, [x5, x1]
					(shell->ctx->temp_buff[buff_idx++] -
    4000b110:	11000c23 	add	w3, w1, #0x3
    4000b114:	12003c63 	and	w3, w3, #0xffff
				while (shell->ctx->temp_buff[buff_idx] != ';') {
    4000b118:	7100ec9f 	cmp	w4, #0x3b
    4000b11c:	54fffec1 	b.ne	4000b0f4 <cmd_resize+0x140>  // b.any
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
    4000b120:	7104007f 	cmp	w3, #0x100
    4000b124:	54fffc40 	b.eq	4000b0ac <cmd_resize+0xf8>  // b.none
	*x = 0U;
    4000b128:	52800001 	mov	w1, #0x0                   	// #0
					*x = *x * 10U +
    4000b12c:	52800145 	mov	w5, #0xa                   	// #10
				while (shell->ctx->temp_buff[buff_idx]
    4000b130:	8b23c004 	add	x4, x0, w3, sxtw
    4000b134:	3945d884 	ldrb	w4, [x4, #374]
    4000b138:	35000464 	cbnz	w4, 4000b1c4 <cmd_resize+0x210>
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
    4000b13c:	7103e83f 	cmp	w1, #0xfa
    4000b140:	52801f43 	mov	w3, #0xfa                  	// #250
    4000b144:	1a839021 	csel	w1, w1, w3, ls  // ls = plast
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
    4000b148:	7103e85f 	cmp	w2, #0xfa
    4000b14c:	1a839042 	csel	w2, w2, w3, ls  // ls = plast
	int ret_val = 0;
    4000b150:	52800014 	mov	w20, #0x0                   	// #0
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
    4000b154:	79009002 	strh	w2, [x0, #72]
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
    4000b158:	79009401 	strh	w1, [x0, #74]
				shell->ctx->temp_buff[0] = 0;
    4000b15c:	3905d81f 	strb	wzr, [x0, #374]
	return sh->ctx->cfg.flags.use_vt100 == 1;
    4000b160:	f9400a60 	ldr	x0, [x19, #16]
    4000b164:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
    4000b168:	362800c0 	tbz	w0, #5, 4000b180 <cmd_resize+0x1cc>
    4000b16c:	f9401660 	ldr	x0, [x19, #40]
    4000b170:	90000041 	adrp	x1, 40013000 <shell_cmd_help>
    4000b174:	91034821 	add	x1, x1, #0xd2
    4000b178:	91005821 	add	x1, x1, #0x16
    4000b17c:	97ffff01 	bl	4000ad80 <z_shell_raw_fprintf>
	if (err != 0) {
    4000b180:	34fff374 	cbz	w20, 4000afec <cmd_resize+0x38>
		shell->ctx->vt100_ctx.cons.terminal_hei =
    4000b184:	f9400a60 	ldr	x0, [x19, #16]
    4000b188:	52800301 	mov	w1, #0x18                  	// #24
    4000b18c:	72a00a01 	movk	w1, #0x50, lsl #16
		shell_warn(shell, "No response from the terminal, assumed 80x24"
    4000b190:	d0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000b194:	91287c42 	add	x2, x2, #0xa1f
    4000b198:	128000f4 	mov	w20, #0xfffffff8            	// #-8
		shell->ctx->vt100_ctx.cons.terminal_hei =
    4000b19c:	b9004801 	str	w1, [x0, #72]
		shell_warn(shell, "No response from the terminal, assumed 80x24"
    4000b1a0:	aa1303e0 	mov	x0, x19
    4000b1a4:	52800061 	mov	w1, #0x3                   	// #3
    4000b1a8:	97fff70f 	bl	40008de4 <shell_fprintf>
		return -ENOEXEC;
    4000b1ac:	17ffff90 	b	4000afec <cmd_resize+0x38>
				while (shell->ctx->temp_buff[buff_idx] != ';') {
    4000b1b0:	9105e005 	add	x5, x0, #0x178
    4000b1b4:	d2800001 	mov	x1, #0x0                   	// #0
	*y = 0U;
    4000b1b8:	52800002 	mov	w2, #0x0                   	// #0
					*y = *y * 10U +
    4000b1bc:	52800146 	mov	w6, #0xa                   	// #10
    4000b1c0:	17ffffd3 	b	4000b10c <cmd_resize+0x158>
					*x = *x * 10U +
    4000b1c4:	1b051021 	madd	w1, w1, w5, w4
					if (buff_idx >=
    4000b1c8:	11000463 	add	w3, w3, #0x1
    4000b1cc:	12003c64 	and	w4, w3, #0xffff
					*x = *x * 10U +
    4000b1d0:	5100c021 	sub	w1, w1, #0x30
					if (buff_idx >=
    4000b1d4:	7103fc9f 	cmp	w4, #0xff
					*x = *x * 10U +
    4000b1d8:	12003c21 	and	w1, w1, #0xffff
					if (buff_idx >=
    4000b1dc:	54fffaa9 	b.ls	4000b130 <cmd_resize+0x17c>  // b.plast
    4000b1e0:	17ffffb3 	b	4000b0ac <cmd_resize+0xf8>
			shell->ctx->temp_buff[buff_idx] = c;
    4000b1e4:	8b34c002 	add	x2, x0, w20, sxtw
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
    4000b1e8:	11000694 	add	w20, w20, #0x1
    4000b1ec:	12003e94 	and	w20, w20, #0xffff
    4000b1f0:	7100269f 	cmp	w20, #0x9
			shell->ctx->temp_buff[buff_idx] = c;
    4000b1f4:	3905d841 	strb	w1, [x2, #374]
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
    4000b1f8:	54fff3e9 	b.ls	4000b074 <cmd_resize+0xc0>  // b.plast
    4000b1fc:	17ffffbc 	b	4000b0ec <cmd_resize+0x138>

000000004000b200 <cmd_bacskpace_mode_backspace>:
{
    4000b200:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000b204:	910003fd 	mov	x29, sp
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4000b208:	f9400801 	ldr	x1, [x0, #16]
    4000b20c:	d2800100 	mov	x0, #0x8                   	// #8
    4000b210:	910a6021 	add	x1, x1, #0x298
    4000b214:	97ffd777 	bl	40000ff0 <__aarch64_ldclr8_acq_rel>
}
    4000b218:	52800000 	mov	w0, #0x0                   	// #0
    4000b21c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b220:	d65f03c0 	ret

000000004000b224 <cmd_bacskpace_mode_delete>:
{
    4000b224:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000b228:	910003fd 	mov	x29, sp
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4000b22c:	f9400801 	ldr	x1, [x0, #16]
    4000b230:	d2800100 	mov	x0, #0x8                   	// #8
    4000b234:	910a6021 	add	x1, x1, #0x298
    4000b238:	97ffd77a 	bl	40001020 <__aarch64_ldset8_acq_rel>
}
    4000b23c:	52800000 	mov	w0, #0x0                   	// #0
    4000b240:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b244:	d65f03c0 	ret

000000004000b248 <cmd_echo_off>:
{
    4000b248:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000b24c:	910003fd 	mov	x29, sp
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4000b250:	f9400801 	ldr	x1, [x0, #16]
    4000b254:	d2800040 	mov	x0, #0x2                   	// #2
    4000b258:	910a6021 	add	x1, x1, #0x298
    4000b25c:	97ffd765 	bl	40000ff0 <__aarch64_ldclr8_acq_rel>
}
    4000b260:	52800000 	mov	w0, #0x0                   	// #0
    4000b264:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b268:	d65f03c0 	ret

000000004000b26c <cmd_colors_off>:
{
    4000b26c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000b270:	910003fd 	mov	x29, sp
    4000b274:	f9400801 	ldr	x1, [x0, #16]
    4000b278:	d2800200 	mov	x0, #0x10                  	// #16
    4000b27c:	910a6021 	add	x1, x1, #0x298
    4000b280:	97ffd75c 	bl	40000ff0 <__aarch64_ldclr8_acq_rel>
}
    4000b284:	52800000 	mov	w0, #0x0                   	// #0
    4000b288:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b28c:	d65f03c0 	ret

000000004000b290 <cmd_colors_on>:
{
    4000b290:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000b294:	910003fd 	mov	x29, sp
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4000b298:	f9400801 	ldr	x1, [x0, #16]
    4000b29c:	d2800200 	mov	x0, #0x10                  	// #16
    4000b2a0:	910a6021 	add	x1, x1, #0x298
    4000b2a4:	97ffd75f 	bl	40001020 <__aarch64_ldset8_acq_rel>
}
    4000b2a8:	52800000 	mov	w0, #0x0                   	// #0
    4000b2ac:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b2b0:	d65f03c0 	ret

000000004000b2b4 <cmd_echo_on>:
{
    4000b2b4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000b2b8:	910003fd 	mov	x29, sp
    4000b2bc:	f9400801 	ldr	x1, [x0, #16]
    4000b2c0:	d2800040 	mov	x0, #0x2                   	// #2
    4000b2c4:	910a6021 	add	x1, x1, #0x298
    4000b2c8:	97ffd756 	bl	40001020 <__aarch64_ldset8_acq_rel>
}
    4000b2cc:	52800000 	mov	w0, #0x0                   	// #0
    4000b2d0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b2d4:	d65f03c0 	ret

000000004000b2d8 <remove_from_tail.part.0>:
	memcpy(item->data, src, len);
	sys_dlist_prepend(&history->list, &item->dnode);
}

/* Returns true if element was removed. */
static bool remove_from_tail(struct shell_history *history)
    4000b2d8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000b2dc:	910003fd 	mov	x29, sp
 * @return a pointer to the tail element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_tail(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    4000b2e0:	f9400802 	ldr	x2, [x0, #16]

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	total_len = offsetof(struct shell_history_item, data) +
			h_item->len + h_item->padding;
	ring_buf_get_finish(history->ring_buf, total_len);
    4000b2e4:	f9400000 	ldr	x0, [x0]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    4000b2e8:	a9400c41 	ldp	x1, x3, [x2]
	sys_dnode_t *const next = node->next;

	prev->next = next;
    4000b2ec:	f9000061 	str	x1, [x3]
	next->prev = prev;
    4000b2f0:	f9000423 	str	x3, [x1, #8]
			h_item->len + h_item->padding;
    4000b2f4:	79402041 	ldrh	w1, [x2, #16]
	node->prev = NULL;
    4000b2f8:	a9007c5f 	stp	xzr, xzr, [x2]
    4000b2fc:	79402442 	ldrh	w2, [x2, #18]
    4000b300:	0b020021 	add	w1, w1, w2
	ring_buf_get_finish(history->ring_buf, total_len);
    4000b304:	11005021 	add	w1, w1, #0x14
    4000b308:	97ffe243 	bl	40003c14 <ring_buf_get_finish>

	return true;
}
    4000b30c:	52800020 	mov	w0, #0x1                   	// #1
    4000b310:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b314:	d65f03c0 	ret

000000004000b318 <z_shell_history_mode_exit>:
	history->current = NULL;
    4000b318:	f9000c1f 	str	xzr, [x0, #24]
}
    4000b31c:	d65f03c0 	ret

000000004000b320 <z_shell_history_get>:
{
    4000b320:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000b324:	910003fd 	mov	x29, sp
    4000b328:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b32c:	aa0203f4 	mov	x20, x2
	return list->head == list;
    4000b330:	aa0003e2 	mov	x2, x0
    4000b334:	f8408c53 	ldr	x19, [x2, #8]!
    4000b338:	f90013f5 	str	x21, [sp, #32]
    4000b33c:	aa0303f5 	mov	x21, x3
	if (sys_dlist_is_empty(&history->list)) {
    4000b340:	eb02027f 	cmp	x19, x2
    4000b344:	540000e1 	b.ne	4000b360 <z_shell_history_get+0x40>  // b.any
		return false;
    4000b348:	52800000 	mov	w0, #0x0                   	// #0
		*len = 0U;
    4000b34c:	790002bf 	strh	wzr, [x21]
}
    4000b350:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b354:	f94013f5 	ldr	x21, [sp, #32]
    4000b358:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000b35c:	d65f03c0 	ret
    4000b360:	12001c21 	and	w1, w1, #0xff
		if (history->current == NULL) {
    4000b364:	f9400c04 	ldr	x4, [x0, #24]
	if (!up) { /* button down */
    4000b368:	35000261 	cbnz	w1, 4000b3b4 <z_shell_history_get+0x94>
		if (history->current == NULL) {
    4000b36c:	b4fffee4 	cbz	x4, 4000b348 <z_shell_history_get+0x28>
	return (node == list->head) ? NULL : node->prev;
    4000b370:	eb04027f 	cmp	x19, x4
    4000b374:	54000061 	b.ne	4000b380 <z_shell_history_get+0x60>  // b.any
	history->current = l_item;
    4000b378:	f9000c1f 	str	xzr, [x0, #24]
	if (l_item) {
    4000b37c:	17fffff3 	b	4000b348 <z_shell_history_get+0x28>
    4000b380:	f9400493 	ldr	x19, [x4, #8]
	history->current = l_item;
    4000b384:	f9000c13 	str	x19, [x0, #24]
	if (l_item) {
    4000b388:	b4fffe13 	cbz	x19, 4000b348 <z_shell_history_get+0x28>
		memcpy(dst, h_item->data, h_item->len);
    4000b38c:	79402262 	ldrh	w2, [x19, #16]
    4000b390:	91005261 	add	x1, x19, #0x14
    4000b394:	aa1403e0 	mov	x0, x20
    4000b398:	940007df 	bl	4000d314 <memcpy>
		*len = h_item->len;
    4000b39c:	79402261 	ldrh	w1, [x19, #16]
		return true;
    4000b3a0:	52800020 	mov	w0, #0x1                   	// #1
		*len = h_item->len;
    4000b3a4:	790002a1 	strh	w1, [x21]
		dst[*len] = '\0';
    4000b3a8:	92403c21 	and	x1, x1, #0xffff
    4000b3ac:	38216a9f 	strb	wzr, [x20, x1]
		return true;
    4000b3b0:	17ffffe8 	b	4000b350 <z_shell_history_get+0x30>
		sys_dlist_peek_head_not_empty(&history->list) :
    4000b3b4:	b4fffe84 	cbz	x4, 4000b384 <z_shell_history_get+0x64>
	return (node == list->tail) ? NULL : node->next;
    4000b3b8:	f9400801 	ldr	x1, [x0, #16]
    4000b3bc:	eb04003f 	cmp	x1, x4
    4000b3c0:	54fffdc0 	b.eq	4000b378 <z_shell_history_get+0x58>  // b.none
    4000b3c4:	f9400093 	ldr	x19, [x4]
    4000b3c8:	17ffffef 	b	4000b384 <z_shell_history_get+0x64>

000000004000b3cc <z_shell_history_purge>:

void z_shell_history_purge(struct shell_history *history)
{
    4000b3cc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000b3d0:	910003fd 	mov	x29, sp
    4000b3d4:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b3d8:	aa0003f3 	mov	x19, x0
	if (sys_dlist_is_empty(&history->list)) {
    4000b3dc:	91002014 	add	x20, x0, #0x8
    4000b3e0:	f9400660 	ldr	x0, [x19, #8]
    4000b3e4:	eb14001f 	cmp	x0, x20
    4000b3e8:	540000a0 	b.eq	4000b3fc <z_shell_history_purge+0x30>  // b.none
    4000b3ec:	aa1303e0 	mov	x0, x19
    4000b3f0:	97ffffba 	bl	4000b2d8 <remove_from_tail.part.0>
	while (remove_from_tail(history)) {
    4000b3f4:	72001c1f 	tst	w0, #0xff
    4000b3f8:	54ffff41 	b.ne	4000b3e0 <z_shell_history_purge+0x14>  // b.any
	}
}
    4000b3fc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b400:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000b404:	d65f03c0 	ret

000000004000b408 <z_shell_history_put>:

void z_shell_history_put(struct shell_history *history, uint8_t *line,
			 size_t len)
{
    4000b408:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4000b40c:	910003fd 	mov	x29, sp
    4000b410:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b414:	aa0003f3 	mov	x19, x0
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;
	uint32_t total_len = len + offsetof(struct shell_history_item, data);
    4000b418:	11005054 	add	w20, w2, #0x14
 *
 * @return Ring buffer capacity (in 32-bit words or bytes).
 */
static inline uint32_t ring_buf_capacity_get(struct ring_buf *buf)
{
	return buf->size;
    4000b41c:	f9400000 	ldr	x0, [x0]
{
    4000b420:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint32_t claim_len;
	uint32_t claim2_len;
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
    4000b424:	4b1403f5 	neg	w21, w20
{
    4000b428:	a90363f7 	stp	x23, x24, [sp, #48]
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
    4000b42c:	12000ab7 	and	w23, w21, #0x7

	/* align to word. */
	total_len += padding;

	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
    4000b430:	b9401000 	ldr	w0, [x0, #16]
{
    4000b434:	f90023f9 	str	x25, [sp, #64]
	total_len += padding;
    4000b438:	0b1402f4 	add	w20, w23, w20
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
    4000b43c:	6b00029f 	cmp	w20, w0
    4000b440:	54000688 	b.hi	4000b510 <z_shell_history_put+0x108>  // b.pmore
	history->current = NULL;
    4000b444:	f9000e7f 	str	xzr, [x19, #24]
    4000b448:	aa0203f6 	mov	x22, x2
		return;
	}

	z_shell_history_mode_exit(history);

	if (len == 0) {
    4000b44c:	b4000622 	cbz	x2, 4000b510 <z_shell_history_put+0x108>
	return list->head == list;
    4000b450:	f9400660 	ldr	x0, [x19, #8]
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
    4000b454:	91002278 	add	x24, x19, #0x8
    4000b458:	aa0103f9 	mov	x25, x1
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000b45c:	eb00031f 	cmp	x24, x0
    4000b460:	54000481 	b.ne	4000b4f0 <z_shell_history_put+0xe8>  // b.any
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
    4000b464:	f9002fff 	str	xzr, [sp, #88]
		/* Same command as before, do not store */
		return;
	}

	do {
		claim_len = ring_buf_put_claim(history->ring_buf,
    4000b468:	f9400260 	ldr	x0, [x19]
    4000b46c:	2a1403e2 	mov	w2, w20
    4000b470:	910163e1 	add	x1, sp, #0x58
    4000b474:	97ffe170 	bl	40003a34 <ring_buf_put_claim>
    4000b478:	2a0003f5 	mov	w21, w0
						(uint8_t **)&h_item, total_len);
		/* second allocation may succeed if we were at the end of the
		 * buffer.
		 */
		if (claim_len < total_len) {
    4000b47c:	6b00029f 	cmp	w20, w0
    4000b480:	54000549 	b.ls	4000b528 <z_shell_history_put+0x120>  // b.plast
			claim2_len =
				ring_buf_put_claim(history->ring_buf,
    4000b484:	f9400260 	ldr	x0, [x19]
    4000b488:	2a1403e2 	mov	w2, w20
    4000b48c:	910163e1 	add	x1, sp, #0x58
    4000b490:	97ffe169 	bl	40003a34 <ring_buf_put_claim>
						   (uint8_t **)&h_item, total_len);
			if (claim2_len == total_len) {
    4000b494:	6b00029f 	cmp	w20, w0
    4000b498:	540004a1 	b.ne	4000b52c <z_shell_history_put+0x124>  // b.any
				ring_buf_put_finish(history->ring_buf,
    4000b49c:	f9400260 	ldr	x0, [x19]
    4000b4a0:	2a1503e1 	mov	w1, w21
						    claim_len);
				padding += claim_len;
    4000b4a4:	0b1502f5 	add	w21, w23, w21
    4000b4a8:	12003eb7 	and	w23, w21, #0xffff
    4000b4ac:	2a1403f5 	mov	w21, w20
				ring_buf_put_finish(history->ring_buf,
    4000b4b0:	97ffe178 	bl	40003a90 <ring_buf_put_finish>
				claim_len = total_len;
			}
		}

		if (claim_len == total_len) {
			add_to_head(history, h_item, line, len, padding);
    4000b4b4:	f9402ff4 	ldr	x20, [sp, #88]
	memcpy(item->data, src, len);
    4000b4b8:	aa1903e1 	mov	x1, x25
    4000b4bc:	aa1603e2 	mov	x2, x22
    4000b4c0:	91005280 	add	x0, x20, #0x14
	item->len = len;
    4000b4c4:	79002296 	strh	w22, [x20, #16]
	item->padding = padding;
    4000b4c8:	79002697 	strh	w23, [x20, #18]
	memcpy(item->data, src, len);
    4000b4cc:	94000792 	bl	4000d314 <memcpy>
	sys_dnode_t *const head = list->head;
    4000b4d0:	f9400660 	ldr	x0, [x19, #8]
	node->prev = list;
    4000b4d4:	a9006280 	stp	x0, x24, [x20]
			ring_buf_put_finish(history->ring_buf, claim_len);
    4000b4d8:	2a1503e1 	mov	w1, w21
	head->prev = node;
    4000b4dc:	f9000414 	str	x20, [x0, #8]
    4000b4e0:	f9400260 	ldr	x0, [x19]
	list->head = node;
    4000b4e4:	f9000674 	str	x20, [x19, #8]
    4000b4e8:	97ffe16a 	bl	40003a90 <ring_buf_put_finish>
			break;
    4000b4ec:	14000009 	b	4000b510 <z_shell_history_put+0x108>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
    4000b4f0:	f9002fe0 	str	x0, [sp, #88]
	if (l_item &&
    4000b4f4:	b4fffba0 	cbz	x0, 4000b468 <z_shell_history_put+0x60>
	   (h_item->len == len) &&
    4000b4f8:	79402003 	ldrh	w3, [x0, #16]
	if (l_item &&
    4000b4fc:	eb02007f 	cmp	x3, x2
    4000b500:	54fffb41 	b.ne	4000b468 <z_shell_history_put+0x60>  // b.any
	   (memcmp(h_item->data, line, len) == 0)) {
    4000b504:	91005000 	add	x0, x0, #0x14
    4000b508:	94000766 	bl	4000d2a0 <memcmp>
	   (h_item->len == len) &&
    4000b50c:	35fffae0 	cbnz	w0, 4000b468 <z_shell_history_put+0x60>
			 * of ring buffer capacity length.
			 */
			ring_buf_reset(history->ring_buf);
		}
	} while (1);
}
    4000b510:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b514:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b518:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000b51c:	f94023f9 	ldr	x25, [sp, #64]
    4000b520:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000b524:	d65f03c0 	ret
		if (claim_len == total_len) {
    4000b528:	54fffc60 	b.eq	4000b4b4 <z_shell_history_put+0xac>  // b.none
		ring_buf_put_finish(history->ring_buf, 0);
    4000b52c:	f9400260 	ldr	x0, [x19]
    4000b530:	52800001 	mov	w1, #0x0                   	// #0
    4000b534:	97ffe157 	bl	40003a90 <ring_buf_put_finish>
	if (sys_dlist_is_empty(&history->list)) {
    4000b538:	f9400660 	ldr	x0, [x19, #8]
    4000b53c:	eb00031f 	cmp	x24, x0
    4000b540:	540000e1 	b.ne	4000b55c <z_shell_history_put+0x154>  // b.any
	buf->head = 0;
    4000b544:	f9400260 	ldr	x0, [x19]
	memset(&buf->misc, 0, sizeof(buf->misc));
    4000b548:	d2800102 	mov	x2, #0x8                   	// #8
    4000b54c:	52800001 	mov	w1, #0x0                   	// #0
	buf->head = 0;
    4000b550:	f800841f 	str	xzr, [x0], #8
	memset(&buf->misc, 0, sizeof(buf->misc));
    4000b554:	94000778 	bl	4000d334 <memset>
}
    4000b558:	17ffffc4 	b	4000b468 <z_shell_history_put+0x60>
    4000b55c:	aa1303e0 	mov	x0, x19
    4000b560:	97ffff5e 	bl	4000b2d8 <remove_from_tail.part.0>
		if (remove_from_tail(history) == false) {
    4000b564:	72001c1f 	tst	w0, #0xff
    4000b568:	54fff801 	b.ne	4000b468 <z_shell_history_put+0x60>  // b.any
    4000b56c:	17fffff6 	b	4000b544 <z_shell_history_put+0x13c>

000000004000b570 <z_shell_history_init>:

void z_shell_history_init(struct shell_history *history)
{
	sys_dlist_init(&history->list);
    4000b570:	91002001 	add	x1, x0, #0x8
	list->tail = (sys_dnode_t *)list;
    4000b574:	a9008401 	stp	x1, x1, [x0, #8]
	history->current = NULL;
    4000b578:	f9000c1f 	str	xzr, [x0, #24]
}
    4000b57c:	d65f03c0 	ret

000000004000b580 <z_shell_has_wildcard>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
    4000b580:	b5000060 	cbnz	x0, 4000b58c <z_shell_has_wildcard+0xc>
		if ((str[i] == '?') || (str[i] == '*')) {
			return true;
		}
	}

	return false;
    4000b584:	52800000 	mov	w0, #0x0                   	// #0
}
    4000b588:	d65f03c0 	ret
{
    4000b58c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000b590:	910003fd 	mov	x29, sp
    4000b594:	f9000bf3 	str	x19, [sp, #16]
    4000b598:	aa0003f3 	mov	x19, x0
    4000b59c:	9400071b 	bl	4000d208 <strlen>
	for (size_t i = 0; i < str_len; i++) {
    4000b5a0:	92403c03 	and	x3, x0, #0xffff
    4000b5a4:	d2800002 	mov	x2, #0x0                   	// #0
    4000b5a8:	eb03005f 	cmp	x2, x3
    4000b5ac:	540000a3 	b.cc	4000b5c0 <z_shell_has_wildcard+0x40>  // b.lo, b.ul, b.last
	return false;
    4000b5b0:	52800000 	mov	w0, #0x0                   	// #0
}
    4000b5b4:	f9400bf3 	ldr	x19, [sp, #16]
    4000b5b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000b5bc:	d65f03c0 	ret
		if ((str[i] == '?') || (str[i] == '*')) {
    4000b5c0:	38626a60 	ldrb	w0, [x19, x2]
    4000b5c4:	7100fc1f 	cmp	w0, #0x3f
    4000b5c8:	1a9f17e1 	cset	w1, eq  // eq = none
    4000b5cc:	7100a81f 	cmp	w0, #0x2a
    4000b5d0:	1a9f17e0 	cset	w0, eq  // eq = none
    4000b5d4:	2a000020 	orr	w0, w1, w0
    4000b5d8:	35fffee0 	cbnz	w0, 4000b5b4 <z_shell_has_wildcard+0x34>
	for (size_t i = 0; i < str_len; i++) {
    4000b5dc:	91000442 	add	x2, x2, #0x1
    4000b5e0:	17fffff2 	b	4000b5a8 <z_shell_has_wildcard+0x28>

000000004000b5e4 <z_shell_wildcard_prepare>:

void z_shell_wildcard_prepare(const struct shell *shell)
{
    4000b5e4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	 *    buffer with all expanded commands is copied to Command buffer.
	 * 7. Deepest found handler is executed and all lower level commands,
	 *    including expanded commands, are passed as arguments.
	 */

	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    4000b5e8:	d2802002 	mov	x2, #0x100                 	// #256
    4000b5ec:	52800001 	mov	w1, #0x0                   	// #0
{
    4000b5f0:	910003fd 	mov	x29, sp
    4000b5f4:	f9000bf3 	str	x19, [sp, #16]
    4000b5f8:	aa0003f3 	mov	x19, x0
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    4000b5fc:	f9400800 	ldr	x0, [x0, #16]
    4000b600:	9105d800 	add	x0, x0, #0x176
    4000b604:	9400074c 	bl	4000d334 <memset>
	memcpy(shell->ctx->temp_buff,
    4000b608:	f9400a60 	ldr	x0, [x19, #16]
    4000b60c:	9101d801 	add	x1, x0, #0x76
    4000b610:	7940e002 	ldrh	w2, [x0, #112]
    4000b614:	9105d800 	add	x0, x0, #0x176
    4000b618:	9400073f 	bl	4000d314 <memcpy>

	/* Function shell_spaces_trim must be used instead of shell_make_argv.
	 * At this point it is important to keep temp_buff as one string.
	 * It will allow to find wildcard commands easily with strstr function.
	 */
	z_shell_spaces_trim(shell->ctx->temp_buff);
    4000b61c:	f9400a60 	ldr	x0, [x19, #16]
    4000b620:	9105d800 	add	x0, x0, #0x176
    4000b624:	97fff85f 	bl	400097a0 <z_shell_spaces_trim>

	/* +1 for EOS*/
	shell->ctx->cmd_tmp_buff_len = z_shell_strlen(shell->ctx->temp_buff) + 1;
    4000b628:	f9400a60 	ldr	x0, [x19, #16]
    4000b62c:	b105d800 	adds	x0, x0, #0x176
    4000b630:	54000120 	b.eq	4000b654 <z_shell_wildcard_prepare+0x70>  // b.none
    4000b634:	940006f5 	bl	4000d208 <strlen>
    4000b638:	12003c00 	and	w0, w0, #0xffff
    4000b63c:	f9400a61 	ldr	x1, [x19, #16]
    4000b640:	11000400 	add	w0, w0, #0x1
}
    4000b644:	f9400bf3 	ldr	x19, [sp, #16]
	shell->ctx->cmd_tmp_buff_len = z_shell_strlen(shell->ctx->temp_buff) + 1;
    4000b648:	7900e820 	strh	w0, [x1, #116]
}
    4000b64c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000b650:	d65f03c0 	ret
    4000b654:	52800000 	mov	w0, #0x0                   	// #0
    4000b658:	17fffff9 	b	4000b63c <z_shell_wildcard_prepare+0x58>

000000004000b65c <z_shell_wildcard_process>:


enum shell_wildcard_status z_shell_wildcard_process(const struct shell *shell,
					const struct shell_static_entry *cmd,
					const char *pattern)
{
    4000b65c:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    4000b660:	910003fd 	mov	x29, sp
    4000b664:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b668:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000b66c:	a90363f7 	stp	x23, x24, [sp, #48]
    4000b670:	a9046bf9 	stp	x25, x26, [sp, #64]
    4000b674:	a90573fb 	stp	x27, x28, [sp, #80]
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
    4000b678:	b5000141 	cbnz	x1, 4000b6a0 <z_shell_wildcard_process+0x44>
		return ret_val;
    4000b67c:	52800073 	mov	w19, #0x3                   	// #3
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(shell, cmd, pattern);

	return ret_val;
}
    4000b680:	2a1303e0 	mov	w0, w19
    4000b684:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b688:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b68c:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000b690:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000b694:	a94573fb 	ldp	x27, x28, [sp, #80]
    4000b698:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    4000b69c:	d65f03c0 	ret
    4000b6a0:	aa0003f5 	mov	x21, x0
    4000b6a4:	aa0103f6 	mov	x22, x1
    4000b6a8:	aa0203f4 	mov	x20, x2
	if (!z_shell_has_wildcard(pattern)) {
    4000b6ac:	aa0203e0 	mov	x0, x2
    4000b6b0:	97ffffb4 	bl	4000b580 <z_shell_has_wildcard>
    4000b6b4:	72001c1f 	tst	w0, #0xff
    4000b6b8:	54fffe20 	b.eq	4000b67c <z_shell_wildcard_process+0x20>  // b.none
	size_t cnt = 0;
    4000b6bc:	d2800018 	mov	x24, #0x0                   	// #0
	size_t cmd_idx = 0;
    4000b6c0:	d2800001 	mov	x1, #0x0                   	// #0
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
    4000b6c4:	52800053 	mov	w19, #0x2                   	// #2
	completion_addr[cmd_len] = ' ';
    4000b6c8:	5280041a 	mov	w26, #0x20                  	// #32
    4000b6cc:	1400001c 	b	4000b73c <z_shell_wildcard_process+0xe0>
    4000b6d0:	52800013 	mov	w19, #0x0                   	// #0
    4000b6d4:	1400002c 	b	4000b784 <z_shell_wildcard_process+0x128>
	completion_addr = strstr(buff, pattern);
    4000b6d8:	aa1403e1 	mov	x1, x20
    4000b6dc:	9105dae0 	add	x0, x23, #0x176
    4000b6e0:	94000687 	bl	4000d0fc <strstr>
    4000b6e4:	aa0003fb 	mov	x27, x0
	if (!completion_addr) {
    4000b6e8:	b4000740 	cbz	x0, 4000b7d0 <z_shell_wildcard_process+0x174>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
    4000b6ec:	92403e79 	and	x25, x19, #0xffff
    4000b6f0:	940006c6 	bl	4000d208 <strlen>
    4000b6f4:	92403c02 	and	x2, x0, #0xffff
    4000b6f8:	91000720 	add	x0, x25, #0x1
    4000b6fc:	91000442 	add	x2, x2, #0x1
    4000b700:	aa1b03e1 	mov	x1, x27
    4000b704:	8b000360 	add	x0, x27, x0
    4000b708:	940006f4 	bl	4000d2d8 <memmove>
	memcpy(completion_addr, cmd, cmd_len);
    4000b70c:	aa1903e2 	mov	x2, x25
    4000b710:	aa1c03e1 	mov	x1, x28
    4000b714:	aa1b03e0 	mov	x0, x27
    4000b718:	940006ff 	bl	4000d314 <memcpy>
	completion_addr[cmd_len] = ' ';
    4000b71c:	38396b7a 	strb	w26, [x27, x25]
			cnt++;
    4000b720:	91000718 	add	x24, x24, #0x1
	*buff_len += cmd_len + 1; /* + 1 for space */
    4000b724:	7940eae0 	ldrh	w0, [x23, #116]
    4000b728:	0b000273 	add	w19, w19, w0
    4000b72c:	11000673 	add	w19, w19, #0x1
    4000b730:	7900eaf3 	strh	w19, [x23, #116]
			ret_val = command_add(shell->ctx->temp_buff,
    4000b734:	52800013 	mov	w19, #0x0                   	// #0
    4000b738:	f94037e1 	ldr	x1, [sp, #104]
	while ((entry = z_shell_cmd_get(cmd, cmd_idx++, &dloc)) != NULL) {
    4000b73c:	91000420 	add	x0, x1, #0x1
    4000b740:	9101e3e2 	add	x2, sp, #0x78
    4000b744:	f90037e0 	str	x0, [sp, #104]
    4000b748:	aa1603e0 	mov	x0, x22
    4000b74c:	97fff7a4 	bl	400095dc <z_shell_cmd_get>
    4000b750:	aa0003fb 	mov	x27, x0
    4000b754:	b4000300 	cbz	x0, 4000b7b4 <z_shell_wildcard_process+0x158>
		if (fnmatch(pattern, entry->syntax, 0) == 0) {
    4000b758:	f9400361 	ldr	x1, [x27]
    4000b75c:	aa1403e0 	mov	x0, x20
    4000b760:	52800002 	mov	w2, #0x0                   	// #0
    4000b764:	97ffe251 	bl	400040a8 <fnmatch>
    4000b768:	35fffe80 	cbnz	w0, 4000b738 <z_shell_wildcard_process+0xdc>
			ret_val = command_add(shell->ctx->temp_buff,
    4000b76c:	f940037c 	ldr	x28, [x27]
    4000b770:	f9400ab7 	ldr	x23, [x21, #16]
    4000b774:	b4fffafc 	cbz	x28, 4000b6d0 <z_shell_wildcard_process+0x74>
    4000b778:	aa1c03e0 	mov	x0, x28
    4000b77c:	940006a3 	bl	4000d208 <strlen>
    4000b780:	12003c13 	and	w19, w0, #0xffff
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
    4000b784:	7940eae0 	ldrh	w0, [x23, #116]
    4000b788:	11000400 	add	w0, w0, #0x1
    4000b78c:	0b130000 	add	w0, w0, w19
    4000b790:	7104001f 	cmp	w0, #0x100
    4000b794:	54fffa2d 	b.le	4000b6d8 <z_shell_wildcard_process+0x7c>
			ret_val = command_add(shell->ctx->temp_buff,
    4000b798:	52800033 	mov	w19, #0x1                   	// #1
				z_shell_fprintf(shell, SHELL_WARNING,
    4000b79c:	aa1403e3 	mov	x3, x20
    4000b7a0:	aa1503e0 	mov	x0, x21
    4000b7a4:	d0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000b7a8:	91384442 	add	x2, x2, #0xe11
    4000b7ac:	52800061 	mov	w1, #0x3                   	// #3
    4000b7b0:	97fffa33 	bl	4000a07c <z_shell_fprintf>
	if (cnt > 0) {
    4000b7b4:	b4fff678 	cbz	x24, 4000b680 <z_shell_wildcard_process+0x24>
		z_shell_pattern_remove(shell->ctx->temp_buff,
    4000b7b8:	f9400aa0 	ldr	x0, [x21, #16]
    4000b7bc:	aa1403e2 	mov	x2, x20
    4000b7c0:	9101d001 	add	x1, x0, #0x74
    4000b7c4:	9105d800 	add	x0, x0, #0x176
    4000b7c8:	97fff75c 	bl	40009538 <z_shell_pattern_remove>
	return ret_val;
    4000b7cc:	17ffffad 	b	4000b680 <z_shell_wildcard_process+0x24>
		return SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
    4000b7d0:	52800053 	mov	w19, #0x2                   	// #2
    4000b7d4:	17fffff8 	b	4000b7b4 <z_shell_wildcard_process+0x158>

000000004000b7d8 <z_shell_wildcard_finalize>:

void z_shell_wildcard_finalize(const struct shell *shell)
{
    4000b7d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000b7dc:	910003fd 	mov	x29, sp
    4000b7e0:	f9000bf3 	str	x19, [sp, #16]
    4000b7e4:	aa0003f3 	mov	x19, x0
	memcpy(shell->ctx->cmd_buff,
    4000b7e8:	f9400800 	ldr	x0, [x0, #16]
    4000b7ec:	9105d801 	add	x1, x0, #0x176
    4000b7f0:	9101d800 	add	x0, x0, #0x76
    4000b7f4:	785fe002 	ldurh	w2, [x0, #-2]
    4000b7f8:	940006c7 	bl	4000d314 <memcpy>
	       shell->ctx->temp_buff,
	       shell->ctx->cmd_tmp_buff_len);
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
    4000b7fc:	f9400a60 	ldr	x0, [x19, #16]
}
    4000b800:	f9400bf3 	ldr	x19, [sp, #16]
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
    4000b804:	7940e801 	ldrh	w1, [x0, #116]
    4000b808:	7900e001 	strh	w1, [x0, #112]
}
    4000b80c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000b810:	d65f03c0 	ret

000000004000b814 <stats_walk>:
 * @return 0 on success, the return code of the walk_func on abort.
 *
 */
int
stats_walk(struct stats_hdr *hdr, stats_walk_fn *walk_func, void *arg)
{
    4000b814:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4000b818:	910003fd 	mov	x29, sp
    4000b81c:	a90153f3 	stp	x19, x20, [sp, #16]
		dst[len++] = '0' + idx % 10;
    4000b820:	910163f3 	add	x19, sp, #0x58
	const char *name;
	char name_buf[STATS_GEN_NAME_MAX_LEN];
	int rc;
	int i;

	for (i = 0; i < hdr->s_cnt; i++) {
    4000b824:	52800014 	mov	w20, #0x0                   	// #0
{
    4000b828:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000b82c:	aa0003f5 	mov	x21, x0
    4000b830:	aa0103f6 	mov	x22, x1
    4000b834:	a90363f7 	stp	x23, x24, [sp, #48]
    4000b838:	aa0203f7 	mov	x23, x2
		dst[len++] = '0' + idx % 10;
    4000b83c:	52800158 	mov	w24, #0xa                   	// #10
{
    4000b840:	a9046bf9 	stp	x25, x26, [sp, #64]
	dst[len++] = 's';
    4000b844:	52800e79 	mov	w25, #0x73                  	// #115
	for (i = 0; i < len / 2; i++) {
    4000b848:	5280005a 	mov	w26, #0x2                   	// #2
	for (i = 0; i < hdr->s_cnt; i++) {
    4000b84c:	794016a0 	ldrh	w0, [x21, #10]
    4000b850:	6b14001f 	cmp	w0, w20
    4000b854:	5400010c 	b.gt	4000b874 <stats_walk+0x60>
		if (rc != 0) {
			return rc;
		}
	}

	return 0;
    4000b858:	52800000 	mov	w0, #0x0                   	// #0
}
    4000b85c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b860:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b864:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000b868:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000b86c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000b870:	d65f03c0 	ret
    4000b874:	2a1403e4 	mov	w4, w20
	len = 0;
    4000b878:	52800003 	mov	w3, #0x0                   	// #0
		dst[len++] = '0' + idx % 10;
    4000b87c:	1ad80882 	udiv	w2, w4, w24
    4000b880:	2a0303e0 	mov	w0, w3
    4000b884:	11000463 	add	w3, w3, #0x1
    4000b888:	1b189041 	msub	w1, w2, w24, w4
    4000b88c:	1100c021 	add	w1, w1, #0x30
    4000b890:	3820ca61 	strb	w1, [x19, w0, sxtw]
		idx /= 10;
    4000b894:	2a0403e1 	mov	w1, w4
    4000b898:	2a0203e4 	mov	w4, w2
	} while (idx > 0);
    4000b89c:	7100243f 	cmp	w1, #0x9
    4000b8a0:	54fffeec 	b.gt	4000b87c <stats_walk+0x68>
	dst[len++] = 's';
    4000b8a4:	11000800 	add	w0, w0, #0x2
    4000b8a8:	aa1303e1 	mov	x1, x19
	for (i = 0; i < len / 2; i++) {
    4000b8ac:	52800004 	mov	w4, #0x0                   	// #0
	dst[len++] = 's';
    4000b8b0:	3823ca79 	strb	w25, [x19, w3, sxtw]
	for (i = 0; i < len / 2; i++) {
    4000b8b4:	1ada0c05 	sdiv	w5, w0, w26
    4000b8b8:	6b05009f 	cmp	w4, w5
    4000b8bc:	5400018b 	b.lt	4000b8ec <stats_walk+0xd8>  // b.tstop
	return (uint16_t) (sizeof(*hdr) + idx * (int) hdr->s_size);
    4000b8c0:	394022a3 	ldrb	w3, [x21, #8]
		rc = walk_func(hdr, arg, name, stats_get_off(hdr, i));
    4000b8c4:	aa1303e2 	mov	x2, x19
    4000b8c8:	aa1703e1 	mov	x1, x23
	dst[len] = '\0';
    4000b8cc:	3820ca7f 	strb	wzr, [x19, w0, sxtw]
		rc = walk_func(hdr, arg, name, stats_get_off(hdr, i));
    4000b8d0:	aa1503e0 	mov	x0, x21
	return (uint16_t) (sizeof(*hdr) + idx * (int) hdr->s_size);
    4000b8d4:	1b037e83 	mul	w3, w20, w3
    4000b8d8:	11006063 	add	w3, w3, #0x18
		rc = walk_func(hdr, arg, name, stats_get_off(hdr, i));
    4000b8dc:	d63f02c0 	blr	x22
		if (rc != 0) {
    4000b8e0:	35fffbe0 	cbnz	w0, 4000b85c <stats_walk+0x48>
	for (i = 0; i < hdr->s_cnt; i++) {
    4000b8e4:	11000694 	add	w20, w20, #0x1
    4000b8e8:	17ffffd9 	b	4000b84c <stats_walk+0x38>
		dst[i] = dst[len - i - 1];
    4000b8ec:	4b040062 	sub	w2, w3, w4
		c = dst[i];
    4000b8f0:	39400026 	ldrb	w6, [x1]
	for (i = 0; i < len / 2; i++) {
    4000b8f4:	11000484 	add	w4, w4, #0x1
		dst[i] = dst[len - i - 1];
    4000b8f8:	3862ca67 	ldrb	w7, [x19, w2, sxtw]
    4000b8fc:	38001427 	strb	w7, [x1], #1
		dst[len - i - 1] = c;
    4000b900:	3822ca66 	strb	w6, [x19, w2, sxtw]
	for (i = 0; i < len / 2; i++) {
    4000b904:	17ffffed 	b	4000b8b8 <stats_walk+0xa4>

000000004000b908 <stats_group_walk>:
 *
 * @return 0 on success, non-zero error code on failure
 */
int
stats_group_walk(stats_group_walk_fn *walk_func, void *arg)
{
    4000b908:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000b90c:	910003fd 	mov	x29, sp
    4000b910:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b914:	aa0003f4 	mov	x20, x0
	struct stats_hdr *hdr;
	int rc;

	for (hdr = stats_list; hdr != NULL; hdr = hdr->s_next) {
    4000b918:	d00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000b91c:	f9439013 	ldr	x19, [x0, #1824]
{
    4000b920:	f90013f5 	str	x21, [sp, #32]
    4000b924:	aa0103f5 	mov	x21, x1
	for (hdr = stats_list; hdr != NULL; hdr = hdr->s_next) {
    4000b928:	b50000d3 	cbnz	x19, 4000b940 <stats_group_walk+0x38>
		if (rc != 0) {
			return rc;
		}
	}

	return 0;
    4000b92c:	52800000 	mov	w0, #0x0                   	// #0
}
    4000b930:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b934:	f94013f5 	ldr	x21, [sp, #32]
    4000b938:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000b93c:	d65f03c0 	ret
		rc = walk_func(hdr, arg);
    4000b940:	aa1503e1 	mov	x1, x21
    4000b944:	aa1303e0 	mov	x0, x19
    4000b948:	d63f0280 	blr	x20
		if (rc != 0) {
    4000b94c:	35ffff20 	cbnz	w0, 4000b930 <stats_group_walk+0x28>
	for (hdr = stats_list; hdr != NULL; hdr = hdr->s_next) {
    4000b950:	f9400a73 	ldr	x19, [x19, #16]
    4000b954:	17fffff5 	b	4000b928 <stats_group_walk+0x20>

000000004000b958 <cmd_stats_list>:
}

static int cmd_stats_list(const struct shell *sh, size_t argc,
			  char **argv)
{
	return stats_group_walk(stats_group_cb, (struct shell *)sh);
    4000b958:	aa0003e1 	mov	x1, x0
    4000b95c:	90000000 	adrp	x0, 4000b000 <cmd_resize+0x4c>
    4000b960:	91277000 	add	x0, x0, #0x9dc
    4000b964:	17ffffe9 	b	4000b908 <stats_group_walk>

000000004000b968 <stats_cb>:
{
    4000b968:	aa0003e6 	mov	x6, x0
    4000b96c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000b970:	aa0103e0 	mov	x0, x1
    4000b974:	910003fd 	mov	x29, sp
	switch (hdr->s_size) {
    4000b978:	394020c7 	ldrb	w7, [x6, #8]
{
    4000b97c:	12003c64 	and	w4, w3, #0xffff
	void *addr = (uint8_t *)hdr + off;
    4000b980:	92403c61 	and	x1, x3, #0xffff
    4000b984:	8b2320c5 	add	x5, x6, w3, uxth
	switch (hdr->s_size) {
    4000b988:	710010ff 	cmp	w7, #0x4
    4000b98c:	540001c0 	b.eq	4000b9c4 <stats_cb+0x5c>  // b.none
    4000b990:	710020ff 	cmp	w7, #0x8
    4000b994:	540001c0 	b.eq	4000b9cc <stats_cb+0x64>  // b.none
    4000b998:	710008ff 	cmp	w7, #0x2
    4000b99c:	540001c1 	b.ne	4000b9d4 <stats_cb+0x6c>  // b.any
		val = *(uint16_t *)(addr);
    4000b9a0:	786168c6 	ldrh	w6, [x6, x1]
	shell_print(sh, "\t%s (offset: %u, addr: %p): %" PRIu64, name, off, addr, val);
    4000b9a4:	aa0203e3 	mov	x3, x2
    4000b9a8:	52800101 	mov	w1, #0x8                   	// #8
    4000b9ac:	d0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000b9b0:	91398c42 	add	x2, x2, #0xe63
    4000b9b4:	97fff50c 	bl	40008de4 <shell_fprintf>
}
    4000b9b8:	52800000 	mov	w0, #0x0                   	// #0
    4000b9bc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b9c0:	d65f03c0 	ret
		val = *(uint32_t *)(addr);
    4000b9c4:	b86168c6 	ldr	w6, [x6, x1]
		break;
    4000b9c8:	17fffff7 	b	4000b9a4 <stats_cb+0x3c>
		val = *(uint64_t *)(addr);
    4000b9cc:	f86168c6 	ldr	x6, [x6, x1]
		break;
    4000b9d0:	17fffff5 	b	4000b9a4 <stats_cb+0x3c>
	switch (hdr->s_size) {
    4000b9d4:	d2800006 	mov	x6, #0x0                   	// #0
    4000b9d8:	17fffff3 	b	4000b9a4 <stats_cb+0x3c>

000000004000b9dc <stats_group_cb>:
{
    4000b9dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	shell_print(sh, "Stats Group %s (hdr addr: %p)", hdr->s_name, (void *)hdr);
    4000b9e0:	aa0003e4 	mov	x4, x0
    4000b9e4:	d0000042 	adrp	x2, 40015000 <prefix.1+0x2aa>
    4000b9e8:	913a1442 	add	x2, x2, #0xe85
{
    4000b9ec:	910003fd 	mov	x29, sp
    4000b9f0:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b9f4:	aa0003f3 	mov	x19, x0
    4000b9f8:	aa0103f4 	mov	x20, x1
	shell_print(sh, "Stats Group %s (hdr addr: %p)", hdr->s_name, (void *)hdr);
    4000b9fc:	aa1403e0 	mov	x0, x20
    4000ba00:	52800101 	mov	w1, #0x8                   	// #8
    4000ba04:	f9400263 	ldr	x3, [x19]
    4000ba08:	97fff4f7 	bl	40008de4 <shell_fprintf>
	return stats_walk(hdr, stats_cb, arg);
    4000ba0c:	aa1403e2 	mov	x2, x20
    4000ba10:	aa1303e0 	mov	x0, x19
}
    4000ba14:	a94153f3 	ldp	x19, x20, [sp, #16]
	return stats_walk(hdr, stats_cb, arg);
    4000ba18:	90000001 	adrp	x1, 4000b000 <cmd_resize+0x4c>
    4000ba1c:	9125a021 	add	x1, x1, #0x968
}
    4000ba20:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return stats_walk(hdr, stats_cb, arg);
    4000ba24:	17ffff7c 	b	4000b814 <stats_walk>

000000004000ba28 <arch_timing_init>:
#include <sys_clock.h>
#include <timing/timing.h>

void arch_timing_init(void)
{
}
    4000ba28:	d65f03c0 	ret

000000004000ba2c <arch_timing_start>:
    4000ba2c:	d65f03c0 	ret

000000004000ba30 <arch_timing_counter_get>:
void arch_timing_stop(void)
{
}

timing_t arch_timing_counter_get(void)
{
    4000ba30:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000ba34:	910003fd 	mov	x29, sp
    4000ba38:	940009e2 	bl	4000e1c0 <sys_clock_cycle_get_32>
	return k_cycle_get_32();
}
    4000ba3c:	2a0003e0 	mov	w0, w0
    4000ba40:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000ba44:	d65f03c0 	ret

000000004000ba48 <arch_cpu_idle>:
#ifdef CONFIG_TRACING
	stp	xzr, x30, [sp, #-16]!
	bl	sys_trace_idle
	ldp	xzr, x30, [sp], #16
#endif
	dsb	sy
    4000ba48:	d5033f9f 	dsb	sy
	wfi
    4000ba4c:	d503207f 	wfi
	msr	daifclr, #(DAIFCLR_IRQ_BIT)
    4000ba50:	d50342ff 	msr	daifclr, #0x2
	ret
    4000ba54:	d65f03c0 	ret

000000004000ba58 <z_arm64_fatal_error>:

	return false;
}

void z_arm64_fatal_error(unsigned int reason, z_arch_esf_t *esf)
{
    4000ba58:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	uint64_t esr = 0;
	uint64_t elr = 0;
	uint64_t far = 0;
	uint64_t el;

	if (reason != K_ERR_SPURIOUS_IRQ) {
    4000ba5c:	7100041f 	cmp	w0, #0x1
{
    4000ba60:	910003fd 	mov	x29, sp
    4000ba64:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ba68:	aa0103f4 	mov	x20, x1
    4000ba6c:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000ba70:	a90363f7 	stp	x23, x24, [sp, #48]
    4000ba74:	a9046bf9 	stp	x25, x26, [sp, #64]
    4000ba78:	2a0003f9 	mov	w25, w0
    4000ba7c:	a90573fb 	stp	x27, x28, [sp, #80]
	if (reason != K_ERR_SPURIOUS_IRQ) {
    4000ba80:	54000e20 	b.eq	4000bc44 <z_arm64_fatal_error+0x1ec>  // b.none
MAKE_REG_HELPER(currentel);
    4000ba84:	d5384240 	mrs	x0, currentel
		el = read_currentel();

		switch (GET_EL(el)) {
    4000ba88:	d3420c00 	ubfx	x0, x0, #2, #2
    4000ba8c:	f100041f 	cmp	x0, #0x1
    4000ba90:	54000100 	b.eq	4000bab0 <z_arm64_fatal_error+0x58>  // b.none
    4000ba94:	f1000c1f 	cmp	x0, #0x3
    4000ba98:	54000440 	b.eq	4000bb20 <z_arm64_fatal_error+0xc8>  // b.none
			far = read_far_el3();
			elr = read_elr_el3();
			break;
		}

		if (GET_EL(el) != MODE_EL0) {
    4000ba9c:	b4000d40 	cbz	x0, 4000bc44 <z_arm64_fatal_error+0x1ec>
	uint64_t esr = 0;
    4000baa0:	d2800017 	mov	x23, #0x0                   	// #0
	uint64_t elr = 0;
    4000baa4:	d2800001 	mov	x1, #0x0                   	// #0
	uint64_t far = 0;
    4000baa8:	d2800018 	mov	x24, #0x0                   	// #0
    4000baac:	14000004 	b	4000babc <z_arm64_fatal_error+0x64>
MAKE_REG_HELPER_EL123(esr)
    4000bab0:	d5385217 	mrs	x23, esr_el1
MAKE_REG_HELPER_EL123(far)
    4000bab4:	d5386018 	mrs	x24, far_el1
MAKE_REG_HELPER_EL123(elr)
    4000bab8:	d5384021 	mrs	x1, elr_el1
#ifdef CONFIG_EXCEPTION_DEBUG
			bool dump_far = false;

			LOG_ERR("ELR_ELn: 0x%016llx", elr);
    4000babc:	90000336 	adrp	x22, 4006f000 <sys_work_q_stack+0xc10>
    4000bac0:	913372d5 	add	x21, x22, #0xcdc
    4000bac4:	b94cdec0 	ldr	w0, [x22, #3292]
    4000bac8:	f240081f 	tst	x0, #0x7
    4000bacc:	54000140 	b.eq	4000baf4 <z_arm64_fatal_error+0x9c>  // b.none
    4000bad0:	90000322 	adrp	x2, 4006f000 <sys_work_q_stack+0xc10>
    4000bad4:	91334042 	add	x2, x2, #0xcd0
    4000bad8:	cb0202a2 	sub	x2, x21, x2
    4000badc:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bae0:	9115ac00 	add	x0, x0, #0x56b
    4000bae4:	d342fc42 	lsr	x2, x2, #2
    4000bae8:	531a2442 	ubfiz	w2, w2, #6, #10
    4000baec:	32000042 	orr	w2, w2, #0x1
    4000baf0:	97ffe37b 	bl	400048dc <log_1>
	switch (GET_ESR_EC(esr)) {
    4000baf4:	531a7efb 	lsr	w27, w23, #26
    4000baf8:	f100f37f 	cmp	x27, #0x3c
    4000bafc:	540023c8 	b.hi	4000bf74 <z_arm64_fatal_error+0x51c>  // b.pmore
    4000bb00:	7100f37f 	cmp	w27, #0x3c
    4000bb04:	54002388 	b.hi	4000bf74 <z_arm64_fatal_error+0x51c>  // b.pmore
    4000bb08:	b0000040 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    4000bb0c:	91146000 	add	x0, x0, #0x518
    4000bb10:	787b5800 	ldrh	w0, [x0, w27, uxtw #1]
    4000bb14:	10000061 	adr	x1, 4000bb20 <z_arm64_fatal_error+0xc8>
    4000bb18:	8b20a820 	add	x0, x1, w0, sxth #2
    4000bb1c:	d61f0000 	br	x0
MAKE_REG_HELPER_EL123(esr)
    4000bb20:	d53e5217 	mrs	x23, esr_el3
MAKE_REG_HELPER_EL123(far)
    4000bb24:	d53e6018 	mrs	x24, far_el3
MAKE_REG_HELPER_EL123(elr)
    4000bb28:	d53e4021 	mrs	x1, elr_el3
			break;
    4000bb2c:	17ffffe4 	b	4000babc <z_arm64_fatal_error+0x64>
		err = "Trapped WFI or WFE instruction execution";
    4000bb30:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bb34:	91150a73 	add	x19, x19, #0x542
			bool dump_far = false;
    4000bb38:	5280001a 	mov	w26, #0x0                   	// #0
	LOG_ERR("ESR_ELn: 0x%016llx", esr);
    4000bb3c:	b94cdec0 	ldr	w0, [x22, #3292]
    4000bb40:	f240081f 	tst	x0, #0x7
    4000bb44:	540004a0 	b.eq	4000bbd8 <z_arm64_fatal_error+0x180>  // b.none
    4000bb48:	9000033c 	adrp	x28, 4006f000 <sys_work_q_stack+0xc10>
    4000bb4c:	9133439c 	add	x28, x28, #0xcd0
    4000bb50:	cb1c02bc 	sub	x28, x21, x28
    4000bb54:	aa1703e1 	mov	x1, x23
    4000bb58:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bb5c:	9115f800 	add	x0, x0, #0x57e
    4000bb60:	d342ff9c 	lsr	x28, x28, #2
    4000bb64:	531a279c 	ubfiz	w28, w28, #6, #10
    4000bb68:	3200039c 	orr	w28, w28, #0x1
    4000bb6c:	2a1c03e2 	mov	w2, w28
    4000bb70:	97ffe35b 	bl	400048dc <log_1>
	LOG_ERR("  EC:  0x%llx (%s)", GET_ESR_EC(esr), err);
    4000bb74:	b94cdec0 	ldr	w0, [x22, #3292]
    4000bb78:	f240081f 	tst	x0, #0x7
    4000bb7c:	540002e0 	b.eq	4000bbd8 <z_arm64_fatal_error+0x180>  // b.none
    4000bb80:	2a1c03e3 	mov	w3, w28
    4000bb84:	aa1303e2 	mov	x2, x19
    4000bb88:	aa1b03e1 	mov	x1, x27
    4000bb8c:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bb90:	91164400 	add	x0, x0, #0x591
    4000bb94:	97ffe369 	bl	40004938 <log_2>
	LOG_ERR("  IL:  0x%llx", GET_ESR_IL(esr));
    4000bb98:	b94cdec0 	ldr	w0, [x22, #3292]
    4000bb9c:	f240081f 	tst	x0, #0x7
    4000bba0:	540001c0 	b.eq	4000bbd8 <z_arm64_fatal_error+0x180>  // b.none
    4000bba4:	2a1c03e2 	mov	w2, w28
    4000bba8:	d35966e1 	ubfx	x1, x23, #25, #1
    4000bbac:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bbb0:	91169000 	add	x0, x0, #0x5a4
    4000bbb4:	97ffe34a 	bl	400048dc <log_1>
	LOG_ERR("  ISS: 0x%llx", GET_ESR_ISS(esr));
    4000bbb8:	b94cdec0 	ldr	w0, [x22, #3292]
    4000bbbc:	f240081f 	tst	x0, #0x7
    4000bbc0:	540000c0 	b.eq	4000bbd8 <z_arm64_fatal_error+0x180>  // b.none
    4000bbc4:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bbc8:	9116c800 	add	x0, x0, #0x5b2
    4000bbcc:	2a1c03e2 	mov	w2, w28
    4000bbd0:	924062e1 	and	x1, x23, #0x1ffffff
    4000bbd4:	97ffe342 	bl	400048dc <log_1>

			dump_esr(esr, &dump_far);

			if (dump_far)
    4000bbd8:	340001da 	cbz	w26, 4000bc10 <z_arm64_fatal_error+0x1b8>
				LOG_ERR("FAR_ELn: 0x%016llx", far);
    4000bbdc:	b94cdec0 	ldr	w0, [x22, #3292]
    4000bbe0:	f240081f 	tst	x0, #0x7
    4000bbe4:	54000300 	b.eq	4000bc44 <z_arm64_fatal_error+0x1ec>  // b.none
    4000bbe8:	90000322 	adrp	x2, 4006f000 <sys_work_q_stack+0xc10>
    4000bbec:	91334042 	add	x2, x2, #0xcd0
    4000bbf0:	cb0202a2 	sub	x2, x21, x2
    4000bbf4:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bbf8:	91170000 	add	x0, x0, #0x5c0
    4000bbfc:	aa1803e1 	mov	x1, x24
    4000bc00:	d342fc42 	lsr	x2, x2, #2
    4000bc04:	531a2442 	ubfiz	w2, w2, #6, #10
    4000bc08:	32000042 	orr	w2, w2, #0x1
    4000bc0c:	97ffe334 	bl	400048dc <log_1>

			LOG_ERR("TPIDRRO: 0x%016llx", read_tpidrro_el0());
    4000bc10:	b94cdec0 	ldr	w0, [x22, #3292]
    4000bc14:	f240081f 	tst	x0, #0x7
    4000bc18:	54000160 	b.eq	4000bc44 <z_arm64_fatal_error+0x1ec>  // b.none
    4000bc1c:	90000322 	adrp	x2, 4006f000 <sys_work_q_stack+0xc10>
    4000bc20:	91334042 	add	x2, x2, #0xcd0
    4000bc24:	cb0202a2 	sub	x2, x21, x2
    4000bc28:	d342fc42 	lsr	x2, x2, #2
    4000bc2c:	531a2442 	ubfiz	w2, w2, #6, #10
    4000bc30:	32000042 	orr	w2, w2, #0x1
MAKE_REG_HELPER(tpidrro_el0);
    4000bc34:	d53bd061 	mrs	x1, tpidrro_el0
    4000bc38:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bc3c:	91174c00 	add	x0, x0, #0x5d3
    4000bc40:	97ffe327 	bl	400048dc <log_1>
				return;
		}
	}

#ifdef CONFIG_EXCEPTION_DEBUG
	if (esf != NULL) {
    4000bc44:	b4000b34 	cbz	x20, 4000bda8 <z_arm64_fatal_error+0x350>
	LOG_ERR("x0:  0x%016llx  x1:  0x%016llx", esf->x0, esf->x1);
    4000bc48:	90000333 	adrp	x19, 4006f000 <sys_work_q_stack+0xc10>
    4000bc4c:	91337275 	add	x21, x19, #0xcdc
    4000bc50:	b94cde60 	ldr	w0, [x19, #3292]
    4000bc54:	f240081f 	tst	x0, #0x7
    4000bc58:	54000a80 	b.eq	4000bda8 <z_arm64_fatal_error+0x350>  // b.none
    4000bc5c:	90000320 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000bc60:	91334000 	add	x0, x0, #0xcd0
    4000bc64:	cb0002b5 	sub	x21, x21, x0
    4000bc68:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bc6c:	91179800 	add	x0, x0, #0x5e6
    4000bc70:	a9400a81 	ldp	x1, x2, [x20]
    4000bc74:	d342feb5 	lsr	x21, x21, #2
    4000bc78:	531a26b5 	ubfiz	w21, w21, #6, #10
    4000bc7c:	320002b6 	orr	w22, w21, #0x1
    4000bc80:	2a1603e3 	mov	w3, w22
    4000bc84:	97ffe32d 	bl	40004938 <log_2>
	LOG_ERR("x2:  0x%016llx  x3:  0x%016llx", esf->x2, esf->x3);
    4000bc88:	b94cde60 	ldr	w0, [x19, #3292]
    4000bc8c:	f240081f 	tst	x0, #0x7
    4000bc90:	540008c0 	b.eq	4000bda8 <z_arm64_fatal_error+0x350>  // b.none
    4000bc94:	a9410a81 	ldp	x1, x2, [x20, #16]
    4000bc98:	2a1603e3 	mov	w3, w22
    4000bc9c:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bca0:	91181400 	add	x0, x0, #0x605
    4000bca4:	97ffe325 	bl	40004938 <log_2>
	LOG_ERR("x4:  0x%016llx  x5:  0x%016llx", esf->x4, esf->x5);
    4000bca8:	b94cde60 	ldr	w0, [x19, #3292]
    4000bcac:	f240081f 	tst	x0, #0x7
    4000bcb0:	540007c0 	b.eq	4000bda8 <z_arm64_fatal_error+0x350>  // b.none
    4000bcb4:	a9420a81 	ldp	x1, x2, [x20, #32]
    4000bcb8:	2a1603e3 	mov	w3, w22
    4000bcbc:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bcc0:	91189000 	add	x0, x0, #0x624
    4000bcc4:	97ffe31d 	bl	40004938 <log_2>
	LOG_ERR("x6:  0x%016llx  x7:  0x%016llx", esf->x6, esf->x7);
    4000bcc8:	b94cde60 	ldr	w0, [x19, #3292]
    4000bccc:	f240081f 	tst	x0, #0x7
    4000bcd0:	540006c0 	b.eq	4000bda8 <z_arm64_fatal_error+0x350>  // b.none
    4000bcd4:	a9430a81 	ldp	x1, x2, [x20, #48]
    4000bcd8:	2a1603e3 	mov	w3, w22
    4000bcdc:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bce0:	91190c00 	add	x0, x0, #0x643
    4000bce4:	97ffe315 	bl	40004938 <log_2>
	LOG_ERR("x8:  0x%016llx  x9:  0x%016llx", esf->x8, esf->x9);
    4000bce8:	b94cde60 	ldr	w0, [x19, #3292]
    4000bcec:	f240081f 	tst	x0, #0x7
    4000bcf0:	540005c0 	b.eq	4000bda8 <z_arm64_fatal_error+0x350>  // b.none
    4000bcf4:	a9440a81 	ldp	x1, x2, [x20, #64]
    4000bcf8:	2a1603e3 	mov	w3, w22
    4000bcfc:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bd00:	91198800 	add	x0, x0, #0x662
    4000bd04:	97ffe30d 	bl	40004938 <log_2>
	LOG_ERR("x10: 0x%016llx  x11: 0x%016llx", esf->x10, esf->x11);
    4000bd08:	b94cde60 	ldr	w0, [x19, #3292]
    4000bd0c:	f240081f 	tst	x0, #0x7
    4000bd10:	540004c0 	b.eq	4000bda8 <z_arm64_fatal_error+0x350>  // b.none
    4000bd14:	a9450a81 	ldp	x1, x2, [x20, #80]
    4000bd18:	2a1603e3 	mov	w3, w22
    4000bd1c:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bd20:	911a0400 	add	x0, x0, #0x681
    4000bd24:	97ffe305 	bl	40004938 <log_2>
	LOG_ERR("x12: 0x%016llx  x13: 0x%016llx", esf->x12, esf->x13);
    4000bd28:	b94cde60 	ldr	w0, [x19, #3292]
    4000bd2c:	f240081f 	tst	x0, #0x7
    4000bd30:	540003c0 	b.eq	4000bda8 <z_arm64_fatal_error+0x350>  // b.none
    4000bd34:	a9460a81 	ldp	x1, x2, [x20, #96]
    4000bd38:	2a1603e3 	mov	w3, w22
    4000bd3c:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bd40:	911a8000 	add	x0, x0, #0x6a0
    4000bd44:	97ffe2fd 	bl	40004938 <log_2>
	LOG_ERR("x14: 0x%016llx  x15: 0x%016llx", esf->x14, esf->x15);
    4000bd48:	b94cde60 	ldr	w0, [x19, #3292]
    4000bd4c:	f240081f 	tst	x0, #0x7
    4000bd50:	540002c0 	b.eq	4000bda8 <z_arm64_fatal_error+0x350>  // b.none
    4000bd54:	a9470a81 	ldp	x1, x2, [x20, #112]
    4000bd58:	2a1603e3 	mov	w3, w22
    4000bd5c:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bd60:	911afc00 	add	x0, x0, #0x6bf
    4000bd64:	97ffe2f5 	bl	40004938 <log_2>
	LOG_ERR("x16: 0x%016llx  x17: 0x%016llx", esf->x16, esf->x17);
    4000bd68:	b94cde60 	ldr	w0, [x19, #3292]
    4000bd6c:	f240081f 	tst	x0, #0x7
    4000bd70:	540001c0 	b.eq	4000bda8 <z_arm64_fatal_error+0x350>  // b.none
    4000bd74:	a9480a81 	ldp	x1, x2, [x20, #128]
    4000bd78:	2a1603e3 	mov	w3, w22
    4000bd7c:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bd80:	911b7800 	add	x0, x0, #0x6de
    4000bd84:	97ffe2ed 	bl	40004938 <log_2>
	LOG_ERR("x18: 0x%016llx  x30: 0x%016llx", esf->x18, esf->x30);
    4000bd88:	b94cde60 	ldr	w0, [x19, #3292]
    4000bd8c:	f240081f 	tst	x0, #0x7
    4000bd90:	540000c0 	b.eq	4000bda8 <z_arm64_fatal_error+0x350>  // b.none
    4000bd94:	a9490a81 	ldp	x1, x2, [x20, #144]
    4000bd98:	f0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bd9c:	911bf400 	add	x0, x0, #0x6fd
    4000bda0:	2a1603e3 	mov	w3, w22
    4000bda4:	97ffe2e5 	bl	40004938 <log_2>
		esf_dump(esf);
	}
#endif /* CONFIG_EXCEPTION_DEBUG */

	z_fatal_error(reason, esf);
    4000bda8:	aa1403e1 	mov	x1, x20
    4000bdac:	2a1903e0 	mov	w0, w25
    4000bdb0:	9400099d 	bl	4000e424 <z_fatal_error>
		err = "Trapped MCR or MRC access with (coproc==0b1111) that "
    4000bdb4:	d0000053 	adrp	x19, 40015000 <prefix.1+0x2aa>
    4000bdb8:	913b5673 	add	x19, x19, #0xed5
			bool dump_far = false;
    4000bdbc:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bdc0:	17ffff5f 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Trapped MCRR or MRRC access with (coproc==0b1111) "
    4000bdc4:	d0000053 	adrp	x19, 40015000 <prefix.1+0x2aa>
    4000bdc8:	913cb273 	add	x19, x19, #0xf2c
			bool dump_far = false;
    4000bdcc:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bdd0:	17ffff5b 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Trapped MCR or MRC access with (coproc==0b1110)";
    4000bdd4:	d0000053 	adrp	x19, 40015000 <prefix.1+0x2aa>
    4000bdd8:	913e1673 	add	x19, x19, #0xf85
			bool dump_far = false;
    4000bddc:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bde0:	17ffff57 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Trapped LDC or STC access";
    4000bde4:	d0000053 	adrp	x19, 40015000 <prefix.1+0x2aa>
    4000bde8:	913ed673 	add	x19, x19, #0xfb5
			bool dump_far = false;
    4000bdec:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bdf0:	17ffff53 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Trapped access to SVE, Advanced SIMD, or "
    4000bdf4:	d0000053 	adrp	x19, 40015000 <prefix.1+0x2aa>
    4000bdf8:	913f3e73 	add	x19, x19, #0xfcf
			bool dump_far = false;
    4000bdfc:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000be00:	17ffff4f 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Trapped MRRC access with (coproc==0b1110)";
    4000be04:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000be08:	91005673 	add	x19, x19, #0x15
			bool dump_far = false;
    4000be0c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000be10:	17ffff4b 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Branch Target Exception";
    4000be14:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000be18:	9100fe73 	add	x19, x19, #0x3f
			bool dump_far = false;
    4000be1c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000be20:	17ffff47 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Illegal Execution state";
    4000be24:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000be28:	91015e73 	add	x19, x19, #0x57
			bool dump_far = false;
    4000be2c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000be30:	17ffff43 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "SVC instruction execution in AArch32 state";
    4000be34:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000be38:	9101be73 	add	x19, x19, #0x6f
			bool dump_far = false;
    4000be3c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000be40:	17ffff3f 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Trapped MSR, MRS or System instruction execution in "
    4000be44:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000be48:	91026a73 	add	x19, x19, #0x9a
			bool dump_far = false;
    4000be4c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000be50:	17ffff3b 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Trapped access to SVE functionality";
    4000be54:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000be58:	91046a73 	add	x19, x19, #0x11a
			bool dump_far = false;
    4000be5c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000be60:	17ffff37 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Instruction Abort from a lower Exception level, that "
    4000be64:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000be68:	9104fa73 	add	x19, x19, #0x13e
		*dump_far = true;
    4000be6c:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000be70:	17ffff33 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Instruction Abort taken without a change in Exception "
    4000be74:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000be78:	91065673 	add	x19, x19, #0x195
		*dump_far = true;
    4000be7c:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000be80:	17ffff2f 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "PC alignment fault exception.";
    4000be84:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000be88:	91074a73 	add	x19, x19, #0x1d2
		*dump_far = true;
    4000be8c:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000be90:	17ffff2b 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Data Abort from a lower Exception level, that might "
    4000be94:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000be98:	9107c273 	add	x19, x19, #0x1f0
		*dump_far = true;
    4000be9c:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000bea0:	17ffff27 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Data Abort taken without a change in Exception level";
    4000bea4:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bea8:	91090273 	add	x19, x19, #0x240
		*dump_far = true;
    4000beac:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000beb0:	17ffff23 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "SP alignment fault exception";
    4000beb4:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000beb8:	9109d673 	add	x19, x19, #0x275
			bool dump_far = false;
    4000bebc:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bec0:	17ffff1f 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Trapped floating-point exception taken from AArch32 "
    4000bec4:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bec8:	910a4a73 	add	x19, x19, #0x292
			bool dump_far = false;
    4000becc:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bed0:	17ffff1b 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Trapped floating-point exception taken from AArch64 "
    4000bed4:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bed8:	910b3273 	add	x19, x19, #0x2cc
			bool dump_far = false;
    4000bedc:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bee0:	17ffff17 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "SError interrupt";
    4000bee4:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bee8:	910c1e73 	add	x19, x19, #0x307
			bool dump_far = false;
    4000beec:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bef0:	17ffff13 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Breakpoint exception from a lower Exception level, "
    4000bef4:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bef8:	910c6273 	add	x19, x19, #0x318
			bool dump_far = false;
    4000befc:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bf00:	17ffff0f 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Breakpoint exception taken without a change in "
    4000bf04:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bf08:	910dca73 	add	x19, x19, #0x372
			bool dump_far = false;
    4000bf0c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bf10:	17ffff0b 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Software Step exception from a lower Exception level, "
    4000bf14:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bf18:	910ec673 	add	x19, x19, #0x3b1
			bool dump_far = false;
    4000bf1c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bf20:	17ffff07 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Software Step exception taken without a change in "
    4000bf24:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bf28:	91103a73 	add	x19, x19, #0x40e
			bool dump_far = false;
    4000bf2c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bf30:	17ffff03 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Watchpoint exception from a lower Exception level, "
    4000bf34:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bf38:	91114273 	add	x19, x19, #0x450
		*dump_far = true;
    4000bf3c:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000bf40:	17fffeff 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Watchpoint exception taken without a change in "
    4000bf44:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bf48:	9112aa73 	add	x19, x19, #0x4aa
		*dump_far = true;
    4000bf4c:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000bf50:	17fffefb 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "BKPT instruction execution in AArch32 state";
    4000bf54:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bf58:	9113aa73 	add	x19, x19, #0x4ea
			bool dump_far = false;
    4000bf5c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bf60:	17fffef7 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "BRK instruction execution in AArch64 state.";
    4000bf64:	f0000053 	adrp	x19, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000bf68:	91145a73 	add	x19, x19, #0x516
			bool dump_far = false;
    4000bf6c:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000bf70:	17fffef3 	b	4000bb3c <z_arm64_fatal_error+0xe4>
		err = "Unknown";
    4000bf74:	d0000053 	adrp	x19, 40015000 <prefix.1+0x2aa>
    4000bf78:	913afa73 	add	x19, x19, #0xebe
			bool dump_far = false;
    4000bf7c:	5280001a 	mov	w26, #0x0                   	// #0
    4000bf80:	17fffeef 	b	4000bb3c <z_arm64_fatal_error+0xe4>
	switch (GET_ESR_EC(esr)) {
    4000bf84:	d0000053 	adrp	x19, 40015000 <prefix.1+0x2aa>
    4000bf88:	913b1a73 	add	x19, x19, #0xec6
    4000bf8c:	5280001a 	mov	w26, #0x0                   	// #0
    4000bf90:	17fffeeb 	b	4000bb3c <z_arm64_fatal_error+0xe4>

000000004000bf94 <z_arm64_do_kernel_oops>:
 * (e.g. kernel oops, panic, etc.).
 *
 * @param esf exception frame
 */
void z_arm64_do_kernel_oops(z_arch_esf_t *esf)
{
    4000bf94:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000bf98:	aa0003e1 	mov	x1, x0
    4000bf9c:	910003fd 	mov	x29, sp
		reason != K_ERR_STACK_CHK_FAIL) {
		reason = K_ERR_KERNEL_OOPS;
	}
#endif

	z_arm64_fatal_error(reason, esf);
    4000bfa0:	b9404000 	ldr	w0, [x0, #64]
    4000bfa4:	97fffead 	bl	4000ba58 <z_arm64_fatal_error>

000000004000bfa8 <z_arm64_interrupt_init>:
{
#ifdef CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER
	/* Invoke SoC-specific interrupt controller initialisation */
	z_soc_irq_init();
#endif
}
    4000bfa8:	d65f03c0 	ret

000000004000bfac <arch_irq_enable>:
 * `include/arch/arm64/irq.h`.
 */

void arch_irq_enable(unsigned int irq)
{
	arm_gic_irq_enable(irq);
    4000bfac:	140006ed 	b	4000db60 <arm_gic_irq_enable>

000000004000bfb0 <z_arm64_irq_priority_set>:
	return arm_gic_irq_is_enabled(irq);
}

void z_arm64_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	arm_gic_irq_set_priority(irq, prio, flags);
    4000bfb0:	140006bd 	b	4000daa4 <arm_gic_irq_set_priority>

000000004000bfb4 <z_irq_spurious>:

void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm64_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    4000bfb4:	d2800001 	mov	x1, #0x0                   	// #0
    4000bfb8:	52800020 	mov	w0, #0x1                   	// #1
    4000bfbc:	17fffea7 	b	4000ba58 <z_arm64_fatal_error>

000000004000bfc0 <z_arm64_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm64_prep_c(void)
{
    4000bfc0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000bfc4:	d00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000bfc8:	911d8000 	add	x0, x0, #0x760
    4000bfcc:	910003fd 	mov	x29, sp
    4000bfd0:	d51bd060 	msr	tpidrro_el0, x0
	uint64_t *p = (uint64_t *)__bss_start;
    4000bfd4:	90000060 	adrp	x0, 40017000 <__aarch64_have_lse_atomics>
    4000bfd8:	91000000 	add	x0, x0, #0x0
	while (p < end) {
    4000bfdc:	d00002e1 	adrp	x1, 40069000 <z_page_frames+0x47413>
    4000bfe0:	912fc021 	add	x1, x1, #0xbf0
    4000bfe4:	eb01001f 	cmp	x0, x1
    4000bfe8:	540000a3 	b.cc	4000bffc <z_arm64_prep_c+0x3c>  // b.lo, b.ul, b.last

	z_arm64_bss_zero();
#ifdef CONFIG_XIP
	z_data_copy();
#endif
	z_arm64_mm_init(true);
    4000bfec:	52800020 	mov	w0, #0x1                   	// #1
    4000bff0:	9400024e 	bl	4000c928 <z_arm64_mm_init>
	z_arm64_interrupt_init();
    4000bff4:	97ffffed 	bl	4000bfa8 <z_arm64_interrupt_init>
	z_cstart();
    4000bff8:	94000990 	bl	4000e638 <z_cstart>
		*p++ = 0U;
    4000bffc:	f800841f 	str	xzr, [x0], #8
    4000c000:	17fffff9 	b	4000bfe4 <z_arm64_prep_c+0x24>

000000004000c004 <z_arm64_el3_plat_prep_c>:
	ret
    4000c004:	d65f03c0 	ret

000000004000c008 <z_arm64_el2_plat_prep_c>:
	ret
    4000c008:	d65f03c0 	ret

000000004000c00c <z_arm64_el1_plat_prep_c>:
	ret
    4000c00c:	d65f03c0 	ret

000000004000c010 <el3_get_next_el>:
MAKE_REG_HELPER(id_aa64pfr0_el1);
    4000c010:	d5380400 	mrs	x0, id_aa64pfr0_el1
	EL3_TO_EL1_SKIP_EL2
};

static inline enum el3_next_el el3_get_next_el(void)
{
	if (!is_el_implemented(2)) {
    4000c014:	f2780c1f 	tst	x0, #0xf00
    4000c018:	540000c0 	b.eq	4000c030 <el3_get_next_el+0x20>  // b.none
    4000c01c:	d5380400 	mrs	x0, id_aa64pfr0_el1
		 * implemented and the value of the SCR_EL3.NS bit is 0 if
		 * ARMv8.4-SecEL2 is not implemented" (D1.11.2 from ARM DDI 0487E.a)
		 */
		return EL3_TO_EL1_SKIP_EL2;
	} else {
		return EL3_TO_EL2;
    4000c020:	f25c0c1f 	tst	x0, #0xf000000000
    4000c024:	1a9f17e0 	cset	w0, eq  // eq = none
    4000c028:	531f7800 	lsl	w0, w0, #1
	}
}
    4000c02c:	d65f03c0 	ret
		return EL3_TO_EL1_NO_EL2;
    4000c030:	52800020 	mov	w0, #0x1                   	// #1
    4000c034:	17fffffe 	b	4000c02c <el3_get_next_el+0x1c>

000000004000c038 <z_arm64_el_highest_plat_init>:
}
    4000c038:	d65f03c0 	ret

000000004000c03c <z_arm64_el2_plat_init>:
    4000c03c:	d65f03c0 	ret

000000004000c040 <z_arm64_el1_plat_init>:
    4000c040:	d65f03c0 	ret

000000004000c044 <z_arm64_el_highest_init>:
{
    4000c044:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000c048:	910003fd 	mov	x29, sp
    4000c04c:	d5380400 	mrs	x0, id_aa64pfr0_el1
static inline bool is_el_highest_implemented(void)
{
	uint32_t el_highest;
	uint32_t curr_el;

	el_highest = read_id_aa64pfr0_el1() & 0xFFFF;
    4000c050:	12003c00 	and	w0, w0, #0xffff
	el_highest = (31U - __builtin_clz(el_highest)) / 4;
    4000c054:	5ac01000 	clz	w0, w0
MAKE_REG_HELPER(currentel);
    4000c058:	d5384241 	mrs	x1, currentel
	el_highest = (31U - __builtin_clz(el_highest)) / 4;
    4000c05c:	528003e2 	mov	w2, #0x1f                  	// #31
    4000c060:	4b000040 	sub	w0, w2, w0

	curr_el = GET_EL(read_currentel());
    4000c064:	53020c21 	ubfx	w1, w1, #2, #2

	if (curr_el < el_highest)
    4000c068:	6b40083f 	cmp	w1, w0, lsr #2
    4000c06c:	54000083 	b.cc	4000c07c <z_arm64_el_highest_init+0x38>  // b.lo, b.ul, b.last
MAKE_REG_HELPER(cntfrq_el0);
    4000c070:	d2959400 	mov	x0, #0xaca0                	// #44192
    4000c074:	f2a07720 	movk	x0, #0x3b9, lsl #16
    4000c078:	d51be000 	msr	cntfrq_el0, x0
	z_arm64_el_highest_plat_init();
    4000c07c:	97ffffef 	bl	4000c038 <z_arm64_el_highest_plat_init>
	isb();
    4000c080:	d5033fdf 	isb
}
    4000c084:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000c088:	d65f03c0 	ret

000000004000c08c <z_arm64_el2_init>:
		z_arm64_el2_init();
	}
}

void z_arm64_el2_init(void)
{
    4000c08c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000c090:	910003fd 	mov	x29, sp
MAKE_REG_HELPER_EL123(sctlr)
    4000c094:	d53c1000 	mrs	x0, sctlr_el2
	uint64_t reg;

	reg = read_sctlr_el2();
	reg |= (SCTLR_EL2_RES1 |	/* RES1 */
    4000c098:	d2830701 	mov	x1, #0x1838                	// #6200
    4000c09c:	f2a618a1 	movk	x1, #0x30c5, lsl #16
    4000c0a0:	aa010000 	orr	x0, x0, x1
    4000c0a4:	d51c1000 	msr	sctlr_el2, x0
MAKE_REG_HELPER(hcr_el2);
    4000c0a8:	d53c1100 	mrs	x0, hcr_el2
		SCTLR_I_BIT |		/* Enable i-cache */
		SCTLR_SA_BIT);		/* Enable SP alignment check */
	write_sctlr_el2(reg);

	reg = read_hcr_el2();
	reg |= HCR_RW_BIT;		/* EL1 Execution state is AArch64 */
    4000c0ac:	b2610000 	orr	x0, x0, #0x80000000
    4000c0b0:	d51c1100 	msr	hcr_el2, x0
MAKE_REG_HELPER_EL123(cptr)
    4000c0b4:	d2865fe0 	mov	x0, #0x32ff                	// #13055
    4000c0b8:	d51c1140 	msr	cptr_el2, x0
MAKE_REG_HELPER(cntvoff_el2);
    4000c0bc:	d51ce07f 	msr	cntvoff_el2, xzr
MAKE_REG_HELPER(cnthctl_el2);
    4000c0c0:	d51ce11f 	msr	cnthctl_el2, xzr
MAKE_REG_HELPER(cnthp_ctl_el2);
    4000c0c4:	d51ce23f 	msr	cnthp_ctl_el2, xzr
	/*
	 * Enable this if/when we use the hypervisor timer.
	 * write_cnthp_cval_el2(~(uint64_t)0);
	 */

	z_arm64_el2_plat_init();
    4000c0c8:	97ffffdd 	bl	4000c03c <z_arm64_el2_plat_init>

	isb();
    4000c0cc:	d5033fdf 	isb
}
    4000c0d0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000c0d4:	d65f03c0 	ret

000000004000c0d8 <z_arm64_el3_init>:
{
    4000c0d8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER_EL123(vbar)
    4000c0dc:	90ffffa0 	adrp	x0, 40000000 <__text_region_start>
    4000c0e0:	91200000 	add	x0, x0, #0x800
    4000c0e4:	910003fd 	mov	x29, sp
    4000c0e8:	d51ec000 	msr	vbar_el3, x0
	isb();
    4000c0ec:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(cptr)
    4000c0f0:	d2800000 	mov	x0, #0x0                   	// #0
    4000c0f4:	d51e1140 	msr	cptr_el3, x0
MAKE_REG_HELPER(scr_el3);
    4000c0f8:	d281b600 	mov	x0, #0xdb0                 	// #3504
    4000c0fc:	d51e1100 	msr	scr_el3, x0
	reg = read_sysreg(ICC_SRE_EL3);
    4000c100:	d53ecca0 	mrs	x0, s3_6_c12_c12_5
	write_sysreg(reg, ICC_SRE_EL3);
    4000c104:	d2800120 	mov	x0, #0x9                   	// #9
    4000c108:	d51ecca0 	msr	s3_6_c12_c12_5, x0
	z_arm64_el3_plat_init();
    4000c10c:	97ffdfea 	bl	400040b4 <z_arm64_el3_plat_init>
	isb();
    4000c110:	d5033fdf 	isb
	if (el3_get_next_el() == EL3_TO_EL1_SKIP_EL2) {
    4000c114:	97ffffbf 	bl	4000c010 <el3_get_next_el>
    4000c118:	7100081f 	cmp	w0, #0x2
    4000c11c:	54000061 	b.ne	4000c128 <z_arm64_el3_init+0x50>  // b.any
}
    4000c120:	a8c17bfd 	ldp	x29, x30, [sp], #16
		z_arm64_el2_init();
    4000c124:	17ffffda 	b	4000c08c <z_arm64_el2_init>
}
    4000c128:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000c12c:	d65f03c0 	ret

000000004000c130 <z_arm64_el1_init>:

void z_arm64_el1_init(void)
{
    4000c130:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER_EL123(vbar)
    4000c134:	90ffffa0 	adrp	x0, 40000000 <__text_region_start>
    4000c138:	91200000 	add	x0, x0, #0x800
    4000c13c:	910003fd 	mov	x29, sp
    4000c140:	d518c000 	msr	vbar_el1, x0
	uint64_t reg;

	/* Setup vector table */
	write_vbar_el1((uint64_t)_vector_table);
	isb();
    4000c144:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(cpacr)
    4000c148:	d2a00600 	mov	x0, #0x300000              	// #3145728
    4000c14c:	d5181040 	msr	cpacr_el1, x0
MAKE_REG_HELPER_EL123(sctlr)
    4000c150:	d5381000 	mrs	x0, sctlr_el1
	reg |= CPACR_EL1_FPEN_NOTRAP;	/* Do not trap NEON/SIMD/FP initially */
					/* TODO: CONFIG_FLOAT_*_FORBIDDEN */
	write_cpacr_el1(reg);

	reg = read_sctlr_el1();
	reg |= (SCTLR_EL1_RES1 |	/* RES1 */
    4000c154:	d2830101 	mov	x1, #0x1808                	// #6152
    4000c158:	f2a61a01 	movk	x1, #0x30d0, lsl #16
    4000c15c:	aa010000 	orr	x0, x0, x1
    4000c160:	d5181000 	msr	sctlr_el1, x0
MAKE_REG_HELPER(cntv_cval_el0)
    4000c164:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4000c168:	d51be340 	msr	cntv_cval_el0, x0
	 * Enable these if/when we use the corresponding timers.
	 * write_cntp_cval_el0(~(uint64_t)0);
	 * write_cntps_cval_el1(~(uint64_t)0);
	 */

	z_arm64_el1_plat_init();
    4000c16c:	97ffffb5 	bl	4000c040 <z_arm64_el1_plat_init>

	isb();
    4000c170:	d5033fdf 	isb
}
    4000c174:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000c178:	d65f03c0 	ret

000000004000c17c <z_arm64_el3_get_next_el>:

void z_arm64_el3_get_next_el(uint64_t switch_addr)
{
    4000c17c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000c180:	910003fd 	mov	x29, sp
MAKE_REG_HELPER_EL123(elr)
    4000c184:	d51e4020 	msr	elr_el3, x0
	write_elr_el3(switch_addr);

	/* Mask the DAIF */
	spsr = SPSR_DAIF_MASK;

	if (el3_get_next_el() == EL3_TO_EL2) {
    4000c188:	97ffffa2 	bl	4000c010 <el3_get_next_el>
		/* Dropping into EL2 */
		spsr |= SPSR_MODE_EL2T;
	} else {
		/* Dropping into EL1 */
		spsr |= SPSR_MODE_EL1T;
    4000c18c:	7100001f 	cmp	w0, #0x0
    4000c190:	d2807881 	mov	x1, #0x3c4                 	// #964
    4000c194:	d2807900 	mov	x0, #0x3c8                 	// #968
    4000c198:	9a810000 	csel	x0, x0, x1, eq  // eq = none
MAKE_REG_HELPER_EL123(spsr)
    4000c19c:	d51e4000 	msr	spsr_el3, x0
	}

	write_spsr_el3(spsr);
}
    4000c1a0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000c1a4:	d65f03c0 	ret

000000004000c1a8 <z_arm64_context_switch>:

GTEXT(z_arm64_context_switch)
SECTION_FUNC(TEXT, z_arm64_context_switch)

	/* Save the current SP_EL0 */
	mrs	x4, sp_el0
    4000c1a8:	d5384104 	mrs	x4, sp_el0

	stp	x19, x20, [x1, #_thread_offset_to_callee_saved_x19_x20]
    4000c1ac:	a9055033 	stp	x19, x20, [x1, #80]
	stp	x21, x22, [x1, #_thread_offset_to_callee_saved_x21_x22]
    4000c1b0:	a9065835 	stp	x21, x22, [x1, #96]
	stp	x23, x24, [x1, #_thread_offset_to_callee_saved_x23_x24]
    4000c1b4:	a9076037 	stp	x23, x24, [x1, #112]
	stp	x25, x26, [x1, #_thread_offset_to_callee_saved_x25_x26]
    4000c1b8:	a9086839 	stp	x25, x26, [x1, #128]
	stp	x27, x28, [x1, #_thread_offset_to_callee_saved_x27_x28]
    4000c1bc:	a909703b 	stp	x27, x28, [x1, #144]
	stp	x29, x4,  [x1, #_thread_offset_to_callee_saved_x29_sp_el0]
    4000c1c0:	a90a103d 	stp	x29, x4, [x1, #160]

	/* Save the current SP_ELx */
	mov	x4, sp
    4000c1c4:	910003e4 	mov	x4, sp
	str	x4, [x1, #_thread_offset_to_callee_saved_sp_elx]
    4000c1c8:	f9005824 	str	x4, [x1, #176]

	/* save current thread's exception depth */
	mrs	x4, tpidrro_el0
    4000c1cc:	d53bd064 	mrs	x4, tpidrro_el0
	lsr	x2, x4, #TPIDRROEL0_EXC_SHIFT
    4000c1d0:	d378fc82 	lsr	x2, x4, #56
	strb	w2, [x1, #_thread_offset_to_exception_depth]
    4000c1d4:	390dc022 	strb	w2, [x1, #880]

	/* retrieve next thread's exception depth */
	ldrb	w2, [x0, #_thread_offset_to_exception_depth]
    4000c1d8:	394dc002 	ldrb	w2, [x0, #880]
	bic	x4, x4, #TPIDRROEL0_EXC_DEPTH
    4000c1dc:	9240dc84 	and	x4, x4, #0xffffffffffffff
	orr	x4, x4, x2, lsl #TPIDRROEL0_EXC_SHIFT
    4000c1e0:	aa02e084 	orr	x4, x4, x2, lsl #56
	msr	tpidrro_el0, x4
    4000c1e4:	d51bd064 	msr	tpidrro_el0, x4
	 * thread variables with offsets added by toolchain.
	 */
	msr	tpidr_el0, x2
#endif

	ldp	x19, x20, [x0, #_thread_offset_to_callee_saved_x19_x20]
    4000c1e8:	a9455013 	ldp	x19, x20, [x0, #80]
	ldp	x21, x22, [x0, #_thread_offset_to_callee_saved_x21_x22]
    4000c1ec:	a9465815 	ldp	x21, x22, [x0, #96]
	ldp	x23, x24, [x0, #_thread_offset_to_callee_saved_x23_x24]
    4000c1f0:	a9476017 	ldp	x23, x24, [x0, #112]
	ldp	x25, x26, [x0, #_thread_offset_to_callee_saved_x25_x26]
    4000c1f4:	a9486819 	ldp	x25, x26, [x0, #128]
	ldp	x27, x28, [x0, #_thread_offset_to_callee_saved_x27_x28]
    4000c1f8:	a949701b 	ldp	x27, x28, [x0, #144]
	ldp	x29, x4,  [x0, #_thread_offset_to_callee_saved_x29_sp_el0]
    4000c1fc:	a94a101d 	ldp	x29, x4, [x0, #160]

	/* Restore SP_EL0 */
	msr	sp_el0, x4
    4000c200:	d5184104 	msr	sp_el0, x4

	/* Restore SP_EL1 */
	ldr	x4, [x0, #_thread_offset_to_callee_saved_sp_elx]
    4000c204:	f9405804 	ldr	x4, [x0, #176]
	mov	sp, x4
    4000c208:	9100009f 	mov	sp, x4
	bl	z_thread_mark_switched_in
	ldp	xzr, x30, [sp], #16
#endif

	/* Return to z_arm64_sync_exc() or _isr_wrapper() */
	ret
    4000c20c:	d65f03c0 	ret

000000004000c210 <z_arm64_sync_exc>:
 */

GTEXT(z_arm64_sync_exc)
SECTION_FUNC(TEXT, z_arm64_sync_exc)

	mrs	x0, esr_el1
    4000c210:	d5385200 	mrs	x0, esr_el1
	lsr	x1, x0, #26
    4000c214:	d35afc01 	lsr	x1, x0, #26

#ifdef CONFIG_FPU_SHARING
	cmp	x1, #0x07 /*Access to SIMD or floating-point */
    4000c218:	f1001c3f 	cmp	x1, #0x7
	bne	1f
    4000c21c:	54000081 	b.ne	4000c22c <z_arm64_sync_exc+0x1c>  // b.any
	mov	x0, sp
    4000c220:	910003e0 	mov	x0, sp
	bl	z_arm64_fpu_trap
    4000c224:	94000048 	bl	4000c344 <z_arm64_fpu_trap>
	b	z_arm64_exit_exc_fpu_done
    4000c228:	1400002c 	b	4000c2d8 <z_arm64_exit_exc_fpu_done>
1:
#endif

	cmp	x1, #0x15 /* 0x15 = SVC */
    4000c22c:	f100543f 	cmp	x1, #0x15
	bne	inv
    4000c230:	540001a1 	b.ne	4000c264 <inv>  // b.any

	/* Demux the SVC call */
	and	x1, x0, #0xff
    4000c234:	92401c01 	and	x1, x0, #0xff

	cmp	x1, #_SVC_CALL_CONTEXT_SWITCH
    4000c238:	f100003f 	cmp	x1, #0x0
	beq	context_switch
    4000c23c:	540000c0 	b.eq	4000c254 <context_switch>  // b.none

	cmp	x1, #_SVC_CALL_RUNTIME_EXCEPT
    4000c240:	f100083f 	cmp	x1, #0x2
	beq	oops
    4000c244:	54000040 	b.eq	4000c24c <oops>  // b.none

	/* --(_kernel->nested) */
	dec_nest_counter x0, x1
	b	z_arm64_exit_exc
#endif
	b	inv
    4000c248:	14000007 	b	4000c264 <inv>

000000004000c24c <oops>:

oops:
	mov	x0, sp
    4000c24c:	910003e0 	mov	x0, sp
	b	z_arm64_do_kernel_oops
    4000c250:	17ffff51 	b	4000bf94 <z_arm64_do_kernel_oops>

000000004000c254 <context_switch>:
	 * Retrieve x0 and x1 from the stack:
	 *
	 *  - x0 = new_thread->switch_handle = switch_to thread
	 *  - x1 = &old_thread->switch_handle = current thread
	 */
	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    4000c254:	a94007e0 	ldp	x0, x1, [sp]

	/* Get old thread from x1 */
	sub	x1, x1, ___thread_t_switch_handle_OFFSET
    4000c258:	d1052021 	sub	x1, x1, #0x148

	/* Switch thread */
	bl	z_arm64_context_switch
    4000c25c:	97ffffd3 	bl	4000c1a8 <z_arm64_context_switch>
	b	z_arm64_exit_exc
    4000c260:	1400001d 	b	4000c2d4 <z_arm64_exit_exc>

000000004000c264 <inv>:

inv:
	mov	x0, #0 /* K_ERR_CPU_EXCEPTION */
    4000c264:	d2800000 	mov	x0, #0x0                   	// #0
	mov	x1, sp
    4000c268:	910003e1 	mov	x1, sp
	bl	z_arm64_fatal_error
    4000c26c:	97fffdfb 	bl	4000ba58 <z_arm64_fatal_error>

	/* Return here only in case of recoverable error */
	b	z_arm64_exit_exc
    4000c270:	14000019 	b	4000c2d4 <z_arm64_exit_exc>

000000004000c274 <z_arm64_call_svc>:

GTEXT(z_arm64_call_svc)
SECTION_FUNC(TEXT, z_arm64_call_svc)
	svc	#_SVC_CALL_CONTEXT_SWITCH
    4000c274:	d4000001 	svc	#0x0
	ret
    4000c278:	d65f03c0 	ret

000000004000c27c <arch_new_thread>:
	 * dropping into EL0.
	 */

	pInitCtx = Z_STACK_PTR_TO_FRAME(struct __esf, stack_ptr);

	pInitCtx->x0 = (uint64_t)entry;
    4000c27c:	d102c041 	sub	x1, x2, #0xb0
	pInitCtx->x1 = (uint64_t)p1;
    4000c280:	a9351043 	stp	x3, x4, [x2, #-176]
	pInitCtx->x2 = (uint64_t)p2;
	pInitCtx->x3 = (uint64_t)p3;
    4000c284:	a9361845 	stp	x5, x6, [x2, #-160]
		pInitCtx->elr = (uint64_t)arch_user_mode_enter;
	} else {
		pInitCtx->elr = (uint64_t)z_thread_entry;
	}
#else
	pInitCtx->elr = (uint64_t)z_thread_entry;
    4000c288:	b0ffffa2 	adrp	x2, 40001000 <__aarch64_ldclr8_acq_rel+0x10>
    4000c28c:	913de042 	add	x2, x2, #0xf78
    4000c290:	f9005422 	str	x2, [x1, #168]
#endif
	/* Keep using SP_EL1 */
	pInitCtx->spsr = SPSR_MODE_EL1H | DAIF_FIQ_BIT;
    4000c294:	d28008a2 	mov	x2, #0x45                  	// #69
    4000c298:	f9005022 	str	x2, [x1, #160]

	/* thread birth happens through the exception return path */
	thread->arch.exception_depth = 1;
    4000c29c:	52800022 	mov	w2, #0x1                   	// #1
	 * We are saving SP_EL1 to pop out entry and parameters when going
	 * through z_arm64_exit_exc(). For user threads the definitive location
	 * of SP_EL1 will be set implicitly when going through
	 * z_arm64_userspace_enter() (see comments there)
	 */
	thread->callee_saved.sp_elx = (uint64_t)pInitCtx;
    4000c2a0:	f9005801 	str	x1, [x0, #176]

	thread->switch_handle = thread;
    4000c2a4:	f900a400 	str	x0, [x0, #328]
	thread->arch.exception_depth = 1;
    4000c2a8:	390dc002 	strb	w2, [x0, #880]
}
    4000c2ac:	d65f03c0 	ret

000000004000c2b0 <z_arch_get_next_switch_handle>:

void *z_arch_get_next_switch_handle(struct k_thread **old_thread)
{
    4000c2b0:	aa0003e1 	mov	x1, x0
	*old_thread =  _current;
    4000c2b4:	b00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000c2b8:	f943b800 	ldr	x0, [x0, #1904]
    4000c2bc:	f9000020 	str	x0, [x1]

	return z_get_next_switch_handle(*old_thread);
    4000c2c0:	14000fce 	b	400101f8 <z_get_next_switch_handle>

000000004000c2c4 <z_arm64_serror>:

GTEXT(z_arm64_serror)
SECTION_FUNC(TEXT, z_arm64_serror)

	mov	x1, sp
    4000c2c4:	910003e1 	mov	x1, sp
	mov	x0, #0 /* K_ERR_CPU_EXCEPTION */
    4000c2c8:	d2800000 	mov	x0, #0x0                   	// #0

	bl	z_arm64_fatal_error
    4000c2cc:	97fffde3 	bl	4000ba58 <z_arm64_fatal_error>
	/* Return here only in case of recoverable error */
	b	z_arm64_exit_exc
    4000c2d0:	14000001 	b	4000c2d4 <z_arm64_exit_exc>

000000004000c2d4 <z_arm64_exit_exc>:

GTEXT(z_arm64_exit_exc)
SECTION_FUNC(TEXT, z_arm64_exit_exc)

#ifdef CONFIG_FPU_SHARING
	bl	z_arm64_fpu_exit_exc
    4000c2d4:	94000055 	bl	4000c428 <z_arm64_fpu_exit_exc>

000000004000c2d8 <z_arm64_exit_exc_fpu_done>:

 GTEXT(z_arm64_exit_exc_fpu_done)
 z_arm64_exit_exc_fpu_done:
#endif

	ldp	x0, x1, [sp, ___esf_t_spsr_elr_OFFSET]
    4000c2d8:	a94a07e0 	ldp	x0, x1, [sp, #160]
	msr	spsr_el1, x0
    4000c2dc:	d5184000 	msr	spsr_el1, x0
	msr	elr_el1, x1
    4000c2e0:	d5184021 	msr	elr_el1, x1

	/* Restore the kernel/user mode flag and decrement exception depth */
	tst	x0, #SPSR_MODE_MASK	/* EL0 == 0 */
    4000c2e4:	f2400c1f 	tst	x0, #0xf
	mrs	x0, tpidrro_el0
    4000c2e8:	d53bd060 	mrs	x0, tpidrro_el0
	mov	x1, #TPIDRROEL0_EXC_UNIT
    4000c2ec:	d2e02001 	mov	x1, #0x100000000000000     	// #72057594037927936
	orr	x2, x0, #TPIDRROEL0_IN_EL0
    4000c2f0:	b2400002 	orr	x2, x0, #0x1
	csel	x0, x2, x0, eq
    4000c2f4:	9a800040 	csel	x0, x2, x0, eq  // eq = none
	sub	x0, x0, x1
    4000c2f8:	cb010000 	sub	x0, x0, x1
	msr	tpidrro_el0, x0
    4000c2fc:	d51bd060 	msr	tpidrro_el0, x0

	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    4000c300:	a94007e0 	ldp	x0, x1, [sp]
	ldp	x2, x3, [sp, ___esf_t_x2_x3_OFFSET]
    4000c304:	a9410fe2 	ldp	x2, x3, [sp, #16]
	ldp	x4, x5, [sp, ___esf_t_x4_x5_OFFSET]
    4000c308:	a94217e4 	ldp	x4, x5, [sp, #32]
	ldp	x6, x7, [sp, ___esf_t_x6_x7_OFFSET]
    4000c30c:	a9431fe6 	ldp	x6, x7, [sp, #48]
	ldp	x8, x9, [sp, ___esf_t_x8_x9_OFFSET]
    4000c310:	a94427e8 	ldp	x8, x9, [sp, #64]
	ldp	x10, x11, [sp, ___esf_t_x10_x11_OFFSET]
    4000c314:	a9452fea 	ldp	x10, x11, [sp, #80]
	ldp	x12, x13, [sp, ___esf_t_x12_x13_OFFSET]
    4000c318:	a94637ec 	ldp	x12, x13, [sp, #96]
	ldp	x14, x15, [sp, ___esf_t_x14_x15_OFFSET]
    4000c31c:	a9473fee 	ldp	x14, x15, [sp, #112]
	ldp	x16, x17, [sp, ___esf_t_x16_x17_OFFSET]
    4000c320:	a94847f0 	ldp	x16, x17, [sp, #128]
	ldp	x18, x30, [sp, ___esf_t_x18_x30_OFFSET]
    4000c324:	a9497bf2 	ldp	x18, x30, [sp, #144]

	add	sp, sp, ___esf_t_SIZEOF
    4000c328:	9102c3ff 	add	sp, sp, #0xb0
	 * - The address of ret in z_arm64_call_svc()
	 * - The address of the next instruction at the time of the IRQ when the
	 *   thread was switched out.
	 * - The address of z_thread_entry() for new threads (see thread.c).
	 */
	eret
    4000c32c:	d69f03e0 	eret

000000004000c330 <z_arm64_fpu_enter_exc>:
MAKE_REG_HELPER_EL123(cpacr)
    4000c330:	d5381040 	mrs	x0, cpacr_el1
void z_arm64_fpu_enter_exc(void)
{
	__ASSERT(read_daif() & DAIF_IRQ_BIT, "must be called with IRQs disabled");

	/* always deny FPU access whenever an exception is entered */
	write_cpacr_el1(read_cpacr_el1() & ~CPACR_EL1_FPEN_NOTRAP);
    4000c334:	926af400 	and	x0, x0, #0xffffffffffcfffff
    4000c338:	d5181040 	msr	cpacr_el1, x0
	isb();
    4000c33c:	d5033fdf 	isb
}
    4000c340:	d65f03c0 	ret

000000004000c344 <z_arm64_fpu_trap>:
 * there is nothing to save/restore for that context... as long as we
 * don't get interrupted that is. To ensure that we mask interrupts to
 * the triggering exception context.
 */
void z_arm64_fpu_trap(z_arch_esf_t *esf)
{
    4000c344:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000c348:	910003fd 	mov	x29, sp
    4000c34c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000c350:	aa0003f3 	mov	x19, x0
MAKE_REG_HELPER(tpidrro_el0);
    4000c354:	d53bd060 	mrs	x0, tpidrro_el0
	return (_cpu_t *)(read_tpidrro_el0() & TPIDRROEL0_CURR_CPU);
}

static ALWAYS_INLINE int arch_exception_depth(void)
{
	return (read_tpidrro_el0() & TPIDRROEL0_EXC_DEPTH) / TPIDRROEL0_EXC_UNIT;
    4000c358:	d378fc00 	lsr	x0, x0, #56
	if (arch_exception_depth() <= 1) {
    4000c35c:	f100041f 	cmp	x0, #0x1
    4000c360:	54000309 	b.ls	4000c3c0 <z_arm64_fpu_trap+0x7c>  // b.plast
	uint32_t *pc = (uint32_t *)esf->elr;
    4000c364:	f9405662 	ldr	x2, [x19, #168]
	uintptr_t sp = (uintptr_t)esf + sizeof(*esf);
    4000c368:	9102c263 	add	x3, x19, #0xb0
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    4000c36c:	52807f04 	mov	w4, #0x3f8                 	// #1016
    4000c370:	72bff804 	movk	w4, #0xffc0, lsl #16
	uint32_t *pc = (uint32_t *)esf->elr;
    4000c374:	aa0203e0 	mov	x0, x2
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    4000c378:	52807c05 	mov	w5, #0x3e0                 	// #992
    4000c37c:	72a7b005 	movk	w5, #0x3d80, lsl #16
		uint32_t insn = *pc;
    4000c380:	b9400001 	ldr	w1, [x0]
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    4000c384:	0a040026 	and	w6, w1, w4
    4000c388:	6b0500df 	cmp	w6, w5
    4000c38c:	540000e1 	b.ne	4000c3a8 <z_arm64_fpu_trap+0x64>  // b.any
		uint32_t pimm = (insn >> 10) & 0xfff;
    4000c390:	d34a5421 	ubfx	x1, x1, #10, #12
		pc++;
    4000c394:	91001000 	add	x0, x0, #0x4
		*(__int128 *)(sp + pimm * 16) = 0;
    4000c398:	d37c2c21 	ubfiz	x1, x1, #4, #12
    4000c39c:	8b030021 	add	x1, x1, x3
    4000c3a0:	a9007c3f 	stp	xzr, xzr, [x1]
	for (;;) {
    4000c3a4:	17fffff7 	b	4000c380 <z_arm64_fpu_trap+0x3c>
	if (pc != (uint32_t *)esf->elr) {
    4000c3a8:	eb00005f 	cmp	x2, x0
    4000c3ac:	540000a0 	b.eq	4000c3c0 <z_arm64_fpu_trap+0x7c>  // b.none
		esf->elr = (uintptr_t)pc;
    4000c3b0:	f9005660 	str	x0, [x19, #168]
	_current_cpu->arch.fpu_owner = _current;

	/* restore our content */
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
	DBG("restore", _current);
}
    4000c3b4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000c3b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000c3bc:	d65f03c0 	ret
MAKE_REG_HELPER_EL123(cpacr)
    4000c3c0:	d5381040 	mrs	x0, cpacr_el1
	write_cpacr_el1(read_cpacr_el1() | CPACR_EL1_FPEN_NOTRAP);
    4000c3c4:	b26c0400 	orr	x0, x0, #0x300000
    4000c3c8:	d5181040 	msr	cpacr_el1, x0
	isb();
    4000c3cc:	d5033fdf 	isb
	struct k_thread *owner = _current_cpu->arch.fpu_owner;
    4000c3d0:	b00000b4 	adrp	x20, 40021000 <k_sys_work_q+0x200>
    4000c3d4:	911d8294 	add	x20, x20, #0x760
    4000c3d8:	f9401a80 	ldr	x0, [x20, #48]
	if (owner) {
    4000c3dc:	b40000a0 	cbz	x0, 4000c3f0 <z_arm64_fpu_trap+0xac>
		z_arm64_fpu_save(&owner->arch.saved_fp_context);
    4000c3e0:	91058000 	add	x0, x0, #0x160
    4000c3e4:	94000021 	bl	4000c468 <z_arm64_fpu_save>
		dsb();
    4000c3e8:	d5033f9f 	dsb	sy
		_current_cpu->arch.fpu_owner = NULL;
    4000c3ec:	f9001a9f 	str	xzr, [x20, #48]
MAKE_REG_HELPER(tpidrro_el0);
    4000c3f0:	d53bd060 	mrs	x0, tpidrro_el0
    4000c3f4:	d378fc00 	lsr	x0, x0, #56
	if (arch_exception_depth() > 1) {
    4000c3f8:	f100041f 	cmp	x0, #0x1
    4000c3fc:	540000a9 	b.ls	4000c410 <z_arm64_fpu_trap+0xcc>  // b.plast
		esf->spsr |= DAIF_IRQ_BIT;
    4000c400:	f9405260 	ldr	x0, [x19, #160]
    4000c404:	b2790000 	orr	x0, x0, #0x80
    4000c408:	f9005260 	str	x0, [x19, #160]
		return;
    4000c40c:	17ffffea 	b	4000c3b4 <z_arm64_fpu_trap+0x70>
	_current_cpu->arch.fpu_owner = _current;
    4000c410:	f9400a80 	ldr	x0, [x20, #16]
    4000c414:	f9001a80 	str	x0, [x20, #48]
}
    4000c418:	a94153f3 	ldp	x19, x20, [sp, #16]
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
    4000c41c:	91058000 	add	x0, x0, #0x160
}
    4000c420:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
    4000c424:	14000026 	b	4000c4bc <z_arm64_fpu_restore>

000000004000c428 <z_arm64_fpu_exit_exc>:
MAKE_REG_HELPER_EL123(cpacr)
    4000c428:	d5381040 	mrs	x0, cpacr_el1
MAKE_REG_HELPER(tpidrro_el0);
    4000c42c:	d53bd061 	mrs	x1, tpidrro_el0
    4000c430:	d378fc21 	lsr	x1, x1, #56
{
	__ASSERT(read_daif() & DAIF_IRQ_BIT, "must be called with IRQs disabled");

	uint64_t cpacr = read_cpacr_el1();

	if (arch_exception_depth() == 1) {
    4000c434:	f100043f 	cmp	x1, #0x1
    4000c438:	54000141 	b.ne	4000c460 <z_arm64_fpu_exit_exc+0x38>  // b.any
		/* We're about to leave exception mode */
		if (_current_cpu->arch.fpu_owner == _current) {
    4000c43c:	b00000a1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000c440:	911d8021 	add	x1, x1, #0x760
    4000c444:	f9401822 	ldr	x2, [x1, #48]
    4000c448:	f9400821 	ldr	x1, [x1, #16]
    4000c44c:	eb01005f 	cmp	x2, x1
    4000c450:	54000081 	b.ne	4000c460 <z_arm64_fpu_exit_exc+0x38>  // b.any
			/* turn on FPU access */
			write_cpacr_el1(cpacr | CPACR_EL1_FPEN_NOTRAP);
    4000c454:	b26c0400 	orr	x0, x0, #0x300000
MAKE_REG_HELPER_EL123(cpacr)
    4000c458:	d5181040 	msr	cpacr_el1, x0
		 * access as we want to make sure IRQs are disabled before
		 * granting them access.
		 */
		write_cpacr_el1(cpacr & ~CPACR_EL1_FPEN_NOTRAP);
	}
}
    4000c45c:	d65f03c0 	ret
		write_cpacr_el1(cpacr & ~CPACR_EL1_FPEN_NOTRAP);
    4000c460:	926af400 	and	x0, x0, #0xffffffffffcfffff
    4000c464:	17fffffd 	b	4000c458 <z_arm64_fpu_exit_exc+0x30>

000000004000c468 <z_arm64_fpu_save>:
_ASM_FILE_PROLOGUE

GTEXT(z_arm64_fpu_save)
SECTION_FUNC(TEXT, z_arm64_fpu_save)

	stp	q0,  q1,  [x0, #(16 *  0)]
    4000c468:	ad000400 	stp	q0, q1, [x0]
	stp	q2,  q3,  [x0, #(16 *  2)]
    4000c46c:	ad010c02 	stp	q2, q3, [x0, #32]
	stp	q4,  q5,  [x0, #(16 *  4)]
    4000c470:	ad021404 	stp	q4, q5, [x0, #64]
	stp	q6,  q7,  [x0, #(16 *  6)]
    4000c474:	ad031c06 	stp	q6, q7, [x0, #96]
	stp	q8,  q9,  [x0, #(16 *  8)]
    4000c478:	ad042408 	stp	q8, q9, [x0, #128]
	stp	q10, q11, [x0, #(16 * 10)]
    4000c47c:	ad052c0a 	stp	q10, q11, [x0, #160]
	stp	q12, q13, [x0, #(16 * 12)]
    4000c480:	ad06340c 	stp	q12, q13, [x0, #192]
	stp	q14, q15, [x0, #(16 * 14)]
    4000c484:	ad073c0e 	stp	q14, q15, [x0, #224]
	stp	q16, q17, [x0, #(16 * 16)]
    4000c488:	ad084410 	stp	q16, q17, [x0, #256]
	stp	q18, q19, [x0, #(16 * 18)]
    4000c48c:	ad094c12 	stp	q18, q19, [x0, #288]
	stp	q20, q21, [x0, #(16 * 20)]
    4000c490:	ad0a5414 	stp	q20, q21, [x0, #320]
	stp	q22, q23, [x0, #(16 * 22)]
    4000c494:	ad0b5c16 	stp	q22, q23, [x0, #352]
	stp	q24, q25, [x0, #(16 * 24)]
    4000c498:	ad0c6418 	stp	q24, q25, [x0, #384]
	stp	q26, q27, [x0, #(16 * 26)]
    4000c49c:	ad0d6c1a 	stp	q26, q27, [x0, #416]
	stp	q28, q29, [x0, #(16 * 28)]
    4000c4a0:	ad0e741c 	stp	q28, q29, [x0, #448]
	stp	q30, q31, [x0, #(16 * 30)]
    4000c4a4:	ad0f7c1e 	stp	q30, q31, [x0, #480]

	mrs	x1, fpsr
    4000c4a8:	d53b4421 	mrs	x1, fpsr
	mrs	x2, fpcr
    4000c4ac:	d53b4402 	mrs	x2, fpcr
	str	w1, [x0, #(16 * 32 + 0)]
    4000c4b0:	b9020001 	str	w1, [x0, #512]
	str	w2, [x0, #(16 * 32 + 4)]
    4000c4b4:	b9020402 	str	w2, [x0, #516]

	ret
    4000c4b8:	d65f03c0 	ret

000000004000c4bc <z_arm64_fpu_restore>:

GTEXT(z_arm64_fpu_restore)
SECTION_FUNC(TEXT, z_arm64_fpu_restore)

	ldp	q0,  q1,  [x0, #(16 *  0)]
    4000c4bc:	ad400400 	ldp	q0, q1, [x0]
	ldp	q2,  q3,  [x0, #(16 *  2)]
    4000c4c0:	ad410c02 	ldp	q2, q3, [x0, #32]
	ldp	q4,  q5,  [x0, #(16 *  4)]
    4000c4c4:	ad421404 	ldp	q4, q5, [x0, #64]
	ldp	q6,  q7,  [x0, #(16 *  6)]
    4000c4c8:	ad431c06 	ldp	q6, q7, [x0, #96]
	ldp	q8,  q9,  [x0, #(16 *  8)]
    4000c4cc:	ad442408 	ldp	q8, q9, [x0, #128]
	ldp	q10, q11, [x0, #(16 * 10)]
    4000c4d0:	ad452c0a 	ldp	q10, q11, [x0, #160]
	ldp	q12, q13, [x0, #(16 * 12)]
    4000c4d4:	ad46340c 	ldp	q12, q13, [x0, #192]
	ldp	q14, q15, [x0, #(16 * 14)]
    4000c4d8:	ad473c0e 	ldp	q14, q15, [x0, #224]
	ldp	q16, q17, [x0, #(16 * 16)]
    4000c4dc:	ad484410 	ldp	q16, q17, [x0, #256]
	ldp	q18, q19, [x0, #(16 * 18)]
    4000c4e0:	ad494c12 	ldp	q18, q19, [x0, #288]
	ldp	q20, q21, [x0, #(16 * 20)]
    4000c4e4:	ad4a5414 	ldp	q20, q21, [x0, #320]
	ldp	q22, q23, [x0, #(16 * 22)]
    4000c4e8:	ad4b5c16 	ldp	q22, q23, [x0, #352]
	ldp	q24, q25, [x0, #(16 * 24)]
    4000c4ec:	ad4c6418 	ldp	q24, q25, [x0, #384]
	ldp	q26, q27, [x0, #(16 * 26)]
    4000c4f0:	ad4d6c1a 	ldp	q26, q27, [x0, #416]
	ldp	q28, q29, [x0, #(16 * 28)]
    4000c4f4:	ad4e741c 	ldp	q28, q29, [x0, #448]
	ldp	q30, q31, [x0, #(16 * 30)]
    4000c4f8:	ad4f7c1e 	ldp	q30, q31, [x0, #480]

	ldr	w1, [x0, #(16 * 32 + 0)]
    4000c4fc:	b9420001 	ldr	w1, [x0, #512]
	ldr	w2, [x0, #(16 * 32 + 4)]
    4000c500:	b9420402 	ldr	w2, [x0, #516]
	msr	fpsr, x1
    4000c504:	d51b4421 	msr	fpsr, x1
	msr	fpcr, x2
    4000c508:	d51b4402 	msr	fpcr, x2

	ret
    4000c50c:	d65f03c0 	ret

000000004000c510 <table_usage>:
	return NULL;
}

static inline unsigned int table_index(uint64_t *pte)
{
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    4000c510:	90000062 	adrp	x2, 40018000 <xlat_tables>
    4000c514:	91000042 	add	x2, x2, #0x0
    4000c518:	cb020002 	sub	x2, x0, x2
    4000c51c:	d2804000 	mov	x0, #0x200                 	// #512
/* Adjusts usage count and returns current count. */
static int table_usage(uint64_t *table, int adjustment)
{
	unsigned int i = table_index(table);

	xlat_use_count[i] += adjustment;
    4000c520:	b00000a3 	adrp	x3, 40021000 <k_sys_work_q+0x200>
    4000c524:	91247063 	add	x3, x3, #0x91c
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    4000c528:	9343fc42 	asr	x2, x2, #3
    4000c52c:	9ac00c42 	sdiv	x2, x2, x0
	xlat_use_count[i] += adjustment;
    4000c530:	2a0203e2 	mov	w2, w2
    4000c534:	78627860 	ldrh	w0, [x3, x2, lsl #1]
    4000c538:	0b000020 	add	w0, w1, w0
    4000c53c:	12003c00 	and	w0, w0, #0xffff
    4000c540:	78227860 	strh	w0, [x3, x2, lsl #1]
	__ASSERT(xlat_use_count[i] > 0, "usage count underflow");
	return xlat_use_count[i];
}
    4000c544:	d65f03c0 	ret

000000004000c548 <new_table>:
		if (xlat_use_count[i] == 0U) {
    4000c548:	b00000a2 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    4000c54c:	91247042 	add	x2, x2, #0x91c
{
    4000c550:	d2800001 	mov	x1, #0x0                   	// #0
		if (xlat_use_count[i] == 0U) {
    4000c554:	78617843 	ldrh	w3, [x2, x1, lsl #1]
    4000c558:	2a0103e0 	mov	w0, w1
    4000c55c:	35000103 	cbnz	w3, 4000c57c <new_table+0x34>
			xlat_use_count[i] = 1U;
    4000c560:	52800021 	mov	w1, #0x1                   	// #1
    4000c564:	78205841 	strh	w1, [x2, w0, uxtw #1]
			return &xlat_tables[i * Ln_XLAT_NUM_ENTRIES];
    4000c568:	d3745800 	ubfiz	x0, x0, #12, #23
    4000c56c:	90000061 	adrp	x1, 40018000 <xlat_tables>
    4000c570:	91000021 	add	x1, x1, #0x0
    4000c574:	8b010000 	add	x0, x0, x1
    4000c578:	d65f03c0 	ret
	for (i = 0U; i < CONFIG_MAX_XLAT_TABLES; i++) {
    4000c57c:	91000421 	add	x1, x1, #0x1
    4000c580:	f100203f 	cmp	x1, #0x8
    4000c584:	54fffe81 	b.ne	4000c554 <new_table+0xc>  // b.any
	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
    4000c588:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000c58c:	91337001 	add	x1, x0, #0xcdc
    4000c590:	b94cdc00 	ldr	w0, [x0, #3292]
    4000c594:	f240081f 	tst	x0, #0x7
    4000c598:	540001e0 	b.eq	4000c5d4 <new_table+0x8c>  // b.none
    4000c59c:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000c5a0:	91334000 	add	x0, x0, #0xcd0
    4000c5a4:	cb000021 	sub	x1, x1, x0
{
    4000c5a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
    4000c5ac:	d0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000c5b0:	911c7000 	add	x0, x0, #0x71c
    4000c5b4:	d342fc21 	lsr	x1, x1, #2
{
    4000c5b8:	910003fd 	mov	x29, sp
	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
    4000c5bc:	531a2421 	ubfiz	w1, w1, #6, #10
    4000c5c0:	32000021 	orr	w1, w1, #0x1
    4000c5c4:	97ffe0b7 	bl	400048a0 <log_0>
    4000c5c8:	d2800000 	mov	x0, #0x0                   	// #0
}
    4000c5cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000c5d0:	d65f03c0 	ret
	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
    4000c5d4:	d2800000 	mov	x0, #0x0                   	// #0
}
    4000c5d8:	d65f03c0 	ret

000000004000c5dc <set_mapping.constprop.0>:
	table_usage(table, 1);

	return table;
}

static int set_mapping(struct arm_mmu_ptables *ptables,
    4000c5dc:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    4000c5e0:	910003fd 	mov	x29, sp
    4000c5e4:	a90363f7 	stp	x23, x24, [sp, #48]
		       uintptr_t virt, size_t size,
		       uint64_t desc, bool may_overwrite)
{
	uint64_t *pte, *ptes[XLAT_LAST_LEVEL + 1];
	uint64_t level_size;
	uint64_t *table = ptables->base_xlat_table;
    4000c5e8:	b00000b8 	adrp	x24, 40021000 <k_sys_work_q+0x200>
    4000c5ec:	f9439704 	ldr	x4, [x24, #1832]
static int set_mapping(struct arm_mmu_ptables *ptables,
    4000c5f0:	aa0003f7 	mov	x23, x0
    4000c5f4:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000c5f8:	aa0103f6 	mov	x22, x1
    4000c5fc:	aa0203f5 	mov	x21, x2
    4000c600:	a9046bf9 	stp	x25, x26, [sp, #64]
	xlat_use_count[i] = 0U;
    4000c604:	b00000b9 	adrp	x25, 40021000 <k_sys_work_q+0x200>
    4000c608:	91247339 	add	x25, x25, #0x91c
static int set_mapping(struct arm_mmu_ptables *ptables,
    4000c60c:	12001c7a 	and	w26, w3, #0xff
    4000c610:	a90573fb 	stp	x27, x28, [sp, #80]
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    4000c614:	1281ff9b 	mov	w27, #0xfffff003            	// #-4093
    4000c618:	d281ff9c 	mov	x28, #0xffc                 	// #4092
    4000c61c:	f2dffffb 	movk	x27, #0xffff, lsl #32
    4000c620:	f2ffff1c 	movk	x28, #0xfff8, lsl #48
static int set_mapping(struct arm_mmu_ptables *ptables,
    4000c624:	a90153f3 	stp	x19, x20, [sp, #16]
	unsigned int level = BASE_XLAT_LEVEL;
    4000c628:	52800034 	mov	w20, #0x1                   	// #1
	int ret = 0;

	while (size) {
    4000c62c:	b5000136 	cbnz	x22, 4000c650 <set_mapping.constprop.0+0x74>
	int ret = 0;
    4000c630:	52800000 	mov	w0, #0x0                   	// #0
		table = ptables->base_xlat_table;
		level = BASE_XLAT_LEVEL;
	}

	return ret;
}
    4000c634:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000c638:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000c63c:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000c640:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000c644:	a94573fb 	ldp	x27, x28, [sp, #80]
    4000c648:	a8c97bfd 	ldp	x29, x30, [sp], #144
    4000c64c:	d65f03c0 	ret
		pte = &table[XLAT_TABLE_VA_IDX(virt, level)];
    4000c650:	12800102 	mov	w2, #0xfffffff7            	// #-9
		ptes[level] = pte;
    4000c654:	9101c3e5 	add	x5, sp, #0x70
    4000c658:	2a1403e1 	mov	w1, w20
	return level != XLAT_LAST_LEVEL &&
    4000c65c:	71000e9f 	cmp	w20, #0x3
		pte = &table[XLAT_TABLE_VA_IDX(virt, level)];
    4000c660:	1b027e82 	mul	w2, w20, w2
    4000c664:	11009c46 	add	w6, w2, #0x27
    4000c668:	9ac626e0 	lsr	x0, x23, x6
    4000c66c:	d37d2000 	ubfiz	x0, x0, #3, #9
    4000c670:	8b000093 	add	x19, x4, x0
		ptes[level] = pte;
    4000c674:	f82178b3 	str	x19, [x5, x1, lsl #3]
		if (is_table_desc(*pte, level)) {
    4000c678:	f8606883 	ldr	x3, [x4, x0]
	return level != XLAT_LAST_LEVEL &&
    4000c67c:	540000e0 	b.eq	4000c698 <set_mapping.constprop.0+0xbc>  // b.none
	       (desc & PTE_DESC_TYPE_MASK) == PTE_TABLE_DESC;
    4000c680:	92400460 	and	x0, x3, #0x3
		if (is_table_desc(*pte, level)) {
    4000c684:	f1000c1f 	cmp	x0, #0x3
    4000c688:	54000081 	b.ne	4000c698 <set_mapping.constprop.0+0xbc>  // b.any
			level++;
    4000c68c:	11000694 	add	w20, w20, #0x1
	uint64_t address = desc & GENMASK(47, PAGE_SIZE_SHIFT);
    4000c690:	92748c64 	and	x4, x3, #0xfffffffff000
			continue;
    4000c694:	17ffffe6 	b	4000c62c <set_mapping.constprop.0+0x50>
		if (!may_overwrite && !is_free_desc(*pte)) {
    4000c698:	3500029a 	cbnz	w26, 4000c6e8 <set_mapping.constprop.0+0x10c>
    4000c69c:	f240047f 	tst	x3, #0x3
    4000c6a0:	54000240 	b.eq	4000c6e8 <set_mapping.constprop.0+0x10c>  // b.none
			LOG_ERR("entry already in use: "
    4000c6a4:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000c6a8:	91337004 	add	x4, x0, #0xcdc
    4000c6ac:	b94cdc00 	ldr	w0, [x0, #3292]
    4000c6b0:	f240081f 	tst	x0, #0x7
    4000c6b4:	54000160 	b.eq	4000c6e0 <set_mapping.constprop.0+0x104>  // b.none
    4000c6b8:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000c6bc:	91334000 	add	x0, x0, #0xcd0
    4000c6c0:	cb000084 	sub	x4, x4, x0
    4000c6c4:	aa1303e2 	mov	x2, x19
    4000c6c8:	d0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000c6cc:	911cf800 	add	x0, x0, #0x73e
    4000c6d0:	d342fc84 	lsr	x4, x4, #2
    4000c6d4:	531a2484 	ubfiz	w4, w4, #6, #10
    4000c6d8:	32000084 	orr	w4, w4, #0x1
    4000c6dc:	97ffe0b0 	bl	4000499c <log_3>
			ret = -EBUSY;
    4000c6e0:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    4000c6e4:	17ffffd4 	b	4000c634 <set_mapping.constprop.0+0x58>
		level_size = 1ULL << LEVEL_TO_VA_SIZE_SHIFT(level);
    4000c6e8:	d2800021 	mov	x1, #0x1                   	// #1
    4000c6ec:	9ac62024 	lsl	x4, x1, x6
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    4000c6f0:	cb0403e0 	neg	x0, x4
    4000c6f4:	8a1b0000 	and	x0, x0, x27
	return (desc1 & mask) == (desc2 & mask);
    4000c6f8:	ca150066 	eor	x6, x3, x21
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    4000c6fc:	aa1c0000 	orr	x0, x0, x28
		if (is_desc_superset(*pte, desc, level)) {
    4000c700:	ea06001f 	tst	x0, x6
    4000c704:	540001c1 	b.ne	4000c73c <set_mapping.constprop.0+0x160>  // b.any
			level_size -= (virt & (level_size - 1));
    4000c708:	d1000480 	sub	x0, x4, #0x1
    4000c70c:	8a170000 	and	x0, x0, x23
    4000c710:	cb000084 	sub	x4, x4, x0
			if (level_size > size) {
    4000c714:	eb16009f 	cmp	x4, x22
    4000c718:	9a969084 	csel	x4, x4, x22, ls  // ls = plast
		desc += desc ? level_size : 0;
    4000c71c:	f10002bf 	cmp	x21, #0x0
		virt += level_size;
    4000c720:	8b0402f7 	add	x23, x23, x4
		desc += desc ? level_size : 0;
    4000c724:	9a9f1080 	csel	x0, x4, xzr, ne  // ne = any
		size -= level_size;
    4000c728:	cb0402d6 	sub	x22, x22, x4
		desc += desc ? level_size : 0;
    4000c72c:	8b0002b5 	add	x21, x21, x0
		level = BASE_XLAT_LEVEL;
    4000c730:	52800034 	mov	w20, #0x1                   	// #1
		table = ptables->base_xlat_table;
    4000c734:	f9439704 	ldr	x4, [x24, #1832]
		level = BASE_XLAT_LEVEL;
    4000c738:	17ffffbd 	b	4000c62c <set_mapping.constprop.0+0x50>
		if ((size < level_size) || (virt & (level_size - 1)) ||
    4000c73c:	eb16009f 	cmp	x4, x22
    4000c740:	54000108 	b.hi	4000c760 <set_mapping.constprop.0+0x184>  // b.pmore
	bool aligned = !((desc & mask) & (level_size - 1));
    4000c744:	51000480 	sub	w0, w4, #0x1
		if ((size < level_size) || (virt & (level_size - 1)) ||
    4000c748:	d1000486 	sub	x6, x4, #0x1
	bool aligned = !((desc & mask) & (level_size - 1));
    4000c74c:	8a150000 	and	x0, x0, x21
		if ((size < level_size) || (virt & (level_size - 1)) ||
    4000c750:	8a1700c6 	and	x6, x6, x23
	bool aligned = !((desc & mask) & (level_size - 1));
    4000c754:	92748c00 	and	x0, x0, #0xfffffffff000
		if ((size < level_size) || (virt & (level_size - 1)) ||
    4000c758:	aa060000 	orr	x0, x0, x6
    4000c75c:	b4000400 	cbz	x0, 4000c7dc <set_mapping.constprop.0+0x200>
    4000c760:	b9006fe2 	str	w2, [sp, #108]
	table = new_table();
    4000c764:	97ffff79 	bl	4000c548 <new_table>
    4000c768:	aa0003e4 	mov	x4, x0
	if (!table) {
    4000c76c:	b4000760 	cbz	x0, 4000c858 <set_mapping.constprop.0+0x27c>
	if (!is_free_desc(*pte)) {
    4000c770:	f9400260 	ldr	x0, [x19]
    4000c774:	f240041f 	tst	x0, #0x3
    4000c778:	540002c0 	b.eq	4000c7d0 <set_mapping.constprop.0+0x1f4>  // b.none
		if (level + 1 == XLAT_LAST_LEVEL) {
    4000c77c:	b9406fe2 	ldr	w2, [sp, #108]
    4000c780:	71000a9f 	cmp	w20, #0x2
    4000c784:	54000041 	b.ne	4000c78c <set_mapping.constprop.0+0x1b0>  // b.any
			desc |= PTE_PAGE_DESC;
    4000c788:	b2400400 	orr	x0, x0, #0x3
		stride_shift = LEVEL_TO_VA_SIZE_SHIFT(level + 1);
    4000c78c:	11007842 	add	w2, w2, #0x1e
    4000c790:	d2800001 	mov	x1, #0x0                   	// #0
			table[i] = desc | (i << stride_shift);
    4000c794:	1ac22023 	lsl	w3, w1, w2
    4000c798:	aa000063 	orr	x3, x3, x0
    4000c79c:	f8217883 	str	x3, [x4, x1, lsl #3]
		for (i = 0U; i < Ln_XLAT_NUM_ENTRIES; i++) {
    4000c7a0:	91000421 	add	x1, x1, #0x1
    4000c7a4:	f108003f 	cmp	x1, #0x200
    4000c7a8:	54ffff61 	b.ne	4000c794 <set_mapping.constprop.0+0x1b8>  // b.any
		table_usage(table, Ln_XLAT_NUM_ENTRIES);
    4000c7ac:	aa0403e0 	mov	x0, x4
		table_usage(pte, 1);
    4000c7b0:	97ffff58 	bl	4000c510 <table_usage>
	table_usage(table, 1);
    4000c7b4:	52800021 	mov	w1, #0x1                   	// #1
	*pte = PTE_TABLE_DESC | (uint64_t)table;
    4000c7b8:	b2400480 	orr	x0, x4, #0x3
    4000c7bc:	f9000260 	str	x0, [x19]
			level++;
    4000c7c0:	0b010294 	add	w20, w20, w1
	table_usage(table, 1);
    4000c7c4:	aa0403e0 	mov	x0, x4
    4000c7c8:	97ffff52 	bl	4000c510 <table_usage>
			continue;
    4000c7cc:	17ffff98 	b	4000c62c <set_mapping.constprop.0+0x50>
		table_usage(pte, 1);
    4000c7d0:	aa1303e0 	mov	x0, x19
    4000c7d4:	52800021 	mov	w1, #0x1                   	// #1
    4000c7d8:	17fffff6 	b	4000c7b0 <set_mapping.constprop.0+0x1d4>
		if (is_free_desc(*pte)) {
    4000c7dc:	f240047f 	tst	x3, #0x3
    4000c7e0:	54000061 	b.ne	4000c7ec <set_mapping.constprop.0+0x210>  // b.any
			table_usage(pte, 1);
    4000c7e4:	aa1303e0 	mov	x0, x19
    4000c7e8:	97ffff4a 	bl	4000c510 <table_usage>
		if (!desc) {
    4000c7ec:	b50003b5 	cbnz	x21, 4000c860 <set_mapping.constprop.0+0x284>
			table_usage(pte, -1);
    4000c7f0:	aa1303e0 	mov	x0, x19
    4000c7f4:	12800001 	mov	w1, #0xffffffff            	// #-1
    4000c7f8:	97ffff46 	bl	4000c510 <table_usage>
    4000c7fc:	d2800000 	mov	x0, #0x0                   	// #0
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    4000c800:	90000066 	adrp	x6, 40018000 <xlat_tables>
    4000c804:	910000c6 	add	x6, x6, #0x0
    4000c808:	d2804007 	mov	x7, #0x200                 	// #512
	*pte = desc;
    4000c80c:	f9000260 	str	x0, [x19]
		while (level != BASE_XLAT_LEVEL &&
    4000c810:	7100069f 	cmp	w20, #0x1
    4000c814:	54fff840 	b.eq	4000c71c <set_mapping.constprop.0+0x140>  // b.none
	return table_usage(table, 0) == 1;
    4000c818:	aa1303e0 	mov	x0, x19
    4000c81c:	52800001 	mov	w1, #0x0                   	// #0
    4000c820:	97ffff3c 	bl	4000c510 <table_usage>
		while (level != BASE_XLAT_LEVEL &&
    4000c824:	7100041f 	cmp	w0, #0x1
    4000c828:	54fff7a1 	b.ne	4000c71c <set_mapping.constprop.0+0x140>  // b.any
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    4000c82c:	cb060273 	sub	x19, x19, x6
			pte = ptes[--level];
    4000c830:	51000694 	sub	w20, w20, #0x1
			table_usage(pte, -1);
    4000c834:	12800001 	mov	w1, #0xffffffff            	// #-1
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    4000c838:	9343fe73 	asr	x19, x19, #3
    4000c83c:	9ac70e73 	sdiv	x19, x19, x7
	xlat_use_count[i] = 0U;
    4000c840:	78335b3f 	strh	wzr, [x25, w19, uxtw #1]
			pte = ptes[--level];
    4000c844:	f87458b3 	ldr	x19, [x5, w20, uxtw #3]
			table_usage(pte, -1);
    4000c848:	aa1303e0 	mov	x0, x19
	*pte = desc;
    4000c84c:	f900027f 	str	xzr, [x19]
			table_usage(pte, -1);
    4000c850:	97ffff30 	bl	4000c510 <table_usage>
    4000c854:	17ffffef 	b	4000c810 <set_mapping.constprop.0+0x234>
				ret = -ENOMEM;
    4000c858:	12800160 	mov	w0, #0xfffffff4            	// #-12
	return ret;
    4000c85c:	17ffff76 	b	4000c634 <set_mapping.constprop.0+0x58>
		desc |= (level == XLAT_LAST_LEVEL) ? PTE_PAGE_DESC : PTE_BLOCK_DESC;
    4000c860:	71000e9f 	cmp	w20, #0x3
    4000c864:	d2800060 	mov	x0, #0x3                   	// #3
    4000c868:	9a9f0400 	csinc	x0, x0, xzr, eq  // eq = none
    4000c86c:	aa0002a0 	orr	x0, x21, x0
    4000c870:	17ffffe4 	b	4000c800 <set_mapping.constprop.0+0x224>

000000004000c874 <__add_map.constprop.0>:
{
	unsigned int mem_type;
	uint64_t desc = 0U;

	/* NS bit for security memory access from secure state */
	desc |= (attrs & MT_NS) ? PTE_BLOCK_DESC_NS : 0;
    4000c874:	d37f7c65 	ubfiz	x5, x3, #1, #32
	 *     10      RO   NA
	 *     11      RO   RO
	 */

	/* AP bits for Data access permission */
	desc |= (attrs & MT_RW) ? PTE_BLOCK_DESC_AP_RW : PTE_BLOCK_DESC_AP_RO;
    4000c878:	f27d007f 	tst	x3, #0x8
	desc |= (attrs & MT_NS) ? PTE_BLOCK_DESC_NS : 0;
    4000c87c:	927b00a7 	and	x7, x5, #0x20

	/* Mirror permissions to EL0 */
	desc |= (attrs & MT_RW_AP_ELx) ?
		 PTE_BLOCK_DESC_AP_ELx : PTE_BLOCK_DESC_AP_EL_HIGHER;
    4000c880:	53017c65 	lsr	w5, w3, #1
	desc |= (attrs & MT_RW) ? PTE_BLOCK_DESC_AP_RW : PTE_BLOCK_DESC_AP_RO;
    4000c884:	9a9f17e4 	cset	x4, eq  // eq = none
		 PTE_BLOCK_DESC_AP_ELx : PTE_BLOCK_DESC_AP_EL_HIGHER;
    4000c888:	927a00a5 	and	x5, x5, #0x40
    4000c88c:	aa0700a5 	orr	x5, x5, x7
	/* the access flag */
	desc |= PTE_BLOCK_DESC_AF;

	/* memory attribute index field */
	mem_type = MT_TYPE(attrs);
	desc |= PTE_BLOCK_DESC_MEMTYPE(mem_type);
    4000c890:	d37e0867 	ubfiz	x7, x3, #2, #3
    4000c894:	aa041ce4 	orr	x4, x7, x4, lsl #7
	}

	return desc;
}

static int __add_map(struct arm_mmu_ptables *ptables, const char *name,
    4000c898:	aa0003e6 	mov	x6, x0
    4000c89c:	aa0400a5 	orr	x5, x5, x4
    4000c8a0:	aa0103e0 	mov	x0, x1
    4000c8a4:	aa0203e1 	mov	x1, x2
	mem_type = MT_TYPE(attrs);
    4000c8a8:	12000862 	and	w2, w3, #0x7
	desc |= PTE_BLOCK_DESC_MEMTYPE(mem_type);
    4000c8ac:	b27600a4 	orr	x4, x5, #0x400
	switch (mem_type) {
    4000c8b0:	7100085f 	cmp	w2, #0x2
    4000c8b4:	54000109 	b.ls	4000c8d4 <__add_map.constprop.0+0x60>  // b.plast
    4000c8b8:	51000c47 	sub	w7, w2, #0x3
    4000c8bc:	710004ff 	cmp	w7, #0x1
    4000c8c0:	54000129 	b.ls	4000c8e4 <__add_map.constprop.0+0x70>  // b.plast
		     uintptr_t phys, uintptr_t virt, size_t size, uint32_t attrs)
{
	uint64_t desc = get_region_desc(attrs);
	bool may_overwrite = !(attrs & MT_NO_OVERWRITE);
    4000c8c4:	d2780063 	eor	x3, x3, #0x100
	MMU_DEBUG("mmap [%s]: virt %lx phys %lx size %lx attr %llx\n",
		  name, virt, phys, size, desc);
	__ASSERT(((virt | phys | size) & (CONFIG_MMU_PAGE_SIZE - 1)) == 0,
		 "address/size are not page aligned\n");
	desc |= phys;
	return set_mapping(ptables, virt, size, desc, may_overwrite);
    4000c8c8:	aa0400c2 	orr	x2, x6, x4
    4000c8cc:	53082063 	ubfx	w3, w3, #8, #1
    4000c8d0:	17ffff43 	b	4000c5dc <set_mapping.constprop.0>
		desc |= PTE_BLOCK_DESC_UXN;
    4000c8d4:	d280c004 	mov	x4, #0x600                 	// #1536
    4000c8d8:	f2e00c04 	movk	x4, #0x60, lsl #48
    4000c8dc:	aa0400a4 	orr	x4, x5, x4
		break;
    4000c8e0:	17fffff9 	b	4000c8c4 <__add_map.constprop.0+0x50>
		if ((attrs & MT_RW) || (attrs & MT_P_EXECUTE_NEVER))
    4000c8e4:	52800507 	mov	w7, #0x28                  	// #40
    4000c8e8:	6a07007f 	tst	w3, w7
    4000c8ec:	54000080 	b.eq	4000c8fc <__add_map.constprop.0+0x88>  // b.none
			desc |= PTE_BLOCK_DESC_PXN;
    4000c8f0:	d2808004 	mov	x4, #0x400                 	// #1024
    4000c8f4:	f2e00404 	movk	x4, #0x20, lsl #48
    4000c8f8:	aa0400a4 	orr	x4, x5, x4
		if (((attrs & MT_RW) && (attrs & MT_RW_AP_ELx)) ||
    4000c8fc:	52801105 	mov	w5, #0x88                  	// #136
    4000c900:	0a050065 	and	w5, w3, w5
    4000c904:	710220bf 	cmp	w5, #0x88
    4000c908:	54000040 	b.eq	4000c910 <__add_map.constprop.0+0x9c>  // b.none
    4000c90c:	36300043 	tbz	w3, #6, 4000c914 <__add_map.constprop.0+0xa0>
			desc |= PTE_BLOCK_DESC_UXN;
    4000c910:	b24a0084 	orr	x4, x4, #0x40000000000000
			desc |= PTE_BLOCK_DESC_INNER_SHARE;
    4000c914:	b2780485 	orr	x5, x4, #0x300
    4000c918:	7100105f 	cmp	w2, #0x4
    4000c91c:	b2770084 	orr	x4, x4, #0x200
    4000c920:	9a851084 	csel	x4, x4, x5, ne  // ne = any
    4000c924:	17ffffe8 	b	4000c8c4 <__add_map.constprop.0+0x50>

000000004000c928 <z_arm64_mm_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Management Unit (MMU).
 */
void z_arm64_mm_init(bool is_primary_core)
{
    4000c928:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	__ASSERT((read_sctlr_el1() & SCTLR_M_BIT) == 0, "MMU is already enabled\n");

	/*
	 * Only booting core setup up the page tables.
	 */
	if (is_primary_core) {
    4000c92c:	72001c1f 	tst	w0, #0xff
{
    4000c930:	910003fd 	mov	x29, sp
    4000c934:	a90153f3 	stp	x19, x20, [sp, #16]
    4000c938:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000c93c:	b00000b5 	adrp	x21, 40021000 <k_sys_work_q+0x200>
    4000c940:	f9001bf7 	str	x23, [sp, #48]
	if (is_primary_core) {
    4000c944:	54000360 	b.eq	4000c9b0 <z_arm64_mm_init+0x88>  // b.none
		kernel_ptables.base_xlat_table = new_table();
    4000c948:	97ffff00 	bl	4000c548 <new_table>
    4000c94c:	f90396a0 	str	x0, [x21, #1832]
	for (index = 0U; index < mmu_config.num_regions; index++) {
    4000c950:	f0000020 	adrp	x0, 40013000 <shell_cmd_help>
    4000c954:	b945b001 	ldr	w1, [x0, #1456]
    4000c958:	90000053 	adrp	x19, 40014000 <shell_m_sub_colors+0x50>
    4000c95c:	910ae273 	add	x19, x19, #0x2b8
    4000c960:	2a0103f7 	mov	w23, w1
    4000c964:	aa0003f4 	mov	x20, x0
    4000c968:	52800076 	mov	w22, #0x3                   	// #3
	size_t size = (uintptr_t)range->end - address;
    4000c96c:	a9408a61 	ldp	x1, x2, [x19, #8]
	if (size) {
    4000c970:	eb010042 	subs	x2, x2, x1
    4000c974:	54000080 	b.eq	4000c984 <z_arm64_mm_init+0x5c>  // b.none
		__add_map(ptables, range->name, address, address,
    4000c978:	b9401a63 	ldr	w3, [x19, #24]
    4000c97c:	aa0103e0 	mov	x0, x1
    4000c980:	97ffffbd 	bl	4000c874 <__add_map.constprop.0>
	for (index = 0U; index < ARRAY_SIZE(mmu_zephyr_ranges); index++) {
    4000c984:	91008273 	add	x19, x19, #0x20
    4000c988:	710006d6 	subs	w22, w22, #0x1
    4000c98c:	54ffff01 	b.ne	4000c96c <z_arm64_mm_init+0x44>  // b.any
		region = &mmu_config.mmu_regions[index];
    4000c990:	9116c294 	add	x20, x20, #0x5b0
    4000c994:	d2800013 	mov	x19, #0x0                   	// #0
    4000c998:	d2800516 	mov	x22, #0x28                  	// #40
	for (index = 0U; index < mmu_config.num_regions; index++) {
    4000c99c:	6b1302ff 	cmp	w23, w19
    4000c9a0:	54000348 	b.hi	4000ca08 <z_arm64_mm_init+0xe0>  // b.pmore
	__asm__ volatile (
    4000c9a4:	d508871f 	tlbi	vmalle1
    4000c9a8:	d5033f9f 	dsb	sy
    4000c9ac:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(mair)
    4000c9b0:	d2808000 	mov	x0, #0x400                 	// #1024
    4000c9b4:	f2a88180 	movk	x0, #0x440c, lsl #16
    4000c9b8:	f2d77fe0 	movk	x0, #0xbbff, lsl #32
    4000c9bc:	d518a200 	msr	mair_el1, x0
MAKE_REG_HELPER_EL123(tcr)
    4000c9c0:	d286a400 	mov	x0, #0x3520                	// #13600
    4000c9c4:	f2a01000 	movk	x0, #0x80, lsl #16
    4000c9c8:	d5182040 	msr	tcr_el1, x0
MAKE_REG_HELPER_EL123(ttbr0)
    4000c9cc:	f94396a0 	ldr	x0, [x21, #1832]
    4000c9d0:	d5182000 	msr	ttbr0_el1, x0
	isb();
    4000c9d4:	d5033fdf 	isb

__syscall int sys_cache_data_all(int op);
static inline int z_impl_sys_cache_data_all(int op)
{
#if defined(CONFIG_CACHE_MANAGEMENT)
	return cache_data_all(op);
    4000c9d8:	52800040 	mov	w0, #0x2                   	// #2
    4000c9dc:	9400005a 	bl	4000cb44 <arch_dcache_all>
MAKE_REG_HELPER_EL123(sctlr)
    4000c9e0:	d5381000 	mrs	x0, sctlr_el1
	write_sctlr_el1(val | SCTLR_M_BIT | SCTLR_C_BIT);
    4000c9e4:	d28000a1 	mov	x1, #0x5                   	// #5
    4000c9e8:	aa010000 	orr	x0, x0, x1
    4000c9ec:	d5181000 	msr	sctlr_el1, x0
	isb();
    4000c9f0:	d5033fdf 	isb
		setup_page_tables(&kernel_ptables);
	}

	/* currently only EL1 is supported */
	enable_mmu_el1(&kernel_ptables, flags);
}
    4000c9f4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000c9f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000c9fc:	f9401bf7 	ldr	x23, [sp, #48]
    4000ca00:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000ca04:	d65f03c0 	ret
		region = &mmu_config.mmu_regions[index];
    4000ca08:	f9400685 	ldr	x5, [x20, #8]
    4000ca0c:	9b167e64 	mul	x4, x19, x22
    4000ca10:	8b0400a0 	add	x0, x5, x4
	if (region->size || region->attrs) {
    4000ca14:	f9400802 	ldr	x2, [x0, #16]
    4000ca18:	b9402003 	ldr	w3, [x0, #32]
    4000ca1c:	b5000042 	cbnz	x2, 4000ca24 <z_arm64_mm_init+0xfc>
    4000ca20:	340000a3 	cbz	w3, 4000ca34 <z_arm64_mm_init+0x10c>
		__add_map(ptables, region->name, region->base_pa, region->base_va,
    4000ca24:	f9400401 	ldr	x1, [x0, #8]
    4000ca28:	32180063 	orr	w3, w3, #0x100
    4000ca2c:	f86468a0 	ldr	x0, [x5, x4]
    4000ca30:	97ffff91 	bl	4000c874 <__add_map.constprop.0>
	for (index = 0U; index < mmu_config.num_regions; index++) {
    4000ca34:	91000673 	add	x19, x19, #0x1
    4000ca38:	17ffffd9 	b	4000c99c <z_arm64_mm_init+0x74>

000000004000ca3c <arch_mem_map>:

	return add_map(ptables, "generic", phys, (uintptr_t)virt, size, entry_flags);
}

void arch_mem_map(void *virt, uintptr_t phys, size_t size, uint32_t flags)
{
    4000ca3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000ca40:	2a0303e4 	mov	w4, w3
	switch (flags & K_MEM_CACHE_MASK) {
    4000ca44:	12000863 	and	w3, w3, #0x7
{
    4000ca48:	910003fd 	mov	x29, sp
    4000ca4c:	f9000bf3 	str	x19, [sp, #16]
    4000ca50:	7100087f 	cmp	w3, #0x2
    4000ca54:	540002c8 	b.hi	4000caac <arch_mem_map+0x70>  // b.pmore
    4000ca58:	aa0003e5 	mov	x5, x0
    4000ca5c:	aa0103e0 	mov	x0, x1
    4000ca60:	d0000041 	adrp	x1, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000ca64:	911ed821 	add	x1, x1, #0x7b6
    4000ca68:	38636823 	ldrb	w3, [x1, x3]
	if ((flags & K_MEM_PERM_RW) != 0U) {
    4000ca6c:	36180044 	tbz	w4, #3, 4000ca74 <arch_mem_map+0x38>
		entry_flags |= MT_RW;
    4000ca70:	321d0063 	orr	w3, w3, #0x8
	if ((flags & K_MEM_PERM_EXEC) == 0U) {
    4000ca74:	37200044 	tbnz	w4, #4, 4000ca7c <arch_mem_map+0x40>
		entry_flags |= MT_P_EXECUTE_NEVER;
    4000ca78:	321b0063 	orr	w3, w3, #0x20
	if ((flags & K_MEM_PERM_USER) != 0U) {
    4000ca7c:	37280184 	tbnz	w4, #5, 4000caac <arch_mem_map+0x70>
MAKE_REG_HELPER(daif)
    4000ca80:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ca84:	d50342df 	msr	daifset, #0x2
	ret = __add_map(ptables, name, phys, virt, size, attrs);
    4000ca88:	aa0503e1 	mov	x1, x5
MAKE_REG_HELPER(daif)
    4000ca8c:	92407e73 	and	x19, x19, #0xffffffff
    4000ca90:	97ffff79 	bl	4000c874 <__add_map.constprop.0>
    4000ca94:	d51b4233 	msr	daif, x19
	int ret = __arch_mem_map(virt, phys, size, flags);

	if (ret) {
    4000ca98:	350000c0 	cbnz	w0, 4000cab0 <arch_mem_map+0x74>
	__asm__ volatile (
    4000ca9c:	d508871f 	tlbi	vmalle1
    4000caa0:	d5033f9f 	dsb	sy
    4000caa4:	d5033fdf 	isb
		k_panic();
	} else {
		sync_domains((uintptr_t)virt, size);
		invalidate_tlb_all();
	}
}
    4000caa8:	14000013 	b	4000caf4 <arch_mem_map+0xb8>
		return -ENOTSUP;
    4000caac:	128010a0 	mov	w0, #0xffffff7a            	// #-134
		LOG_ERR("__arch_mem_map() returned %d", ret);
    4000cab0:	f0000301 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
    4000cab4:	91337022 	add	x2, x1, #0xcdc
    4000cab8:	b94cdc21 	ldr	w1, [x1, #3292]
    4000cabc:	f240083f 	tst	x1, #0x7
    4000cac0:	54000160 	b.eq	4000caec <arch_mem_map+0xb0>  // b.none
    4000cac4:	f0000301 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
    4000cac8:	91334021 	add	x1, x1, #0xcd0
    4000cacc:	cb010042 	sub	x2, x2, x1
    4000cad0:	93407c01 	sxtw	x1, w0
    4000cad4:	d0000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000cad8:	911dcc00 	add	x0, x0, #0x773
    4000cadc:	d342fc42 	lsr	x2, x2, #2
    4000cae0:	531a2442 	ubfiz	w2, w2, #6, #10
    4000cae4:	32000042 	orr	w2, w2, #0x1
    4000cae8:	97ffdf7d 	bl	400048dc <log_1>
		k_panic();
    4000caec:	d2800088 	mov	x8, #0x4                   	// #4
    4000caf0:	d4000041 	svc	#0x2
}
    4000caf4:	f9400bf3 	ldr	x19, [sp, #16]
    4000caf8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000cafc:	d65f03c0 	ret

000000004000cb00 <arch_virt_region_align>:
	int level;

	for (level = XLAT_LAST_LEVEL; level >= BASE_XLAT_LEVEL; level--) {
		level_size = 1 << LEVEL_TO_VA_SIZE_SHIFT(level);

		if (size < level_size) {
    4000cb00:	b24053e2 	mov	x2, #0x1fffff              	// #2097151
    4000cb04:	eb02003f 	cmp	x1, x2
    4000cb08:	54000169 	b.ls	4000cb34 <arch_virt_region_align+0x34>  // b.plast
			break;
		}

		if ((phys & (level_size - 1))) {
    4000cb0c:	f240501f 	tst	x0, #0x1fffff
    4000cb10:	54000121 	b.ne	4000cb34 <arch_virt_region_align+0x34>  // b.any
		if (size < level_size) {
    4000cb14:	b24077e2 	mov	x2, #0x3fffffff            	// #1073741823
    4000cb18:	eb02003f 	cmp	x1, x2
    4000cb1c:	54000109 	b.ls	4000cb3c <arch_virt_region_align+0x3c>  // b.plast
		level_size = 1 << LEVEL_TO_VA_SIZE_SHIFT(level);
    4000cb20:	f240741f 	tst	x0, #0x3fffffff
    4000cb24:	d2a80001 	mov	x1, #0x40000000            	// #1073741824
    4000cb28:	d2a00400 	mov	x0, #0x200000              	// #2097152
    4000cb2c:	9a811000 	csel	x0, x0, x1, ne  // ne = any

		alignment = level_size;
	}

	return alignment;
}
    4000cb30:	d65f03c0 	ret
	size_t alignment = CONFIG_MMU_PAGE_SIZE;
    4000cb34:	d2820000 	mov	x0, #0x1000                	// #4096
    4000cb38:	17fffffe 	b	4000cb30 <arch_virt_region_align+0x30>
		level_size = 1 << LEVEL_TO_VA_SIZE_SHIFT(level);
    4000cb3c:	d2a00400 	mov	x0, #0x200000              	// #2097152
    4000cb40:	17fffffc 	b	4000cb30 <arch_virt_region_align+0x30>

000000004000cb44 <arch_dcache_all>:
{
	uint32_t clidr_el1, csselr_el1, ccsidr_el1;
	uint8_t loc, ctype, cache_level, line_size, way_pos;
	uint32_t max_ways, max_sets, dc_val, set, way;

	if (op != K_CACHE_INVD && op != K_CACHE_WB && op != K_CACHE_WB_INVD)
    4000cb44:	51000401 	sub	w1, w0, #0x1
    4000cb48:	7100083f 	cmp	w1, #0x2
    4000cb4c:	540006a8 	b.hi	4000cc20 <arch_dcache_all+0xdc>  // b.pmore
		return -ENOTSUP;

	/* Data barrier before start */
	dsb();
    4000cb50:	d5033f9f 	dsb	sy
MAKE_REG_HELPER(clidr_el1);
    4000cb54:	d5390021 	mrs	x1, clidr_el1

	clidr_el1 = read_clidr_el1();
    4000cb58:	2a0103ea 	mov	w10, w1

	loc = (clidr_el1 >> CLIDR_EL1_LOC_SHIFT) & CLIDR_EL1_LOC_MASK;
    4000cb5c:	53186829 	ubfx	w9, w1, #24, #3
	if (!loc)
    4000cb60:	7208083f 	tst	w1, #0x7000000
    4000cb64:	54000620 	b.eq	4000cc28 <arch_dcache_all+0xe4>  // b.none
    4000cb68:	d2800001 	mov	x1, #0x0                   	// #0
		return 0;

	for (cache_level = 0; cache_level < loc; cache_level++) {
		ctype = (clidr_el1 >> CLIDR_EL1_CTYPE_SHIFT(cache_level))
    4000cb6c:	0b010422 	add	w2, w1, w1, lsl #1
    4000cb70:	531f782b 	lsl	w11, w1, #1
    4000cb74:	1ac22542 	lsr	w2, w10, w2
				& CLIDR_EL1_CTYPE_MASK;
		/* No data cache, continue */
		if (ctype < 2)
    4000cb78:	721f045f 	tst	w2, #0x6
    4000cb7c:	54000320 	b.eq	4000cbe0 <arch_dcache_all+0x9c>  // b.none
MAKE_REG_HELPER(csselr_el1);
    4000cb80:	d37ff822 	lsl	x2, x1, #1
    4000cb84:	d51a0002 	msr	csselr_el1, x2
			continue;

		/* select cache level */
		csselr_el1 = cache_level << 1;
		write_csselr_el1(csselr_el1);
		isb();
    4000cb88:	d5033fdf 	isb
MAKE_REG_HELPER(ccsidr_el1);
    4000cb8c:	d5390002 	mrs	x2, ccsidr_el1

		ccsidr_el1 = read_ccsidr_el1();
		line_size = (ccsidr_el1 >> CCSIDR_EL1_LN_SZ_SHIFT
				& CCSIDR_EL1_LN_SZ_MASK) + 4;
    4000cb90:	12000847 	and	w7, w2, #0x7
		max_ways = (ccsidr_el1 >> CCSIDR_EL1_WAYS_SHIFT)
    4000cb94:	53033048 	ubfx	w8, w2, #3, #10
		line_size = (ccsidr_el1 >> CCSIDR_EL1_LN_SZ_SHIFT
    4000cb98:	110010e7 	add	w7, w7, #0x4
				& CCSIDR_EL1_WAYS_MASK;
		max_sets = (ccsidr_el1 >> CCSIDR_EL1_SETS_SHIFT)
    4000cb9c:	530d6c42 	ubfx	w2, w2, #13, #15
				& CCSIDR_EL1_SETS_MASK;
		/* 32-log2(ways), bit position of way in DC operand */
		way_pos = __builtin_clz(max_ways);
    4000cba0:	5ac0110c 	clz	w12, w8

		for (set = 0; set <= max_sets; set++) {
    4000cba4:	52800005 	mov	w5, #0x0                   	// #0
				/* way number, aligned to pos in DC operand */
				dc_val = way << way_pos;
				/* cache level, aligned to pos in DC operand */
				dc_val |= csselr_el1;
				/* set number, aligned to pos in DC operand */
				dc_val |= set << line_size;
    4000cba8:	1ac720a6 	lsl	w6, w5, w7
    4000cbac:	2a0b00c6 	orr	w6, w6, w11
			for (way = 0; way <= max_ways; way++) {
    4000cbb0:	52800004 	mov	w4, #0x0                   	// #0
				dc_val = way << way_pos;
    4000cbb4:	1acc2083 	lsl	w3, w4, w12

				if (op == K_CACHE_INVD) {
    4000cbb8:	7100081f 	cmp	w0, #0x2
				dc_val |= set << line_size;
    4000cbbc:	2a060063 	orr	w3, w3, w6
				if (op == K_CACHE_INVD) {
    4000cbc0:	54000201 	b.ne	4000cc00 <arch_dcache_all+0xbc>  // b.any
					dc_ops("isw", dc_val);
    4000cbc4:	d5087643 	dc	isw, x3
			for (way = 0; way <= max_ways; way++) {
    4000cbc8:	11000484 	add	w4, w4, #0x1
    4000cbcc:	6b04011f 	cmp	w8, w4
    4000cbd0:	54ffff22 	b.cs	4000cbb4 <arch_dcache_all+0x70>  // b.hs, b.nlast
		for (set = 0; set <= max_sets; set++) {
    4000cbd4:	110004a5 	add	w5, w5, #0x1
    4000cbd8:	6b05005f 	cmp	w2, w5
    4000cbdc:	54fffe62 	b.cs	4000cba8 <arch_dcache_all+0x64>  // b.hs, b.nlast
	for (cache_level = 0; cache_level < loc; cache_level++) {
    4000cbe0:	91000421 	add	x1, x1, #0x1
    4000cbe4:	6b21013f 	cmp	w9, w1, uxtb
    4000cbe8:	54fffc28 	b.hi	4000cb6c <arch_dcache_all+0x28>  // b.pmore
MAKE_REG_HELPER(csselr_el1);
    4000cbec:	d2800000 	mov	x0, #0x0                   	// #0
    4000cbf0:	d51a0000 	msr	csselr_el1, x0
		}
	}

	/* Restore csselr_el1 to level 0 */
	write_csselr_el1(0);
	dsb();
    4000cbf4:	d5033f9f 	dsb	sy
	isb();
    4000cbf8:	d5033fdf 	isb

	return 0;
}
    4000cbfc:	d65f03c0 	ret
				} else if (op == K_CACHE_WB_INVD) {
    4000cc00:	71000c1f 	cmp	w0, #0x3
    4000cc04:	54000061 	b.ne	4000cc10 <arch_dcache_all+0xcc>  // b.any
					dc_ops("cisw", dc_val);
    4000cc08:	d5087e43 	dc	cisw, x3
    4000cc0c:	17ffffef 	b	4000cbc8 <arch_dcache_all+0x84>
				} else if (op == K_CACHE_WB) {
    4000cc10:	7100041f 	cmp	w0, #0x1
    4000cc14:	54fffda1 	b.ne	4000cbc8 <arch_dcache_all+0x84>  // b.any
					dc_ops("csw", dc_val);
    4000cc18:	d5087a43 	dc	csw, x3
    4000cc1c:	17ffffeb 	b	4000cbc8 <arch_dcache_all+0x84>
		return -ENOTSUP;
    4000cc20:	128010a0 	mov	w0, #0xffffff7a            	// #-134
    4000cc24:	17fffff6 	b	4000cbfc <arch_dcache_all+0xb8>
		return 0;
    4000cc28:	52800000 	mov	w0, #0x0                   	// #0
    4000cc2c:	17fffff4 	b	4000cbfc <arch_dcache_all+0xb8>

000000004000cc30 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
    4000cc30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000cc34:	aa0003e6 	mov	x6, x0
    4000cc38:	910003fd 	mov	x29, sp
    4000cc3c:	a90153f3 	stp	x19, x20, [sp, #16]
	register const char *s = nptr;
    4000cc40:	aa0003f3 	mov	x19, x0
{
    4000cc44:	f90013f5 	str	x21, [sp, #32]
    4000cc48:	aa0103f5 	mov	x21, x1
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
    4000cc4c:	aa1303e0 	mov	x0, x19
    4000cc50:	38401663 	ldrb	w3, [x19], #1
    4000cc54:	51002461 	sub	w1, w3, #0x9
    4000cc58:	7100807f 	cmp	w3, #0x20
	} while (isspace(c));
    4000cc5c:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    4000cc60:	54ffff69 	b.ls	4000cc4c <strtol+0x1c>  // b.plast
	if (c == '-') {
    4000cc64:	7100b47f 	cmp	w3, #0x2d
    4000cc68:	54000541 	b.ne	4000cd10 <strtol+0xe0>  // b.any
		neg = 1;
		c = *s++;
    4000cc6c:	39400263 	ldrb	w3, [x19]
    4000cc70:	91000813 	add	x19, x0, #0x2
		neg = 1;
    4000cc74:	52800021 	mov	w1, #0x1                   	// #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
    4000cc78:	721b785f 	tst	w2, #0xffffffef
    4000cc7c:	54000161 	b.ne	4000cca8 <strtol+0x78>  // b.any
    4000cc80:	7100c07f 	cmp	w3, #0x30
    4000cc84:	540008c1 	b.ne	4000cd9c <strtol+0x16c>  // b.any
	    c == '0' && (*s == 'x' || *s == 'X')) {
    4000cc88:	39400260 	ldrb	w0, [x19]
    4000cc8c:	121a7800 	and	w0, w0, #0xffffffdf
    4000cc90:	12001c00 	and	w0, w0, #0xff
    4000cc94:	7101601f 	cmp	w0, #0x58
    4000cc98:	540008a1 	b.ne	4000cdac <strtol+0x17c>  // b.any
		c = s[1];
    4000cc9c:	39400663 	ldrb	w3, [x19, #1]
		s += 2;
    4000cca0:	91000a73 	add	x19, x19, #0x2
		base = 16;
    4000cca4:	52800202 	mov	w2, #0x10                  	// #16
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    4000cca8:	92f00014 	mov	x20, #0x7fffffffffffffff    	// #9223372036854775807
	cutlim = cutoff % (unsigned long)base;
    4000ccac:	93407c47 	sxtw	x7, w2
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    4000ccb0:	8b21c294 	add	x20, x20, w1, sxtw
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
    4000ccb4:	52800005 	mov	w5, #0x0                   	// #0
    4000ccb8:	d2800000 	mov	x0, #0x0                   	// #0
		if (isdigit(c)) {
			c -= '0';
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    4000ccbc:	528006ea 	mov	w10, #0x37                  	// #55
    4000ccc0:	52800aeb 	mov	w11, #0x57                  	// #87
	cutlim = cutoff % (unsigned long)base;
    4000ccc4:	9ac70a88 	udiv	x8, x20, x7
    4000ccc8:	1b07d109 	msub	w9, w8, w7, w20
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    4000cccc:	5100c064 	sub	w4, w3, #0x30
		if (isdigit(c)) {
    4000ccd0:	7100249f 	cmp	w4, #0x9
    4000ccd4:	540002a8 	b.hi	4000cd28 <strtol+0xf8>  // b.pmore
			c -= '0';
    4000ccd8:	2a0403e3 	mov	w3, w4
		} else {
			break;
		}
		if (c >= base) {
    4000ccdc:	6b03005f 	cmp	w2, w3
    4000cce0:	540003ad 	b.le	4000cd54 <strtol+0x124>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
    4000cce4:	710000bf 	cmp	w5, #0x0
    4000cce8:	fa48a002 	ccmp	x0, x8, #0x2, ge  // ge = tcont
    4000ccec:	54000308 	b.hi	4000cd4c <strtol+0x11c>  // b.pmore
    4000ccf0:	eb08001f 	cmp	x0, x8
    4000ccf4:	7a490064 	ccmp	w3, w9, #0x4, eq  // eq = none
    4000ccf8:	540002ac 	b.gt	4000cd4c <strtol+0x11c>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
    4000ccfc:	93407c63 	sxtw	x3, w3
			any = 1;
    4000cd00:	52800025 	mov	w5, #0x1                   	// #1
			acc += c;
    4000cd04:	9b000ce0 	madd	x0, x7, x0, x3
	for (acc = 0, any = 0;; c = *s++) {
    4000cd08:	38401663 	ldrb	w3, [x19], #1
		if (isdigit(c)) {
    4000cd0c:	17fffff0 	b	4000cccc <strtol+0x9c>
	} else if (c == '+') {
    4000cd10:	7100ac7f 	cmp	w3, #0x2b
    4000cd14:	54000061 	b.ne	4000cd20 <strtol+0xf0>  // b.any
		c = *s++;
    4000cd18:	39400263 	ldrb	w3, [x19]
    4000cd1c:	91000813 	add	x19, x0, #0x2
	register int neg = 0, any, cutlim;
    4000cd20:	52800001 	mov	w1, #0x0                   	// #0
    4000cd24:	17ffffd5 	b	4000cc78 <strtol+0x48>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    4000cd28:	321b0064 	orr	w4, w3, #0x20
    4000cd2c:	51018484 	sub	w4, w4, #0x61
		} else if (isalpha(c)) {
    4000cd30:	7100649f 	cmp	w4, #0x19
    4000cd34:	54000108 	b.hi	4000cd54 <strtol+0x124>  // b.pmore
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    4000cd38:	51010464 	sub	w4, w3, #0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    4000cd3c:	7100689f 	cmp	w4, #0x1a
    4000cd40:	1a8b3144 	csel	w4, w10, w11, cc  // cc = lo, ul, last
    4000cd44:	4b040063 	sub	w3, w3, w4
    4000cd48:	17ffffe5 	b	4000ccdc <strtol+0xac>
			any = -1;
    4000cd4c:	12800005 	mov	w5, #0xffffffff            	// #-1
    4000cd50:	17ffffee 	b	4000cd08 <strtol+0xd8>
		}
	}

	if (any < 0) {
    4000cd54:	310004bf 	cmn	w5, #0x1
    4000cd58:	54000141 	b.ne	4000cd80 <strtol+0x150>  // b.any
    4000cd5c:	94000596 	bl	4000e3b4 <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
    4000cd60:	52800441 	mov	w1, #0x22                  	// #34
    4000cd64:	b9000001 	str	w1, [x0]
		acc = neg ? LONG_MIN : LONG_MAX;
    4000cd68:	aa1403e0 	mov	x0, x20
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
    4000cd6c:	b5000135 	cbnz	x21, 4000cd90 <strtol+0x160>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
    4000cd70:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000cd74:	f94013f5 	ldr	x21, [sp, #32]
    4000cd78:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000cd7c:	d65f03c0 	ret
	} else if (neg) {
    4000cd80:	34000041 	cbz	w1, 4000cd88 <strtol+0x158>
		acc = -acc;
    4000cd84:	cb0003e0 	neg	x0, x0
	if (endptr != NULL) {
    4000cd88:	b4ffff55 	cbz	x21, 4000cd70 <strtol+0x140>
		*endptr = (char *)(any ? s - 1 : nptr);
    4000cd8c:	34000045 	cbz	w5, 4000cd94 <strtol+0x164>
    4000cd90:	d1000666 	sub	x6, x19, #0x1
    4000cd94:	f90002a6 	str	x6, [x21]
	return acc;
    4000cd98:	17fffff6 	b	4000cd70 <strtol+0x140>
		base = c == '0' ? 8 : 10;
    4000cd9c:	7100005f 	cmp	w2, #0x0
    4000cda0:	52800140 	mov	w0, #0xa                   	// #10
    4000cda4:	1a801042 	csel	w2, w2, w0, ne  // ne = any
    4000cda8:	17ffffc0 	b	4000cca8 <strtol+0x78>
    4000cdac:	7100005f 	cmp	w2, #0x0
    4000cdb0:	52800100 	mov	w0, #0x8                   	// #8
    4000cdb4:	17fffffc 	b	4000cda4 <strtol+0x174>

000000004000cdb8 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
    4000cdb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000cdbc:	aa0003e6 	mov	x6, x0
    4000cdc0:	910003fd 	mov	x29, sp
    4000cdc4:	a90153f3 	stp	x19, x20, [sp, #16]
    4000cdc8:	aa0103f4 	mov	x20, x1
	register const char *s = nptr;
    4000cdcc:	aa0003f3 	mov	x19, x0

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
    4000cdd0:	aa1303e0 	mov	x0, x19
    4000cdd4:	38401663 	ldrb	w3, [x19], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    4000cdd8:	51002461 	sub	w1, w3, #0x9
    4000cddc:	7100807f 	cmp	w3, #0x20
	} while (isspace(c));
    4000cde0:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    4000cde4:	54ffff69 	b.ls	4000cdd0 <strtoul+0x18>  // b.plast
	if (c == '-') {
    4000cde8:	7100b47f 	cmp	w3, #0x2d
    4000cdec:	54000541 	b.ne	4000ce94 <strtoul+0xdc>  // b.any
		neg = 1;
		c = *s++;
    4000cdf0:	39400263 	ldrb	w3, [x19]
    4000cdf4:	91000813 	add	x19, x0, #0x2
		neg = 1;
    4000cdf8:	52800027 	mov	w7, #0x1                   	// #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
    4000cdfc:	721b785f 	tst	w2, #0xffffffef
    4000ce00:	54000161 	b.ne	4000ce2c <strtoul+0x74>  // b.any
    4000ce04:	7100c07f 	cmp	w3, #0x30
    4000ce08:	54000921 	b.ne	4000cf2c <strtoul+0x174>  // b.any
	    c == '0' && (*s == 'x' || *s == 'X')) {
    4000ce0c:	39400260 	ldrb	w0, [x19]
    4000ce10:	121a7800 	and	w0, w0, #0xffffffdf
    4000ce14:	12001c00 	and	w0, w0, #0xff
    4000ce18:	7101601f 	cmp	w0, #0x58
    4000ce1c:	54000801 	b.ne	4000cf1c <strtoul+0x164>  // b.any
		c = s[1];
    4000ce20:	39400663 	ldrb	w3, [x19, #1]
		s += 2;
    4000ce24:	91000a73 	add	x19, x19, #0x2
		base = 16;
    4000ce28:	52800202 	mov	w2, #0x10                  	// #16

	if (base == 0) {
		base = c == '0' ? 8 : 10;
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    4000ce2c:	93407c48 	sxtw	x8, w2
    4000ce30:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
    4000ce34:	52800005 	mov	w5, #0x0                   	// #0
    4000ce38:	d2800000 	mov	x0, #0x0                   	// #0
		if (isdigit(c)) {
			c -= '0';
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    4000ce3c:	528006ea 	mov	w10, #0x37                  	// #55
    4000ce40:	52800aeb 	mov	w11, #0x57                  	// #87
	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    4000ce44:	9ac80821 	udiv	x1, x1, x8
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
    4000ce48:	9b087c29 	mul	x9, x1, x8
    4000ce4c:	2a2903e9 	mvn	w9, w9
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    4000ce50:	5100c064 	sub	w4, w3, #0x30
		if (isdigit(c)) {
    4000ce54:	7100249f 	cmp	w4, #0x9
    4000ce58:	540002a8 	b.hi	4000ceac <strtoul+0xf4>  // b.pmore
			c -= '0';
    4000ce5c:	2a0403e3 	mov	w3, w4
		} else {
			break;
		}
		if (c >= base) {
    4000ce60:	6b03005f 	cmp	w2, w3
    4000ce64:	540003ad 	b.le	4000ced8 <strtoul+0x120>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
    4000ce68:	710000bf 	cmp	w5, #0x0
    4000ce6c:	fa41a002 	ccmp	x0, x1, #0x2, ge  // ge = tcont
    4000ce70:	54000308 	b.hi	4000ced0 <strtoul+0x118>  // b.pmore
    4000ce74:	eb01001f 	cmp	x0, x1
    4000ce78:	7a490064 	ccmp	w3, w9, #0x4, eq  // eq = none
    4000ce7c:	540002ac 	b.gt	4000ced0 <strtoul+0x118>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
    4000ce80:	93407c63 	sxtw	x3, w3
			any = 1;
    4000ce84:	52800025 	mov	w5, #0x1                   	// #1
			acc += c;
    4000ce88:	9b000d00 	madd	x0, x8, x0, x3
	for (acc = 0, any = 0;; c = *s++) {
    4000ce8c:	38401663 	ldrb	w3, [x19], #1
		if (isdigit(c)) {
    4000ce90:	17fffff0 	b	4000ce50 <strtoul+0x98>
	} else if (c == '+') {
    4000ce94:	7100ac7f 	cmp	w3, #0x2b
    4000ce98:	54000061 	b.ne	4000cea4 <strtoul+0xec>  // b.any
		c = *s++;
    4000ce9c:	39400263 	ldrb	w3, [x19]
    4000cea0:	91000813 	add	x19, x0, #0x2
	register int neg = 0, any, cutlim;
    4000cea4:	52800007 	mov	w7, #0x0                   	// #0
    4000cea8:	17ffffd5 	b	4000cdfc <strtoul+0x44>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    4000ceac:	321b0064 	orr	w4, w3, #0x20
    4000ceb0:	51018484 	sub	w4, w4, #0x61
		} else if (isalpha(c)) {
    4000ceb4:	7100649f 	cmp	w4, #0x19
    4000ceb8:	54000108 	b.hi	4000ced8 <strtoul+0x120>  // b.pmore
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    4000cebc:	51010464 	sub	w4, w3, #0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    4000cec0:	7100689f 	cmp	w4, #0x1a
    4000cec4:	1a8b3144 	csel	w4, w10, w11, cc  // cc = lo, ul, last
    4000cec8:	4b040063 	sub	w3, w3, w4
    4000cecc:	17ffffe5 	b	4000ce60 <strtoul+0xa8>
			any = -1;
    4000ced0:	12800005 	mov	w5, #0xffffffff            	// #-1
    4000ced4:	17ffffee 	b	4000ce8c <strtoul+0xd4>
		}
	}
	if (any < 0) {
    4000ced8:	310004bf 	cmn	w5, #0x1
    4000cedc:	54000121 	b.ne	4000cf00 <strtoul+0x148>  // b.any
    4000cee0:	94000535 	bl	4000e3b4 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
    4000cee4:	52800441 	mov	w1, #0x22                  	// #34
    4000cee8:	b9000001 	str	w1, [x0]
		acc = ULONG_MAX;
    4000ceec:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
    4000cef0:	b5000114 	cbnz	x20, 4000cf10 <strtoul+0x158>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
    4000cef4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000cef8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000cefc:	d65f03c0 	ret
	} else if (neg) {
    4000cf00:	34000047 	cbz	w7, 4000cf08 <strtoul+0x150>
		acc = -acc;
    4000cf04:	cb0003e0 	neg	x0, x0
	if (endptr != NULL) {
    4000cf08:	b4ffff74 	cbz	x20, 4000cef4 <strtoul+0x13c>
		*endptr = (char *)(any ? s - 1 : nptr);
    4000cf0c:	34000045 	cbz	w5, 4000cf14 <strtoul+0x15c>
    4000cf10:	d1000666 	sub	x6, x19, #0x1
    4000cf14:	f9000286 	str	x6, [x20]
	return acc;
    4000cf18:	17fffff7 	b	4000cef4 <strtoul+0x13c>
		base = c == '0' ? 8 : 10;
    4000cf1c:	7100005f 	cmp	w2, #0x0
    4000cf20:	52800100 	mov	w0, #0x8                   	// #8
    4000cf24:	1a801042 	csel	w2, w2, w0, ne  // ne = any
    4000cf28:	17ffffc1 	b	4000ce2c <strtoul+0x74>
    4000cf2c:	7100005f 	cmp	w2, #0x0
    4000cf30:	52800140 	mov	w0, #0xa                   	// #10
    4000cf34:	17fffffc 	b	4000cf24 <strtoul+0x16c>

000000004000cf38 <sift_down>:
#define right(k) (left(k) + 1)

#define A(k) ((uint8_t *)base + size * (k))

static void sift_down(void *base, int start, int end, size_t size, comp3_t comp, void *comp_arg)
{
    4000cf38:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4000cf3c:	910003fd 	mov	x29, sp
    4000cf40:	a90153f3 	stp	x19, x20, [sp, #16]
    4000cf44:	aa0303f4 	mov	x20, x3
    4000cf48:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000cf4c:	aa0003f6 	mov	x22, x0
    4000cf50:	2a0103f5 	mov	w21, w1
    4000cf54:	a9046bf9 	stp	x25, x26, [sp, #64]
    4000cf58:	2a0203f9 	mov	w25, w2
    4000cf5c:	aa0403fa 	mov	x26, x4
    4000cf60:	f9002bfb 	str	x27, [sp, #80]
    4000cf64:	aa0503fb 	mov	x27, x5
    4000cf68:	a90363f7 	stp	x23, x24, [sp, #48]
	int root;
	int child;
	int swap;

	for (swap = start, root = swap; left(root) < end; root = swap) {
    4000cf6c:	531f7ab7 	lsl	w23, w21, #1
    4000cf70:	110006f3 	add	w19, w23, #0x1
    4000cf74:	6b19027f 	cmp	w19, w25
    4000cf78:	5400010b 	b.lt	4000cf98 <sift_down+0x60>  // b.tstop
			return;
		}

		byteswp(A(root), A(swap), size);
	}
}
    4000cf7c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000cf80:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000cf84:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000cf88:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000cf8c:	f9402bfb 	ldr	x27, [sp, #80]
    4000cf90:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000cf94:	d65f03c0 	ret
		if (comp(A(swap), A(child), comp_arg) < 0) {
    4000cf98:	93407e61 	sxtw	x1, w19
    4000cf9c:	93407eb8 	sxtw	x24, w21
    4000cfa0:	aa1b03e2 	mov	x2, x27
		if (right(root) < end && comp(A(swap), A(right(root)), comp_arg) < 0) {
    4000cfa4:	11000af7 	add	w23, w23, #0x2
		if (comp(A(swap), A(child), comp_arg) < 0) {
    4000cfa8:	9b145821 	madd	x1, x1, x20, x22
    4000cfac:	9b145b18 	madd	x24, x24, x20, x22
    4000cfb0:	aa1803e0 	mov	x0, x24
    4000cfb4:	d63f0340 	blr	x26
    4000cfb8:	7100001f 	cmp	w0, #0x0
    4000cfbc:	1a95b273 	csel	w19, w19, w21, lt  // lt = tstop
		if (right(root) < end && comp(A(swap), A(right(root)), comp_arg) < 0) {
    4000cfc0:	6b1902ff 	cmp	w23, w25
    4000cfc4:	5400012a 	b.ge	4000cfe8 <sift_down+0xb0>  // b.tcont
    4000cfc8:	93407e60 	sxtw	x0, w19
    4000cfcc:	93407ee1 	sxtw	x1, w23
    4000cfd0:	aa1b03e2 	mov	x2, x27
    4000cfd4:	9b145821 	madd	x1, x1, x20, x22
    4000cfd8:	9b145800 	madd	x0, x0, x20, x22
    4000cfdc:	d63f0340 	blr	x26
    4000cfe0:	7100001f 	cmp	w0, #0x0
    4000cfe4:	1a97a273 	csel	w19, w19, w23, ge  // ge = tcont
		if (swap == root) {
    4000cfe8:	6b1302bf 	cmp	w21, w19
    4000cfec:	54fffc80 	b.eq	4000cf7c <sift_down+0x44>  // b.none
		byteswp(A(root), A(swap), size);
    4000cff0:	93407e60 	sxtw	x0, w19
{
	uint8_t t;
	uint8_t *aa = (uint8_t *)a;
	uint8_t *bb = (uint8_t *)b;

	for (; size > 0; --size) {
    4000cff4:	d2800001 	mov	x1, #0x0                   	// #0
    4000cff8:	9b145800 	madd	x0, x0, x20, x22
    4000cffc:	eb14003f 	cmp	x1, x20
    4000d000:	54000061 	b.ne	4000d00c <sift_down+0xd4>  // b.any
    4000d004:	2a1303f5 	mov	w21, w19
    4000d008:	17ffffd9 	b	4000cf6c <sift_down+0x34>
		t = *aa;
		*aa++ = *bb;
    4000d00c:	38616803 	ldrb	w3, [x0, x1]
		t = *aa;
    4000d010:	38616b02 	ldrb	w2, [x24, x1]
		*aa++ = *bb;
    4000d014:	38216b03 	strb	w3, [x24, x1]
		*bb++ = t;
    4000d018:	38216802 	strb	w2, [x0, x1]
	for (; size > 0; --size) {
    4000d01c:	91000421 	add	x1, x1, #0x1
    4000d020:	17fffff7 	b	4000cffc <sift_down+0xc4>

000000004000d024 <qsort_r>:
		sift_down(base, 0, end, size, comp, comp_arg);
	}
}

void qsort_r(void *base, size_t nmemb, size_t size, comp3_t comp, void *arg)
{
    4000d024:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000d028:	910003fd 	mov	x29, sp
    4000d02c:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (start = parent(nmemb - 1); start >= 0; --start) {
    4000d030:	51000836 	sub	w22, w1, #0x2
{
    4000d034:	aa0203f5 	mov	x21, x2
	for (start = parent(nmemb - 1); start >= 0; --start) {
    4000d038:	13017ed6 	asr	w22, w22, #1
{
    4000d03c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000d040:	aa0003f4 	mov	x20, x0
    4000d044:	aa0103f3 	mov	x19, x1
    4000d048:	a90363f7 	stp	x23, x24, [sp, #48]
    4000d04c:	aa0303f7 	mov	x23, x3
    4000d050:	aa0403f8 	mov	x24, x4
    4000d054:	f90023f9 	str	x25, [sp, #64]
	heap_sort(base, nmemb, size, comp, arg);
    4000d058:	2a0103f9 	mov	w25, w1
	for (start = parent(nmemb - 1); start >= 0; --start) {
    4000d05c:	36f80196 	tbz	w22, #31, 4000d08c <qsort_r+0x68>
	for (end = nmemb - 1; end > 0; --end) {
    4000d060:	51000673 	sub	w19, w19, #0x1
    4000d064:	93407e76 	sxtw	x22, w19
    4000d068:	9b1552d6 	madd	x22, x22, x21, x20
    4000d06c:	7100027f 	cmp	w19, #0x0
    4000d070:	5400020c 	b.gt	4000d0b0 <qsort_r+0x8c>
}
    4000d074:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000d078:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000d07c:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000d080:	f94023f9 	ldr	x25, [sp, #64]
    4000d084:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4000d088:	d65f03c0 	ret
		sift_down(base, start, nmemb, size, comp, comp_arg);
    4000d08c:	2a1603e1 	mov	w1, w22
    4000d090:	aa1803e5 	mov	x5, x24
    4000d094:	aa1703e4 	mov	x4, x23
    4000d098:	aa1503e3 	mov	x3, x21
    4000d09c:	2a1903e2 	mov	w2, w25
    4000d0a0:	aa1403e0 	mov	x0, x20
	for (start = parent(nmemb - 1); start >= 0; --start) {
    4000d0a4:	510006d6 	sub	w22, w22, #0x1
		sift_down(base, start, nmemb, size, comp, comp_arg);
    4000d0a8:	97ffffa4 	bl	4000cf38 <sift_down>
	for (start = parent(nmemb - 1); start >= 0; --start) {
    4000d0ac:	17ffffec 	b	4000d05c <qsort_r+0x38>
    4000d0b0:	d2800000 	mov	x0, #0x0                   	// #0
    4000d0b4:	eb0002bf 	cmp	x21, x0
    4000d0b8:	54000161 	b.ne	4000d0e4 <qsort_r+0xc0>  // b.any
		sift_down(base, 0, end, size, comp, comp_arg);
    4000d0bc:	2a1303e2 	mov	w2, w19
    4000d0c0:	aa1803e5 	mov	x5, x24
    4000d0c4:	aa1703e4 	mov	x4, x23
    4000d0c8:	aa1503e3 	mov	x3, x21
    4000d0cc:	aa1403e0 	mov	x0, x20
    4000d0d0:	52800001 	mov	w1, #0x0                   	// #0
	for (end = nmemb - 1; end > 0; --end) {
    4000d0d4:	51000673 	sub	w19, w19, #0x1
    4000d0d8:	cb1502d6 	sub	x22, x22, x21
		sift_down(base, 0, end, size, comp, comp_arg);
    4000d0dc:	97ffff97 	bl	4000cf38 <sift_down>
	for (end = nmemb - 1; end > 0; --end) {
    4000d0e0:	17ffffe3 	b	4000d06c <qsort_r+0x48>
		*aa++ = *bb;
    4000d0e4:	38606a82 	ldrb	w2, [x20, x0]
		t = *aa;
    4000d0e8:	38606ac1 	ldrb	w1, [x22, x0]
		*aa++ = *bb;
    4000d0ec:	38206ac2 	strb	w2, [x22, x0]
		*bb++ = t;
    4000d0f0:	38206a81 	strb	w1, [x20, x0]
	for (; size > 0; --size) {
    4000d0f4:	91000400 	add	x0, x0, #0x1
    4000d0f8:	17ffffef 	b	4000d0b4 <qsort_r+0x90>

000000004000d0fc <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
    4000d0fc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000d100:	910003fd 	mov	x29, sp
    4000d104:	a90153f3 	stp	x19, x20, [sp, #16]
    4000d108:	aa0003f4 	mov	x20, x0
    4000d10c:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000d110:	f9001bf7 	str	x23, [sp, #48]
	char c, sc;
	size_t len;

	c = *find++;
    4000d114:	39400037 	ldrb	w23, [x1]
	if (c != 0) {
    4000d118:	340001f7 	cbz	w23, 4000d154 <strstr+0x58>
	c = *find++;
    4000d11c:	91000433 	add	x19, x1, #0x1
		len = strlen(find);
    4000d120:	aa1303e0 	mov	x0, x19
    4000d124:	94000039 	bl	4000d208 <strlen>
    4000d128:	aa0003f6 	mov	x22, x0
		do {
			do {
				sc = *s++;
    4000d12c:	aa1403f5 	mov	x21, x20
    4000d130:	384016a0 	ldrb	w0, [x21], #1
				if (sc == 0) {
    4000d134:	34000200 	cbz	w0, 4000d174 <strstr+0x78>
					return NULL;
				}
			} while (sc != c);
    4000d138:	6b0002ff 	cmp	w23, w0
    4000d13c:	54000181 	b.ne	4000d16c <strstr+0x70>  // b.any
		} while (strncmp(s, find, len) != 0);
    4000d140:	aa1603e2 	mov	x2, x22
    4000d144:	aa1303e1 	mov	x1, x19
    4000d148:	aa1503e0 	mov	x0, x21
    4000d14c:	94000048 	bl	4000d26c <strncmp>
    4000d150:	350000e0 	cbnz	w0, 4000d16c <strstr+0x70>
	s--;
	}
	return (char *)s;
}
    4000d154:	aa1403e0 	mov	x0, x20
    4000d158:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000d15c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000d160:	f9401bf7 	ldr	x23, [sp, #48]
    4000d164:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000d168:	d65f03c0 	ret
{
    4000d16c:	aa1503f4 	mov	x20, x21
    4000d170:	17ffffef 	b	4000d12c <strstr+0x30>
					return NULL;
    4000d174:	d2800014 	mov	x20, #0x0                   	// #0
    4000d178:	17fffff7 	b	4000d154 <strstr+0x58>

000000004000d17c <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
    4000d17c:	d2800002 	mov	x2, #0x0                   	// #0
    4000d180:	38626823 	ldrb	w3, [x1, x2]
    4000d184:	8b020004 	add	x4, x0, x2
    4000d188:	35000063 	cbnz	w3, 4000d194 <strcpy+0x18>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
    4000d18c:	3900009f 	strb	wzr, [x4]

	return dest;
}
    4000d190:	d65f03c0 	ret
		*d = *s;
    4000d194:	38226803 	strb	w3, [x0, x2]
		s++;
    4000d198:	91000442 	add	x2, x2, #0x1
    4000d19c:	17fffff9 	b	4000d180 <strcpy+0x4>

000000004000d1a0 <strncpy>:

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    4000d1a0:	d2800003 	mov	x3, #0x0                   	// #0
    4000d1a4:	cb030045 	sub	x5, x2, x3
    4000d1a8:	8b030006 	add	x6, x0, x3
    4000d1ac:	eb02007f 	cmp	x3, x2
    4000d1b0:	54000100 	b.eq	4000d1d0 <strncpy+0x30>  // b.none
    4000d1b4:	38636824 	ldrb	w4, [x1, x3]
    4000d1b8:	350000e4 	cbnz	w4, 4000d1d4 <strncpy+0x34>
    4000d1bc:	d2800001 	mov	x1, #0x0                   	// #0
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
    4000d1c0:	382168df 	strb	wzr, [x6, x1]
	while (n > 0) {
    4000d1c4:	91000421 	add	x1, x1, #0x1
    4000d1c8:	eb05003f 	cmp	x1, x5
    4000d1cc:	54ffffa1 	b.ne	4000d1c0 <strncpy+0x20>  // b.any
		d++;
		n--;
	}

	return dest;
}
    4000d1d0:	d65f03c0 	ret
		*d = *s;
    4000d1d4:	38236804 	strb	w4, [x0, x3]
		n--;
    4000d1d8:	91000463 	add	x3, x3, #0x1
    4000d1dc:	17fffff2 	b	4000d1a4 <strncpy+0x4>

000000004000d1e0 <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
    4000d1e0:	12001c21 	and	w1, w1, #0xff

	while ((*s != tmp) && (*s != '\0')) {
    4000d1e4:	39400002 	ldrb	w2, [x0]
    4000d1e8:	6b01005f 	cmp	w2, w1
    4000d1ec:	54000080 	b.eq	4000d1fc <strchr+0x1c>  // b.none
    4000d1f0:	35000082 	cbnz	w2, 4000d200 <strchr+0x20>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
    4000d1f4:	7100003f 	cmp	w1, #0x0
    4000d1f8:	9a9f0000 	csel	x0, x0, xzr, eq  // eq = none
}
    4000d1fc:	d65f03c0 	ret
		s++;
    4000d200:	91000400 	add	x0, x0, #0x1
    4000d204:	17fffff8 	b	4000d1e4 <strchr+0x4>

000000004000d208 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    4000d208:	aa0003e1 	mov	x1, x0
	size_t n = 0;
    4000d20c:	d2800000 	mov	x0, #0x0                   	// #0

	while (*s != '\0') {
    4000d210:	38606822 	ldrb	w2, [x1, x0]
    4000d214:	35000042 	cbnz	w2, 4000d21c <strlen+0x14>
		s++;
		n++;
	}

	return n;
}
    4000d218:	d65f03c0 	ret
		n++;
    4000d21c:	91000400 	add	x0, x0, #0x1
    4000d220:	17fffffc 	b	4000d210 <strlen+0x8>

000000004000d224 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    4000d224:	aa0003e2 	mov	x2, x0
	size_t n = 0;
    4000d228:	d2800000 	mov	x0, #0x0                   	// #0

	while (*s != '\0' && n < maxlen) {
    4000d22c:	38606843 	ldrb	w3, [x2, x0]
    4000d230:	34000063 	cbz	w3, 4000d23c <strnlen+0x18>
    4000d234:	eb01001f 	cmp	x0, x1
    4000d238:	54000041 	b.ne	4000d240 <strnlen+0x1c>  // b.any
		s++;
		n++;
	}

	return n;
}
    4000d23c:	d65f03c0 	ret
		n++;
    4000d240:	91000400 	add	x0, x0, #0x1
    4000d244:	17fffffa 	b	4000d22c <strnlen+0x8>

000000004000d248 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    4000d248:	d2800002 	mov	x2, #0x0                   	// #0
    4000d24c:	38626803 	ldrb	w3, [x0, x2]
    4000d250:	38626824 	ldrb	w4, [x1, x2]
    4000d254:	6b04007f 	cmp	w3, w4
    4000d258:	54000061 	b.ne	4000d264 <strcmp+0x1c>  // b.any
    4000d25c:	91000442 	add	x2, x2, #0x1
    4000d260:	35ffff63 	cbnz	w3, 4000d24c <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    4000d264:	4b040060 	sub	w0, w3, w4
    4000d268:	d65f03c0 	ret

000000004000d26c <strncmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    4000d26c:	d2800004 	mov	x4, #0x0                   	// #0
    4000d270:	eb04005f 	cmp	x2, x4
    4000d274:	54000120 	b.eq	4000d298 <strncmp+0x2c>  // b.none
    4000d278:	38646803 	ldrb	w3, [x0, x4]
    4000d27c:	38646825 	ldrb	w5, [x1, x4]
    4000d280:	6b05007f 	cmp	w3, w5
    4000d284:	54000061 	b.ne	4000d290 <strncmp+0x24>  // b.any
    4000d288:	91000484 	add	x4, x4, #0x1
    4000d28c:	35ffff23 	cbnz	w3, 4000d270 <strncmp+0x4>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
    4000d290:	4b050060 	sub	w0, w3, w5
    4000d294:	14000002 	b	4000d29c <strncmp+0x30>
    4000d298:	52800000 	mov	w0, #0x0                   	// #0
}
    4000d29c:	d65f03c0 	ret

000000004000d2a0 <memcmp>:
int memcmp(const void *m1, const void *m2, size_t n)
{
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
    4000d2a0:	b4000182 	cbz	x2, 4000d2d0 <memcmp+0x30>
    4000d2a4:	d1000442 	sub	x2, x2, #0x1
    4000d2a8:	d2800004 	mov	x4, #0x0                   	// #0
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
    4000d2ac:	38646803 	ldrb	w3, [x0, x4]
    4000d2b0:	eb04005f 	cmp	x2, x4
    4000d2b4:	38646825 	ldrb	w5, [x1, x4]
    4000d2b8:	54000080 	b.eq	4000d2c8 <memcmp+0x28>  // b.none
    4000d2bc:	91000484 	add	x4, x4, #0x1
    4000d2c0:	6b05007f 	cmp	w3, w5
    4000d2c4:	54ffff40 	b.eq	4000d2ac <memcmp+0xc>  // b.none
		c1++;
		c2++;
	}

	return *c1 - *c2;
    4000d2c8:	4b050060 	sub	w0, w3, w5
}
    4000d2cc:	d65f03c0 	ret
		return 0;
    4000d2d0:	52800000 	mov	w0, #0x0                   	// #0
    4000d2d4:	17fffffe 	b	4000d2cc <memcmp+0x2c>

000000004000d2d8 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
    4000d2d8:	cb010003 	sub	x3, x0, x1
    4000d2dc:	eb02007f 	cmp	x3, x2
    4000d2e0:	54000163 	b.cc	4000d30c <memmove+0x34>  // b.lo, b.ul, b.last
    4000d2e4:	d2800003 	mov	x3, #0x0                   	// #0
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
    4000d2e8:	eb03005f 	cmp	x2, x3
    4000d2ec:	54000120 	b.eq	4000d310 <memmove+0x38>  // b.none
			*dest = *src;
    4000d2f0:	38636824 	ldrb	w4, [x1, x3]
    4000d2f4:	38236804 	strb	w4, [x0, x3]
			dest++;
			src++;
			n--;
    4000d2f8:	91000463 	add	x3, x3, #0x1
    4000d2fc:	17fffffb 	b	4000d2e8 <memmove+0x10>
			n--;
    4000d300:	d1000442 	sub	x2, x2, #0x1
			dest[n] = src[n];
    4000d304:	38626823 	ldrb	w3, [x1, x2]
    4000d308:	38226803 	strb	w3, [x0, x2]
		while (n > 0) {
    4000d30c:	b5ffffa2 	cbnz	x2, 4000d300 <memmove+0x28>
		}
	}

	return d;
}
    4000d310:	d65f03c0 	ret

000000004000d314 <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
    4000d314:	d2800003 	mov	x3, #0x0                   	// #0
    4000d318:	eb03005f 	cmp	x2, x3
    4000d31c:	54000041 	b.ne	4000d324 <memcpy+0x10>  // b.any
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    4000d320:	d65f03c0 	ret
		*(d_byte++) = *(s_byte++);
    4000d324:	38636824 	ldrb	w4, [x1, x3]
    4000d328:	38236804 	strb	w4, [x0, x3]
		n--;
    4000d32c:	91000463 	add	x3, x3, #0x1
    4000d330:	17fffffa 	b	4000d318 <memcpy+0x4>

000000004000d334 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    4000d334:	12001c21 	and	w1, w1, #0xff
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    4000d338:	d2800003 	mov	x3, #0x0                   	// #0
    4000d33c:	eb03005f 	cmp	x2, x3
    4000d340:	54000041 	b.ne	4000d348 <memset+0x14>  // b.any
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    4000d344:	d65f03c0 	ret
		*(d_byte++) = c_byte;
    4000d348:	38236801 	strb	w1, [x0, x3]
		n--;
    4000d34c:	91000463 	add	x3, x3, #0x1
    4000d350:	17fffffb 	b	4000d33c <memset+0x8>

000000004000d354 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
    4000d354:	12800000 	mov	w0, #0xffffffff            	// #-1
    4000d358:	d65f03c0 	ret

000000004000d35c <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    4000d35c:	d0000301 	adrp	x1, 4006f000 <sys_work_q_stack+0xc10>
    4000d360:	f9063020 	str	x0, [x1, #3168]
}
    4000d364:	d65f03c0 	ret

000000004000d368 <sprintf_out>:
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
	if (p->len > 1) { /* need to reserve a byte for EOS */
    4000d368:	b9400822 	ldr	w2, [x1, #8]
    4000d36c:	7100045f 	cmp	w2, #0x1
    4000d370:	5400012d 	b.le	4000d394 <sprintf_out+0x2c>
		*(p->ptr) = c;
    4000d374:	f9400022 	ldr	x2, [x1]
    4000d378:	39000040 	strb	w0, [x2]
		p->ptr += 1;
    4000d37c:	f9400020 	ldr	x0, [x1]
    4000d380:	91000400 	add	x0, x0, #0x1
    4000d384:	f9000020 	str	x0, [x1]
		p->len -= 1;
    4000d388:	b9400820 	ldr	w0, [x1, #8]
    4000d38c:	51000400 	sub	w0, w0, #0x1
    4000d390:	b9000820 	str	w0, [x1, #8]
	}
	return 0; /* indicate keep going so we get the total count */
}
    4000d394:	52800000 	mov	w0, #0x0                   	// #0
    4000d398:	d65f03c0 	ret

000000004000d39c <snprintf>:

int snprintf(char *ZRESTRICT str, size_t len,
	     const char *ZRESTRICT format, ...)
{
    4000d39c:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
    4000d3a0:	910003fd 	mov	x29, sp
    4000d3a4:	3d801fe0 	str	q0, [sp, #112]
    4000d3a8:	3d8023e1 	str	q1, [sp, #128]
    4000d3ac:	3d8027e2 	str	q2, [sp, #144]
    4000d3b0:	3d802be3 	str	q3, [sp, #160]
    4000d3b4:	3d802fe4 	str	q4, [sp, #176]
    4000d3b8:	3d8033e5 	str	q5, [sp, #192]
    4000d3bc:	3d8037e6 	str	q6, [sp, #208]
    4000d3c0:	3d803be7 	str	q7, [sp, #224]
    4000d3c4:	a90f93e3 	stp	x3, x4, [sp, #248]
    4000d3c8:	a9109be5 	stp	x5, x6, [sp, #264]
    4000d3cc:	f9008fe7 	str	x7, [sp, #280]

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
    4000d3d0:	b5000041 	cbnz	x1, 4000d3d8 <snprintf+0x3c>
		str = &dummy; /* write final NUL to dummy, can't change *s */
    4000d3d4:	9100ffe0 	add	x0, sp, #0x3f
	}

	p.ptr = str;
    4000d3d8:	f90023e0 	str	x0, [sp, #64]
	p.len = (int) len;

	va_start(vargs, format);
    4000d3dc:	910483e0 	add	x0, sp, #0x120
    4000d3e0:	a90503e0 	stp	x0, x0, [sp, #80]
    4000d3e4:	9103c3e0 	add	x0, sp, #0xf0
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
    4000d3e8:	910043e3 	add	x3, sp, #0x10
	va_start(vargs, format);
    4000d3ec:	f90033e0 	str	x0, [sp, #96]
    4000d3f0:	128004e0 	mov	w0, #0xffffffd8            	// #-40
    4000d3f4:	b9006be0 	str	w0, [sp, #104]
    4000d3f8:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    4000d3fc:	b9006fe0 	str	w0, [sp, #108]
	p.len = (int) len;
    4000d400:	b9004be1 	str	w1, [sp, #72]
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
    4000d404:	a94507e0 	ldp	x0, x1, [sp, #80]
    4000d408:	a90107e0 	stp	x0, x1, [sp, #16]
    4000d40c:	a94607e0 	ldp	x0, x1, [sp, #96]
    4000d410:	a90207e0 	stp	x0, x1, [sp, #32]
    4000d414:	910103e1 	add	x1, sp, #0x40
    4000d418:	90000000 	adrp	x0, 4000d000 <sift_down+0xc8>
    4000d41c:	910da000 	add	x0, x0, #0x368
    4000d420:	97ffd503 	bl	4000282c <cbvprintf>
	va_end(vargs);

	*(p.ptr) = 0;
    4000d424:	f94023e1 	ldr	x1, [sp, #64]
    4000d428:	3900003f 	strb	wzr, [x1]
	return r;
}
    4000d42c:	a8d27bfd 	ldp	x29, x30, [sp], #288
    4000d430:	d65f03c0 	ret

000000004000d434 <sprintf>:

int sprintf(char *ZRESTRICT str, const char *ZRESTRICT format, ...)
{
    4000d434:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
    4000d438:	910003fd 	mov	x29, sp
	va_list vargs;

	struct emitter p;
	int     r;

	p.ptr = str;
    4000d43c:	f9001be0 	str	x0, [sp, #48]
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
    4000d440:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    4000d444:	b9003be0 	str	w0, [sp, #56]

	va_start(vargs, format);
    4000d448:	910443e0 	add	x0, sp, #0x110
    4000d44c:	a90403e0 	stp	x0, x0, [sp, #64]
    4000d450:	910383e0 	add	x0, sp, #0xe0
    4000d454:	f9002be0 	str	x0, [sp, #80]
    4000d458:	128005e0 	mov	w0, #0xffffffd0            	// #-48
    4000d45c:	b9005be0 	str	w0, [sp, #88]
    4000d460:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    4000d464:	b9005fe0 	str	w0, [sp, #92]
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
    4000d468:	90000000 	adrp	x0, 4000d000 <sift_down+0xc8>
    4000d46c:	910da000 	add	x0, x0, #0x368
{
    4000d470:	a90e0fe2 	stp	x2, x3, [sp, #224]
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
    4000d474:	a9440fe2 	ldp	x2, x3, [sp, #64]
    4000d478:	a9010fe2 	stp	x2, x3, [sp, #16]
    4000d47c:	a9450fe2 	ldp	x2, x3, [sp, #80]
    4000d480:	a9020fe2 	stp	x2, x3, [sp, #32]
    4000d484:	910043e3 	add	x3, sp, #0x10
    4000d488:	aa0103e2 	mov	x2, x1
    4000d48c:	9100c3e1 	add	x1, sp, #0x30
{
    4000d490:	3d801be0 	str	q0, [sp, #96]
    4000d494:	3d801fe1 	str	q1, [sp, #112]
    4000d498:	3d8023e2 	str	q2, [sp, #128]
    4000d49c:	3d8027e3 	str	q3, [sp, #144]
    4000d4a0:	3d802be4 	str	q4, [sp, #160]
    4000d4a4:	3d802fe5 	str	q5, [sp, #176]
    4000d4a8:	3d8033e6 	str	q6, [sp, #192]
    4000d4ac:	3d8037e7 	str	q7, [sp, #208]
    4000d4b0:	a90f17e4 	stp	x4, x5, [sp, #240]
    4000d4b4:	a9101fe6 	stp	x6, x7, [sp, #256]
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
    4000d4b8:	97ffd4dd 	bl	4000282c <cbvprintf>
	va_end(vargs);

	*(p.ptr) = 0;
    4000d4bc:	f9401be1 	ldr	x1, [sp, #48]
    4000d4c0:	3900003f 	strb	wzr, [x1]
	return r;
}
    4000d4c4:	a8d17bfd 	ldp	x29, x30, [sp], #272
    4000d4c8:	d65f03c0 	ret

000000004000d4cc <gmtime_r>:
 * applied to @p time before invoking this function.
 */
struct tm *gmtime_r(const time_t *ZRESTRICT timep,
		    struct tm *ZRESTRICT result)
{
	time_t z = *timep;
    4000d4cc:	f9400002 	ldr	x2, [x0]
	bigint_type days = (z >= 0 ? z : z - 86399) / 86400;
    4000d4d0:	d28a3003 	mov	x3, #0x5180                	// #20864
    4000d4d4:	f2a00023 	movk	x3, #0x1, lsl #16
    4000d4d8:	b6f80a82 	tbz	x2, #63, 4000d628 <gmtime_r+0x15c>
    4000d4dc:	d1405440 	sub	x0, x2, #0x15, lsl #12
    4000d4e0:	d105fc00 	sub	x0, x0, #0x17f
    4000d4e4:	9ac30c03 	sdiv	x3, x0, x3
	unsigned int rem = z - days * 86400;
    4000d4e8:	5295d000 	mov	w0, #0xae80                	// #44672
    4000d4ec:	72bfffc0 	movk	w0, #0xfffe, lsl #16

	*result = (struct tm){ 0 };
    4000d4f0:	a9007c3f 	stp	xzr, xzr, [x1]
	tp->tm_wday = (z >= -4) ? ((z + 4) % 7) : ((z + 5) % 7 + 6);
    4000d4f4:	b100107f 	cmn	x3, #0x4
	unsigned int rem = z - days * 86400;
    4000d4f8:	1b030806 	madd	w6, w0, w3, w2
	*result = (struct tm){ 0 };
    4000d4fc:	a9017c3f 	stp	xzr, xzr, [x1, #16]
    4000d500:	d28000e4 	mov	x4, #0x7                   	// #7
    4000d504:	b900203f 	str	wzr, [x1, #32]
	tp->tm_wday = (z >= -4) ? ((z + 4) % 7) : ((z + 5) % 7 + 6);
    4000d508:	5400094b 	b.lt	4000d630 <gmtime_r+0x164>  // b.tstop
    4000d50c:	91001060 	add	x0, x3, #0x4
    4000d510:	9ac40802 	udiv	x2, x0, x4
    4000d514:	1b048040 	msub	w0, w2, w4, w0
    4000d518:	b9001820 	str	w0, [x1, #24]
	z += 719468;
    4000d51c:	9142bc62 	add	x2, x3, #0xaf, lsl #12
    4000d520:	d2875620 	mov	x0, #0x3ab1                	// #15025
    4000d524:	f2a00040 	movk	x0, #0x2, lsl #16
    4000d528:	9129b042 	add	x2, x2, #0xa6c
	bigint_type era = ((z >= 0) ? z : (z - 146096)) / 146097;
    4000d52c:	b6f808c2 	tbz	x2, #63, 4000d644 <gmtime_r+0x178>
    4000d530:	91422c63 	add	x3, x3, #0x8b, lsl #12
    4000d534:	913ef063 	add	x3, x3, #0xfbc
    4000d538:	9ac00c60 	sdiv	x0, x3, x0
	unsigned int doe = (z - era * (bigint_type)146097);
    4000d53c:	5298a9e5 	mov	w5, #0xc54f                	// #50511
    4000d540:	72bfffa5 	movk	w5, #0xfffd, lsl #16
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
    4000d544:	5280b683 	mov	w3, #0x5b4                 	// #1460
    4000d548:	5291d584 	mov	w4, #0x8eac                	// #36524
	unsigned int doe = (z - era * (bigint_type)146097);
    4000d54c:	1b0008a5 	madd	w5, w5, w0, w2
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
    4000d550:	52875607 	mov	w7, #0x3ab0                	// #15024
    4000d554:	72a00047 	movk	w7, #0x2, lsl #16
    4000d558:	52802da9 	mov	w9, #0x16d                 	// #365
	bigint_type y = (time_t)yoe + era * 400;
    4000d55c:	d2803208 	mov	x8, #0x190                 	// #400
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
    4000d560:	52800c8b 	mov	w11, #0x64                  	// #100
	unsigned int d = doy - (153U * mp + 2U) / 5U + 1U;
    4000d564:	528000ac 	mov	w12, #0x5                   	// #5
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
    4000d568:	1ac308a2 	udiv	w2, w5, w3
    4000d56c:	1ac708a7 	udiv	w7, w5, w7
    4000d570:	1ac408a4 	udiv	w4, w5, w4
    4000d574:	0b070042 	add	w2, w2, w7
    4000d578:	0b050084 	add	w4, w4, w5
    4000d57c:	4b020084 	sub	w4, w4, w2
    4000d580:	1ac90882 	udiv	w2, w4, w9
	bigint_type y = (time_t)yoe + era * 400;
    4000d584:	9b080800 	madd	x0, x0, x8, x2
	unsigned int yoe = (doe - doe / 1460U + doe / 36524U - doe / 146096U)
    4000d588:	aa0203e7 	mov	x7, x2
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
    4000d58c:	1acb0848 	udiv	w8, w2, w11
	tp->tm_year = y + (m <= 2) - 1900;
    4000d590:	511db000 	sub	w0, w0, #0x76c
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
    4000d594:	1ac30882 	udiv	w2, w4, w3
    4000d598:	1b0994e5 	msub	w5, w7, w9, w5
	unsigned int mp = (5U * doy + 2U) / 153U;
    4000d59c:	52801323 	mov	w3, #0x99                  	// #153
	unsigned int doy = doe - (365U * yoe + yoe / 4U - yoe / 100U);
    4000d5a0:	4b020102 	sub	w2, w8, w2
    4000d5a4:	0b050042 	add	w2, w2, w5
	unsigned int d = doy - (153U * mp + 2U) / 5U + 1U;
    4000d5a8:	1100044a 	add	w10, w2, #0x1
	unsigned int mp = (5U * doy + 2U) / 153U;
    4000d5ac:	0b020849 	add	w9, w2, w2, lsl #2
    4000d5b0:	11000929 	add	w9, w9, #0x2
	unsigned int m = mp + ((mp < 10) ? 3 : -9);
    4000d5b4:	7117e93f 	cmp	w9, #0x5fa
	unsigned int mp = (5U * doy + 2U) / 153U;
    4000d5b8:	1ac30925 	udiv	w5, w9, w3
	unsigned int m = mp + ((mp < 10) ? 3 : -9);
    4000d5bc:	52800069 	mov	w9, #0x3                   	// #3
	unsigned int d = doy - (153U * mp + 2U) / 5U + 1U;
    4000d5c0:	1b037ca3 	mul	w3, w5, w3
    4000d5c4:	11000863 	add	w3, w3, #0x2
    4000d5c8:	1acc0863 	udiv	w3, w3, w12
    4000d5cc:	4b030143 	sub	w3, w10, w3
	unsigned int m = mp + ((mp < 10) ? 3 : -9);
    4000d5d0:	1280010a 	mov	w10, #0xfffffff7            	// #-9
    4000d5d4:	1a8a3129 	csel	w9, w9, w10, cc  // cc = lo, ul, last
    4000d5d8:	0b0900a5 	add	w5, w5, w9
	tp->tm_year = y + (m <= 2) - 1900;
    4000d5dc:	710008bf 	cmp	w5, #0x2
	tp->tm_mon = m - 1;
    4000d5e0:	510004a5 	sub	w5, w5, #0x1
	tp->tm_year = y + (m <= 2) - 1900;
    4000d5e4:	1a808400 	cinc	w0, w0, ls  // ls = plast
	tp->tm_mon = m - 1;
    4000d5e8:	29019423 	stp	w3, w5, [x1, #12]
	tp->tm_year = y + (m <= 2) - 1900;
    4000d5ec:	b9001420 	str	w0, [x1, #20]
	if (doy >= 306U) {
    4000d5f0:	7104c45f 	cmp	w2, #0x131
    4000d5f4:	540002c9 	b.ls	4000d64c <gmtime_r+0x180>  // b.plast
		tp->tm_yday = doy - 306U;
    4000d5f8:	5104c842 	sub	w2, w2, #0x132
		tp->tm_yday = doy + 59U + (((yoe % 4U == 0U) && (yoe % 100U != 0U)) || (yoe == 0U));
    4000d5fc:	b9001c22 	str	w2, [x1, #28]

	time_civil_from_days(days, result);

	result->tm_hour = rem / 60U / 60U;
    4000d600:	5281c202 	mov	w2, #0xe10                 	// #3600
	rem -= result->tm_hour * 60 * 60;
	result->tm_min = rem / 60;
    4000d604:	52800783 	mov	w3, #0x3c                  	// #60
	result->tm_hour = rem / 60U / 60U;
    4000d608:	1ac208c0 	udiv	w0, w6, w2
    4000d60c:	b9000820 	str	w0, [x1, #8]
	rem -= result->tm_hour * 60 * 60;
    4000d610:	1b029800 	msub	w0, w0, w2, w6
	result->tm_min = rem / 60;
    4000d614:	1ac30802 	udiv	w2, w0, w3
	result->tm_sec = rem - result->tm_min * 60;
    4000d618:	1b038040 	msub	w0, w2, w3, w0
	result->tm_min = rem / 60;
    4000d61c:	29000820 	stp	w0, w2, [x1]

	return result;
}
    4000d620:	aa0103e0 	mov	x0, x1
    4000d624:	d65f03c0 	ret
	bigint_type days = (z >= 0 ? z : z - 86399) / 86400;
    4000d628:	9ac30c43 	sdiv	x3, x2, x3
    4000d62c:	17ffffaf 	b	4000d4e8 <gmtime_r+0x1c>
	tp->tm_wday = (z >= -4) ? ((z + 4) % 7) : ((z + 5) % 7 + 6);
    4000d630:	91001462 	add	x2, x3, #0x5
    4000d634:	9ac40c40 	sdiv	x0, x2, x4
    4000d638:	9b048800 	msub	x0, x0, x4, x2
    4000d63c:	11001800 	add	w0, w0, #0x6
    4000d640:	17ffffb6 	b	4000d518 <gmtime_r+0x4c>
	bigint_type era = ((z >= 0) ? z : (z - 146096)) / 146097;
    4000d644:	9ac00c40 	sdiv	x0, x2, x0
    4000d648:	17ffffbd 	b	4000d53c <gmtime_r+0x70>
		tp->tm_yday = doy + 59U + (((yoe % 4U == 0U) && (yoe % 100U != 0U)) || (yoe == 0U));
    4000d64c:	f24004ff 	tst	x7, #0x3
    4000d650:	54000061 	b.ne	4000d65c <gmtime_r+0x190>  // b.any
    4000d654:	1b0b9d07 	msub	w7, w8, w11, w7
    4000d658:	350000c7 	cbnz	w7, 4000d670 <gmtime_r+0x1a4>
    4000d65c:	7105b09f 	cmp	w4, #0x16c
    4000d660:	1a9f87e0 	cset	w0, ls  // ls = plast
    4000d664:	1100ec42 	add	w2, w2, #0x3b
    4000d668:	0b000042 	add	w2, w2, w0
    4000d66c:	17ffffe4 	b	4000d5fc <gmtime_r+0x130>
    4000d670:	52800020 	mov	w0, #0x1                   	// #1
    4000d674:	17fffffc 	b	4000d664 <gmtime_r+0x198>

000000004000d678 <z_impl_clock_gettime>:
 * @brief Get clock time specified by clock_id.
 *
 * See IEEE 1003.1
 */
int z_impl_clock_gettime(clockid_t clock_id, struct timespec *ts)
{
    4000d678:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	uint64_t elapsed_nsecs;
	struct timespec base;

	switch (clock_id) {
    4000d67c:	7100041f 	cmp	w0, #0x1
{
    4000d680:	910003fd 	mov	x29, sp
    4000d684:	a90153f3 	stp	x19, x20, [sp, #16]
    4000d688:	aa0103f4 	mov	x20, x1
    4000d68c:	f90013f5 	str	x21, [sp, #32]
	switch (clock_id) {
    4000d690:	54000160 	b.eq	4000d6bc <z_impl_clock_gettime+0x44>  // b.none
    4000d694:	7100101f 	cmp	w0, #0x4
    4000d698:	54000420 	b.eq	4000d71c <z_impl_clock_gettime+0xa4>  // b.none
    4000d69c:	94000346 	bl	4000e3b4 <z_impl_z_errno>
	case CLOCK_REALTIME:
		base = rt_clock_base;
		break;

	default:
		errno = EINVAL;
    4000d6a0:	528002c1 	mov	w1, #0x16                  	// #22
    4000d6a4:	b9000001 	str	w1, [x0]
		return -1;
    4000d6a8:	12800000 	mov	w0, #0xffffffff            	// #-1
		ts->tv_sec++;
		ts->tv_nsec -= NSEC_PER_SEC;
	}

	return 0;
}
    4000d6ac:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000d6b0:	f94013f5 	ldr	x21, [sp, #32]
    4000d6b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000d6b8:	d65f03c0 	ret
		base = rt_clock_base;
    4000d6bc:	900000a0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000d6c0:	911cc001 	add	x1, x0, #0x730
    4000d6c4:	f9439813 	ldr	x19, [x0, #1840]
    4000d6c8:	f9400435 	ldr	x21, [x1, #8]
	return z_impl_k_uptime_ticks();
    4000d6cc:	94000cfe 	bl	40010ac4 <z_impl_k_uptime_ticks>
			return t * ((uint64_t)to_hz / from_hz);
    4000d6d0:	d292d002 	mov	x2, #0x9680                	// #38528
    4000d6d4:	f2a01302 	movk	x2, #0x98, lsl #16
	ts->tv_sec = (int32_t) (elapsed_nsecs / NSEC_PER_SEC);
    4000d6d8:	d2994001 	mov	x1, #0xca00                	// #51712
    4000d6dc:	f2a77341 	movk	x1, #0x3b9a, lsl #16
    4000d6e0:	9b027c00 	mul	x0, x0, x2
    4000d6e4:	9ac10802 	udiv	x2, x0, x1
	ts->tv_sec += base.tv_sec;
    4000d6e8:	8b22c273 	add	x19, x19, w2, sxtw
	ts->tv_nsec = (int32_t) (elapsed_nsecs % NSEC_PER_SEC);
    4000d6ec:	9b018042 	msub	x2, x2, x1, x0
	ts->tv_nsec += base.tv_nsec;
    4000d6f0:	8b150040 	add	x0, x2, x21
    4000d6f4:	a9000293 	stp	x19, x0, [x20]
	if (ts->tv_nsec >= NSEC_PER_SEC) {
    4000d6f8:	d2993fe2 	mov	x2, #0xc9ff                	// #51711
    4000d6fc:	f2a77342 	movk	x2, #0x3b9a, lsl #16
    4000d700:	eb02001f 	cmp	x0, x2
    4000d704:	5400008d 	b.le	4000d714 <z_impl_clock_gettime+0x9c>
		ts->tv_sec++;
    4000d708:	91000673 	add	x19, x19, #0x1
		ts->tv_nsec -= NSEC_PER_SEC;
    4000d70c:	cb010000 	sub	x0, x0, x1
    4000d710:	a9000293 	stp	x19, x0, [x20]
	return 0;
    4000d714:	52800000 	mov	w0, #0x0                   	// #0
    4000d718:	17ffffe5 	b	4000d6ac <z_impl_clock_gettime+0x34>
	switch (clock_id) {
    4000d71c:	d2800015 	mov	x21, #0x0                   	// #0
    4000d720:	d2800013 	mov	x19, #0x0                   	// #0
    4000d724:	17ffffea 	b	4000d6cc <z_impl_clock_gettime+0x54>

000000004000d728 <clock_settime>:
 *
 * Note that only the `CLOCK_REALTIME` clock can be set using this
 * call.
 */
int clock_settime(clockid_t clock_id, const struct timespec *tp)
{
    4000d728:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	struct timespec base;

	if (clock_id != CLOCK_REALTIME) {
    4000d72c:	7100041f 	cmp	w0, #0x1
{
    4000d730:	910003fd 	mov	x29, sp
    4000d734:	f9000bf3 	str	x19, [sp, #16]
	if (clock_id != CLOCK_REALTIME) {
    4000d738:	54000100 	b.eq	4000d758 <clock_settime+0x30>  // b.none
    4000d73c:	9400031e 	bl	4000e3b4 <z_impl_z_errno>
		errno = EINVAL;
    4000d740:	528002c1 	mov	w1, #0x16                  	// #22
    4000d744:	b9000001 	str	w1, [x0]
		return -1;
    4000d748:	12800000 	mov	w0, #0xffffffff            	// #-1
	base.tv_nsec = delta % NSEC_PER_SEC;

	rt_clock_base = base;

	return 0;
}
    4000d74c:	f9400bf3 	ldr	x19, [sp, #16]
    4000d750:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000d754:	d65f03c0 	ret
    4000d758:	aa0103f3 	mov	x19, x1
    4000d75c:	94000cda 	bl	40010ac4 <z_impl_k_uptime_ticks>
	int64_t delta = (int64_t)NSEC_PER_SEC * tp->tv_sec + tp->tv_nsec
    4000d760:	a9400e61 	ldp	x1, x3, [x19]
    4000d764:	d2994002 	mov	x2, #0xca00                	// #51712
    4000d768:	f2a77342 	movk	x2, #0x3b9a, lsl #16
    4000d76c:	9b020c21 	madd	x1, x1, x2, x3
		- elapsed_nsecs;
    4000d770:	d292d003 	mov	x3, #0x9680                	// #38528
    4000d774:	f2a01303 	movk	x3, #0x98, lsl #16
    4000d778:	9b038400 	msub	x0, x0, x3, x1
	rt_clock_base = base;
    4000d77c:	900000a3 	adrp	x3, 40021000 <k_sys_work_q+0x200>
    4000d780:	911cc064 	add	x4, x3, #0x730
	base.tv_sec = delta / NSEC_PER_SEC;
    4000d784:	9ac20c01 	sdiv	x1, x0, x2
	rt_clock_base = base;
    4000d788:	f9039861 	str	x1, [x3, #1840]
	base.tv_nsec = delta % NSEC_PER_SEC;
    4000d78c:	9b028021 	msub	x1, x1, x2, x0
	return 0;
    4000d790:	52800000 	mov	w0, #0x0                   	// #0
	rt_clock_base = base;
    4000d794:	f9000481 	str	x1, [x4, #8]
	return 0;
    4000d798:	17ffffed 	b	4000d74c <clock_settime+0x24>

000000004000d79c <timing_init>:

static bool has_inited;
static atomic_val_t started_ref;

void timing_init(void)
{
    4000d79c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000d7a0:	910003fd 	mov	x29, sp
    4000d7a4:	f9000bf3 	str	x19, [sp, #16]
	if (has_inited) {
    4000d7a8:	900000b3 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    4000d7ac:	396faa60 	ldrb	w0, [x19, #3050]
    4000d7b0:	35000080 	cbnz	w0, 4000d7c0 <timing_init+0x24>
#if defined(CONFIG_BOARD_HAS_TIMING_FUNCTIONS)
	board_timing_init();
#elif defined(CONFIG_SOC_HAS_TIMING_FUNCTIONS)
	soc_timing_init();
#else
	arch_timing_init();
    4000d7b4:	97fff89d 	bl	4000ba28 <arch_timing_init>
#endif

	has_inited = true;
    4000d7b8:	52800020 	mov	w0, #0x1                   	// #1
    4000d7bc:	392faa60 	strb	w0, [x19, #3050]
}
    4000d7c0:	f9400bf3 	ldr	x19, [sp, #16]
    4000d7c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000d7c8:	d65f03c0 	ret

000000004000d7cc <timing_start>:

void timing_start(void)
{
    4000d7cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    4000d7d0:	900000a1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000d7d4:	911d0021 	add	x1, x1, #0x740
    4000d7d8:	910003fd 	mov	x29, sp
    4000d7dc:	d2800020 	mov	x0, #0x1                   	// #1
    4000d7e0:	97ffcdf8 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (atomic_inc(&started_ref) != 0) {
    4000d7e4:	b5000060 	cbnz	x0, 4000d7f0 <timing_start+0x24>
#elif defined(CONFIG_SOC_HAS_TIMING_FUNCTIONS)
	soc_timing_start();
#else
	arch_timing_start();
#endif
}
    4000d7e8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	arch_timing_start();
    4000d7ec:	17fff890 	b	4000ba2c <arch_timing_start>
}
    4000d7f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000d7f4:	d65f03c0 	ret

000000004000d7f8 <gic_get_rdist>:
MAKE_REG_HELPER(tpidrro_el0);
    4000d7f8:	d53bd060 	mrs	x0, tpidrro_el0
	return (_cpu_t *)(read_tpidrro_el0() & TPIDRROEL0_CURR_CPU);
    4000d7fc:	927db000 	and	x0, x0, #0xfffffffffff8
atomic_t nlpi_intid = ATOMIC_INIT(8192);
#endif

static inline mem_addr_t gic_get_rdist(void)
{
	return gic_rdists[arch_curr_cpu()->id];
    4000d800:	39409001 	ldrb	w1, [x0, #36]
}
    4000d804:	900000a0 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000d808:	911d2000 	add	x0, x0, #0x748
    4000d80c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    4000d810:	d65f03c0 	ret

000000004000d814 <gic_wait_rwp.isra.0>:
static int gic_wait_rwp(uint32_t intid)
{
	uint32_t rwp_mask;
	mem_addr_t base;

	if (intid < GIC_SPI_INT_BASE) {
    4000d814:	71007c1f 	cmp	w0, #0x1f
    4000d818:	54000168 	b.hi	4000d844 <gic_wait_rwp.isra.0+0x30>  // b.pmore
static int gic_wait_rwp(uint32_t intid)
    4000d81c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000d820:	910003fd 	mov	x29, sp
		base = (gic_get_rdist() + GICR_CTLR);
    4000d824:	97fffff5 	bl	4000d7f8 <gic_get_rdist>
		rwp_mask = BIT(GICR_CTLR_RWP);
    4000d828:	52800101 	mov	w1, #0x8                   	// #8
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000d82c:	b9400002 	ldr	w2, [x0]
	__DMB();
    4000d830:	d5033fbf 	dmb	sy
	} else {
		base = GICD_CTLR;
		rwp_mask = BIT(GICD_CTLR_RWP);
	}

	while (sys_read32(base) & rwp_mask)
    4000d834:	6a01005f 	tst	w2, w1
    4000d838:	54ffffa1 	b.ne	4000d82c <gic_wait_rwp.isra.0+0x18>  // b.any
		;

	return 0;
}
    4000d83c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000d840:	d65f03c0 	ret
		base = GICD_CTLR;
    4000d844:	d2a10000 	mov	x0, #0x8000000             	// #134217728
		rwp_mask = BIT(GICD_CTLR_RWP);
    4000d848:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000d84c:	b9400002 	ldr	w2, [x0]
	__DMB();
    4000d850:	d5033fbf 	dmb	sy
	while (sys_read32(base) & rwp_mask)
    4000d854:	6a01005f 	tst	w2, w1
    4000d858:	54ffffa1 	b.ne	4000d84c <gic_wait_rwp.isra.0+0x38>  // b.any
    4000d85c:	d65f03c0 	ret

000000004000d860 <arm_gic_init>:

	gicv3_cpuif_init();
}

int arm_gic_init(const struct device *unused)
{
    4000d860:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000d864:	d2800083 	mov	x3, #0x4                   	// #4
    4000d868:	f2a10003 	movk	x3, #0x800, lsl #16
    4000d86c:	910003fd 	mov	x29, sp
    4000d870:	b9400063 	ldr	w3, [x3]
	__DMB();
    4000d874:	d5033fbf 	dmb	sy
	num_ints = (num_ints + 1) << 5;
    4000d878:	531b1063 	ubfiz	w3, w3, #5, #5
    4000d87c:	11008063 	add	w3, w3, #0x20
	__DMB();
    4000d880:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d884:	52800000 	mov	w0, #0x0                   	// #0
    4000d888:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    4000d88c:	b9000020 	str	w0, [x1]
	gic_wait_rwp(GIC_SPI_INT_BASE);
    4000d890:	52800400 	mov	w0, #0x20                  	// #32
    4000d894:	97ffffe0 	bl	4000d814 <gic_wait_rwp.isra.0>
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000d898:	52803005 	mov	w5, #0x180                 	// #384
    4000d89c:	72a10005 	movk	w5, #0x800, lsl #16
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000d8a0:	52805006 	mov	w6, #0x280                 	// #640
    4000d8a4:	72a10006 	movk	w6, #0x800, lsl #16
		sys_write32(IGROUPR_VAL, IGROUPR(base, idx));
    4000d8a8:	52801008 	mov	w8, #0x80                  	// #128
    4000d8ac:	72a10008 	movk	w8, #0x800, lsl #16
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000d8b0:	5281a009 	mov	w9, #0xd00                 	// #3328
    4000d8b4:	72a10009 	movk	w9, #0x800, lsl #16
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    4000d8b8:	52800401 	mov	w1, #0x20                  	// #32
    4000d8bc:	12800002 	mov	w2, #0xffffffff            	// #-1
    4000d8c0:	52800007 	mov	w7, #0x0                   	// #0
    4000d8c4:	6b01007f 	cmp	w3, w1
    4000d8c8:	54000ba8 	b.hi	4000da3c <arm_gic_init+0x1dc>  // b.pmore
	gic_wait_rwp(GIC_SPI_INT_BASE);
    4000d8cc:	52800400 	mov	w0, #0x20                  	// #32
    4000d8d0:	97ffffd1 	bl	4000d814 <gic_wait_rwp.isra.0>
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    4000d8d4:	d2808400 	mov	x0, #0x420                 	// #1056
    4000d8d8:	f2a10000 	movk	x0, #0x800, lsl #16
    4000d8dc:	529f8002 	mov	w2, #0xfc00                	// #64512
    4000d8e0:	72beffe2 	movk	w2, #0xf7ff, lsl #16
    4000d8e4:	52941404 	mov	w4, #0xa0a0                	// #41120
    4000d8e8:	72b41404 	movk	w4, #0xa0a0, lsl #16
    4000d8ec:	0b020001 	add	w1, w0, w2
    4000d8f0:	6b01007f 	cmp	w3, w1
    4000d8f4:	54000c48 	b.hi	4000da7c <arm_gic_init+0x21c>  // b.pmore
		sys_write32(0, ICFGR(base, idx));
    4000d8f8:	52818004 	mov	w4, #0xc00                 	// #3072
    4000d8fc:	72a10004 	movk	w4, #0x800, lsl #16
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    4000d900:	52800401 	mov	w1, #0x20                  	// #32
    4000d904:	52800002 	mov	w2, #0x0                   	// #0
    4000d908:	6b01007f 	cmp	w3, w1
    4000d90c:	54000c08 	b.hi	4000da8c <arm_gic_init+0x22c>  // b.pmore
extern "C" {
#endif

static ALWAYS_INLINE void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
    4000d910:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    4000d914:	b9400020 	ldr	w0, [x1]

	*(volatile uint32_t *)addr = temp | (1 << bit);
    4000d918:	321e0000 	orr	w0, w0, #0x4
    4000d91c:	b9000020 	str	w0, [x1]
    4000d920:	d53bd060 	mrs	x0, tpidrro_el0
    4000d924:	927db000 	and	x0, x0, #0xfffffffffff8
	cpu = arch_curr_cpu()->id;
    4000d928:	39409002 	ldrb	w2, [x0, #36]
	gic_rdists[cpu] = GIC_RDIST_BASE + MPIDR_TO_CORE(GET_MPIDR()) * 0x20000;
    4000d92c:	d53800a0 	mrs	x0, mpidr_el1
    4000d930:	92401c00 	and	x0, x0, #0xff
    4000d934:	900000a1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000d938:	911d2021 	add	x1, x1, #0x748
    4000d93c:	91101400 	add	x0, x0, #0x405
    4000d940:	d36fb800 	lsl	x0, x0, #17
    4000d944:	f822d820 	str	x0, [x1, w2, sxtw #3]
	gicv3_rdist_enable(gic_get_rdist());
    4000d948:	97ffffac 	bl	4000d7f8 <gic_get_rdist>
	if (!(sys_read32(rdist + GICR_WAKER) & BIT(GICR_WAKER_CA)))
    4000d94c:	91005002 	add	x2, x0, #0x14
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000d950:	b9400041 	ldr	w1, [x2]
	__DMB();
    4000d954:	d5033fbf 	dmb	sy
    4000d958:	361000e1 	tbz	w1, #2, 4000d974 <arm_gic_init+0x114>
}

static ALWAYS_INLINE void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
    4000d95c:	b9401401 	ldr	w1, [x0, #20]

	*(volatile uint32_t *)addr = temp & ~(1 << bit);
    4000d960:	121e7821 	and	w1, w1, #0xfffffffd
    4000d964:	b9001401 	str	w1, [x0, #20]
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000d968:	b9400040 	ldr	w0, [x2]
	__DMB();
    4000d96c:	d5033fbf 	dmb	sy
	while (sys_read32(rdist + GICR_WAKER) & BIT(GICR_WAKER_CA))
    4000d970:	3717ffc0 	tbnz	w0, #2, 4000d968 <arm_gic_init+0x108>
	mem_addr_t base = gic_get_rdist() + GICR_SGI_BASE_OFF;
    4000d974:	97ffffa1 	bl	4000d7f8 <gic_get_rdist>
    4000d978:	aa0003e3 	mov	x3, x0
	__DMB();
    4000d97c:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), ICENABLER(base, 0));
    4000d980:	91404000 	add	x0, x0, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d984:	12800004 	mov	w4, #0xffffffff            	// #-1
    4000d988:	91060000 	add	x0, x0, #0x180
    4000d98c:	b9000004 	str	w4, [x0]
	gic_wait_rwp(0);
    4000d990:	52800000 	mov	w0, #0x0                   	// #0
    4000d994:	97ffffa0 	bl	4000d814 <gic_wait_rwp.isra.0>
	__DMB();
    4000d998:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), ICPENDR(base, 0));
    4000d99c:	91404060 	add	x0, x3, #0x10, lsl #12
    4000d9a0:	910a0000 	add	x0, x0, #0x280
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d9a4:	b9000004 	str	w4, [x0]
	__DMB();
    4000d9a8:	d5033fbf 	dmb	sy
	sys_write32(IGROUPR_VAL, IGROUPR(base, 0));
    4000d9ac:	91404061 	add	x1, x3, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d9b0:	52800000 	mov	w0, #0x0                   	// #0
    4000d9b4:	91020021 	add	x1, x1, #0x80
    4000d9b8:	b9000020 	str	w0, [x1]
	__DMB();
    4000d9bc:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), IGROUPMODR(base, 0));
    4000d9c0:	91404060 	add	x0, x3, #0x10, lsl #12
    4000d9c4:	91340000 	add	x0, x0, #0xd00
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d9c8:	b9000004 	str	w4, [x0]
	for (intid = 0; intid < GIC_SPI_INT_BASE;
    4000d9cc:	91404060 	add	x0, x3, #0x10, lsl #12
    4000d9d0:	91404061 	add	x1, x3, #0x10, lsl #12
    4000d9d4:	91100000 	add	x0, x0, #0x400
    4000d9d8:	91108021 	add	x1, x1, #0x420
    4000d9dc:	52941402 	mov	w2, #0xa0a0                	// #41120
    4000d9e0:	72b41402 	movk	w2, #0xa0a0, lsl #16
	__DMB();
    4000d9e4:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d9e8:	b9000002 	str	w2, [x0]
    4000d9ec:	91001000 	add	x0, x0, #0x4
    4000d9f0:	eb01001f 	cmp	x0, x1
    4000d9f4:	54ffff81 	b.ne	4000d9e4 <arm_gic_init+0x184>  // b.any
	__DMB();
    4000d9f8:	d5033fbf 	dmb	sy
	sys_write32(0, ICFGR(base, 1));
    4000d9fc:	91404063 	add	x3, x3, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000da00:	52800000 	mov	w0, #0x0                   	// #0
    4000da04:	91301063 	add	x3, x3, #0xc04
    4000da08:	b9000060 	str	w0, [x3]
	icc_sre = read_sysreg(ICC_SRE_EL1);
    4000da0c:	d538cca0 	mrs	x0, s3_0_c12_c12_5
	if (!(icc_sre & ICC_SRE_ELx_SRE_BIT)) {
    4000da10:	37000080 	tbnz	w0, #0, 4000da20 <arm_gic_init+0x1c0>
		icc_sre = (icc_sre | ICC_SRE_ELx_SRE_BIT |
    4000da14:	32000800 	orr	w0, w0, #0x7
		write_sysreg(icc_sre, ICC_SRE_EL1);
    4000da18:	d518cca0 	msr	s3_0_c12_c12_5, x0
		icc_sre = read_sysreg(ICC_SRE_EL1);
    4000da1c:	d538cca0 	mrs	x0, s3_0_c12_c12_5
	write_sysreg(GIC_IDLE_PRIO, ICC_PMR_EL1);
    4000da20:	52801fe0 	mov	w0, #0xff                  	// #255
    4000da24:	d5184600 	msr	s3_0_c4_c6_0, x0
	write_sysreg(1, ICC_IGRPEN1_EL1);
    4000da28:	52800020 	mov	w0, #0x1                   	// #1
    4000da2c:	d518cce0 	msr	s3_0_c12_c12_7, x0
	gicv3_dist_init();

	__arm_gic_init();

	return 0;
}
    4000da30:	52800000 	mov	w0, #0x0                   	// #0
    4000da34:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000da38:	d65f03c0 	ret
		idx = intid / GIC_NUM_INTR_PER_REG;
    4000da3c:	53057c20 	lsr	w0, w1, #5
			    ICENABLER(base, idx));
    4000da40:	531e7400 	lsl	w0, w0, #2
	__DMB();
    4000da44:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000da48:	0b050004 	add	w4, w0, w5
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000da4c:	b9000082 	str	w2, [x4]
	__DMB();
    4000da50:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000da54:	0b060004 	add	w4, w0, w6
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000da58:	b9000082 	str	w2, [x4]
	__DMB();
    4000da5c:	d5033fbf 	dmb	sy
		sys_write32(IGROUPR_VAL, IGROUPR(base, idx));
    4000da60:	0b080004 	add	w4, w0, w8
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000da64:	b9000087 	str	w7, [x4]
	__DMB();
    4000da68:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000da6c:	0b090000 	add	w0, w0, w9
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000da70:	b9000002 	str	w2, [x0]
	     intid += GIC_NUM_INTR_PER_REG) {
    4000da74:	11008021 	add	w1, w1, #0x20
    4000da78:	17ffff93 	b	4000d8c4 <arm_gic_init+0x64>
	__DMB();
    4000da7c:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000da80:	b9000004 	str	w4, [x0]
	     intid += GIC_NUM_PRI_PER_REG) {
    4000da84:	91001000 	add	x0, x0, #0x4
    4000da88:	17ffff99 	b	4000d8ec <arm_gic_init+0x8c>
	__DMB();
    4000da8c:	d5033fbf 	dmb	sy
		idx = intid / GIC_NUM_CFG_PER_REG;
    4000da90:	53047c20 	lsr	w0, w1, #4
		sys_write32(0, ICFGR(base, idx));
    4000da94:	0b000880 	add	w0, w4, w0, lsl #2
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000da98:	b9000002 	str	w2, [x0]
	     intid += GIC_NUM_CFG_PER_REG) {
    4000da9c:	11004021 	add	w1, w1, #0x10
    4000daa0:	17ffff9a 	b	4000d908 <arm_gic_init+0xa8>

000000004000daa4 <arm_gic_irq_set_priority>:
{
    4000daa4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000daa8:	2a0003e3 	mov	w3, w0
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000daac:	12001000 	and	w0, w0, #0x1f
{
    4000dab0:	910003fd 	mov	x29, sp
    4000dab4:	2a0203e6 	mov	w6, w2
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000dab8:	d2800022 	mov	x2, #0x1                   	// #1
{
    4000dabc:	2a0103e7 	mov	w7, w1
	uint32_t idx = intid / GIC_NUM_INTR_PER_REG;
    4000dac0:	53057c64 	lsr	w4, w3, #5
	mem_addr_t base = GET_DIST_BASE(intid);
    4000dac4:	71007c7f 	cmp	w3, #0x1f
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000dac8:	9ac02042 	lsl	x2, x2, x0
	mem_addr_t base = GET_DIST_BASE(intid);
    4000dacc:	54000468 	b.hi	4000db58 <arm_gic_irq_set_priority+0xb4>  // b.pmore
    4000dad0:	97ffff4a 	bl	4000d7f8 <gic_get_rdist>
    4000dad4:	91404005 	add	x5, x0, #0x10, lsl #12
	__DMB();
    4000dad8:	d5033fbf 	dmb	sy
	sys_write32(mask, ICENABLER(base, idx));
    4000dadc:	531e7484 	lsl	w4, w4, #2
    4000dae0:	11060084 	add	w4, w4, #0x180
    4000dae4:	8b2440a4 	add	x4, x5, w4, uxtw
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000dae8:	b9000082 	str	w2, [x4]
	gic_wait_rwp(intid);
    4000daec:	2a0303e0 	mov	w0, w3
    4000daf0:	97ffff49 	bl	4000d814 <gic_wait_rwp.isra.0>
	__DMB();
    4000daf4:	d5033fbf 	dmb	sy
	sys_write8(prio & GIC_PRI_MASK, IPRIORITYR(base, intid));
    4000daf8:	2a0303e0 	mov	w0, w3
    4000dafc:	91100000 	add	x0, x0, #0x400
    4000db00:	8b050000 	add	x0, x0, x5
	__asm__ volatile("strb %w0, [%1]" : : "r" (data), "r" (addr));
    4000db04:	39000007 	strb	w7, [x0]
	if (!GIC_IS_SGI(intid)) {
    4000db08:	71003c7f 	cmp	w3, #0xf
    4000db0c:	54000229 	b.ls	4000db50 <arm_gic_irq_set_priority+0xac>  // b.plast
		idx = intid / GIC_NUM_CFG_PER_REG;
    4000db10:	53047c60 	lsr	w0, w3, #4
		shift = (intid & (GIC_NUM_CFG_PER_REG - 1)) * 2;
    4000db14:	531f0c64 	ubfiz	w4, w3, #1, #4
		val = sys_read32(ICFGR(base, idx));
    4000db18:	531e7400 	lsl	w0, w0, #2
    4000db1c:	11300000 	add	w0, w0, #0xc00
    4000db20:	8b2040a0 	add	x0, x5, w0, uxtw
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000db24:	b9400002 	ldr	w2, [x0]
	__DMB();
    4000db28:	d5033fbf 	dmb	sy
		val &= ~(GICD_ICFGR_MASK << shift);
    4000db2c:	d2800061 	mov	x1, #0x3                   	// #3
    4000db30:	9ac42021 	lsl	x1, x1, x4
    4000db34:	0a210041 	bic	w1, w2, w1
		if (flags & IRQ_TYPE_EDGE) {
    4000db38:	36100086 	tbz	w6, #2, 4000db48 <arm_gic_irq_set_priority+0xa4>
			val |= (GICD_ICFGR_TYPE << shift);
    4000db3c:	d2800042 	mov	x2, #0x2                   	// #2
    4000db40:	9ac42042 	lsl	x2, x2, x4
    4000db44:	2a020021 	orr	w1, w1, w2
	__DMB();
    4000db48:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000db4c:	b9000001 	str	w1, [x0]
}
    4000db50:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000db54:	d65f03c0 	ret
	mem_addr_t base = GET_DIST_BASE(intid);
    4000db58:	d2a10005 	mov	x5, #0x8000000             	// #134217728
    4000db5c:	17ffffdf 	b	4000dad8 <arm_gic_irq_set_priority+0x34>

000000004000db60 <arm_gic_irq_enable>:
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000db60:	12001001 	and	w1, w0, #0x1f
    4000db64:	d2800023 	mov	x3, #0x1                   	// #1
	uint32_t idx = intid / GIC_NUM_INTR_PER_REG;
    4000db68:	53057c02 	lsr	w2, w0, #5
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    4000db6c:	71007c1f 	cmp	w0, #0x1f
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000db70:	9ac12063 	lsl	x3, x3, x1
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    4000db74:	54000188 	b.hi	4000dba4 <arm_gic_irq_enable+0x44>  // b.pmore
{
    4000db78:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000db7c:	910003fd 	mov	x29, sp
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    4000db80:	97ffff1e 	bl	4000d7f8 <gic_get_rdist>
    4000db84:	91404000 	add	x0, x0, #0x10, lsl #12
    4000db88:	91040000 	add	x0, x0, #0x100
	__DMB();
    4000db8c:	d5033fbf 	dmb	sy
    4000db90:	d37e6842 	ubfiz	x2, x2, #2, #27
    4000db94:	8b000042 	add	x2, x2, x0
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000db98:	b9000043 	str	w3, [x2]
}
    4000db9c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000dba0:	d65f03c0 	ret
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    4000dba4:	d2802000 	mov	x0, #0x100                 	// #256
    4000dba8:	f2a10000 	movk	x0, #0x800, lsl #16
	__DMB();
    4000dbac:	d5033fbf 	dmb	sy
    4000dbb0:	d37e6842 	ubfiz	x2, x2, #2, #27
    4000dbb4:	8b000042 	add	x2, x2, x0
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000dbb8:	b9000043 	str	w3, [x2]
    4000dbbc:	d65f03c0 	ret

000000004000dbc0 <arm_gic_get_active>:
	intid = read_sysreg(ICC_IAR1_EL1);
    4000dbc0:	d538cc00 	mrs	x0, s3_0_c12_c12_0
}
    4000dbc4:	d65f03c0 	ret

000000004000dbc8 <arm_gic_eoi>:
	__DSB();
    4000dbc8:	d5033f9f 	dsb	sy
	write_sysreg(intid, ICC_EOIR1_EL1);
    4000dbcc:	d518cc20 	msr	s3_0_c12_c12_1, x0
}
    4000dbd0:	d65f03c0 	ret

000000004000dbd4 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    4000dbd4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    4000dbd8:	900000a1 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000dbdc:	b0000020 	adrp	x0, 40012000 <__rodata_region_start>
    4000dbe0:	91024000 	add	x0, x0, #0x90
{
    4000dbe4:	910003fd 	mov	x29, sp
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    4000dbe8:	f903a820 	str	x0, [x1, #1872]
{
    4000dbec:	f9000bf3 	str	x19, [sp, #16]
    4000dbf0:	940001d8 	bl	4000e350 <z_device_ready>
    4000dbf4:	72001c1f 	tst	w0, #0xff
    4000dbf8:	54000160 	b.eq	4000dc24 <uart_console_init+0x50>  // b.none
	__stdout_hook_install(console_out);
    4000dbfc:	90000013 	adrp	x19, 4000d000 <sift_down+0xc8>
    4000dc00:	9130b273 	add	x19, x19, #0xc2c
    4000dc04:	aa1303e0 	mov	x0, x19
    4000dc08:	97fffdd5 	bl	4000d35c <__stdout_hook_install>
	__printk_hook_install(console_out);
    4000dc0c:	aa1303e0 	mov	x0, x19
    4000dc10:	97ffd0a4 	bl	40001ea0 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
    4000dc14:	52800000 	mov	w0, #0x0                   	// #0
}
    4000dc18:	f9400bf3 	ldr	x19, [sp, #16]
    4000dc1c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000dc20:	d65f03c0 	ret
		return -ENODEV;
    4000dc24:	12800240 	mov	w0, #0xffffffed            	// #-19
    4000dc28:	17fffffc 	b	4000dc18 <uart_console_init+0x44>

000000004000dc2c <console_out>:
{
    4000dc2c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if ('\n' == c) {
    4000dc30:	7100281f 	cmp	w0, #0xa
{
    4000dc34:	910003fd 	mov	x29, sp
    4000dc38:	a90153f3 	stp	x19, x20, [sp, #16]
    4000dc3c:	2a0003f3 	mov	w19, w0
    4000dc40:	900000b4 	adrp	x20, 40021000 <k_sys_work_q+0x200>
	if ('\n' == c) {
    4000dc44:	540000c1 	b.ne	4000dc5c <console_out+0x30>  // b.any
		uart_poll_out(uart_console_dev, '\r');
    4000dc48:	f943aa80 	ldr	x0, [x20, #1872]
	api->poll_out(dev, out_char);
    4000dc4c:	f9400801 	ldr	x1, [x0, #16]
    4000dc50:	f9400422 	ldr	x2, [x1, #8]
    4000dc54:	528001a1 	mov	w1, #0xd                   	// #13
    4000dc58:	d63f0040 	blr	x2
	uart_poll_out(uart_console_dev, c);
    4000dc5c:	f943aa80 	ldr	x0, [x20, #1872]
    4000dc60:	f9400801 	ldr	x1, [x0, #16]
    4000dc64:	f9400422 	ldr	x2, [x1, #8]
    4000dc68:	2a1303e1 	mov	w1, w19
    4000dc6c:	d63f0040 	blr	x2
}
    4000dc70:	2a1303e0 	mov	w0, w19
    4000dc74:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000dc78:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000dc7c:	d65f03c0 	ret

000000004000dc80 <pl011_poll_in>:
	return 0;
}

static bool pl011_is_readable(const struct device *dev)
{
	if (!DEV_DATA(dev)->sbsa &&
    4000dc80:	f9401003 	ldr	x3, [x0, #32]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    4000dc84:	f9400402 	ldr	x2, [x0, #8]
	if (!DEV_DATA(dev)->sbsa &&
    4000dc88:	39401063 	ldrb	w3, [x3, #4]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    4000dc8c:	f9400042 	ldr	x2, [x2]
	if (!DEV_DATA(dev)->sbsa &&
    4000dc90:	350000a3 	cbnz	w3, 4000dca4 <pl011_poll_in+0x24>
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    4000dc94:	b9403043 	ldr	w3, [x2, #48]
	if (!DEV_DATA(dev)->sbsa &&
    4000dc98:	36000183 	tbz	w3, #0, 4000dcc8 <pl011_poll_in+0x48>
	     !(PL011_REGS(dev)->cr & PL011_CR_RXE)))
    4000dc9c:	b9403043 	ldr	w3, [x2, #48]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    4000dca0:	36480143 	tbz	w3, #9, 4000dcc8 <pl011_poll_in+0x48>
		return false;

	return (PL011_REGS(dev)->fr & PL011_FR_RXFE) == 0U;
    4000dca4:	b9401843 	ldr	w3, [x2, #24]
}

static int pl011_poll_in(const struct device *dev, unsigned char *c)
{
	if (!pl011_is_readable(dev)) {
    4000dca8:	37200103 	tbnz	w3, #4, 4000dcc8 <pl011_poll_in+0x48>
		return -1;
	}

	/* got a character */
	*c = (unsigned char)PL011_REGS(dev)->dr;
    4000dcac:	b9400042 	ldr	w2, [x2]
    4000dcb0:	39000022 	strb	w2, [x1]

	return PL011_REGS(dev)->rsr & PL011_RSR_ERROR_MASK;
    4000dcb4:	f9400400 	ldr	x0, [x0, #8]
    4000dcb8:	f9400000 	ldr	x0, [x0]
    4000dcbc:	b9400400 	ldr	w0, [x0, #4]
    4000dcc0:	12000c00 	and	w0, w0, #0xf
}
    4000dcc4:	d65f03c0 	ret
		return -1;
    4000dcc8:	12800000 	mov	w0, #0xffffffff            	// #-1
    4000dccc:	17fffffe 	b	4000dcc4 <pl011_poll_in+0x44>

000000004000dcd0 <pl011_poll_out>:

static void pl011_poll_out(const struct device *dev,
					     unsigned char c)
{
	/* Wait for space in FIFO */
	while (PL011_REGS(dev)->fr & PL011_FR_TXFF) {
    4000dcd0:	f9400400 	ldr	x0, [x0, #8]
{
    4000dcd4:	12001c21 	and	w1, w1, #0xff
	while (PL011_REGS(dev)->fr & PL011_FR_TXFF) {
    4000dcd8:	f9400000 	ldr	x0, [x0]
    4000dcdc:	b9401802 	ldr	w2, [x0, #24]
    4000dce0:	372fffe2 	tbnz	w2, #5, 4000dcdc <pl011_poll_out+0xc>
		; /* Wait */
	}

	/* Send a character */
	PL011_REGS(dev)->dr = (uint32_t)c;
    4000dce4:	b9000001 	str	w1, [x0]
}
    4000dce8:	d65f03c0 	ret

000000004000dcec <pl011_fifo_fill>:
static int pl011_fifo_fill(const struct device *dev,
				    const uint8_t *tx_data, int len)
{
	uint8_t num_tx = 0U;

	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    4000dcec:	f9400400 	ldr	x0, [x0, #8]
    4000dcf0:	f9400003 	ldr	x3, [x0]
	uint8_t num_tx = 0U;
    4000dcf4:	52800000 	mov	w0, #0x0                   	// #0
	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    4000dcf8:	b9401864 	ldr	w4, [x3, #24]
    4000dcfc:	37280084 	tbnz	w4, #5, 4000dd0c <pl011_fifo_fill+0x20>
	       (len - num_tx > 0)) {
    4000dd00:	4b000044 	sub	w4, w2, w0
	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    4000dd04:	7100009f 	cmp	w4, #0x0
    4000dd08:	5400004c 	b.gt	4000dd10 <pl011_fifo_fill+0x24>
		PL011_REGS(dev)->dr = tx_data[num_tx++];
	}
	return num_tx;
}
    4000dd0c:	d65f03c0 	ret
		PL011_REGS(dev)->dr = tx_data[num_tx++];
    4000dd10:	11000404 	add	w4, w0, #0x1
    4000dd14:	92401c00 	and	x0, x0, #0xff
    4000dd18:	38606820 	ldrb	w0, [x1, x0]
    4000dd1c:	b9000060 	str	w0, [x3]
    4000dd20:	12001c80 	and	w0, w4, #0xff
    4000dd24:	17fffff5 	b	4000dcf8 <pl011_fifo_fill+0xc>

000000004000dd28 <pl011_fifo_read>:

static int pl011_fifo_read(const struct device *dev,
				    uint8_t *rx_data, const int len)
{
    4000dd28:	aa0003e4 	mov	x4, x0
	uint8_t num_rx = 0U;
    4000dd2c:	52800000 	mov	w0, #0x0                   	// #0

	while ((len - num_rx > 0) &&
    4000dd30:	4b000043 	sub	w3, w2, w0
    4000dd34:	7100007f 	cmp	w3, #0x0
    4000dd38:	540000ad 	b.le	4000dd4c <pl011_fifo_read+0x24>
	       !(PL011_REGS(dev)->fr & PL011_FR_RXFE)) {
    4000dd3c:	f9400483 	ldr	x3, [x4, #8]
    4000dd40:	f9400063 	ldr	x3, [x3]
    4000dd44:	b9401865 	ldr	w5, [x3, #24]
	while ((len - num_rx > 0) &&
    4000dd48:	36200045 	tbz	w5, #4, 4000dd50 <pl011_fifo_read+0x28>
		rx_data[num_rx++] = PL011_REGS(dev)->dr;
	}

	return num_rx;
}
    4000dd4c:	d65f03c0 	ret
		rx_data[num_rx++] = PL011_REGS(dev)->dr;
    4000dd50:	b9400066 	ldr	w6, [x3]
    4000dd54:	92401c03 	and	x3, x0, #0xff
    4000dd58:	11000405 	add	w5, w0, #0x1
    4000dd5c:	12001ca0 	and	w0, w5, #0xff
    4000dd60:	38236826 	strb	w6, [x1, x3]
    4000dd64:	17fffff3 	b	4000dd30 <pl011_fifo_read+0x8>

000000004000dd68 <pl011_irq_tx_enable>:

static void pl011_irq_tx_enable(const struct device *dev)
{
	PL011_REGS(dev)->imsc |= PL011_IMSC_TXIM;
    4000dd68:	f9400400 	ldr	x0, [x0, #8]
    4000dd6c:	f9400001 	ldr	x1, [x0]
    4000dd70:	b9403820 	ldr	w0, [x1, #56]
    4000dd74:	321b0000 	orr	w0, w0, #0x20
    4000dd78:	b9003820 	str	w0, [x1, #56]
}
    4000dd7c:	d65f03c0 	ret

000000004000dd80 <pl011_irq_tx_disable>:

static void pl011_irq_tx_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~PL011_IMSC_TXIM;
    4000dd80:	f9400400 	ldr	x0, [x0, #8]
    4000dd84:	f9400001 	ldr	x1, [x0]
    4000dd88:	b9403820 	ldr	w0, [x1, #56]
    4000dd8c:	121a7800 	and	w0, w0, #0xffffffdf
    4000dd90:	b9003820 	str	w0, [x1, #56]
}
    4000dd94:	d65f03c0 	ret

000000004000dd98 <pl011_irq_tx_complete>:

static int pl011_irq_tx_complete(const struct device *dev)
{
	/* check for TX FIFO empty */
	return PL011_REGS(dev)->fr & PL011_FR_TXFE;
    4000dd98:	f9400400 	ldr	x0, [x0, #8]
    4000dd9c:	f9400000 	ldr	x0, [x0]
    4000dda0:	b9401800 	ldr	w0, [x0, #24]
}
    4000dda4:	12190000 	and	w0, w0, #0x80
    4000dda8:	d65f03c0 	ret

000000004000ddac <pl011_irq_rx_enable>:
		pl011_irq_tx_complete(dev));
}

static void pl011_irq_rx_enable(const struct device *dev)
{
	PL011_REGS(dev)->imsc |= PL011_IMSC_RXIM |
    4000ddac:	f9400400 	ldr	x0, [x0, #8]
    4000ddb0:	52800a02 	mov	w2, #0x50                  	// #80
    4000ddb4:	f9400001 	ldr	x1, [x0]
    4000ddb8:	b9403820 	ldr	w0, [x1, #56]
    4000ddbc:	2a020000 	orr	w0, w0, w2
    4000ddc0:	b9003820 	str	w0, [x1, #56]
				 PL011_IMSC_RTIM;
}
    4000ddc4:	d65f03c0 	ret

000000004000ddc8 <pl011_irq_rx_disable>:

static void pl011_irq_rx_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~(PL011_IMSC_RXIM |
    4000ddc8:	f9400400 	ldr	x0, [x0, #8]
    4000ddcc:	12800a02 	mov	w2, #0xffffffaf            	// #-81
    4000ddd0:	f9400001 	ldr	x1, [x0]
    4000ddd4:	b9403820 	ldr	w0, [x1, #56]
    4000ddd8:	0a020000 	and	w0, w0, w2
    4000dddc:	b9003820 	str	w0, [x1, #56]
				   PL011_IMSC_RTIM);
}
    4000dde0:	d65f03c0 	ret

000000004000dde4 <pl011_irq_rx_ready>:

static int pl011_irq_rx_ready(const struct device *dev)
{
	if (!DEV_DATA(dev)->sbsa && !(PL011_REGS(dev)->cr & PL011_CR_RXE))
    4000dde4:	f9400401 	ldr	x1, [x0, #8]
    4000dde8:	f9401000 	ldr	x0, [x0, #32]
    4000ddec:	f9400021 	ldr	x1, [x1]
    4000ddf0:	39401000 	ldrb	w0, [x0, #4]
    4000ddf4:	35000060 	cbnz	w0, 4000de00 <pl011_irq_rx_ready+0x1c>
    4000ddf8:	b9403020 	ldr	w0, [x1, #48]
    4000ddfc:	364800e0 	tbz	w0, #9, 4000de18 <pl011_irq_rx_ready+0x34>
		return false;

	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    4000de00:	b9403820 	ldr	w0, [x1, #56]
    4000de04:	362000a0 	tbz	w0, #4, 4000de18 <pl011_irq_rx_ready+0x34>
		(!(PL011_REGS(dev)->fr & PL011_FR_RXFE)));
    4000de08:	b9401820 	ldr	w0, [x1, #24]
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    4000de0c:	d27c0000 	eor	x0, x0, #0x10
    4000de10:	d3441000 	ubfx	x0, x0, #4, #1
}
    4000de14:	d65f03c0 	ret
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    4000de18:	52800000 	mov	w0, #0x0                   	// #0
    4000de1c:	17fffffe 	b	4000de14 <pl011_irq_rx_ready+0x30>

000000004000de20 <pl011_irq_err_enable>:

static void pl011_irq_err_enable(const struct device *dev)
{
	/* enable framing, parity, break, and overrun */
	PL011_REGS(dev)->imsc |= PL011_IMSC_ERROR_MASK;
    4000de20:	f9400400 	ldr	x0, [x0, #8]
    4000de24:	f9400001 	ldr	x1, [x0]
    4000de28:	b9403820 	ldr	w0, [x1, #56]
    4000de2c:	32190c00 	orr	w0, w0, #0x780
    4000de30:	b9003820 	str	w0, [x1, #56]
}
    4000de34:	d65f03c0 	ret

000000004000de38 <pl011_irq_err_disable>:

static void pl011_irq_err_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~PL011_IMSC_ERROR_MASK;
    4000de38:	f9400400 	ldr	x0, [x0, #8]
    4000de3c:	f9400001 	ldr	x1, [x0]
    4000de40:	b9403820 	ldr	w0, [x1, #56]
    4000de44:	12156c00 	and	w0, w0, #0xfffff87f
    4000de48:	b9003820 	str	w0, [x1, #56]
}
    4000de4c:	d65f03c0 	ret

000000004000de50 <pl011_irq_update>:
}

static int pl011_irq_update(const struct device *dev)
{
	return 1;
}
    4000de50:	52800020 	mov	w0, #0x1                   	// #1
    4000de54:	d65f03c0 	ret

000000004000de58 <pl011_irq_callback_set>:

static void pl011_irq_callback_set(const struct device *dev,
					    uart_irq_callback_user_data_t cb,
					    void *cb_data)
{
	DEV_DATA(dev)->irq_cb = cb;
    4000de58:	f9401000 	ldr	x0, [x0, #32]
	DEV_DATA(dev)->irq_cb_data = cb_data;
    4000de5c:	a9008801 	stp	x1, x2, [x0, #8]
}
    4000de60:	d65f03c0 	ret

000000004000de64 <pl011_isr>:
}

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
void pl011_isr(const struct device *dev)
{
	struct pl011_data *data = DEV_DATA(dev);
    4000de64:	f9401001 	ldr	x1, [x0, #32]

	/* Verify if the callback has been registered */
	if (data->irq_cb) {
    4000de68:	f9400422 	ldr	x2, [x1, #8]
    4000de6c:	b4000082 	cbz	x2, 4000de7c <pl011_isr+0x18>
		data->irq_cb(dev, data->irq_cb_data);
    4000de70:	f9400821 	ldr	x1, [x1, #16]
    4000de74:	aa0203f0 	mov	x16, x2
    4000de78:	d61f0200 	br	x16
	}
}
    4000de7c:	d65f03c0 	ret

000000004000de80 <pl011_irq_config_func_0>:
		    CONFIG_SERIAL_INIT_PRIORITY,
		    &pl011_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void pl011_irq_config_func_0(const struct device *dev)
{
    4000de80:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
#if DT_NUM_IRQS(DT_INST(0, arm_pl011)) == 1
	IRQ_CONNECT(DT_INST_IRQN(0),
    4000de84:	52800002 	mov	w2, #0x0                   	// #0
    4000de88:	52800001 	mov	w1, #0x0                   	// #0
{
    4000de8c:	910003fd 	mov	x29, sp
	IRQ_CONNECT(DT_INST_IRQN(0),
    4000de90:	52800420 	mov	w0, #0x21                  	// #33
    4000de94:	97fff847 	bl	4000bfb0 <z_arm64_irq_priority_set>
		    pl011_isr,
		    DEVICE_DT_INST_GET(0),
		    0);
	irq_enable(DT_INST_IRQ_BY_NAME(0, rxtim, irq));
#endif
}
    4000de98:	a8c17bfd 	ldp	x29, x30, [sp], #16
	irq_enable(DT_INST_IRQN(0));
    4000de9c:	52800420 	mov	w0, #0x21                  	// #33
    4000dea0:	17fff843 	b	4000bfac <arch_irq_enable>

000000004000dea4 <pl011_irq_tx_ready>:
	if (!DEV_DATA(dev)->sbsa && !(PL011_REGS(dev)->cr & PL011_CR_TXE))
    4000dea4:	f9401002 	ldr	x2, [x0, #32]
    4000dea8:	f9400401 	ldr	x1, [x0, #8]
    4000deac:	39401042 	ldrb	w2, [x2, #4]
    4000deb0:	f9400021 	ldr	x1, [x1]
    4000deb4:	35000062 	cbnz	w2, 4000dec0 <pl011_irq_tx_ready+0x1c>
    4000deb8:	b9403022 	ldr	w2, [x1, #48]
    4000debc:	36400142 	tbz	w2, #8, 4000dee4 <pl011_irq_tx_ready+0x40>
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_TXIM) &&
    4000dec0:	b9403821 	ldr	w1, [x1, #56]
    4000dec4:	36280101 	tbz	w1, #5, 4000dee4 <pl011_irq_tx_ready+0x40>
{
    4000dec8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000decc:	910003fd 	mov	x29, sp
		pl011_irq_tx_complete(dev));
    4000ded0:	97ffffb2 	bl	4000dd98 <pl011_irq_tx_complete>
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_TXIM) &&
    4000ded4:	7100001f 	cmp	w0, #0x0
    4000ded8:	1a9f07e0 	cset	w0, ne  // ne = any
}
    4000dedc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000dee0:	d65f03c0 	ret
		return false;
    4000dee4:	52800000 	mov	w0, #0x0                   	// #0
}
    4000dee8:	d65f03c0 	ret

000000004000deec <pl011_irq_is_pending>:
{
    4000deec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000def0:	aa0003e2 	mov	x2, x0
    4000def4:	910003fd 	mov	x29, sp
	return pl011_irq_rx_ready(dev) || pl011_irq_tx_ready(dev);
    4000def8:	97ffffbb 	bl	4000dde4 <pl011_irq_rx_ready>
    4000defc:	350000e0 	cbnz	w0, 4000df18 <pl011_irq_is_pending+0x2c>
    4000df00:	aa0203e0 	mov	x0, x2
    4000df04:	97ffffe8 	bl	4000dea4 <pl011_irq_tx_ready>
    4000df08:	7100001f 	cmp	w0, #0x0
    4000df0c:	1a9f07e0 	cset	w0, ne  // ne = any
}
    4000df10:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000df14:	d65f03c0 	ret
	return pl011_irq_rx_ready(dev) || pl011_irq_tx_ready(dev);
    4000df18:	52800020 	mov	w0, #0x1                   	// #1
    4000df1c:	17fffffd 	b	4000df10 <pl011_irq_is_pending+0x24>

000000004000df20 <pl011_init>:
{
    4000df20:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000df24:	910003fd 	mov	x29, sp
	if (!DEV_DATA(dev)->sbsa) {
    4000df28:	f9401002 	ldr	x2, [x0, #32]
{
    4000df2c:	f9000bf3 	str	x19, [sp, #16]
    4000df30:	aa0003f3 	mov	x19, x0
	if (!DEV_DATA(dev)->sbsa) {
    4000df34:	39401040 	ldrb	w0, [x2, #4]
    4000df38:	35000460 	cbnz	w0, 4000dfc4 <pl011_init+0xa4>
    4000df3c:	f9400663 	ldr	x3, [x19, #8]
				/ (baudrate * 16U);
    4000df40:	b9400042 	ldr	w2, [x2]
	PL011_REGS(dev)->cr &= ~PL011_CR_UARTEN;
    4000df44:	f9400061 	ldr	x1, [x3]
				/ (baudrate * 16U);
    4000df48:	531c6c42 	lsl	w2, w2, #4
	PL011_REGS(dev)->cr &= ~PL011_CR_UARTEN;
    4000df4c:	b9403020 	ldr	w0, [x1, #48]
    4000df50:	121f7800 	and	w0, w0, #0xfffffffe
    4000df54:	b9003020 	str	w0, [x1, #48]
	PL011_REGS(dev)->lcr_h &= ~PL011_LCRH_FEN;
    4000df58:	b9402c20 	ldr	w0, [x1, #44]
    4000df5c:	121b7800 	and	w0, w0, #0xffffffef
    4000df60:	b9002c20 	str	w0, [x1, #44]
	uint64_t bauddiv = (((uint64_t)clk) << PL011_FBRD_WIDTH)
    4000df64:	b9400860 	ldr	w0, [x3, #8]
    4000df68:	d37ae400 	lsl	x0, x0, #6
    4000df6c:	9ac20800 	udiv	x0, x0, x2
	if ((bauddiv < (1u << PL011_FBRD_WIDTH))
    4000df70:	b2793be2 	mov	x2, #0x3fff80              	// #4194176
		|| (bauddiv > (65535u << PL011_FBRD_WIDTH))) {
    4000df74:	d1010003 	sub	x3, x0, #0x40
	if ((bauddiv < (1u << PL011_FBRD_WIDTH))
    4000df78:	eb02007f 	cmp	x3, x2
    4000df7c:	54000688 	b.hi	4000e04c <pl011_init+0x12c>  // b.pmore
	PL011_REGS(dev)->ibrd = bauddiv >> PL011_FBRD_WIDTH;
    4000df80:	d346fc02 	lsr	x2, x0, #6
    4000df84:	b9002422 	str	w2, [x1, #36]
	PL011_REGS(dev)->fbrd = bauddiv & ((1u << PL011_FBRD_WIDTH) - 1u);
    4000df88:	12001400 	and	w0, w0, #0x3f
    4000df8c:	b9002820 	str	w0, [x1, #40]
	__DMB();
    4000df90:	d5033fbf 	dmb	sy
	PL011_REGS(dev)->lcr_h = PL011_REGS(dev)->lcr_h;
    4000df94:	f9400660 	ldr	x0, [x19, #8]
		lcrh &= ~(BIT(0) | BIT(7));
    4000df98:	12801ce2 	mov	w2, #0xffffff18            	// #-232
	PL011_REGS(dev)->lcr_h = PL011_REGS(dev)->lcr_h;
    4000df9c:	f9400000 	ldr	x0, [x0]
    4000dfa0:	b9402c01 	ldr	w1, [x0, #44]
    4000dfa4:	b9002c01 	str	w1, [x0, #44]
		lcrh = PL011_REGS(dev)->lcr_h & ~(PL011_LCRH_FORMAT_MASK);
    4000dfa8:	b9402c01 	ldr	w1, [x0, #44]
		lcrh &= ~(BIT(0) | BIT(7));
    4000dfac:	0a020021 	and	w1, w1, w2
		lcrh |= PL011_LCRH_WLEN_SIZE(8) << PL011_LCRH_WLEN_SHIFT;
    4000dfb0:	321b0421 	orr	w1, w1, #0x60
		PL011_REGS(dev)->lcr_h = lcrh;
    4000dfb4:	b9002c01 	str	w1, [x0, #44]
	PL011_REGS(dev)->lcr_h |= PL011_LCRH_FEN;
    4000dfb8:	b9402c01 	ldr	w1, [x0, #44]
    4000dfbc:	321c0021 	orr	w1, w1, #0x10
    4000dfc0:	b9002c01 	str	w1, [x0, #44]
	PL011_REGS(dev)->imsc = 0U;
    4000dfc4:	f9400660 	ldr	x0, [x19, #8]
	PL011_REGS(dev)->icr = PL011_IMSC_MASK_ALL;
    4000dfc8:	5280ffe1 	mov	w1, #0x7ff                 	// #2047
	PL011_REGS(dev)->imsc = 0U;
    4000dfcc:	f9400000 	ldr	x0, [x0]
    4000dfd0:	b900381f 	str	wzr, [x0, #56]
	PL011_REGS(dev)->icr = PL011_IMSC_MASK_ALL;
    4000dfd4:	b9004401 	str	w1, [x0, #68]
	if (!DEV_DATA(dev)->sbsa) {
    4000dfd8:	f9401261 	ldr	x1, [x19, #32]
    4000dfdc:	39401021 	ldrb	w1, [x1, #4]
    4000dfe0:	350001a1 	cbnz	w1, 4000e014 <pl011_init+0xf4>
		PL011_REGS(dev)->dmacr = 0U;
    4000dfe4:	b900481f 	str	wzr, [x0, #72]
		__ISB();
    4000dfe8:	d5033fdf 	isb
		PL011_REGS(dev)->cr &= ~(BIT(14) | BIT(15) | BIT(1));
    4000dfec:	f9400660 	ldr	x0, [x19, #8]
    4000dff0:	12980042 	mov	w2, #0xffff3ffd            	// #-49155
    4000dff4:	f9400000 	ldr	x0, [x0]
    4000dff8:	b9403001 	ldr	w1, [x0, #48]
    4000dffc:	0a020021 	and	w1, w1, w2
    4000e000:	b9003001 	str	w1, [x0, #48]
		PL011_REGS(dev)->cr |= PL011_CR_RXE | PL011_CR_TXE;
    4000e004:	b9403001 	ldr	w1, [x0, #48]
    4000e008:	32180421 	orr	w1, w1, #0x300
    4000e00c:	b9003001 	str	w1, [x0, #48]
		__ISB();
    4000e010:	d5033fdf 	isb
	DEV_CFG(dev)->irq_config_func(dev);
    4000e014:	f9400660 	ldr	x0, [x19, #8]
    4000e018:	f9400801 	ldr	x1, [x0, #16]
    4000e01c:	aa1303e0 	mov	x0, x19
    4000e020:	d63f0020 	blr	x1
	if (!DEV_DATA(dev)->sbsa)
    4000e024:	f9401260 	ldr	x0, [x19, #32]
    4000e028:	39401000 	ldrb	w0, [x0, #4]
    4000e02c:	350000c0 	cbnz	w0, 4000e044 <pl011_init+0x124>
	PL011_REGS(dev)->cr |=  PL011_CR_UARTEN;
    4000e030:	f9400660 	ldr	x0, [x19, #8]
    4000e034:	f9400001 	ldr	x1, [x0]
    4000e038:	b9403020 	ldr	w0, [x1, #48]
    4000e03c:	32000000 	orr	w0, w0, #0x1
    4000e040:	b9003020 	str	w0, [x1, #48]
	return 0;
    4000e044:	52800000 	mov	w0, #0x0                   	// #0
    4000e048:	14000002 	b	4000e050 <pl011_init+0x130>
		return -EINVAL;
    4000e04c:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
    4000e050:	f9400bf3 	ldr	x19, [sp, #16]
    4000e054:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000e058:	d65f03c0 	ret

000000004000e05c <arm_arch_timer_compare_isr>:
MAKE_REG_HELPER(daif)
    4000e05c:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e060:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    4000e064:	d53be040 	mrs	x0, cntvct_el0
		return;
	}
#endif /* CONFIG_ARM_ARCH_TIMER_ERRATUM_740657 */

	uint64_t curr_cycle = arm_arch_timer_count();
	uint32_t delta_ticks = (uint32_t)((curr_cycle - last_cycle) / CYC_PER_TICK);
    4000e068:	f0000083 	adrp	x3, 40021000 <k_sys_work_q+0x200>
    4000e06c:	f943ac64 	ldr	x4, [x3, #1880]
    4000e070:	d2912d05 	mov	x5, #0x8968                	// #35176
    4000e074:	f2a00125 	movk	x5, #0x9, lsl #16
    4000e078:	cb040000 	sub	x0, x0, x4
    4000e07c:	9ac50800 	udiv	x0, x0, x5

	last_cycle += delta_ticks * CYC_PER_TICK;
    4000e080:	92407c02 	and	x2, x0, #0xffffffff
    4000e084:	9b051042 	madd	x2, x2, x5, x4
    4000e088:	f903ac62 	str	x2, [x3, #1880]
MAKE_REG_HELPER(cntv_ctl_el0)
    4000e08c:	d53be322 	mrs	x2, cntv_ctl_el0
	uint64_t cntv_ctl;

	cntv_ctl = read_cntv_ctl_el0();

	if (mask) {
		cntv_ctl |= CNTV_CTL_IMASK_BIT;
    4000e090:	b27f0042 	orr	x2, x2, #0x2
    4000e094:	d51be322 	msr	cntv_ctl_el0, x2
MAKE_REG_HELPER(daif)
    4000e098:	92407c21 	and	x1, x1, #0xffffffff
    4000e09c:	d51b4221 	msr	daif, x1
	}
#endif /* CONFIG_ARM_ARCH_TIMER_ERRATUM_740657 */

	k_spin_unlock(&lock, key);

	sys_clock_announce(delta_ticks);
    4000e0a0:	14000a41 	b	400109a4 <sys_clock_announce>

000000004000e0a4 <sys_clock_driver_init>:
}

int sys_clock_driver_init(const struct device *dev)
{
    4000e0a4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(dev);

	IRQ_CONNECT(ARM_ARCH_TIMER_IRQ, ARM_ARCH_TIMER_PRIO,
    4000e0a8:	52800042 	mov	w2, #0x2                   	// #2
    4000e0ac:	52801401 	mov	w1, #0xa0                  	// #160
{
    4000e0b0:	910003fd 	mov	x29, sp
	IRQ_CONNECT(ARM_ARCH_TIMER_IRQ, ARM_ARCH_TIMER_PRIO,
    4000e0b4:	52800360 	mov	w0, #0x1b                  	// #27
    4000e0b8:	97fff7be 	bl	4000bfb0 <z_arm64_irq_priority_set>
MAKE_REG_HELPER(cntvct_el0);
    4000e0bc:	d53be040 	mrs	x0, cntvct_el0
		    arm_arch_timer_compare_isr, NULL, ARM_ARCH_TIMER_FLAGS);
	arm_arch_timer_init();
	arm_arch_timer_set_compare(arm_arch_timer_count() + CYC_PER_TICK);
    4000e0c0:	91426000 	add	x0, x0, #0x98, lsl #12
    4000e0c4:	9125a000 	add	x0, x0, #0x968
MAKE_REG_HELPER(cntv_cval_el0)
    4000e0c8:	d51be340 	msr	cntv_cval_el0, x0
MAKE_REG_HELPER(cntv_ctl_el0)
    4000e0cc:	d53be320 	mrs	x0, cntv_ctl_el0
		cntv_ctl |= CNTV_CTL_ENABLE_BIT;
    4000e0d0:	b2400000 	orr	x0, x0, #0x1
    4000e0d4:	d51be320 	msr	cntv_ctl_el0, x0
	arm_arch_timer_enable(true);
	irq_enable(ARM_ARCH_TIMER_IRQ);
    4000e0d8:	52800360 	mov	w0, #0x1b                  	// #27
    4000e0dc:	97fff7b4 	bl	4000bfac <arch_irq_enable>
    4000e0e0:	d53be320 	mrs	x0, cntv_ctl_el0
	} else {
		cntv_ctl &= ~CNTV_CTL_IMASK_BIT;
    4000e0e4:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    4000e0e8:	d51be320 	msr	cntv_ctl_el0, x0
	arm_arch_timer_set_irq_mask(false);

	return 0;
}
    4000e0ec:	52800000 	mov	w0, #0x0                   	// #0
    4000e0f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000e0f4:	d65f03c0 	ret

000000004000e0f8 <sys_clock_set_timeout>:

void sys_clock_set_timeout(int32_t ticks, bool idle)
{
#if defined(CONFIG_TICKLESS_KERNEL)

	if (ticks == K_TICKS_FOREVER && idle) {
    4000e0f8:	72001c3f 	tst	w1, #0xff
    4000e0fc:	3a411800 	ccmn	w0, #0x1, #0x0, ne  // ne = any
    4000e100:	54000420 	b.eq	4000e184 <sys_clock_set_timeout+0x8c>  // b.none
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : \
    4000e104:	3100041f 	cmn	w0, #0x1
    4000e108:	54000400 	b.eq	4000e188 <sys_clock_set_timeout+0x90>  // b.none
    4000e10c:	71000400 	subs	w0, w0, #0x1
    4000e110:	1a9f5000 	csel	w0, w0, wzr, pl  // pl = nfrst
MAKE_REG_HELPER(daif)
    4000e114:	d53b4224 	mrs	x4, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e118:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    4000e11c:	d53be042 	mrs	x2, cntvct_el0
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t curr_cycle = arm_arch_timer_count();
	uint64_t req_cycle = ticks * CYC_PER_TICK;

	/* Round up to next tick boundary */
	req_cycle += (curr_cycle - last_cycle) + (CYC_PER_TICK - 1);
    4000e120:	f0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000e124:	f943ac23 	ldr	x3, [x1, #1880]
    4000e128:	52912d05 	mov	w5, #0x8968                	// #35176
    4000e12c:	72a00125 	movk	w5, #0x9, lsl #16
    4000e130:	d2912ce1 	mov	x1, #0x8967                	// #35175
    4000e134:	f2a00121 	movk	x1, #0x9, lsl #16
    4000e138:	cb030021 	sub	x1, x1, x3
    4000e13c:	9b250800 	smaddl	x0, w0, w5, x2

	req_cycle = (req_cycle / CYC_PER_TICK) * CYC_PER_TICK;

	if ((req_cycle + last_cycle - curr_cycle) < MIN_DELAY) {
    4000e140:	cb020062 	sub	x2, x3, x2
	req_cycle += (curr_cycle - last_cycle) + (CYC_PER_TICK - 1);
    4000e144:	8b000020 	add	x0, x1, x0
	req_cycle = (req_cycle / CYC_PER_TICK) * CYC_PER_TICK;
    4000e148:	d2912d01 	mov	x1, #0x8968                	// #35176
    4000e14c:	f2a00121 	movk	x1, #0x9, lsl #16
    4000e150:	9ac10800 	udiv	x0, x0, x1
    4000e154:	9b017c00 	mul	x0, x0, x1
	if ((req_cycle + last_cycle - curr_cycle) < MIN_DELAY) {
    4000e158:	8b000042 	add	x2, x2, x0
    4000e15c:	f10f9c5f 	cmp	x2, #0x3e7
    4000e160:	54000048 	b.hi	4000e168 <sys_clock_set_timeout+0x70>  // b.pmore
		req_cycle += CYC_PER_TICK;
    4000e164:	8b010000 	add	x0, x0, x1
	}

	arm_arch_timer_set_compare(req_cycle + last_cycle);
    4000e168:	8b000060 	add	x0, x3, x0
MAKE_REG_HELPER(cntv_cval_el0)
    4000e16c:	d51be340 	msr	cntv_cval_el0, x0
MAKE_REG_HELPER(cntv_ctl_el0)
    4000e170:	d53be320 	mrs	x0, cntv_ctl_el0
    4000e174:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    4000e178:	d51be320 	msr	cntv_ctl_el0, x0
MAKE_REG_HELPER(daif)
    4000e17c:	92407c80 	and	x0, x4, #0xffffffff
    4000e180:	d51b4220 	msr	daif, x0

#else  /* CONFIG_TICKLESS_KERNEL */
	ARG_UNUSED(ticks);
	ARG_UNUSED(idle);
#endif
}
    4000e184:	d65f03c0 	ret
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : \
    4000e188:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    4000e18c:	17ffffe2 	b	4000e114 <sys_clock_set_timeout+0x1c>

000000004000e190 <sys_clock_elapsed>:
    4000e190:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e194:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    4000e198:	d53be040 	mrs	x0, cntvct_el0
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = (uint32_t)((arm_arch_timer_count() - last_cycle)
    4000e19c:	f0000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    4000e1a0:	f943ac42 	ldr	x2, [x2, #1880]
MAKE_REG_HELPER(daif)
    4000e1a4:	92407c21 	and	x1, x1, #0xffffffff
    4000e1a8:	cb020000 	sub	x0, x0, x2
		    / CYC_PER_TICK);
    4000e1ac:	d2912d02 	mov	x2, #0x8968                	// #35176
    4000e1b0:	f2a00122 	movk	x2, #0x9, lsl #16
    4000e1b4:	9ac20800 	udiv	x0, x0, x2
    4000e1b8:	d51b4221 	msr	daif, x1

	k_spin_unlock(&lock, key);
	return ret;
}
    4000e1bc:	d65f03c0 	ret

000000004000e1c0 <sys_clock_cycle_get_32>:
MAKE_REG_HELPER(cntvct_el0);
    4000e1c0:	d53be040 	mrs	x0, cntvct_el0

uint32_t sys_clock_cycle_get_32(void)
{
	return (uint32_t)arm_arch_timer_count();
}
    4000e1c4:	d65f03c0 	ret

000000004000e1c8 <arch_busy_wait>:
}

#ifdef CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT
void arch_busy_wait(uint32_t usec_to_wait)
{
	if (usec_to_wait == 0) {
    4000e1c8:	34000100 	cbz	w0, 4000e1e8 <arch_busy_wait+0x20>
    4000e1cc:	d53be042 	mrs	x2, cntvct_el0
		return;
	}

	uint64_t start_cycles = arm_arch_timer_count();

	uint64_t cycles_to_wait = sys_clock_hw_cycles_per_sec() / USEC_PER_SEC * usec_to_wait;
    4000e1d0:	528007c1 	mov	w1, #0x3e                  	// #62
    4000e1d4:	1b017c00 	mul	w0, w0, w1
    4000e1d8:	d53be041 	mrs	x1, cntvct_el0

	for (;;) {
		uint64_t current_cycles = arm_arch_timer_count();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
    4000e1dc:	cb020021 	sub	x1, x1, x2
    4000e1e0:	eb00003f 	cmp	x1, x0
    4000e1e4:	54ffffa3 	b.cc	4000e1d8 <arch_busy_wait+0x10>  // b.lo, b.ul, b.last
			break;
		}
	}
}
    4000e1e8:	d65f03c0 	ret

000000004000e1ec <device_visitor>:

static int device_visitor(const device_handle_t *handles,
			   size_t handle_count,
			   device_visitor_callback_t visitor_cb,
			   void *context)
{
    4000e1ec:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000e1f0:	910003fd 	mov	x29, sp
    4000e1f4:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t numdev = __device_end - __device_start;
    4000e1f8:	90000033 	adrp	x19, 40012000 <__rodata_region_start>
    4000e1fc:	9103c273 	add	x19, x19, #0xf0
    4000e200:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000e204:	90000035 	adrp	x21, 40012000 <__rodata_region_start>
    4000e208:	910242b5 	add	x21, x21, #0x90
    4000e20c:	cb150273 	sub	x19, x19, x21
    4000e210:	a90363f7 	stp	x23, x24, [sp, #48]
    4000e214:	aa0003f7 	mov	x23, x0
    4000e218:	9344fe73 	asr	x19, x19, #4
    4000e21c:	b201f3e0 	mov	x0, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
    4000e220:	f2955560 	movk	x0, #0xaaab
    4000e224:	aa0103f6 	mov	x22, x1
    4000e228:	aa0203f8 	mov	x24, x2
    4000e22c:	a9046bf9 	stp	x25, x26, [sp, #64]
    4000e230:	9b007e73 	mul	x19, x19, x0
    4000e234:	aa0303f9 	mov	x25, x3
	/* Iterate over fixed devices */
	for (size_t i = 0; i < handle_count; ++i) {
    4000e238:	d2800014 	mov	x20, #0x0                   	// #0
		dev = &__device_start[dev_handle - 1];
    4000e23c:	5280061a 	mov	w26, #0x30                  	// #48
    4000e240:	eb16029f 	cmp	x20, x22
    4000e244:	54000101 	b.ne	4000e264 <device_visitor+0x78>  // b.any
		if (rc < 0) {
			return rc;
		}
	}

	return handle_count;
    4000e248:	2a1403e0 	mov	w0, w20
}
    4000e24c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e250:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000e254:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000e258:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000e25c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4000e260:	d65f03c0 	ret
		device_handle_t dh = handles[i];
    4000e264:	78f47ae0 	ldrsh	w0, [x23, x20, lsl #1]
	if ((dev_handle > 0) && ((size_t)dev_handle <= numdev)) {
    4000e268:	7100001f 	cmp	w0, #0x0
    4000e26c:	5400016d 	b.le	4000e298 <device_visitor+0xac>
		dev = &__device_start[dev_handle - 1];
    4000e270:	51000404 	sub	w4, w0, #0x1
    4000e274:	eb20a27f 	cmp	x19, w0, sxth
    4000e278:	13003c84 	sxth	w4, w4
    4000e27c:	9b3a5484 	smaddl	x4, w4, w26, x21
    4000e280:	9a9f2080 	csel	x0, x4, xzr, cs  // cs = hs, nlast
		int rc = visitor_cb(rdev, context);
    4000e284:	aa1903e1 	mov	x1, x25
    4000e288:	d63f0300 	blr	x24
		if (rc < 0) {
    4000e28c:	37fffe00 	tbnz	w0, #31, 4000e24c <device_visitor+0x60>
	for (size_t i = 0; i < handle_count; ++i) {
    4000e290:	91000694 	add	x20, x20, #0x1
    4000e294:	17ffffeb 	b	4000e240 <device_visitor+0x54>
	const struct device *dev = NULL;
    4000e298:	d2800000 	mov	x0, #0x0                   	// #0
    4000e29c:	17fffffa 	b	4000e284 <device_visitor+0x98>

000000004000e2a0 <z_device_state_init>:
}
    4000e2a0:	d65f03c0 	ret

000000004000e2a4 <z_sys_init_run_level>:
{
    4000e2a4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    4000e2a8:	d0000021 	adrp	x1, 40014000 <shell_m_sub_colors+0x50>
    4000e2ac:	910ec021 	add	x1, x1, #0x3b0
{
    4000e2b0:	910003fd 	mov	x29, sp
    4000e2b4:	a90153f3 	stp	x19, x20, [sp, #16]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    4000e2b8:	f860d833 	ldr	x19, [x1, w0, sxtw #3]
    4000e2bc:	11000400 	add	w0, w0, #0x1
{
    4000e2c0:	a9025bf5 	stp	x21, x22, [sp, #32]
				dev->state->init_res = rc;
    4000e2c4:	52801ff6 	mov	w22, #0xff                  	// #255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    4000e2c8:	f860d835 	ldr	x21, [x1, w0, sxtw #3]
    4000e2cc:	eb1302bf 	cmp	x21, x19
    4000e2d0:	540000a8 	b.hi	4000e2e4 <z_sys_init_run_level+0x40>  // b.pmore
}
    4000e2d4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e2d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000e2dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000e2e0:	d65f03c0 	ret
		const struct device *dev = entry->dev;
    4000e2e4:	a9405261 	ldp	x1, x20, [x19]
		int rc = entry->init(dev);
    4000e2e8:	aa1403e0 	mov	x0, x20
    4000e2ec:	d63f0020 	blr	x1
		if (dev != NULL) {
    4000e2f0:	b4000174 	cbz	x20, 4000e31c <z_sys_init_run_level+0x78>
			if (rc != 0) {
    4000e2f4:	7100001f 	cmp	w0, #0x0
				dev->state->init_res = rc;
    4000e2f8:	f9400e81 	ldr	x1, [x20, #24]
			if (rc != 0) {
    4000e2fc:	340000a0 	cbz	w0, 4000e310 <z_sys_init_run_level+0x6c>
				if (rc < 0) {
    4000e300:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
				dev->state->init_res = rc;
    4000e304:	7103fc1f 	cmp	w0, #0xff
    4000e308:	1a96d000 	csel	w0, w0, w22, le
    4000e30c:	39000020 	strb	w0, [x1]
			dev->state->initialized = true;
    4000e310:	79400020 	ldrh	w0, [x1]
    4000e314:	32180000 	orr	w0, w0, #0x100
    4000e318:	79000020 	strh	w0, [x1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    4000e31c:	91004273 	add	x19, x19, #0x10
    4000e320:	17ffffeb 	b	4000e2cc <z_sys_init_run_level+0x28>

000000004000e324 <z_device_get_all_static>:
	*devices = __device_start;
    4000e324:	90000021 	adrp	x1, 40012000 <__rodata_region_start>
    4000e328:	91024021 	add	x1, x1, #0x90
    4000e32c:	f9000001 	str	x1, [x0]
	return __device_end - __device_start;
    4000e330:	90000020 	adrp	x0, 40012000 <__rodata_region_start>
    4000e334:	9103c000 	add	x0, x0, #0xf0
    4000e338:	cb010000 	sub	x0, x0, x1
}
    4000e33c:	b201f3e1 	mov	x1, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
    4000e340:	f2955561 	movk	x1, #0xaaab
	return __device_end - __device_start;
    4000e344:	9344fc00 	asr	x0, x0, #4
}
    4000e348:	9b017c00 	mul	x0, x0, x1
    4000e34c:	d65f03c0 	ret

000000004000e350 <z_device_ready>:
	if (dev == NULL) {
    4000e350:	b40000e0 	cbz	x0, 4000e36c <z_device_ready+0x1c>
	return dev->state->initialized && (dev->state->init_res == 0U);
    4000e354:	f9400c00 	ldr	x0, [x0, #24]
    4000e358:	b9400000 	ldr	w0, [x0]
    4000e35c:	12002000 	and	w0, w0, #0x1ff
    4000e360:	7104001f 	cmp	w0, #0x100
    4000e364:	1a9f17e0 	cset	w0, eq  // eq = none
}
    4000e368:	d65f03c0 	ret
		return false;
    4000e36c:	52800000 	mov	w0, #0x0                   	// #0
    4000e370:	17fffffe 	b	4000e368 <z_device_ready+0x18>

000000004000e374 <device_required_foreach>:
int device_required_foreach(const struct device *dev,
			    device_visitor_callback_t visitor_cb,
			    void *context)
{
	size_t handle_count = 0;
	const device_handle_t *handles = device_required_handles_get(dev, &handle_count);
    4000e374:	f9401400 	ldr	x0, [x0, #40]
{
    4000e378:	aa0103e4 	mov	x4, x1
    4000e37c:	aa0203e3 	mov	x3, x2
		size_t i = 0;
    4000e380:	d2800001 	mov	x1, #0x0                   	// #0
	if (rv != NULL) {
    4000e384:	b5000120 	cbnz	x0, 4000e3a8 <device_required_foreach+0x34>

	return device_visitor(handles, handle_count, visitor_cb, context);
    4000e388:	aa0403e2 	mov	x2, x4
    4000e38c:	17ffff98 	b	4000e1ec <device_visitor>
			++i;
    4000e390:	91000421 	add	x1, x1, #0x1
		       && (rv[i] != DEVICE_HANDLE_SEP)) {
    4000e394:	78617802 	ldrh	w2, [x0, x1, lsl #1]
    4000e398:	0b060042 	add	w2, w2, w6
		while ((rv[i] != DEVICE_HANDLE_ENDS)
    4000e39c:	6b2220bf 	cmp	w5, w2, uxth
    4000e3a0:	54ffff82 	b.cs	4000e390 <device_required_foreach+0x1c>  // b.hs, b.nlast
    4000e3a4:	17fffff9 	b	4000e388 <device_required_foreach+0x14>
		       && (rv[i] != DEVICE_HANDLE_SEP)) {
    4000e3a8:	528fffe6 	mov	w6, #0x7fff                	// #32767
		while ((rv[i] != DEVICE_HANDLE_ENDS)
    4000e3ac:	529fffa5 	mov	w5, #0xfffd                	// #65533
    4000e3b0:	17fffff9 	b	4000e394 <device_required_foreach+0x20>

000000004000e3b4 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
    4000e3b4:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000e3b8:	f943b800 	ldr	x0, [x0, #1904]
}
    4000e3bc:	91048000 	add	x0, x0, #0x120
    4000e3c0:	d65f03c0 	ret

000000004000e3c4 <arch_system_halt>:
MAKE_REG_HELPER(daif)
    4000e3c4:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e3c8:	d50342df 	msr	daifset, #0x2
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
    4000e3cc:	14000000 	b	4000e3cc <arch_system_halt+0x8>

000000004000e3d0 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    4000e3d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000e3d4:	910003fd 	mov	x29, sp
    4000e3d8:	f9000bf3 	str	x19, [sp, #16]
    4000e3dc:	2a0003f3 	mov	w19, w0
	z_impl_log_panic();
    4000e3e0:	97ffd98c 	bl	40004a10 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
    4000e3e4:	b0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000e3e8:	91337001 	add	x1, x0, #0xcdc
    4000e3ec:	b94cdc00 	ldr	w0, [x0, #3292]
    4000e3f0:	f240081f 	tst	x0, #0x7
    4000e3f4:	54000140 	b.eq	4000e41c <k_sys_fatal_error_handler+0x4c>  // b.none
    4000e3f8:	b0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000e3fc:	91334000 	add	x0, x0, #0xcd0
    4000e400:	cb000021 	sub	x1, x1, x0
    4000e404:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000e408:	911f2800 	add	x0, x0, #0x7ca
    4000e40c:	d342fc21 	lsr	x1, x1, #2
    4000e410:	531a2421 	ubfiz	w1, w1, #6, #10
    4000e414:	32000021 	orr	w1, w1, #0x1
    4000e418:	97ffd922 	bl	400048a0 <log_0>
	arch_system_halt(reason);
    4000e41c:	2a1303e0 	mov	w0, w19
    4000e420:	97ffffe9 	bl	4000e3c4 <arch_system_halt>

000000004000e424 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    4000e424:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000e428:	910003fd 	mov	x29, sp
    4000e42c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000e430:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000e434:	2a0003f5 	mov	w21, w0
    4000e438:	a90363f7 	stp	x23, x24, [sp, #48]
    4000e43c:	aa0103f7 	mov	x23, x1
MAKE_REG_HELPER(daif)
    4000e440:	d53b4236 	mrs	x22, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e444:	d50342df 	msr	daifset, #0x2
	return z_impl_z_current_get();
    4000e448:	940006b7 	bl	4000ff24 <z_impl_z_current_get>
    4000e44c:	aa0003f4 	mov	x20, x0
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    4000e450:	b0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000e454:	b94cdc01 	ldr	w1, [x0, #3292]
    4000e458:	f240083f 	tst	x1, #0x7
    4000e45c:	54000420 	b.eq	4000e4e0 <z_fatal_error+0xbc>  // b.none
    4000e460:	91337013 	add	x19, x0, #0xcdc
    4000e464:	aa0003f8 	mov	x24, x0
    4000e468:	b0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000e46c:	91334000 	add	x0, x0, #0xcd0
    4000e470:	cb000273 	sub	x19, x19, x0
    4000e474:	2a1503e1 	mov	w1, w21
    4000e478:	710012bf 	cmp	w21, #0x4
    4000e47c:	d342fe73 	lsr	x19, x19, #2
    4000e480:	531a2673 	ubfiz	w19, w19, #6, #10
    4000e484:	32000264 	orr	w4, w19, #0x1
	switch (reason) {
    4000e488:	54000428 	b.hi	4000e50c <z_fatal_error+0xe8>  // b.pmore
    4000e48c:	d0000020 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    4000e490:	910f6000 	add	x0, x0, #0x3d8
    4000e494:	f8617802 	ldr	x2, [x0, x1, lsl #3]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    4000e498:	d2800003 	mov	x3, #0x0                   	// #0
    4000e49c:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000e4a0:	911fbc00 	add	x0, x0, #0x7ef
    4000e4a4:	97ffd93e 	bl	4000499c <log_3>
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    4000e4a8:	b94cdf00 	ldr	w0, [x24, #3292]
    4000e4ac:	f240081f 	tst	x0, #0x7
    4000e4b0:	54000180 	b.eq	4000e4e0 <z_fatal_error+0xbc>  // b.none
    4000e4b4:	32000273 	orr	w19, w19, #0x1
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    4000e4b8:	b5000314 	cbnz	x20, 4000e518 <z_fatal_error+0xf4>
		thread_name = "unknown";
    4000e4bc:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000e4c0:	911f9c00 	add	x0, x0, #0x7e7
{
	if (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
    4000e4c4:	97ffd7f0 	bl	40004484 <z_log_strdup>
	LOG_ERR("Current thread: %p (%s)", thread,
    4000e4c8:	aa0003e2 	mov	x2, x0
    4000e4cc:	2a1303e3 	mov	w3, w19
    4000e4d0:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000e4d4:	91205c00 	add	x0, x0, #0x817
    4000e4d8:	aa1403e1 	mov	x1, x20
    4000e4dc:	97ffd917 	bl	40004938 <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    4000e4e0:	aa1703e1 	mov	x1, x23
    4000e4e4:	2a1503e0 	mov	w0, w21
MAKE_REG_HELPER(daif)
    4000e4e8:	92407ed6 	and	x22, x22, #0xffffffff
    4000e4ec:	97ffffb9 	bl	4000e3d0 <k_sys_fatal_error_handler>
    4000e4f0:	d51b4236 	msr	daif, x22
	z_impl_k_thread_abort(thread);
    4000e4f4:	aa1403e0 	mov	x0, x20
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    4000e4f8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e4fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000e500:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000e504:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000e508:	14000860 	b	40010688 <z_impl_k_thread_abort>
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    4000e50c:	90000042 	adrp	x2, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000e510:	911f6442 	add	x2, x2, #0x7d9
    4000e514:	17ffffe1 	b	4000e498 <z_fatal_error+0x74>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    4000e518:	aa1403e0 	mov	x0, x20
    4000e51c:	94000148 	bl	4000ea3c <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
    4000e520:	b4fffce0 	cbz	x0, 4000e4bc <z_fatal_error+0x98>
    4000e524:	39400001 	ldrb	w1, [x0]
    4000e528:	34fffca1 	cbz	w1, 4000e4bc <z_fatal_error+0x98>
    4000e52c:	17ffffe6 	b	4000e4c4 <z_fatal_error+0xa0>

000000004000e530 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    4000e530:	d10143ff 	sub	sp, sp, #0x50
	k_thread_stack_t *stack = z_idle_stacks[i];

#ifdef CONFIG_THREAD_NAME
	char tname[8];

	snprintk(tname, 8, "idle %02d", i);
    4000e534:	d2800101 	mov	x1, #0x8                   	// #8
    4000e538:	90000042 	adrp	x2, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000e53c:	9121e442 	add	x2, x2, #0x879
{
    4000e540:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000e544:	910043fd 	add	x29, sp, #0x10
    4000e548:	a90253f3 	stp	x19, x20, [sp, #32]
    4000e54c:	93407c14 	sxtw	x20, w0
	snprintk(tname, 8, "idle %02d", i);
    4000e550:	2a1403e3 	mov	w3, w20
{
    4000e554:	a9035bf5 	stp	x21, x22, [sp, #48]
	snprintk(tname, 8, "idle %02d", i);
    4000e558:	910123f6 	add	x22, sp, #0x48
    4000e55c:	aa1603e0 	mov	x0, x22
    4000e560:	97ffce69 	bl	40001f04 <snprintk>
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
    4000e564:	f90007f6 	str	x22, [sp, #8]
	struct k_thread *thread = &z_idle_threads[i];
    4000e568:	d0000080 	adrp	x0, 40020000 <logging_thread>
    4000e56c:	911c0015 	add	x21, x0, #0x700
	z_setup_new_thread(thread, stack,
    4000e570:	52800020 	mov	w0, #0x1                   	// #1
    4000e574:	b90003e0 	str	w0, [sp]
    4000e578:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000e57c:	911d8000 	add	x0, x0, #0x760
    4000e580:	52800704 	mov	w4, #0x38                  	// #56
	k_thread_stack_t *stack = z_idle_stacks[i];
    4000e584:	93747e81 	sbfiz	x1, x20, #12, #32
	z_setup_new_thread(thread, stack,
    4000e588:	528001e7 	mov	w7, #0xf                   	// #15
    4000e58c:	d2800006 	mov	x6, #0x0                   	// #0
    4000e590:	9b240284 	smaddl	x4, w20, w4, x0
    4000e594:	d00002e0 	adrp	x0, 4006c000 <z_main_stack+0xc10>
    4000e598:	910fc000 	add	x0, x0, #0x3f0
    4000e59c:	d2800005 	mov	x5, #0x0                   	// #0
    4000e5a0:	8b010001 	add	x1, x0, x1
    4000e5a4:	52807000 	mov	w0, #0x380                 	// #896
    4000e5a8:	d2820002 	mov	x2, #0x1000                	// #4096
    4000e5ac:	90000003 	adrp	x3, 4000e000 <pl011_init+0xe0>
    4000e5b0:	9137e063 	add	x3, x3, #0xdf8
    4000e5b4:	9b205680 	smaddl	x0, w20, w0, x21
    4000e5b8:	9400014e 	bl	4000eaf0 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    4000e5bc:	d2807000 	mov	x0, #0x380                 	// #896
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    4000e5c0:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000e5c4:	9b005680 	madd	x0, x20, x0, x21
    4000e5c8:	a94253f3 	ldp	x19, x20, [sp, #32]
    4000e5cc:	a9435bf5 	ldp	x21, x22, [sp, #48]
    4000e5d0:	39406401 	ldrb	w1, [x0, #25]
    4000e5d4:	121d7821 	and	w1, w1, #0xfffffffb
    4000e5d8:	39006401 	strb	w1, [x0, #25]
    4000e5dc:	910143ff 	add	sp, sp, #0x50
    4000e5e0:	d65f03c0 	ret

000000004000e5e4 <bg_thread_main>:
{
    4000e5e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000e5e8:	910003fd 	mov	x29, sp
	z_mem_manage_init();
    4000e5ec:	94000a74 	bl	40010fbc <z_mem_manage_init>
	z_sys_post_kernel = true;
    4000e5f0:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000e5f4:	52800021 	mov	w1, #0x1                   	// #1
    4000e5f8:	392fac01 	strb	w1, [x0, #3051]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    4000e5fc:	52800040 	mov	w0, #0x2                   	// #2
    4000e600:	97ffff29 	bl	4000e2a4 <z_sys_init_run_level>
	boot_banner();
    4000e604:	94000c0c 	bl	40011634 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    4000e608:	52800060 	mov	w0, #0x3                   	// #3
    4000e60c:	97ffff26 	bl	4000e2a4 <z_sys_init_run_level>
	z_init_static_threads();
    4000e610:	9400019a 	bl	4000ec78 <z_init_static_threads>
	z_mem_manage_boot_finish();
    4000e614:	94000a9e 	bl	4001108c <z_mem_manage_boot_finish>
	main();
    4000e618:	97ffcc43 	bl	40001724 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    4000e61c:	d0000080 	adrp	x0, 40020000 <logging_thread>
    4000e620:	912a0000 	add	x0, x0, #0xa80
    4000e624:	39406001 	ldrb	w1, [x0, #24]
    4000e628:	121f7821 	and	w1, w1, #0xfffffffe
    4000e62c:	39006001 	strb	w1, [x0, #24]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    4000e630:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000e634:	d65f03c0 	ret

000000004000e638 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    4000e638:	d10f03ff 	sub	sp, sp, #0x3c0
    4000e63c:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000e640:	910043fd 	add	x29, sp, #0x10
    4000e644:	a90253f3 	stp	x19, x20, [sp, #32]
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    4000e648:	f0000093 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    4000e64c:	911d8273 	add	x19, x19, #0x760
    4000e650:	a9035bf5 	stp	x21, x22, [sp, #48]
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
    4000e654:	97ffd6ff 	bl	40004250 <log_core_init>
	dummy_thread->base.user_options = K_ESSENTIAL;
    4000e658:	52802020 	mov	w0, #0x101                 	// #257
    4000e65c:	7900b3e0 	strh	w0, [sp, #88]
	_current_cpu->current = dummy_thread;
    4000e660:	910103e0 	add	x0, sp, #0x40
    4000e664:	f9000a60 	str	x0, [x19, #16]
	_kernel.ready_q.cache = &z_main_thread;
    4000e668:	d0000094 	adrp	x20, 40020000 <logging_thread>
    4000e66c:	912a0294 	add	x20, x20, #0xa80
	dummy_thread->stack_info.size = 0U;
    4000e670:	a916ffff 	stp	xzr, xzr, [sp, #360]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    4000e674:	97ffff0b 	bl	4000e2a0 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    4000e678:	52800000 	mov	w0, #0x0                   	// #0
    4000e67c:	97ffff0a 	bl	4000e2a4 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    4000e680:	52800020 	mov	w0, #0x1                   	// #1
    4000e684:	97ffff08 	bl	4000e2a4 <z_sys_init_run_level>
	__stack_chk_guard = stack_guard;
	__stack_chk_guard <<= 8;
#endif	/* CONFIG_STACK_CANARIES */

#ifdef CONFIG_TIMING_FUNCTIONS_NEED_AT_BOOT
	timing_init();
    4000e688:	97fffc45 	bl	4000d79c <timing_init>
	timing_start();
    4000e68c:	97fffc50 	bl	4000d7cc <timing_start>
	z_sched_init();
    4000e690:	9400061d 	bl	4000ff04 <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
    4000e694:	f9001e74 	str	x20, [x19, #56]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    4000e698:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000e69c:	91220c00 	add	x0, x0, #0x883
    4000e6a0:	f90007e0 	str	x0, [sp, #8]
    4000e6a4:	52800020 	mov	w0, #0x1                   	// #1
    4000e6a8:	b90003e0 	str	w0, [sp]
    4000e6ac:	52800007 	mov	w7, #0x0                   	// #0
    4000e6b0:	d2800006 	mov	x6, #0x0                   	// #0
    4000e6b4:	d2800005 	mov	x5, #0x0                   	// #0
    4000e6b8:	d2800004 	mov	x4, #0x0                   	// #0
    4000e6bc:	d2820002 	mov	x2, #0x1000                	// #4096
    4000e6c0:	aa1403e0 	mov	x0, x20
    4000e6c4:	90000003 	adrp	x3, 4000e000 <pl011_init+0xe0>
    4000e6c8:	91179063 	add	x3, x3, #0x5e4
    4000e6cc:	b00002e1 	adrp	x1, 4006b000 <shell_uart_stack+0x410>
    4000e6d0:	910fc021 	add	x1, x1, #0x3f0
    4000e6d4:	94000107 	bl	4000eaf0 <z_setup_new_thread>
    4000e6d8:	39406680 	ldrb	w0, [x20, #25]
    4000e6dc:	121d7800 	and	w0, w0, #0xfffffffb
    4000e6e0:	39006680 	strb	w0, [x20, #25]
	z_ready_thread(&z_main_thread);
    4000e6e4:	aa1403e0 	mov	x0, x20
    4000e6e8:	94000537 	bl	4000fbc4 <z_ready_thread>
		init_idle_thread(i);
    4000e6ec:	52800000 	mov	w0, #0x0                   	// #0
    4000e6f0:	97ffff90 	bl	4000e530 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    4000e6f4:	d0000080 	adrp	x0, 40020000 <logging_thread>
    4000e6f8:	911c0000 	add	x0, x0, #0x700
    4000e6fc:	f9000e60 	str	x0, [x19, #24]
		_kernel.cpus[i].irq_stack =
    4000e700:	90000300 	adrp	x0, 4006e000 <z_interrupt_stacks+0xc10>
    4000e704:	910fc000 	add	x0, x0, #0x3f0
    4000e708:	f9000660 	str	x0, [x19, #8]
		_kernel.cpus[i].id = i;
    4000e70c:	3900927f 	strb	wzr, [x19, #36]
    4000e710:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e714:	d50342df 	msr	daifset, #0x2
	old_thread = _current;
    4000e718:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    4000e71c:	12800140 	mov	w0, #0xfffffff5            	// #-11
    4000e720:	b90142c0 	str	w0, [x22, #320]
MAKE_REG_HELPER(daif)
    4000e724:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e728:	d50342df 	msr	daifset, #0x2
	new_thread = z_swap_next_thread();
    4000e72c:	94000484 	bl	4000f93c <z_swap_next_thread>
	if (new_thread != old_thread) {
    4000e730:	eb0002df 	cmp	x22, x0
    4000e734:	54000140 	b.eq	4000e75c <z_cstart+0x124>  // b.none
    4000e738:	aa0003f4 	mov	x20, x0
		z_reset_time_slice();
    4000e73c:	9400042d 	bl	4000f7f0 <z_reset_time_slice>

static inline void z_sched_usage_switch(struct k_thread *thread)
{
	ARG_UNUSED(thread);
#ifdef CONFIG_SCHED_THREAD_USAGE
	z_sched_usage_stop();
    4000e740:	94000629 	bl	4000ffe4 <z_sched_usage_stop>
	z_sched_usage_start(thread);
    4000e744:	aa1403e0 	mov	x0, x20
    4000e748:	9400061e 	bl	4000ffc0 <z_sched_usage_start>
{
}

static inline void arch_switch(void *switch_to, void **switched_from)
{
	z_arm64_call_svc(switch_to, switched_from);
    4000e74c:	f940a680 	ldr	x0, [x20, #328]
    4000e750:	910522c1 	add	x1, x22, #0x148
		_current_cpu->current = new_thread;
    4000e754:	f9000a74 	str	x20, [x19, #16]
    4000e758:	97fff6c7 	bl	4000c274 <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    4000e75c:	92407eb5 	and	x21, x21, #0xffffffff
    4000e760:	d51b4235 	msr	daif, x21

000000004000e764 <init_mem_slab_module>:
static int init_mem_slab_module(const struct device *dev)
{
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    4000e764:	b0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    4000e768:	91350000 	add	x0, x0, #0xd40
    4000e76c:	b0000302 	adrp	x2, 4006f000 <sys_work_q_stack+0xc10>
    4000e770:	91350042 	add	x2, x2, #0xd40
    4000e774:	eb02001f 	cmp	x0, x2
    4000e778:	54000063 	b.cc	4000e784 <init_mem_slab_module+0x20>  // b.lo, b.ul, b.last
			goto out;
		}
		z_object_init(slab);
	}

out:
    4000e77c:	52800000 	mov	w0, #0x0                   	// #0
	return rc;
}
    4000e780:	d65f03c0 	ret
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    4000e784:	a9418404 	ldp	x4, x1, [x0, #24]
    4000e788:	aa040023 	orr	x3, x1, x4
    4000e78c:	f240087f 	tst	x3, #0x7
    4000e790:	540001c1 	b.ne	4000e7c8 <init_mem_slab_module+0x64>  // b.any
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e794:	b9401005 	ldr	w5, [x0, #16]
    4000e798:	52800003 	mov	w3, #0x0                   	// #0
	slab->free_list = NULL;
    4000e79c:	f900141f 	str	xzr, [x0, #40]
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e7a0:	6b05007f 	cmp	w3, w5
    4000e7a4:	54000061 	b.ne	4000e7b0 <init_mem_slab_module+0x4c>  // b.any
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    4000e7a8:	9100e000 	add	x0, x0, #0x38
    4000e7ac:	17fffff2 	b	4000e774 <init_mem_slab_module+0x10>
		*(char **)p = slab->free_list;
    4000e7b0:	f9401406 	ldr	x6, [x0, #40]
    4000e7b4:	f9000026 	str	x6, [x1]
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e7b8:	11000463 	add	w3, w3, #0x1
		slab->free_list = p;
    4000e7bc:	f9001401 	str	x1, [x0, #40]
		p += slab->block_size;
    4000e7c0:	8b040021 	add	x1, x1, x4
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e7c4:	17fffff7 	b	4000e7a0 <init_mem_slab_module+0x3c>
    4000e7c8:	128002a0 	mov	w0, #0xffffffea            	// #-22
	return rc;
    4000e7cc:	17ffffed 	b	4000e780 <init_mem_slab_module+0x1c>

000000004000e7d0 <k_mem_slab_init>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    4000e7d0:	aa020024 	orr	x4, x1, x2
int k_mem_slab_init(struct k_mem_slab *slab, void *buffer,
		    size_t block_size, uint32_t num_blocks)
{
	int rc = 0;

	slab->num_blocks = num_blocks;
    4000e7d4:	b9001003 	str	w3, [x0, #16]
	slab->block_size = block_size;
	slab->buffer = buffer;
    4000e7d8:	a9018402 	stp	x2, x1, [x0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    4000e7dc:	f240089f 	tst	x4, #0x7
	slab->num_used = 0U;
    4000e7e0:	b900301f 	str	wzr, [x0, #48]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    4000e7e4:	540001c1 	b.ne	4000e81c <k_mem_slab_init+0x4c>  // b.any
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e7e8:	52800004 	mov	w4, #0x0                   	// #0
	slab->free_list = NULL;
    4000e7ec:	f900141f 	str	xzr, [x0, #40]
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e7f0:	6b04007f 	cmp	w3, w4
    4000e7f4:	54000081 	b.ne	4000e804 <k_mem_slab_init+0x34>  // b.any
    4000e7f8:	a9000000 	stp	x0, x0, [x0]
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
}
    4000e7fc:	52800000 	mov	w0, #0x0                   	// #0
	z_object_init(slab);
out:
	SYS_PORT_TRACING_OBJ_INIT(k_mem_slab, slab, rc);

	return rc;
}
    4000e800:	d65f03c0 	ret
		*(char **)p = slab->free_list;
    4000e804:	f9401405 	ldr	x5, [x0, #40]
    4000e808:	f9000025 	str	x5, [x1]
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e80c:	11000484 	add	w4, w4, #0x1
		slab->free_list = p;
    4000e810:	f9001401 	str	x1, [x0, #40]
		p += slab->block_size;
    4000e814:	8b020021 	add	x1, x1, x2
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e818:	17fffff6 	b	4000e7f0 <k_mem_slab_init+0x20>
		return -EINVAL;
    4000e81c:	128002a0 	mov	w0, #0xffffffea            	// #-22
	return rc;
    4000e820:	17fffff8 	b	4000e800 <k_mem_slab_init+0x30>

000000004000e824 <k_mem_slab_alloc>:

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
    4000e824:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000e828:	aa0203e3 	mov	x3, x2
    4000e82c:	910003fd 	mov	x29, sp
    4000e830:	f9000bf3 	str	x19, [sp, #16]
    4000e834:	aa0103f3 	mov	x19, x1
    4000e838:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e83c:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
    4000e840:	f9401402 	ldr	x2, [x0, #40]
    4000e844:	b4000162 	cbz	x2, 4000e870 <k_mem_slab_alloc+0x4c>
		/* take a free block */
		*mem = slab->free_list;
    4000e848:	f9000262 	str	x2, [x19]
		slab->free_list = *(char **)(slab->free_list);
    4000e84c:	f9400042 	ldr	x2, [x2]
    4000e850:	f9001402 	str	x2, [x0, #40]
		slab->num_used++;
    4000e854:	b9403002 	ldr	w2, [x0, #48]
    4000e858:	11000442 	add	w2, w2, #0x1
    4000e85c:	b9003002 	str	w2, [x0, #48]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
    4000e860:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    4000e864:	92407c21 	and	x1, x1, #0xffffffff
    4000e868:	d51b4221 	msr	daif, x1

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
    4000e86c:	1400000d 	b	4000e8a0 <k_mem_slab_alloc+0x7c>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
    4000e870:	b5000083 	cbnz	x3, 4000e880 <k_mem_slab_alloc+0x5c>
		result = -ENOMEM;
    4000e874:	12800160 	mov	w0, #0xfffffff4            	// #-12
		*mem = NULL;
    4000e878:	f900027f 	str	xzr, [x19]
		result = -ENOMEM;
    4000e87c:	17fffffa 	b	4000e864 <k_mem_slab_alloc+0x40>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
    4000e880:	aa0003e2 	mov	x2, x0
    4000e884:	91004000 	add	x0, x0, #0x10
    4000e888:	94000692 	bl	400102d0 <z_pend_curr>
		if (result == 0) {
    4000e88c:	350000a0 	cbnz	w0, 4000e8a0 <k_mem_slab_alloc+0x7c>
			*mem = _current->base.swap_data;
    4000e890:	f0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000e894:	f943b821 	ldr	x1, [x1, #1904]
    4000e898:	f9401021 	ldr	x1, [x1, #32]
    4000e89c:	f9000261 	str	x1, [x19]
}
    4000e8a0:	f9400bf3 	ldr	x19, [sp, #16]
    4000e8a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000e8a8:	d65f03c0 	ret

000000004000e8ac <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    4000e8ac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000e8b0:	910003fd 	mov	x29, sp
    4000e8b4:	a90153f3 	stp	x19, x20, [sp, #16]
    4000e8b8:	aa0003f3 	mov	x19, x0
    4000e8bc:	aa0103f4 	mov	x20, x1
    4000e8c0:	f90013f5 	str	x21, [sp, #32]
    4000e8c4:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e8c8:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
    4000e8cc:	f9401401 	ldr	x1, [x0, #40]
    4000e8d0:	b50001a1 	cbnz	x1, 4000e904 <k_mem_slab_free+0x58>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    4000e8d4:	9400057b 	bl	4000fec0 <z_unpend_first_thread>

		if (pending_thread != NULL) {
    4000e8d8:	b4000160 	cbz	x0, 4000e904 <k_mem_slab_free+0x58>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    4000e8dc:	f9400281 	ldr	x1, [x20]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    4000e8e0:	f9001001 	str	x1, [x0, #32]
	thread->swap_retval = value;
    4000e8e4:	b901401f 	str	wzr, [x0, #320]
			z_ready_thread(pending_thread);
    4000e8e8:	940004b7 	bl	4000fbc4 <z_ready_thread>
			z_reschedule(&slab->lock, key);
    4000e8ec:	2a1503e1 	mov	w1, w21
    4000e8f0:	91004260 	add	x0, x19, #0x10
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
    4000e8f4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e8f8:	f94013f5 	ldr	x21, [sp, #32]
    4000e8fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
			z_reschedule(&slab->lock, key);
    4000e900:	14000690 	b	40010340 <z_reschedule>
	**(char ***) mem = slab->free_list;
    4000e904:	f9400280 	ldr	x0, [x20]
MAKE_REG_HELPER(daif)
    4000e908:	92407eb5 	and	x21, x21, #0xffffffff
    4000e90c:	f9401661 	ldr	x1, [x19, #40]
    4000e910:	f9000001 	str	x1, [x0]
	slab->free_list = *(char **) mem;
    4000e914:	f9400280 	ldr	x0, [x20]
    4000e918:	f9001660 	str	x0, [x19, #40]
	slab->num_used--;
    4000e91c:	b9403260 	ldr	w0, [x19, #48]
    4000e920:	51000400 	sub	w0, w0, #0x1
    4000e924:	b9003260 	str	w0, [x19, #48]
    4000e928:	d51b4235 	msr	daif, x21
}
    4000e92c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e930:	f94013f5 	ldr	x21, [sp, #32]
    4000e934:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000e938:	d65f03c0 	ret

000000004000e93c <k_thread_foreach>:

#define _FOREACH_STATIC_THREAD(thread_data)              \
	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data)

void k_thread_foreach(k_thread_user_cb_t user_cb, void *user_data)
{
    4000e93c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000e940:	910003fd 	mov	x29, sp
    4000e944:	a90153f3 	stp	x19, x20, [sp, #16]
    4000e948:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000e94c:	aa0003f5 	mov	x21, x0
    4000e950:	aa0103f6 	mov	x22, x1
    4000e954:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e958:	d50342df 	msr	daifset, #0x2
	 */
	key = k_spin_lock(&z_thread_monitor_lock);

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, foreach);

	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
    4000e95c:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000e960:	f943dc13 	ldr	x19, [x0, #1976]
    4000e964:	b50000f3 	cbnz	x19, 4000e980 <k_thread_foreach+0x44>
MAKE_REG_HELPER(daif)
    4000e968:	92407e94 	and	x20, x20, #0xffffffff
    4000e96c:	d51b4234 	msr	daif, x20

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, foreach);

	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
}
    4000e970:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e974:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000e978:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000e97c:	d65f03c0 	ret
		user_cb(thread, user_data);
    4000e980:	aa1303e0 	mov	x0, x19
    4000e984:	aa1603e1 	mov	x1, x22
    4000e988:	d63f02a0 	blr	x21
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
    4000e98c:	f9407e73 	ldr	x19, [x19, #248]
    4000e990:	17fffff5 	b	4000e964 <k_thread_foreach+0x28>

000000004000e994 <k_is_in_isr>:
MAKE_REG_HELPER(tpidrro_el0);
    4000e994:	d53bd060 	mrs	x0, tpidrro_el0
    4000e998:	927db000 	and	x0, x0, #0xfffffffffff8
extern void z_arm64_offload(void);
#endif

static ALWAYS_INLINE bool arch_is_in_isr(void)
{
	return arch_curr_cpu()->nested != 0U;
    4000e99c:	b9400000 	ldr	w0, [x0]
    4000e9a0:	7100001f 	cmp	w0, #0x0
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
    4000e9a4:	1a9f07e0 	cset	w0, ne  // ne = any
    4000e9a8:	d65f03c0 	ret

000000004000e9ac <z_thread_monitor_exit>:
MAKE_REG_HELPER(daif)
    4000e9ac:	d53b4223 	mrs	x3, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e9b0:	d50342df 	msr	daifset, #0x2
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
    4000e9b4:	f0000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    4000e9b8:	911d8042 	add	x2, x2, #0x760
    4000e9bc:	f9402c41 	ldr	x1, [x2, #88]
    4000e9c0:	eb00003f 	cmp	x1, x0
    4000e9c4:	540000e1 	b.ne	4000e9e0 <z_thread_monitor_exit+0x34>  // b.any
		_kernel.threads = _kernel.threads->next_thread;
    4000e9c8:	f9407c20 	ldr	x0, [x1, #248]
    4000e9cc:	f9002c40 	str	x0, [x2, #88]
MAKE_REG_HELPER(daif)
    4000e9d0:	92407c63 	and	x3, x3, #0xffffffff
    4000e9d4:	d51b4223 	msr	daif, x3
			prev_thread->next_thread = thread->next_thread;
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
    4000e9d8:	d65f03c0 	ret
    4000e9dc:	aa0203e1 	mov	x1, x2
		while ((prev_thread != NULL) &&
    4000e9e0:	b4ffff81 	cbz	x1, 4000e9d0 <z_thread_monitor_exit+0x24>
			(thread != prev_thread->next_thread)) {
    4000e9e4:	f9407c22 	ldr	x2, [x1, #248]
		while ((prev_thread != NULL) &&
    4000e9e8:	eb00005f 	cmp	x2, x0
    4000e9ec:	54ffff81 	b.ne	4000e9dc <z_thread_monitor_exit+0x30>  // b.any
			prev_thread->next_thread = thread->next_thread;
    4000e9f0:	f9407c00 	ldr	x0, [x0, #248]
    4000e9f4:	f9007c20 	str	x0, [x1, #248]
    4000e9f8:	17fffff6 	b	4000e9d0 <z_thread_monitor_exit+0x24>

000000004000e9fc <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
    4000e9fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000ea00:	910003fd 	mov	x29, sp
    4000ea04:	f9000bf3 	str	x19, [sp, #16]
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
    4000ea08:	b5000160 	cbnz	x0, 4000ea34 <z_impl_k_thread_name_set+0x38>
		thread = _current;
    4000ea0c:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000ea10:	f943b813 	ldr	x19, [x0, #1904]
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
    4000ea14:	91040260 	add	x0, x19, #0x100
    4000ea18:	d2800402 	mov	x2, #0x20                  	// #32
    4000ea1c:	97fff9e1 	bl	4000d1a0 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    4000ea20:	39047e7f 	strb	wzr, [x19, #287]

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
    4000ea24:	52800000 	mov	w0, #0x0                   	// #0
    4000ea28:	f9400bf3 	ldr	x19, [sp, #16]
    4000ea2c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000ea30:	d65f03c0 	ret
    4000ea34:	aa0003f3 	mov	x19, x0
    4000ea38:	17fffff7 	b	4000ea14 <z_impl_k_thread_name_set+0x18>

000000004000ea3c <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
    4000ea3c:	91040000 	add	x0, x0, #0x100
    4000ea40:	d65f03c0 	ret

000000004000ea44 <k_thread_state_str>:
#endif /* CONFIG_THREAD_NAME */
}

const char *k_thread_state_str(k_tid_t thread_id)
{
	switch (thread_id->base.thread_state) {
    4000ea44:	39406401 	ldrb	w1, [x0, #25]
    4000ea48:	7100403f 	cmp	w1, #0x10
    4000ea4c:	54000148 	b.hi	4000ea74 <k_thread_state_str+0x30>  // b.pmore
    4000ea50:	d0000020 	adrp	x0, 40014000 <shell_m_sub_colors+0x50>
    4000ea54:	91165000 	add	x0, x0, #0x594
    4000ea58:	38614800 	ldrb	w0, [x0, w1, uxtw]
    4000ea5c:	10000061 	adr	x1, 4000ea68 <k_thread_state_str+0x24>
    4000ea60:	8b208820 	add	x0, x1, w0, sxtb #2
    4000ea64:	d61f0000 	br	x0
    4000ea68:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000ea6c:	9122ac00 	add	x0, x0, #0x8ab
	 * this bit of defensive programming will be useful
	 */
		break;
	}
	return "unknown";
}
    4000ea70:	d65f03c0 	ret
	switch (thread_id->base.thread_state) {
    4000ea74:	7100803f 	cmp	w1, #0x20
    4000ea78:	54000340 	b.eq	4000eae0 <k_thread_state_str+0x9c>  // b.none
		return "queued";
    4000ea7c:	7102003f 	cmp	w1, #0x80
    4000ea80:	90000042 	adrp	x2, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000ea84:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000ea88:	9122e841 	add	x1, x2, #0x8ba
    4000ea8c:	911f9c00 	add	x0, x0, #0x7e7
    4000ea90:	9a811000 	csel	x0, x0, x1, ne  // ne = any
    4000ea94:	17fffff7 	b	4000ea70 <k_thread_state_str+0x2c>
		return "pending";
    4000ea98:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000ea9c:	91222c00 	add	x0, x0, #0x88b
    4000eaa0:	17fffff4 	b	4000ea70 <k_thread_state_str+0x2c>
		return "prestart";
    4000eaa4:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000eaa8:	91224c00 	add	x0, x0, #0x893
    4000eaac:	17fffff1 	b	4000ea70 <k_thread_state_str+0x2c>
		return "dead";
    4000eab0:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000eab4:	91227000 	add	x0, x0, #0x89c
    4000eab8:	17ffffee 	b	4000ea70 <k_thread_state_str+0x2c>
		return "suspended";
    4000eabc:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000eac0:	91228400 	add	x0, x0, #0x8a1
    4000eac4:	17ffffeb 	b	4000ea70 <k_thread_state_str+0x2c>
	return "unknown";
    4000eac8:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000eacc:	911f9c00 	add	x0, x0, #0x7e7
    4000ead0:	17ffffe8 	b	4000ea70 <k_thread_state_str+0x2c>
		return "";
    4000ead4:	f0000020 	adrp	x0, 40015000 <prefix.1+0x2aa>
    4000ead8:	91096400 	add	x0, x0, #0x259
    4000eadc:	17ffffe5 	b	4000ea70 <k_thread_state_str+0x2c>
		return "aborting";
    4000eae0:	90000040 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    4000eae4:	9122c400 	add	x0, x0, #0x8b1
    4000eae8:	17ffffe2 	b	4000ea70 <k_thread_state_str+0x2c>

000000004000eaec <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
    4000eaec:	14000624 	b	4001037c <z_sched_start>

000000004000eaf0 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    4000eaf0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    4000eaf4:	91003c42 	add	x2, x2, #0xf
{
    4000eaf8:	910003fd 	mov	x29, sp
    4000eafc:	a90153f3 	stp	x19, x20, [sp, #16]
    4000eb00:	aa0003f3 	mov	x19, x0
	sys_dlist_init(&w->waitq);
    4000eb04:	91030000 	add	x0, x0, #0xc0
    4000eb08:	a9025bf5 	stp	x21, x22, [sp, #32]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    4000eb0c:	927cec54 	and	x20, x2, #0xfffffffffffffff0
{
    4000eb10:	aa0103f5 	mov	x21, x1
    4000eb14:	a90363f7 	stp	x23, x24, [sp, #48]
    4000eb18:	aa0603f6 	mov	x22, x6
    4000eb1c:	aa0503f7 	mov	x23, x5
    4000eb20:	a9046bf9 	stp	x25, x26, [sp, #64]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    4000eb24:	aa1403e2 	mov	x2, x20
{
    4000eb28:	aa0403f9 	mov	x25, x4
    4000eb2c:	a90c0260 	stp	x0, x0, [x19, #192]
	stack_ptr = (char *)stack + stack_obj_size;
    4000eb30:	8b14003a 	add	x26, x1, x20
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    4000eb34:	b94063e0 	ldr	w0, [sp, #96]
	thread_base->pended_on = NULL;
    4000eb38:	f9000a7f 	str	xzr, [x19, #16]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    4000eb3c:	52801541 	mov	w1, #0xaa                  	// #170
	thread_base->user_options = (uint8_t)options;
    4000eb40:	39006260 	strb	w0, [x19, #24]
	thread_base->thread_state = (uint8_t)initial_state;
    4000eb44:	52800080 	mov	w0, #0x4                   	// #4
    4000eb48:	39006660 	strb	w0, [x19, #25]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    4000eb4c:	aa1503e0 	mov	x0, x21

	thread_base->prio = priority;
    4000eb50:	39006a67 	strb	w7, [x19, #26]

	thread_base->sched_locked = 0U;
    4000eb54:	39006e7f 	strb	wzr, [x19, #27]
	node->prev = NULL;
    4000eb58:	a902fe7f 	stp	xzr, xzr, [x19, #40]
{
    4000eb5c:	f9002bfb 	str	x27, [sp, #80]
    4000eb60:	aa0303fb 	mov	x27, x3
    4000eb64:	f94037f8 	ldr	x24, [sp, #104]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    4000eb68:	97fff9f3 	bl	4000d334 <memset>
	new_thread->stack_info.size = stack_buf_size;
    4000eb6c:	a912d275 	stp	x21, x20, [x19, #296]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    4000eb70:	aa1603e6 	mov	x6, x22
    4000eb74:	aa1703e5 	mov	x5, x23
	new_thread->stack_info.delta = delta;
    4000eb78:	f9009e7f 	str	xzr, [x19, #312]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    4000eb7c:	aa1903e4 	mov	x4, x25
    4000eb80:	aa1b03e3 	mov	x3, x27
    4000eb84:	aa1a03e2 	mov	x2, x26
    4000eb88:	aa1503e1 	mov	x1, x21
    4000eb8c:	aa1303e0 	mov	x0, x19
    4000eb90:	97fff5bb 	bl	4000c27c <arch_new_thread>
	new_thread->init_data = NULL;
    4000eb94:	f9005e7f 	str	xzr, [x19, #184]
	new_thread->entry.parameter1 = p1;
    4000eb98:	a90de67b 	stp	x27, x25, [x19, #216]
	new_thread->entry.parameter3 = p3;
    4000eb9c:	a90eda77 	stp	x23, x22, [x19, #232]
    4000eba0:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000eba4:	d50342df 	msr	daifset, #0x2
	new_thread->next_thread = _kernel.threads;
    4000eba8:	f0000094 	adrp	x20, 40021000 <k_sys_work_q+0x200>
    4000ebac:	911d8294 	add	x20, x20, #0x760
MAKE_REG_HELPER(daif)
    4000ebb0:	92407c00 	and	x0, x0, #0xffffffff
    4000ebb4:	f9402e81 	ldr	x1, [x20, #88]
	_kernel.threads = new_thread;
    4000ebb8:	f9002e93 	str	x19, [x20, #88]
	new_thread->next_thread = _kernel.threads;
    4000ebbc:	f9007e61 	str	x1, [x19, #248]
    4000ebc0:	d51b4220 	msr	daif, x0
	if (name != NULL) {
    4000ebc4:	b4000238 	cbz	x24, 4000ec08 <z_setup_new_thread+0x118>
		strncpy(new_thread->name, name,
    4000ebc8:	aa1803e1 	mov	x1, x24
    4000ebcc:	91040260 	add	x0, x19, #0x100
    4000ebd0:	d28003e2 	mov	x2, #0x1f                  	// #31
    4000ebd4:	97fff973 	bl	4000d1a0 <strncpy>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    4000ebd8:	39047e7f 	strb	wzr, [x19, #287]
	new_thread->resource_pool = _current->resource_pool;
    4000ebdc:	f9400a80 	ldr	x0, [x20, #16]
}
    4000ebe0:	a9425bf5 	ldp	x21, x22, [sp, #32]
	new_thread->resource_pool = _current->resource_pool;
    4000ebe4:	f940a800 	ldr	x0, [x0, #336]
}
    4000ebe8:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000ebec:	f9402bfb 	ldr	x27, [sp, #80]
	new_thread->resource_pool = _current->resource_pool;
    4000ebf0:	f900aa60 	str	x0, [x19, #336]
}
    4000ebf4:	aa1a03e0 	mov	x0, x26
    4000ebf8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ebfc:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000ec00:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000ec04:	d65f03c0 	ret
		new_thread->name[0] = '\0';
    4000ec08:	3904027f 	strb	wzr, [x19, #256]
    4000ec0c:	17fffff4 	b	4000ebdc <z_setup_new_thread+0xec>

000000004000ec10 <z_impl_k_thread_create>:
{
    4000ec10:	d100c3ff 	sub	sp, sp, #0x30
    4000ec14:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000ec18:	910043fd 	add	x29, sp, #0x10
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    4000ec1c:	b94033e8 	ldr	w8, [sp, #48]
    4000ec20:	b90003e8 	str	w8, [sp]
    4000ec24:	f90007ff 	str	xzr, [sp, #8]
{
    4000ec28:	a90253f3 	stp	x19, x20, [sp, #32]
    4000ec2c:	aa0003f3 	mov	x19, x0
    4000ec30:	f9401ff4 	ldr	x20, [sp, #56]
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    4000ec34:	97ffffaf 	bl	4000eaf0 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    4000ec38:	b100069f 	cmn	x20, #0x1
    4000ec3c:	54000080 	b.eq	4000ec4c <z_impl_k_thread_create+0x3c>  // b.none
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    4000ec40:	b5000114 	cbnz	x20, 4000ec60 <z_impl_k_thread_create+0x50>
	z_sched_start(thread);
    4000ec44:	aa1303e0 	mov	x0, x19
    4000ec48:	940005cd 	bl	4001037c <z_sched_start>
}
    4000ec4c:	aa1303e0 	mov	x0, x19
    4000ec50:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000ec54:	a94253f3 	ldp	x19, x20, [sp, #32]
    4000ec58:	9100c3ff 	add	sp, sp, #0x30
    4000ec5c:	d65f03c0 	ret

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    4000ec60:	aa1403e2 	mov	x2, x20
    4000ec64:	9100a260 	add	x0, x19, #0x28
    4000ec68:	b0000001 	adrp	x1, 4000f000 <z_impl_k_msgq_get+0xdc>
    4000ec6c:	912fc021 	add	x1, x1, #0xbf0
    4000ec70:	940006df 	bl	400107ec <z_add_timeout>
    4000ec74:	17fffff6 	b	4000ec4c <z_impl_k_thread_create+0x3c>

000000004000ec78 <z_init_static_threads>:
{
    4000ec78:	d10103ff 	sub	sp, sp, #0x40
    4000ec7c:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000ec80:	910043fd 	add	x29, sp, #0x10
    4000ec84:	a90253f3 	stp	x19, x20, [sp, #32]
	_FOREACH_STATIC_THREAD(thread_data) {
    4000ec88:	b0000313 	adrp	x19, 4006f000 <sys_work_q_stack+0xc10>
    4000ec8c:	9133a273 	add	x19, x19, #0xce8
    4000ec90:	aa1303f4 	mov	x20, x19
{
    4000ec94:	a9035bf5 	stp	x21, x22, [sp, #48]
	_FOREACH_STATIC_THREAD(thread_data) {
    4000ec98:	b0000315 	adrp	x21, 4006f000 <sys_work_q_stack+0xc10>
    4000ec9c:	9133a2b5 	add	x21, x21, #0xce8
    4000eca0:	eb15027f 	cmp	x19, x21
    4000eca4:	540001a3 	b.cc	4000ecd8 <z_init_static_threads+0x60>  // b.lo, b.ul, b.last
	_FOREACH_STATIC_THREAD(thread_data) {
    4000eca8:	aa1403f3 	mov	x19, x20
    4000ecac:	b0000014 	adrp	x20, 4000f000 <z_impl_k_msgq_get+0xdc>
    4000ecb0:	912fc294 	add	x20, x20, #0xbf0
			return t / ((uint64_t)from_hz / to_hz);
    4000ecb4:	d2800156 	mov	x22, #0xa                   	// #10
	k_sched_lock();
    4000ecb8:	94000317 	bl	4000f914 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    4000ecbc:	eb15027f 	cmp	x19, x21
    4000ecc0:	54000283 	b.cc	4000ed10 <z_init_static_threads+0x98>  // b.lo, b.ul, b.last
}
    4000ecc4:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000ecc8:	a94253f3 	ldp	x19, x20, [sp, #32]
    4000eccc:	a9435bf5 	ldp	x21, x22, [sp, #48]
    4000ecd0:	910103ff 	add	sp, sp, #0x40
	k_sched_unlock();
    4000ecd4:	14000538 	b	400101b4 <k_sched_unlock>
		z_setup_new_thread(
    4000ecd8:	f9402a60 	ldr	x0, [x19, #80]
    4000ecdc:	f90007e0 	str	x0, [sp, #8]
    4000ece0:	b9403e60 	ldr	w0, [x19, #60]
    4000ece4:	b90003e0 	str	w0, [sp]
    4000ece8:	a9400660 	ldp	x0, x1, [x19]
    4000ecec:	a9419263 	ldp	x3, x4, [x19, #24]
    4000ecf0:	a9429a65 	ldp	x5, x6, [x19, #40]
    4000ecf4:	b9401262 	ldr	w2, [x19, #16]
    4000ecf8:	b9403a67 	ldr	w7, [x19, #56]
    4000ecfc:	97ffff7d 	bl	4000eaf0 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    4000ed00:	f9400260 	ldr	x0, [x19]
    4000ed04:	f9005c13 	str	x19, [x0, #184]
	_FOREACH_STATIC_THREAD(thread_data) {
    4000ed08:	91016273 	add	x19, x19, #0x58
    4000ed0c:	17ffffe5 	b	4000eca0 <z_init_static_threads+0x28>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    4000ed10:	b9404262 	ldr	w2, [x19, #64]
    4000ed14:	3100045f 	cmn	w2, #0x1
    4000ed18:	54000100 	b.eq	4000ed38 <z_init_static_threads+0xc0>  // b.none
					    K_MSEC(thread_data->init_delay));
    4000ed1c:	7100005f 	cmp	w2, #0x0
    4000ed20:	1a9fa042 	csel	w2, w2, wzr, ge  // ge = tcont
			schedule_new_thread(thread_data->init_thread,
    4000ed24:	f9400260 	ldr	x0, [x19]
					    K_MSEC(thread_data->init_delay));
    4000ed28:	93407c43 	sxtw	x3, w2
		t += off;
    4000ed2c:	91002462 	add	x2, x3, #0x9
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    4000ed30:	b5000083 	cbnz	x3, 4000ed40 <z_init_static_threads+0xc8>
	z_sched_start(thread);
    4000ed34:	94000592 	bl	4001037c <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    4000ed38:	91016273 	add	x19, x19, #0x58
    4000ed3c:	17ffffe0 	b	4000ecbc <z_init_static_threads+0x44>
    4000ed40:	9ad60842 	udiv	x2, x2, x22
    4000ed44:	aa1403e1 	mov	x1, x20
    4000ed48:	9100a000 	add	x0, x0, #0x28
    4000ed4c:	940006a8 	bl	400107ec <z_add_timeout>
    4000ed50:	17fffffa 	b	4000ed38 <z_init_static_threads+0xc0>

000000004000ed54 <z_impl_k_thread_stack_space_get>:

int z_impl_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
	const uint8_t *start = (uint8_t *)thread->stack_info.start;
	size_t size = thread->stack_info.size;
    4000ed54:	a9528803 	ldp	x3, x2, [x0, #296]
	size_t unused = 0;
    4000ed58:	d2800000 	mov	x0, #0x0                   	// #0
		 */
		checked_stack += 4;
		size -= 4;
	}

	for (size_t i = 0; i < size; i++) {
    4000ed5c:	eb02001f 	cmp	x0, x2
    4000ed60:	54000081 	b.ne	4000ed70 <z_impl_k_thread_stack_space_get+0x1c>  // b.any
		} else {
			break;
		}
	}

	*unused_ptr = unused;
    4000ed64:	f9000020 	str	x0, [x1]

	return 0;
}
    4000ed68:	52800000 	mov	w0, #0x0                   	// #0
    4000ed6c:	d65f03c0 	ret
		if ((checked_stack[i]) == 0xaaU) {
    4000ed70:	38606864 	ldrb	w4, [x3, x0]
    4000ed74:	7102a89f 	cmp	w4, #0xaa
    4000ed78:	54ffff61 	b.ne	4000ed64 <z_impl_k_thread_stack_space_get+0x10>  // b.any
			unused++;
    4000ed7c:	91000400 	add	x0, x0, #0x1
	for (size_t i = 0; i < size; i++) {
    4000ed80:	17fffff7 	b	4000ed5c <z_impl_k_thread_stack_space_get+0x8>

000000004000ed84 <k_thread_runtime_stats_get>:
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

int k_thread_runtime_stats_get(k_tid_t thread,
			       k_thread_runtime_stats_t *stats)
{
	if ((thread == NULL) || (stats == NULL)) {
    4000ed84:	f100001f 	cmp	x0, #0x0
    4000ed88:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
    4000ed8c:	54000180 	b.eq	4000edbc <k_thread_runtime_stats_get+0x38>  // b.none
{
    4000ed90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000ed94:	910003fd 	mov	x29, sp
    4000ed98:	f9000bf3 	str	x19, [sp, #16]
    4000ed9c:	aa0103f3 	mov	x19, x1
		return -EINVAL;
	}

	*stats = (k_thread_runtime_stats_t) {};
    4000eda0:	f900003f 	str	xzr, [x1]

#ifdef CONFIG_SCHED_THREAD_USAGE
	stats->execution_cycles = z_sched_thread_usage(thread);
    4000eda4:	9400063a 	bl	4001068c <z_sched_thread_usage>
    4000eda8:	f9000260 	str	x0, [x19]
#endif

	return 0;
    4000edac:	52800000 	mov	w0, #0x0                   	// #0
}
    4000edb0:	f9400bf3 	ldr	x19, [sp, #16]
    4000edb4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000edb8:	d65f03c0 	ret
		return -EINVAL;
    4000edbc:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
    4000edc0:	d65f03c0 	ret

000000004000edc4 <k_thread_runtime_stats_all_get>:

int k_thread_runtime_stats_all_get(k_thread_runtime_stats_t *stats)
{
	if (stats == NULL) {
    4000edc4:	b4000100 	cbz	x0, 4000ede4 <k_thread_runtime_stats_all_get+0x20>
	}

	*stats = (k_thread_runtime_stats_t) {};

#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	stats->execution_cycles = (_kernel.all_thread_usage
    4000edc8:	f0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000edcc:	911d8021 	add	x1, x1, #0x760
				   + _kernel.idle_thread_usage);
    4000edd0:	a9460422 	ldp	x2, x1, [x1, #96]
    4000edd4:	8b010041 	add	x1, x2, x1
	stats->execution_cycles = (_kernel.all_thread_usage
    4000edd8:	f9000001 	str	x1, [x0]
#endif

	return 0;
    4000eddc:	52800000 	mov	w0, #0x0                   	// #0
}
    4000ede0:	d65f03c0 	ret
		return -EINVAL;
    4000ede4:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4000ede8:	17fffffe 	b	4000ede0 <k_thread_runtime_stats_all_get+0x1c>

000000004000edec <sys_kernel_version_get>:
 * @return kernel version
 */
uint32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
    4000edec:	528c6000 	mov	w0, #0x6300                	// #25344
    4000edf0:	72a040e0 	movk	w0, #0x207, lsl #16
    4000edf4:	d65f03c0 	ret

000000004000edf8 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    4000edf8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000edfc:	910003fd 	mov	x29, sp
    4000ee00:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ee04:	d50342df 	msr	daifset, #0x2
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    4000ee08:	97fff310 	bl	4000ba48 <arch_cpu_idle>
    4000ee0c:	17fffffd 	b	4000ee00 <idle+0x8>

000000004000ee10 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
    4000ee10:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000ee14:	aa0203e3 	mov	x3, x2
    4000ee18:	910003fd 	mov	x29, sp
    4000ee1c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ee20:	aa0003f3 	mov	x19, x0
    4000ee24:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000ee28:	aa0103f6 	mov	x22, x1
    4000ee2c:	f9001bf7 	str	x23, [sp, #48]

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
    4000ee30:	91004017 	add	x23, x0, #0x10
MAKE_REG_HELPER(daif)
    4000ee34:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ee38:	d50342df 	msr	daifset, #0x2

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
    4000ee3c:	b9401801 	ldr	w1, [x0, #24]
    4000ee40:	b9404002 	ldr	w2, [x0, #64]
    4000ee44:	6b01005f 	cmp	w2, w1
    4000ee48:	54000522 	b.cs	4000eeec <z_impl_k_msgq_put+0xdc>  // b.hs, b.nlast
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    4000ee4c:	9400041d 	bl	4000fec0 <z_unpend_first_thread>
    4000ee50:	aa0003f4 	mov	x20, x0
		if (pending_thread != NULL) {
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, 0);

			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
    4000ee54:	aa1603e1 	mov	x1, x22
    4000ee58:	f9400a62 	ldr	x2, [x19, #16]
		if (pending_thread != NULL) {
    4000ee5c:	b40001e0 	cbz	x0, 4000ee98 <z_impl_k_msgq_put+0x88>
			(void)memcpy(pending_thread->base.swap_data, data,
    4000ee60:	f9401000 	ldr	x0, [x0, #32]
    4000ee64:	97fff92c 	bl	4000d314 <memcpy>
    4000ee68:	b901429f 	str	wzr, [x20, #320]
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
    4000ee6c:	aa1403e0 	mov	x0, x20
    4000ee70:	94000355 	bl	4000fbc4 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    4000ee74:	aa1703e0 	mov	x0, x23
    4000ee78:	2a1503e1 	mov	w1, w21
    4000ee7c:	94000531 	bl	40010340 <z_reschedule>
			return 0;
    4000ee80:	52800000 	mov	w0, #0x0                   	// #0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    4000ee84:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ee88:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000ee8c:	f9401bf7 	ldr	x23, [sp, #48]
    4000ee90:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000ee94:	d65f03c0 	ret
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
    4000ee98:	f9401e60 	ldr	x0, [x19, #56]
    4000ee9c:	97fff91e 	bl	4000d314 <memcpy>
			msgq->write_ptr += msgq->msg_size;
    4000eea0:	f9400a61 	ldr	x1, [x19, #16]
    4000eea4:	f9401e60 	ldr	x0, [x19, #56]
    4000eea8:	8b010000 	add	x0, x0, x1
    4000eeac:	f9001e60 	str	x0, [x19, #56]
			if (msgq->write_ptr == msgq->buffer_end) {
    4000eeb0:	f9401661 	ldr	x1, [x19, #40]
    4000eeb4:	eb01001f 	cmp	x0, x1
    4000eeb8:	54000061 	b.ne	4000eec4 <z_impl_k_msgq_put+0xb4>  // b.any
				msgq->write_ptr = msgq->buffer_start;
    4000eebc:	f9401260 	ldr	x0, [x19, #32]
    4000eec0:	f9001e60 	str	x0, [x19, #56]
			msgq->used_msgs++;
    4000eec4:	b9404260 	ldr	w0, [x19, #64]
	z_handle_obj_poll_events(&msgq->poll_events, state);
    4000eec8:	52800201 	mov	w1, #0x10                  	// #16
			msgq->used_msgs++;
    4000eecc:	11000400 	add	w0, w0, #0x1
    4000eed0:	b9004260 	str	w0, [x19, #64]
	z_handle_obj_poll_events(&msgq->poll_events, state);
    4000eed4:	91012260 	add	x0, x19, #0x48
    4000eed8:	940009a5 	bl	4001156c <z_handle_obj_poll_events>
		result = 0;
    4000eedc:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    4000eee0:	92407eb5 	and	x21, x21, #0xffffffff
    4000eee4:	d51b4235 	msr	daif, x21
	return result;
    4000eee8:	17ffffe7 	b	4000ee84 <z_impl_k_msgq_put+0x74>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    4000eeec:	b4000183 	cbz	x3, 4000ef1c <z_impl_k_msgq_put+0x10c>
		_current->base.swap_data = (void *) data;
    4000eef0:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000eef4:	f943b800 	ldr	x0, [x0, #1904]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000eef8:	aa1303e2 	mov	x2, x19
}
    4000eefc:	a94153f3 	ldp	x19, x20, [sp, #16]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000ef00:	2a1503e1 	mov	w1, w21
		_current->base.swap_data = (void *) data;
    4000ef04:	f9001016 	str	x22, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000ef08:	aa1703e0 	mov	x0, x23
}
    4000ef0c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000ef10:	f9401bf7 	ldr	x23, [sp, #48]
    4000ef14:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000ef18:	140004ee 	b	400102d0 <z_pend_curr>
		result = -ENOMSG;
    4000ef1c:	12800440 	mov	w0, #0xffffffdd            	// #-35
    4000ef20:	17fffff0 	b	4000eee0 <z_impl_k_msgq_put+0xd0>

000000004000ef24 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
    4000ef24:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000ef28:	910003fd 	mov	x29, sp
    4000ef2c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ef30:	aa0003f3 	mov	x19, x0
    4000ef34:	aa0103e0 	mov	x0, x1
    4000ef38:	a9025bf5 	stp	x21, x22, [sp, #32]

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
    4000ef3c:	91004276 	add	x22, x19, #0x10
    4000ef40:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ef44:	d50342df 	msr	daifset, #0x2

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
    4000ef48:	b9404261 	ldr	w1, [x19, #64]
    4000ef4c:	340005e1 	cbz	w1, 4000f008 <z_impl_k_msgq_get+0xe4>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
    4000ef50:	f9400a62 	ldr	x2, [x19, #16]
    4000ef54:	f9401a61 	ldr	x1, [x19, #48]
    4000ef58:	97fff8ef 	bl	4000d314 <memcpy>
		msgq->read_ptr += msgq->msg_size;
    4000ef5c:	f9400a61 	ldr	x1, [x19, #16]
    4000ef60:	f9401a60 	ldr	x0, [x19, #48]
    4000ef64:	8b010000 	add	x0, x0, x1
    4000ef68:	f9001a60 	str	x0, [x19, #48]
		if (msgq->read_ptr == msgq->buffer_end) {
    4000ef6c:	f9401661 	ldr	x1, [x19, #40]
    4000ef70:	eb01001f 	cmp	x0, x1
    4000ef74:	54000061 	b.ne	4000ef80 <z_impl_k_msgq_get+0x5c>  // b.any
			msgq->read_ptr = msgq->buffer_start;
    4000ef78:	f9401260 	ldr	x0, [x19, #32]
    4000ef7c:	f9001a60 	str	x0, [x19, #48]
		}
		msgq->used_msgs--;
    4000ef80:	b9404260 	ldr	w0, [x19, #64]
    4000ef84:	51000400 	sub	w0, w0, #0x1
    4000ef88:	b9004260 	str	w0, [x19, #64]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    4000ef8c:	aa1303e0 	mov	x0, x19
    4000ef90:	940003cc 	bl	4000fec0 <z_unpend_first_thread>
    4000ef94:	aa0003f4 	mov	x20, x0
		if (pending_thread != NULL) {
    4000ef98:	b4000500 	cbz	x0, 4000f038 <z_impl_k_msgq_get+0x114>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
    4000ef9c:	f9400a62 	ldr	x2, [x19, #16]
    4000efa0:	f9401281 	ldr	x1, [x20, #32]
    4000efa4:	f9401e60 	ldr	x0, [x19, #56]
    4000efa8:	97fff8db 	bl	4000d314 <memcpy>
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
    4000efac:	f9400a61 	ldr	x1, [x19, #16]
    4000efb0:	f9401e60 	ldr	x0, [x19, #56]
    4000efb4:	8b010000 	add	x0, x0, x1
    4000efb8:	f9001e60 	str	x0, [x19, #56]
			if (msgq->write_ptr == msgq->buffer_end) {
    4000efbc:	f9401661 	ldr	x1, [x19, #40]
    4000efc0:	eb01001f 	cmp	x0, x1
    4000efc4:	54000061 	b.ne	4000efd0 <z_impl_k_msgq_get+0xac>  // b.any
				msgq->write_ptr = msgq->buffer_start;
    4000efc8:	f9401260 	ldr	x0, [x19, #32]
    4000efcc:	f9001e60 	str	x0, [x19, #56]
			}
			msgq->used_msgs++;
    4000efd0:	b9404260 	ldr	w0, [x19, #64]
    4000efd4:	11000400 	add	w0, w0, #0x1
    4000efd8:	b9004260 	str	w0, [x19, #64]
    4000efdc:	b901429f 	str	wzr, [x20, #320]

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
    4000efe0:	aa1403e0 	mov	x0, x20
    4000efe4:	940002f8 	bl	4000fbc4 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    4000efe8:	aa1603e0 	mov	x0, x22
    4000efec:	2a1503e1 	mov	w1, w21
    4000eff0:	940004d4 	bl	40010340 <z_reschedule>

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
    4000eff4:	52800000 	mov	w0, #0x0                   	// #0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    4000eff8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000effc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000f000:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000f004:	d65f03c0 	ret
    4000f008:	aa0203e3 	mov	x3, x2
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    4000f00c:	b40001e2 	cbz	x2, 4000f048 <z_impl_k_msgq_get+0x124>
		_current->base.swap_data = data;
    4000f010:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000f014:	f943b821 	ldr	x1, [x1, #1904]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000f018:	aa1303e2 	mov	x2, x19
}
    4000f01c:	a94153f3 	ldp	x19, x20, [sp, #16]
		_current->base.swap_data = data;
    4000f020:	f9001020 	str	x0, [x1, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000f024:	2a1503e1 	mov	w1, w21
    4000f028:	aa1603e0 	mov	x0, x22
}
    4000f02c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000f030:	a8c37bfd 	ldp	x29, x30, [sp], #48
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000f034:	140004a7 	b	400102d0 <z_pend_curr>
		result = 0;
    4000f038:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    4000f03c:	92407eb5 	and	x21, x21, #0xffffffff
    4000f040:	d51b4235 	msr	daif, x21
	return result;
    4000f044:	17ffffed 	b	4000eff8 <z_impl_k_msgq_get+0xd4>
		result = -ENOMSG;
    4000f048:	12800440 	mov	w0, #0xffffffdd            	// #-35
    4000f04c:	17fffffc 	b	4000f03c <z_impl_k_msgq_get+0x118>

000000004000f050 <z_impl_k_msgq_peek>:
}
#include <syscalls/k_msgq_get_mrsh.c>
#endif

int z_impl_k_msgq_peek(struct k_msgq *msgq, void *data)
{
    4000f050:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f054:	aa0003e3 	mov	x3, x0
    4000f058:	aa0103e0 	mov	x0, x1
    4000f05c:	910003fd 	mov	x29, sp
    4000f060:	f9000bf3 	str	x19, [sp, #16]
    4000f064:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f068:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);

	if (msgq->used_msgs > 0U) {
    4000f06c:	b9404061 	ldr	w1, [x3, #64]
    4000f070:	34000141 	cbz	w1, 4000f098 <z_impl_k_msgq_peek+0x48>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
    4000f074:	f9400862 	ldr	x2, [x3, #16]
    4000f078:	f9401861 	ldr	x1, [x3, #48]
    4000f07c:	97fff8a6 	bl	4000d314 <memcpy>
		result = 0;
    4000f080:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    4000f084:	92407e73 	and	x19, x19, #0xffffffff
    4000f088:	d51b4233 	msr	daif, x19
	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, peek, msgq, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    4000f08c:	f9400bf3 	ldr	x19, [sp, #16]
    4000f090:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f094:	d65f03c0 	ret
		result = -ENOMSG;
    4000f098:	12800440 	mov	w0, #0xffffffdd            	// #-35
    4000f09c:	17fffffa 	b	4000f084 <z_impl_k_msgq_peek+0x34>

000000004000f0a0 <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
    4000f0a0:	39c06802 	ldrsb	w2, [x0, #26]
    4000f0a4:	6b01005f 	cmp	w2, w1
    4000f0a8:	54000040 	b.eq	4000f0b0 <adjust_owner_prio.isra.0+0x10>  // b.none
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
    4000f0ac:	1400033e 	b	4000fda4 <z_set_prio>
	}
	return false;
}
    4000f0b0:	52800000 	mov	w0, #0x0                   	// #0
    4000f0b4:	d65f03c0 	ret

000000004000f0b8 <z_impl_k_mutex_init>:
	list->tail = (sys_dnode_t *)list;
    4000f0b8:	a9000000 	stp	x0, x0, [x0]
	mutex->owner = NULL;
    4000f0bc:	f900081f 	str	xzr, [x0, #16]
	mutex->lock_count = 0U;
    4000f0c0:	b900181f 	str	wzr, [x0, #24]
}
    4000f0c4:	52800000 	mov	w0, #0x0                   	// #0
    4000f0c8:	d65f03c0 	ret

000000004000f0cc <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    4000f0cc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000f0d0:	910003fd 	mov	x29, sp
    4000f0d4:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f0d8:	aa0003f3 	mov	x19, x0
    4000f0dc:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000f0e0:	f9001bf7 	str	x23, [sp, #48]
    4000f0e4:	aa0103f7 	mov	x23, x1
    4000f0e8:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f0ec:	d50342df 	msr	daifset, #0x2

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    4000f0f0:	b9401801 	ldr	w1, [x0, #24]
    4000f0f4:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    4000f0f8:	911d8042 	add	x2, x2, #0x760
    4000f0fc:	34000141 	cbz	w1, 4000f124 <z_impl_k_mutex_lock+0x58>
    4000f100:	f9400844 	ldr	x4, [x2, #16]
    4000f104:	f9400800 	ldr	x0, [x0, #16]
    4000f108:	eb04001f 	cmp	x0, x4
    4000f10c:	54000280 	b.eq	4000f15c <z_impl_k_mutex_lock+0x90>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    4000f110:	b50002b7 	cbnz	x23, 4000f164 <z_impl_k_mutex_lock+0x98>
MAKE_REG_HELPER(daif)
    4000f114:	92407e94 	and	x20, x20, #0xffffffff
    4000f118:	d51b4234 	msr	daif, x20
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
    4000f11c:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    4000f120:	1400000a 	b	4000f148 <z_impl_k_mutex_lock+0x7c>
					_current->base.prio :
    4000f124:	f9400840 	ldr	x0, [x2, #16]
    4000f128:	39c06800 	ldrsb	w0, [x0, #26]
		mutex->lock_count++;
    4000f12c:	11000421 	add	w1, w1, #0x1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    4000f130:	29030261 	stp	w1, w0, [x19, #24]
		mutex->owner = _current;
    4000f134:	f9400840 	ldr	x0, [x2, #16]
    4000f138:	92407e94 	and	x20, x20, #0xffffffff
    4000f13c:	f9000a60 	str	x0, [x19, #16]
    4000f140:	d51b4234 	msr	daif, x20
		return 0;
    4000f144:	52800000 	mov	w0, #0x0                   	// #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
    4000f148:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f14c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000f150:	f9401bf7 	ldr	x23, [sp, #48]
    4000f154:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000f158:	d65f03c0 	ret
					_current->base.prio :
    4000f15c:	b9401e60 	ldr	w0, [x19, #28]
    4000f160:	17fffff3 	b	4000f12c <z_impl_k_mutex_lock+0x60>
	new_prio = new_prio_for_inheritance(_current->base.prio,
    4000f164:	39c06803 	ldrsb	w3, [x0, #26]
    4000f168:	39c06882 	ldrsb	w2, [x4, #26]
    4000f16c:	6b03005f 	cmp	w2, w3
    4000f170:	1a83d041 	csel	w1, w2, w3, le
    4000f174:	12800fc2 	mov	w2, #0xffffff81            	// #-127
    4000f178:	3101fc3f 	cmn	w1, #0x7f
    4000f17c:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    4000f180:	6b01007f 	cmp	w3, w1
    4000f184:	5400044d 	b.le	4000f20c <z_impl_k_mutex_lock+0x140>
		resched = adjust_owner_prio(mutex, new_prio);
    4000f188:	97ffffc6 	bl	4000f0a0 <adjust_owner_prio.isra.0>
    4000f18c:	12001c16 	and	w22, w0, #0xff
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    4000f190:	d0000095 	adrp	x21, 40021000 <k_sys_work_q+0x200>
    4000f194:	912fb2b5 	add	x21, x21, #0xbec
    4000f198:	aa1703e3 	mov	x3, x23
    4000f19c:	aa1303e2 	mov	x2, x19
    4000f1a0:	2a1403e1 	mov	w1, w20
    4000f1a4:	aa1503e0 	mov	x0, x21
    4000f1a8:	9400044a 	bl	400102d0 <z_pend_curr>
	if (got_mutex == 0) {
    4000f1ac:	34fffce0 	cbz	w0, 4000f148 <z_impl_k_mutex_lock+0x7c>
    4000f1b0:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f1b4:	d50342df 	msr	daifset, #0x2
	return list->head == list;
    4000f1b8:	f9400260 	ldr	x0, [x19]
    4000f1bc:	b9401e61 	ldr	w1, [x19, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000f1c0:	eb00027f 	cmp	x19, x0
    4000f1c4:	54000100 	b.eq	4000f1e4 <z_impl_k_mutex_lock+0x118>  // b.none
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    4000f1c8:	b40000e0 	cbz	x0, 4000f1e4 <z_impl_k_mutex_lock+0x118>
    4000f1cc:	39c06800 	ldrsb	w0, [x0, #26]
    4000f1d0:	6b01001f 	cmp	w0, w1
    4000f1d4:	1a81d001 	csel	w1, w0, w1, le
    4000f1d8:	12800fc0 	mov	w0, #0xffffff81            	// #-127
    4000f1dc:	3101fc3f 	cmn	w1, #0x7f
    4000f1e0:	1a80a021 	csel	w1, w1, w0, ge  // ge = tcont
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    4000f1e4:	f9400a60 	ldr	x0, [x19, #16]
    4000f1e8:	97ffffae 	bl	4000f0a0 <adjust_owner_prio.isra.0>
    4000f1ec:	72001c1f 	tst	w0, #0xff
    4000f1f0:	54000041 	b.ne	4000f1f8 <z_impl_k_mutex_lock+0x12c>  // b.any
	if (resched) {
    4000f1f4:	34000116 	cbz	w22, 4000f214 <z_impl_k_mutex_lock+0x148>
		z_reschedule(&lock, key);
    4000f1f8:	2a1403e1 	mov	w1, w20
    4000f1fc:	aa1503e0 	mov	x0, x21
    4000f200:	94000450 	bl	40010340 <z_reschedule>
	return -EAGAIN;
    4000f204:	12800140 	mov	w0, #0xfffffff5            	// #-11
    4000f208:	17ffffd0 	b	4000f148 <z_impl_k_mutex_lock+0x7c>
	bool resched = false;
    4000f20c:	52800016 	mov	w22, #0x0                   	// #0
    4000f210:	17ffffe0 	b	4000f190 <z_impl_k_mutex_lock+0xc4>
MAKE_REG_HELPER(daif)
    4000f214:	92407e94 	and	x20, x20, #0xffffffff
    4000f218:	d51b4234 	msr	daif, x20
    4000f21c:	17fffffa 	b	4000f204 <z_impl_k_mutex_lock+0x138>

000000004000f220 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    4000f220:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f224:	910003fd 	mov	x29, sp
    4000f228:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f22c:	aa0003f3 	mov	x19, x0

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
    4000f230:	f9400800 	ldr	x0, [x0, #16]
    4000f234:	b4000500 	cbz	x0, 4000f2d4 <z_impl_k_mutex_unlock+0xb4>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    4000f238:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000f23c:	f943b821 	ldr	x1, [x1, #1904]
    4000f240:	eb01001f 	cmp	x0, x1
    4000f244:	540004c1 	b.ne	4000f2dc <z_impl_k_mutex_unlock+0xbc>  // b.any
	--_current->base.sched_locked;
    4000f248:	39406c01 	ldrb	w1, [x0, #27]
    4000f24c:	51000421 	sub	w1, w1, #0x1
    4000f250:	39006c01 	strb	w1, [x0, #27]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
    4000f254:	b9401a60 	ldr	w0, [x19, #24]
    4000f258:	7100041f 	cmp	w0, #0x1
    4000f25c:	54000109 	b.ls	4000f27c <z_impl_k_mutex_unlock+0x5c>  // b.plast
		mutex->lock_count--;
    4000f260:	51000400 	sub	w0, w0, #0x1
    4000f264:	b9001a60 	str	w0, [x19, #24]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
    4000f268:	940003d3 	bl	400101b4 <k_sched_unlock>

	return 0;
    4000f26c:	52800000 	mov	w0, #0x0                   	// #0
}
    4000f270:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f274:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f278:	d65f03c0 	ret
    4000f27c:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f280:	d50342df 	msr	daifset, #0x2
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    4000f284:	b9401e61 	ldr	w1, [x19, #28]
    4000f288:	f9400a60 	ldr	x0, [x19, #16]
    4000f28c:	97ffff85 	bl	4000f0a0 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    4000f290:	aa1303e0 	mov	x0, x19
    4000f294:	9400030b 	bl	4000fec0 <z_unpend_first_thread>
	mutex->owner = new_owner;
    4000f298:	f9000a60 	str	x0, [x19, #16]
	if (new_owner != NULL) {
    4000f29c:	b4000140 	cbz	x0, 4000f2c4 <z_impl_k_mutex_unlock+0xa4>
		mutex->owner_orig_prio = new_owner->base.prio;
    4000f2a0:	39c06801 	ldrsb	w1, [x0, #26]
    4000f2a4:	b9001e61 	str	w1, [x19, #28]
    4000f2a8:	b901401f 	str	wzr, [x0, #320]
		z_ready_thread(new_owner);
    4000f2ac:	94000246 	bl	4000fbc4 <z_ready_thread>
		z_reschedule(&lock, key);
    4000f2b0:	2a1403e1 	mov	w1, w20
    4000f2b4:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000f2b8:	912fb000 	add	x0, x0, #0xbec
    4000f2bc:	94000421 	bl	40010340 <z_reschedule>
    4000f2c0:	17ffffea 	b	4000f268 <z_impl_k_mutex_unlock+0x48>
MAKE_REG_HELPER(daif)
    4000f2c4:	92407e94 	and	x20, x20, #0xffffffff
		mutex->lock_count = 0U;
    4000f2c8:	b9001a7f 	str	wzr, [x19, #24]
    4000f2cc:	d51b4234 	msr	daif, x20
    4000f2d0:	17ffffe6 	b	4000f268 <z_impl_k_mutex_unlock+0x48>
		return -EINVAL;
    4000f2d4:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4000f2d8:	17ffffe6 	b	4000f270 <z_impl_k_mutex_unlock+0x50>
		return -EPERM;
    4000f2dc:	12800000 	mov	w0, #0xffffffff            	// #-1
    4000f2e0:	17ffffe4 	b	4000f270 <z_impl_k_mutex_unlock+0x50>

000000004000f2e4 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    4000f2e4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f2e8:	910003fd 	mov	x29, sp
    4000f2ec:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f2f0:	aa0003f3 	mov	x19, x0
    4000f2f4:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f2f8:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    4000f2fc:	940002f1 	bl	4000fec0 <z_unpend_first_thread>

	if (thread != NULL) {
    4000f300:	b4000120 	cbz	x0, 4000f324 <z_impl_k_sem_give+0x40>
    4000f304:	b901401f 	str	wzr, [x0, #320]
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    4000f308:	9400022f 	bl	4000fbc4 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    4000f30c:	2a1403e1 	mov	w1, w20
    4000f310:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000f314:	912fb000 	add	x0, x0, #0xbec

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    4000f318:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f31c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule(&lock, key);
    4000f320:	14000408 	b	40010340 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    4000f324:	29420660 	ldp	w0, w1, [x19, #16]
    4000f328:	6b00003f 	cmp	w1, w0
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    4000f32c:	52800041 	mov	w1, #0x2                   	// #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    4000f330:	1a800400 	cinc	w0, w0, ne  // ne = any
    4000f334:	b9001260 	str	w0, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    4000f338:	91006260 	add	x0, x19, #0x18
    4000f33c:	9400088c 	bl	4001156c <z_handle_obj_poll_events>
}
    4000f340:	17fffff3 	b	4000f30c <z_impl_k_sem_give+0x28>

000000004000f344 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    4000f344:	aa0003e2 	mov	x2, x0
    4000f348:	aa0103e3 	mov	x3, x1
MAKE_REG_HELPER(daif)
    4000f34c:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f350:	d50342df 	msr	daifset, #0x2

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    4000f354:	b9401000 	ldr	w0, [x0, #16]
    4000f358:	340000e0 	cbz	w0, 4000f374 <z_impl_k_sem_take+0x30>
		sem->count--;
    4000f35c:	51000400 	sub	w0, w0, #0x1
MAKE_REG_HELPER(daif)
    4000f360:	92407c21 	and	x1, x1, #0xffffffff
    4000f364:	b9001040 	str	w0, [x2, #16]
    4000f368:	d51b4221 	msr	daif, x1
		k_spin_unlock(&lock, key);
		ret = 0;
    4000f36c:	52800000 	mov	w0, #0x0                   	// #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    4000f370:	d65f03c0 	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    4000f374:	b50000a3 	cbnz	x3, 4000f388 <z_impl_k_sem_take+0x44>
    4000f378:	92407c21 	and	x1, x1, #0xffffffff
    4000f37c:	d51b4221 	msr	daif, x1
		ret = -EBUSY;
    4000f380:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    4000f384:	17fffffb 	b	4000f370 <z_impl_k_sem_take+0x2c>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    4000f388:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000f38c:	912fb000 	add	x0, x0, #0xbec
    4000f390:	140003d0 	b	400102d0 <z_pend_curr>

000000004000f394 <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
    4000f394:	b9400002 	ldr	w2, [x0]
	*flagp &= ~BIT(bit);
    4000f398:	d2800023 	mov	x3, #0x1                   	// #1
    4000f39c:	9ac12063 	lsl	x3, x3, x1
    4000f3a0:	0a230043 	bic	w3, w2, w3
	return (*flagp & BIT(bit)) != 0U;
    4000f3a4:	2a0203e2 	mov	w2, w2
	*flagp &= ~BIT(bit);
    4000f3a8:	b9000003 	str	w3, [x0]
	return (*flagp & BIT(bit)) != 0U;
    4000f3ac:	9ac12440 	lsr	x0, x2, x1
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
    4000f3b0:	12000000 	and	w0, w0, #0x1
    4000f3b4:	d65f03c0 	ret

000000004000f3b8 <notify_queue_locked.isra.0>:
 */
static inline bool notify_queue_locked(struct k_work_q *queue)
{
	bool rv = false;

	if (queue != NULL) {
    4000f3b8:	b40000a0 	cbz	x0, 4000f3cc <notify_queue_locked.isra.0+0x14>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
    4000f3bc:	910e4000 	add	x0, x0, #0x390
    4000f3c0:	d2800002 	mov	x2, #0x0                   	// #0
    4000f3c4:	52800001 	mov	w1, #0x0                   	// #0
    4000f3c8:	140002e6 	b	4000ff60 <z_sched_wake>
	}

	return rv;
}
    4000f3cc:	d65f03c0 	ret

000000004000f3d0 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
    4000f3d0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000f3d4:	910003fd 	mov	x29, sp
    4000f3d8:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f3dc:	aa0003f4 	mov	x20, x0
    4000f3e0:	a9025bf5 	stp	x21, x22, [sp, #32]
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
    4000f3e4:	d0000095 	adrp	x21, 40021000 <k_sys_work_q+0x200>
    4000f3e8:	911f42b5 	add	x21, x21, #0x7d0
			 * the lock, and we didn't find work nor got asked to
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
    4000f3ec:	d0000096 	adrp	x22, 40021000 <k_sys_work_q+0x200>
    4000f3f0:	912fb2d6 	add	x22, x22, #0xbec
{
    4000f3f4:	a90363f7 	stp	x23, x24, [sp, #48]
    4000f3f8:	f90023f9 	str	x25, [sp, #64]
    4000f3fc:	d53b4237 	mrs	x23, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f400:	d50342df 	msr	daifset, #0x2
    4000f404:	f941c293 	ldr	x19, [x20, #896]
    4000f408:	91100280 	add	x0, x20, #0x400
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    4000f40c:	b50001b3 	cbnz	x19, 4000f440 <work_queue_main+0x70>
		} else if (flag_test_and_clear(&queue->flags,
    4000f410:	910ec280 	add	x0, x20, #0x3b0
    4000f414:	52800041 	mov	w1, #0x2                   	// #2
    4000f418:	97ffffdf 	bl	4000f394 <flag_test_and_clear>
    4000f41c:	72001c1f 	tst	w0, #0xff
    4000f420:	54000421 	b.ne	4000f4a4 <work_queue_main+0xd4>  // b.any
			(void)z_sched_wait(&lock, key, &queue->notifyq,
    4000f424:	910e4282 	add	x2, x20, #0x390
    4000f428:	2a1703e1 	mov	w1, w23
    4000f42c:	aa1603e0 	mov	x0, x22
    4000f430:	d2800004 	mov	x4, #0x0                   	// #0
    4000f434:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    4000f438:	940003b5 	bl	4001030c <z_sched_wait>
					   K_FOREVER, NULL);
			continue;
    4000f43c:	17fffff0 	b	4000f3fc <work_queue_main+0x2c>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    4000f440:	f8588002 	ldur	x2, [x0, #-120]
	return node->next;
    4000f444:	f9400261 	ldr	x1, [x19]
	list->head = node;
    4000f448:	f8180001 	stur	x1, [x0, #-128]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    4000f44c:	eb02027f 	cmp	x19, x2
    4000f450:	54000041 	b.ne	4000f458 <work_queue_main+0x88>  // b.any
	list->tail = node;
    4000f454:	f8188001 	stur	x1, [x0, #-120]
	*flagp |= BIT(bit);
    4000f458:	b943b280 	ldr	w0, [x20, #944]
MAKE_REG_HELPER(daif)
    4000f45c:	92407ef7 	and	x23, x23, #0xffffffff
			handler = work->handler;
    4000f460:	f9400661 	ldr	x1, [x19, #8]
	*flagp |= BIT(bit);
    4000f464:	321f0000 	orr	w0, w0, #0x2
    4000f468:	b903b280 	str	w0, [x20, #944]
	*flagp &= ~BIT(bit);
    4000f46c:	b9401a62 	ldr	w2, [x19, #24]
    4000f470:	121d7842 	and	w2, w2, #0xfffffffb
    4000f474:	32000042 	orr	w2, w2, #0x1
    4000f478:	b9001a62 	str	w2, [x19, #24]
    4000f47c:	d51b4237 	msr	daif, x23

		if (work != NULL) {
			bool yield;

			__ASSERT_NO_MSG(handler != NULL);
			handler(work);
    4000f480:	aa1303e0 	mov	x0, x19
    4000f484:	d63f0020 	blr	x1
    4000f488:	d53b4239 	mrs	x25, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f48c:	d50342df 	msr	daifset, #0x2
	*flagp &= ~BIT(bit);
    4000f490:	b9401a61 	ldr	w1, [x19, #24]
    4000f494:	121f7820 	and	w0, w1, #0xfffffffe
			 * starving other threads.
			 */
			key = k_spin_lock(&lock);

			flag_clear(&work->flags, K_WORK_RUNNING_BIT);
			if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    4000f498:	37080161 	tbnz	w1, #1, 4000f4c4 <work_queue_main+0xf4>
	*flagp &= ~BIT(bit);
    4000f49c:	b9001a60 	str	w0, [x19, #24]
    4000f4a0:	1400000d 	b	4000f4d4 <work_queue_main+0x104>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
    4000f4a4:	910e8293 	add	x19, x20, #0x3a0
	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
    4000f4a8:	aa1303e0 	mov	x0, x19
    4000f4ac:	d2800002 	mov	x2, #0x0                   	// #0
    4000f4b0:	52800021 	mov	w1, #0x1                   	// #1
    4000f4b4:	940002ab 	bl	4000ff60 <z_sched_wake>
    4000f4b8:	72001c1f 	tst	w0, #0xff
    4000f4bc:	54ffff61 	b.ne	4000f4a8 <work_queue_main+0xd8>  // b.any
    4000f4c0:	17ffffd9 	b	4000f424 <work_queue_main+0x54>
	return list->head;
    4000f4c4:	f94002a0 	ldr	x0, [x21]
	*flagp &= ~BIT(bit);
    4000f4c8:	121e7421 	and	w1, w1, #0xfffffffc
    4000f4cc:	b9001a61 	str	w1, [x19, #24]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    4000f4d0:	b5000120 	cbnz	x0, 4000f4f4 <work_queue_main+0x124>
	*flagp &= ~BIT(bit);
    4000f4d4:	b943b280 	ldr	w0, [x20, #944]
MAKE_REG_HELPER(daif)
    4000f4d8:	92407f39 	and	x25, x25, #0xffffffff
    4000f4dc:	121e7800 	and	w0, w0, #0xfffffffd
    4000f4e0:	b903b280 	str	w0, [x20, #944]
    4000f4e4:	d51b4239 	msr	daif, x25
			k_spin_unlock(&lock, key);

			/* Optionally yield to prevent the work queue from
			 * starving other threads.
			 */
			if (yield) {
    4000f4e8:	3747f8a0 	tbnz	w0, #8, 4000f3fc <work_queue_main+0x2c>
	z_impl_k_yield();
    4000f4ec:	940003b9 	bl	400103d0 <z_impl_k_yield>
}
    4000f4f0:	17ffffc3 	b	4000f3fc <work_queue_main+0x2c>
	return node->next;
    4000f4f4:	f9400018 	ldr	x24, [x0]
    4000f4f8:	d2800017 	mov	x23, #0x0                   	// #0
		if (wc->work == work) {
    4000f4fc:	f9400402 	ldr	x2, [x0, #8]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
    4000f500:	aa0003e1 	mov	x1, x0
		if (wc->work == work) {
    4000f504:	eb02027f 	cmp	x19, x2
    4000f508:	54000161 	b.ne	4000f534 <work_queue_main+0x164>  // b.any
    4000f50c:	f9400001 	ldr	x1, [x0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
    4000f510:	b50001d7 	cbnz	x23, 4000f548 <work_queue_main+0x178>
    4000f514:	f94006a2 	ldr	x2, [x21, #8]
	list->head = node;
    4000f518:	f90002a1 	str	x1, [x21]
Z_GENLIST_REMOVE(slist, snode)
    4000f51c:	eb02001f 	cmp	x0, x2
    4000f520:	54000041 	b.ne	4000f528 <work_queue_main+0x158>  // b.any
	list->tail = node;
    4000f524:	f90006a1 	str	x1, [x21, #8]
	parent->next = child;
    4000f528:	f801041f 	str	xzr, [x0], #16
	z_impl_k_sem_give(sem);
    4000f52c:	97ffff6e 	bl	4000f2e4 <z_impl_k_sem_give>
}
    4000f530:	aa1703e1 	mov	x1, x23
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    4000f534:	b4fffd18 	cbz	x24, 4000f4d4 <work_queue_main+0x104>
	return node->next;
    4000f538:	aa1803e0 	mov	x0, x24
    4000f53c:	aa0103f7 	mov	x23, x1
    4000f540:	f9400318 	ldr	x24, [x24]
    4000f544:	17ffffee 	b	4000f4fc <work_queue_main+0x12c>
	return list->tail;
    4000f548:	f94006a2 	ldr	x2, [x21, #8]
	parent->next = child;
    4000f54c:	f90002e1 	str	x1, [x23]
Z_GENLIST_REMOVE(slist, snode)
    4000f550:	eb00005f 	cmp	x2, x0
    4000f554:	54fffea1 	b.ne	4000f528 <work_queue_main+0x158>  // b.any
	list->tail = node;
    4000f558:	f90006b7 	str	x23, [x21, #8]
}
    4000f55c:	17fffff3 	b	4000f528 <work_queue_main+0x158>

000000004000f560 <submit_to_queue_locked>:
{
    4000f560:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000f564:	910003fd 	mov	x29, sp
    4000f568:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f56c:	aa0003f3 	mov	x19, x0
	return (*flagp & BIT(bit)) != 0U;
    4000f570:	b9401800 	ldr	w0, [x0, #24]
{
    4000f574:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000f578:	aa0103f4 	mov	x20, x1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    4000f57c:	37080700 	tbnz	w0, #1, 4000f65c <submit_to_queue_locked+0xfc>
    4000f580:	2a0003e1 	mov	w1, w0
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
    4000f584:	721e003f 	tst	w1, #0x4
    4000f588:	54000701 	b.ne	4000f668 <submit_to_queue_locked+0x108>  // b.any
		if (*queuep == NULL) {
    4000f58c:	f9400281 	ldr	x1, [x20]
    4000f590:	b5000061 	cbnz	x1, 4000f59c <submit_to_queue_locked+0x3c>
			*queuep = work->queue;
    4000f594:	f9400a61 	ldr	x1, [x19, #16]
    4000f598:	f9000281 	str	x1, [x20]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
    4000f59c:	36000520 	tbz	w0, #0, 4000f640 <submit_to_queue_locked+0xe0>
			*queuep = work->queue;
    4000f5a0:	f9400a60 	ldr	x0, [x19, #16]
			ret = 2;
    4000f5a4:	52800055 	mov	w21, #0x2                   	// #2
			*queuep = work->queue;
    4000f5a8:	f9000280 	str	x0, [x20]
		int rc = queue_submit_locked(*queuep, work);
    4000f5ac:	f9400296 	ldr	x22, [x20]
	if (queue == NULL) {
    4000f5b0:	b4000616 	cbz	x22, 4000f670 <submit_to_queue_locked+0x110>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    4000f5b4:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000f5b8:	f943b800 	ldr	x0, [x0, #1904]
    4000f5bc:	eb16001f 	cmp	x0, x22
    4000f5c0:	54000441 	b.ne	4000f648 <submit_to_queue_locked+0xe8>  // b.any
    4000f5c4:	97fffcf4 	bl	4000e994 <k_is_in_isr>
    4000f5c8:	12001c00 	and	w0, w0, #0xff
    4000f5cc:	52000000 	eor	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
    4000f5d0:	b943b2c2 	ldr	w2, [x22, #944]
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    4000f5d4:	12000000 	and	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
    4000f5d8:	d3420841 	ubfx	x1, x2, #2, #1
    4000f5dc:	d3430c43 	ubfx	x3, x2, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
    4000f5e0:	360004c2 	tbz	w2, #0, 4000f678 <submit_to_queue_locked+0x118>
	} else if (draining && !chained) {
    4000f5e4:	52000000 	eor	w0, w0, #0x1
    4000f5e8:	6a00003f 	tst	w1, w0
    4000f5ec:	54000381 	b.ne	4000f65c <submit_to_queue_locked+0xfc>  // b.any
	} else if (plugged && !draining) {
    4000f5f0:	52000021 	eor	w1, w1, #0x1
    4000f5f4:	6a01007f 	tst	w3, w1
    4000f5f8:	54000321 	b.ne	4000f65c <submit_to_queue_locked+0xfc>  // b.any
	return list->tail;
    4000f5fc:	f941c6c1 	ldr	x1, [x22, #904]
	parent->next = child;
    4000f600:	f900027f 	str	xzr, [x19]
	return list->tail;
    4000f604:	911002c0 	add	x0, x22, #0x400
Z_GENLIST_APPEND(slist, snode)
    4000f608:	b5000241 	cbnz	x1, 4000f650 <submit_to_queue_locked+0xf0>
	list->tail = node;
    4000f60c:	a9384c13 	stp	x19, x19, [x0, #-128]
		(void)notify_queue_locked(queue);
    4000f610:	aa1603e0 	mov	x0, x22
    4000f614:	97ffff69 	bl	4000f3b8 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
    4000f618:	b9401a60 	ldr	w0, [x19, #24]
    4000f61c:	321e0000 	orr	w0, w0, #0x4
    4000f620:	b9001a60 	str	w0, [x19, #24]
			work->queue = *queuep;
    4000f624:	f9400280 	ldr	x0, [x20]
    4000f628:	f9000a60 	str	x0, [x19, #16]
}
    4000f62c:	2a1503e0 	mov	w0, w21
    4000f630:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f634:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000f638:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000f63c:	d65f03c0 	ret
		ret = 1;
    4000f640:	52800035 	mov	w21, #0x1                   	// #1
    4000f644:	17ffffda 	b	4000f5ac <submit_to_queue_locked+0x4c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    4000f648:	52800000 	mov	w0, #0x0                   	// #0
    4000f64c:	17ffffe1 	b	4000f5d0 <submit_to_queue_locked+0x70>
	parent->next = child;
    4000f650:	f9000033 	str	x19, [x1]
	list->tail = node;
    4000f654:	f8188013 	stur	x19, [x0, #-120]
}
    4000f658:	17ffffee 	b	4000f610 <submit_to_queue_locked+0xb0>
		ret = -EBUSY;
    4000f65c:	128001f5 	mov	w21, #0xfffffff0            	// #-16
		*queuep = NULL;
    4000f660:	f900029f 	str	xzr, [x20]
	return ret;
    4000f664:	17fffff2 	b	4000f62c <submit_to_queue_locked+0xcc>
	int ret = 0;
    4000f668:	52800015 	mov	w21, #0x0                   	// #0
    4000f66c:	17fffffd 	b	4000f660 <submit_to_queue_locked+0x100>
		return -EINVAL;
    4000f670:	128002b5 	mov	w21, #0xffffffea            	// #-22
    4000f674:	17fffffb 	b	4000f660 <submit_to_queue_locked+0x100>
		ret = -ENODEV;
    4000f678:	12800255 	mov	w21, #0xffffffed            	// #-19
    4000f67c:	17fffff9 	b	4000f660 <submit_to_queue_locked+0x100>

000000004000f680 <k_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    4000f680:	a9007c1f 	stp	xzr, xzr, [x0]
    4000f684:	f9000401 	str	x1, [x0, #8]
    4000f688:	a9017c1f 	stp	xzr, xzr, [x0, #16]
}
    4000f68c:	d65f03c0 	ret

000000004000f690 <k_work_submit_to_queue>:
{
    4000f690:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000f694:	910003fd 	mov	x29, sp
    4000f698:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f69c:	f90017e0 	str	x0, [sp, #40]
    4000f6a0:	aa0103e0 	mov	x0, x1
    4000f6a4:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f6a8:	d50342df 	msr	daifset, #0x2
	int ret = submit_to_queue_locked(work, &queue);
    4000f6ac:	9100a3e1 	add	x1, sp, #0x28
MAKE_REG_HELPER(daif)
    4000f6b0:	92407e94 	and	x20, x20, #0xffffffff
    4000f6b4:	97ffffab 	bl	4000f560 <submit_to_queue_locked>
    4000f6b8:	2a0003f3 	mov	w19, w0
    4000f6bc:	d51b4234 	msr	daif, x20
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
    4000f6c0:	7100001f 	cmp	w0, #0x0
    4000f6c4:	5400008d 	b.le	4000f6d4 <k_work_submit_to_queue+0x44>
	return z_impl_k_is_preempt_thread();
    4000f6c8:	9400021a 	bl	4000ff30 <z_impl_k_is_preempt_thread>
    4000f6cc:	34000040 	cbz	w0, 4000f6d4 <k_work_submit_to_queue+0x44>
	z_impl_k_yield();
    4000f6d0:	94000340 	bl	400103d0 <z_impl_k_yield>
}
    4000f6d4:	2a1303e0 	mov	w0, w19
    4000f6d8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f6dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000f6e0:	d65f03c0 	ret

000000004000f6e4 <k_work_submit>:
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
    4000f6e4:	aa0003e1 	mov	x1, x0
    4000f6e8:	b0000080 	adrp	x0, 40020000 <logging_thread>
    4000f6ec:	91380000 	add	x0, x0, #0xe00
    4000f6f0:	17ffffe8 	b	4000f690 <k_work_submit_to_queue>

000000004000f6f4 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
    4000f6f4:	d100c3ff 	sub	sp, sp, #0x30
    4000f6f8:	2a0303e7 	mov	w7, w3
    4000f6fc:	910e4003 	add	x3, x0, #0x390
    4000f700:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000f704:	910043fd 	add	x29, sp, #0x10
    4000f708:	a90253f3 	stp	x19, x20, [sp, #32]
    4000f70c:	aa0003f3 	mov	x19, x0
	list->tail = (sys_dnode_t *)list;
    4000f710:	910e0000 	add	x0, x0, #0x380
    4000f714:	aa0403f4 	mov	x20, x4
    4000f718:	a9007c1f 	stp	xzr, xzr, [x0]
    4000f71c:	a9010c03 	stp	x3, x3, [x0, #16]
    4000f720:	910e8263 	add	x3, x19, #0x3a0
	list->head = (sys_dnode_t *)list;
    4000f724:	f901d263 	str	x3, [x19, #928]
	list->tail = (sys_dnode_t *)list;
    4000f728:	f901d663 	str	x3, [x19, #936]

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
    4000f72c:	b4000344 	cbz	x4, 4000f794 <k_work_queue_start+0xa0>
    4000f730:	39402080 	ldrb	w0, [x4, #8]
		flags |= K_WORK_QUEUE_NO_YIELD;
    4000f734:	7100001f 	cmp	w0, #0x0
    4000f738:	52802020 	mov	w0, #0x101                 	// #257
    4000f73c:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
	*flagp = flags;
    4000f740:	b903b260 	str	w0, [x19, #944]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    4000f744:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4000f748:	b90003ff 	str	wzr, [sp]
    4000f74c:	f90007e0 	str	x0, [sp, #8]
    4000f750:	90000003 	adrp	x3, 4000f000 <z_impl_k_msgq_get+0xdc>
    4000f754:	910f4063 	add	x3, x3, #0x3d0
    4000f758:	aa1303e4 	mov	x4, x19
    4000f75c:	aa1303e0 	mov	x0, x19
    4000f760:	d2800006 	mov	x6, #0x0                   	// #0
    4000f764:	d2800005 	mov	x5, #0x0                   	// #0
    4000f768:	97fffd2a 	bl	4000ec10 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
    4000f76c:	b40000b4 	cbz	x20, 4000f780 <k_work_queue_start+0x8c>
    4000f770:	f9400281 	ldr	x1, [x20]
    4000f774:	b4000061 	cbz	x1, 4000f780 <k_work_queue_start+0x8c>
	return z_impl_k_thread_name_set(thread, str);
    4000f778:	aa1303e0 	mov	x0, x19
    4000f77c:	97fffca0 	bl	4000e9fc <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
    4000f780:	aa1303e0 	mov	x0, x19
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
    4000f784:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000f788:	a94253f3 	ldp	x19, x20, [sp, #32]
    4000f78c:	9100c3ff 	add	sp, sp, #0x30
    4000f790:	17fffcd7 	b	4000eaec <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
    4000f794:	52800020 	mov	w0, #0x1                   	// #1
    4000f798:	17ffffea 	b	4000f740 <k_work_queue_start+0x4c>

000000004000f79c <sys_dlist_remove>:
	sys_dnode_t *const prev = node->prev;
    4000f79c:	a9400801 	ldp	x1, x2, [x0]
	prev->next = next;
    4000f7a0:	f9000041 	str	x1, [x2]
	next->prev = prev;
    4000f7a4:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
    4000f7a8:	a9007c1f 	stp	xzr, xzr, [x0]
	sys_dnode_init(node);
}
    4000f7ac:	d65f03c0 	ret

000000004000f7b0 <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
    4000f7b0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000f7b4:	aa0003e3 	mov	x3, x0
    4000f7b8:	910003fd 	mov	x29, sp

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    4000f7bc:	97fffff8 	bl	4000f79c <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    4000f7c0:	39406400 	ldrb	w0, [x0, #25]
    4000f7c4:	121e7800 	and	w0, w0, #0xfffffffd
    4000f7c8:	39006460 	strb	w0, [x3, #25]
}
    4000f7cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
	thread->base.pended_on = NULL;
    4000f7d0:	f900087f 	str	xzr, [x3, #16]
}
    4000f7d4:	d65f03c0 	ret

000000004000f7d8 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
    4000f7d8:	39c06802 	ldrsb	w2, [x0, #26]
	int32_t b2 = thread_2->base.prio;
    4000f7dc:	39c06821 	ldrsb	w1, [x1, #26]
		return b2 - b1;
    4000f7e0:	4b020020 	sub	w0, w1, w2
    4000f7e4:	6b01005f 	cmp	w2, w1
}
    4000f7e8:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
    4000f7ec:	d65f03c0 	ret

000000004000f7f0 <z_reset_time_slice>:
{
    4000f7f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f7f4:	910003fd 	mov	x29, sp
    4000f7f8:	f9000bf3 	str	x19, [sp, #16]
	if (slice_time != 0) {
    4000f7fc:	d0000093 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    4000f800:	b9481660 	ldr	w0, [x19, #2068]
    4000f804:	34000160 	cbz	w0, 4000f830 <z_reset_time_slice+0x40>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    4000f808:	97fffa62 	bl	4000e190 <sys_clock_elapsed>
    4000f80c:	2a0003e1 	mov	w1, w0
    4000f810:	b9481660 	ldr	w0, [x19, #2068]
    4000f814:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
}
    4000f818:	f9400bf3 	ldr	x19, [sp, #16]
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    4000f81c:	0b010001 	add	w1, w0, w1
}
    4000f820:	a8c27bfd 	ldp	x29, x30, [sp], #32
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    4000f824:	b9078041 	str	w1, [x2, #1920]
		z_set_timeout_expiry(slice_time, false);
    4000f828:	52800001 	mov	w1, #0x0                   	// #0
    4000f82c:	14000447 	b	40010948 <z_set_timeout_expiry>
}
    4000f830:	f9400bf3 	ldr	x19, [sp, #16]
    4000f834:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f838:	d65f03c0 	ret

000000004000f83c <k_sched_time_slice_set>:
{
    4000f83c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f840:	910003fd 	mov	x29, sp
    4000f844:	f9000bf3 	str	x19, [sp, #16]
    4000f848:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f84c:	d50342df 	msr	daifset, #0x2
		_current_cpu->slice_ticks = 0;
    4000f850:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
		if (result32 && (t < BIT64(32))) {
    4000f854:	b2407fe3 	mov	x3, #0xffffffff            	// #4294967295
    4000f858:	b907805f 	str	wzr, [x2, #1920]
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
    4000f85c:	2a0003e2 	mov	w2, w0
		t += off;
    4000f860:	91002442 	add	x2, x2, #0x9
		if (result32 && (t < BIT64(32))) {
    4000f864:	eb03005f 	cmp	x2, x3
    4000f868:	54000208 	b.hi	4000f8a8 <k_sched_time_slice_set+0x6c>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    4000f86c:	11002402 	add	w2, w0, #0x9
    4000f870:	52800143 	mov	w3, #0xa                   	// #10
    4000f874:	1ac30842 	udiv	w2, w2, w3
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    4000f878:	7100001f 	cmp	w0, #0x0
    4000f87c:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000f880:	540001ac 	b.gt	4000f8b4 <k_sched_time_slice_set+0x78>
			slice_time = MAX(2, slice_time);
    4000f884:	b9081402 	str	w2, [x0, #2068]
		slice_max_prio = prio;
    4000f888:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
MAKE_REG_HELPER(daif)
    4000f88c:	92407e73 	and	x19, x19, #0xffffffff
    4000f890:	b9081001 	str	w1, [x0, #2064]
		z_reset_time_slice();
    4000f894:	97ffffd7 	bl	4000f7f0 <z_reset_time_slice>
    4000f898:	d51b4233 	msr	daif, x19
}
    4000f89c:	f9400bf3 	ldr	x19, [sp, #16]
    4000f8a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f8a4:	d65f03c0 	ret
			return t / ((uint64_t)from_hz / to_hz);
    4000f8a8:	d2800143 	mov	x3, #0xa                   	// #10
    4000f8ac:	9ac30842 	udiv	x2, x2, x3
    4000f8b0:	17fffff2 	b	4000f878 <k_sched_time_slice_set+0x3c>
			slice_time = MAX(2, slice_time);
    4000f8b4:	7100085f 	cmp	w2, #0x2
    4000f8b8:	52800043 	mov	w3, #0x2                   	// #2
    4000f8bc:	1a83a042 	csel	w2, w2, w3, ge  // ge = tcont
    4000f8c0:	17fffff1 	b	4000f884 <k_sched_time_slice_set+0x48>

000000004000f8c4 <z_unpend_thread_no_timeout>:
{
    4000f8c4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000f8c8:	910003fd 	mov	x29, sp
    4000f8cc:	d53b4224 	mrs	x4, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f8d0:	d50342df 	msr	daifset, #0x2
		unpend_thread_no_timeout(thread);
    4000f8d4:	97ffffb7 	bl	4000f7b0 <unpend_thread_no_timeout>
MAKE_REG_HELPER(daif)
    4000f8d8:	92407c84 	and	x4, x4, #0xffffffff
    4000f8dc:	d51b4224 	msr	daif, x4
}
    4000f8e0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000f8e4:	d65f03c0 	ret

000000004000f8e8 <z_unpend_thread>:
{
    4000f8e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000f8ec:	aa0003e4 	mov	x4, x0
    4000f8f0:	910003fd 	mov	x29, sp
    4000f8f4:	d53b4225 	mrs	x5, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f8f8:	d50342df 	msr	daifset, #0x2
		unpend_thread_no_timeout(thread);
    4000f8fc:	97ffffad 	bl	4000f7b0 <unpend_thread_no_timeout>
MAKE_REG_HELPER(daif)
    4000f900:	92407ca5 	and	x5, x5, #0xffffffff
    4000f904:	d51b4225 	msr	daif, x5
}
    4000f908:	a8c17bfd 	ldp	x29, x30, [sp], #16
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    4000f90c:	9100a080 	add	x0, x4, #0x28
    4000f910:	140003fe 	b	40010908 <z_abort_timeout>

000000004000f914 <k_sched_lock>:
    4000f914:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f918:	d50342df 	msr	daifset, #0x2
	--_current->base.sched_locked;
    4000f91c:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000f920:	f943b822 	ldr	x2, [x1, #1904]
    4000f924:	39406c41 	ldrb	w1, [x2, #27]
    4000f928:	51000421 	sub	w1, w1, #0x1
    4000f92c:	39006c41 	strb	w1, [x2, #27]
MAKE_REG_HELPER(daif)
    4000f930:	92407c00 	and	x0, x0, #0xffffffff
    4000f934:	d51b4220 	msr	daif, x0
}
    4000f938:	d65f03c0 	ret

000000004000f93c <z_swap_next_thread>:
}
    4000f93c:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000f940:	f943cc00 	ldr	x0, [x0, #1944]
    4000f944:	d65f03c0 	ret

000000004000f948 <z_priq_dumb_best>:
	return list->head == list;
    4000f948:	f9400001 	ldr	x1, [x0]
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *thread = NULL;
    4000f94c:	eb01001f 	cmp	x0, x1

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    4000f950:	9a9f1020 	csel	x0, x1, xzr, ne  // ne = any
    4000f954:	d65f03c0 	ret

000000004000f958 <update_cache>:
{
    4000f958:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f95c:	2a0003e2 	mov	w2, w0
	return _priq_run_best(curr_cpu_runq());
    4000f960:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000f964:	911e8000 	add	x0, x0, #0x7a0
{
    4000f968:	910003fd 	mov	x29, sp
    4000f96c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f970:	d0000093 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    4000f974:	911d8273 	add	x19, x19, #0x760
	return _priq_run_best(curr_cpu_runq());
    4000f978:	97fffff4 	bl	4000f948 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    4000f97c:	b50001c0 	cbnz	x0, 4000f9b4 <update_cache+0x5c>
    4000f980:	f9400e74 	ldr	x20, [x19, #24]
	if (z_is_thread_prevented_from_running(_current)) {
    4000f984:	f9400a61 	ldr	x1, [x19, #16]
	if (preempt_ok != 0) {
    4000f988:	350001a2 	cbnz	w2, 4000f9bc <update_cache+0x64>
	if (z_is_thread_prevented_from_running(_current)) {
    4000f98c:	39406420 	ldrb	w0, [x1, #25]
    4000f990:	f240101f 	tst	x0, #0x1f
    4000f994:	54000141 	b.ne	4000f9bc <update_cache+0x64>  // b.any
	if (is_preempt(_current) || is_metairq(thread)) {
    4000f998:	79403420 	ldrh	w0, [x1, #26]
    4000f99c:	7101fc1f 	cmp	w0, #0x7f
    4000f9a0:	540000e9 	b.ls	4000f9bc <update_cache+0x64>  // b.plast
		_kernel.ready_q.cache = _current;
    4000f9a4:	f9001e61 	str	x1, [x19, #56]
}
    4000f9a8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f9ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f9b0:	d65f03c0 	ret
    4000f9b4:	aa0003f4 	mov	x20, x0
    4000f9b8:	17fffff3 	b	4000f984 <update_cache+0x2c>
		if (thread != _current) {
    4000f9bc:	eb01029f 	cmp	x20, x1
    4000f9c0:	54000040 	b.eq	4000f9c8 <update_cache+0x70>  // b.none
			z_reset_time_slice();
    4000f9c4:	97ffff8b 	bl	4000f7f0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    4000f9c8:	f9001e74 	str	x20, [x19, #56]
}
    4000f9cc:	17fffff7 	b	4000f9a8 <update_cache+0x50>

000000004000f9d0 <move_thread_to_end_of_prio_q>:
{
    4000f9d0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000f9d4:	aa0003e3 	mov	x3, x0
    4000f9d8:	910003fd 	mov	x29, sp
	if (z_is_thread_queued(thread)) {
    4000f9dc:	39c06402 	ldrsb	w2, [x0, #25]
	return (thread->base.thread_state & state) != 0U;
    4000f9e0:	39406401 	ldrb	w1, [x0, #25]
    4000f9e4:	36f80082 	tbz	w2, #31, 4000f9f4 <move_thread_to_end_of_prio_q+0x24>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000f9e8:	12001821 	and	w1, w1, #0x7f
    4000f9ec:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000f9f0:	97ffff6b 	bl	4000f79c <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    4000f9f4:	39406460 	ldrb	w0, [x3, #25]
    4000f9f8:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000f9fc:	911d8021 	add	x1, x1, #0x760
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000fa00:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    4000fa04:	911e8042 	add	x2, x2, #0x7a0
    4000fa08:	32196000 	orr	w0, w0, #0xffffff80
    4000fa0c:	39006460 	strb	w0, [x3, #25]
	return (node == list->tail) ? NULL : node->next;
    4000fa10:	a9441420 	ldp	x0, x5, [x1, #64]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000fa14:	eb02001f 	cmp	x0, x2
    4000fa18:	540002c0 	b.eq	4000fa70 <move_thread_to_end_of_prio_q+0xa0>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fa1c:	b40002a0 	cbz	x0, 4000fa70 <move_thread_to_end_of_prio_q+0xa0>
	int32_t b1 = thread_1->base.prio;
    4000fa20:	39c06866 	ldrsb	w6, [x3, #26]
	int32_t b2 = thread_2->base.prio;
    4000fa24:	39c06804 	ldrsb	w4, [x0, #26]
	if (b1 != b2) {
    4000fa28:	6b0400df 	cmp	w6, w4
    4000fa2c:	540001a0 	b.eq	4000fa60 <move_thread_to_end_of_prio_q+0x90>  // b.none
		return b2 - b1;
    4000fa30:	4b060084 	sub	w4, w4, w6
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000fa34:	7100009f 	cmp	w4, #0x0
    4000fa38:	5400014d 	b.le	4000fa60 <move_thread_to_end_of_prio_q+0x90>
	sys_dnode_t *const prev = successor->prev;
    4000fa3c:	f9400402 	ldr	x2, [x0, #8]
	node->prev = prev;
    4000fa40:	a9000860 	stp	x0, x2, [x3]
	prev->next = node;
    4000fa44:	f9000043 	str	x3, [x2]
	successor->prev = node;
    4000fa48:	f9000403 	str	x3, [x0, #8]
}
    4000fa4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	update_cache(thread == _current);
    4000fa50:	f9400820 	ldr	x0, [x1, #16]
    4000fa54:	eb03001f 	cmp	x0, x3
    4000fa58:	1a9f17e0 	cset	w0, eq  // eq = none
    4000fa5c:	17ffffbf 	b	4000f958 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    4000fa60:	eb05001f 	cmp	x0, x5
    4000fa64:	54000060 	b.eq	4000fa70 <move_thread_to_end_of_prio_q+0xa0>  // b.none
    4000fa68:	f9400000 	ldr	x0, [x0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fa6c:	b5fffdc0 	cbnz	x0, 4000fa24 <move_thread_to_end_of_prio_q+0x54>
	node->prev = tail;
    4000fa70:	a9001462 	stp	x2, x5, [x3]
	tail->next = node;
    4000fa74:	f90000a3 	str	x3, [x5]
	list->tail = node;
    4000fa78:	f9002423 	str	x3, [x1, #72]
}
    4000fa7c:	17fffff4 	b	4000fa4c <move_thread_to_end_of_prio_q+0x7c>

000000004000fa80 <z_time_slice>:
{
    4000fa80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fa84:	2a0003e3 	mov	w3, w0
    4000fa88:	910003fd 	mov	x29, sp
    4000fa8c:	f9000bf3 	str	x19, [sp, #16]
    4000fa90:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fa94:	d50342df 	msr	daifset, #0x2
	if (slice_time && sliceable(_current)) {
    4000fa98:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000fa9c:	b9481400 	ldr	w0, [x0, #2068]
    4000faa0:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000faa4:	911d8021 	add	x1, x1, #0x760
    4000faa8:	340003c0 	cbz	w0, 4000fb20 <z_time_slice+0xa0>
    4000faac:	f9400820 	ldr	x0, [x1, #16]
		&& !z_is_idle_thread_object(thread);
    4000fab0:	79403402 	ldrh	w2, [x0, #26]
    4000fab4:	7101fc5f 	cmp	w2, #0x7f
    4000fab8:	54000348 	b.hi	4000fb20 <z_time_slice+0xa0>  // b.pmore
		&& !z_is_thread_prevented_from_running(thread)
    4000fabc:	39406402 	ldrb	w2, [x0, #25]
    4000fac0:	f240105f 	tst	x2, #0x1f
    4000fac4:	540002e1 	b.ne	4000fb20 <z_time_slice+0xa0>  // b.any
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    4000fac8:	39c06804 	ldrsb	w4, [x0, #26]
    4000facc:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    4000fad0:	b9481042 	ldr	w2, [x2, #2064]
    4000fad4:	6b02009f 	cmp	w4, w2
    4000fad8:	5400024b 	b.lt	4000fb20 <z_time_slice+0xa0>  // b.tstop
		&& !z_is_idle_thread_object(thread);
    4000fadc:	b0000082 	adrp	x2, 40020000 <logging_thread>
    4000fae0:	911c0042 	add	x2, x2, #0x700
    4000fae4:	eb02001f 	cmp	x0, x2
    4000fae8:	540001c0 	b.eq	4000fb20 <z_time_slice+0xa0>  // b.none
		if (ticks >= _current_cpu->slice_ticks) {
    4000faec:	b9402022 	ldr	w2, [x1, #32]
    4000faf0:	6b03005f 	cmp	w2, w3
    4000faf4:	5400010c 	b.gt	4000fb14 <z_time_slice+0x94>
			move_thread_to_end_of_prio_q(_current);
    4000faf8:	97ffffb6 	bl	4000f9d0 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    4000fafc:	97ffff3d 	bl	4000f7f0 <z_reset_time_slice>
MAKE_REG_HELPER(daif)
    4000fb00:	92407e73 	and	x19, x19, #0xffffffff
    4000fb04:	d51b4233 	msr	daif, x19
}
    4000fb08:	f9400bf3 	ldr	x19, [sp, #16]
    4000fb0c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000fb10:	d65f03c0 	ret
			_current_cpu->slice_ticks -= ticks;
    4000fb14:	4b030042 	sub	w2, w2, w3
    4000fb18:	b9002022 	str	w2, [x1, #32]
    4000fb1c:	17fffff9 	b	4000fb00 <z_time_slice+0x80>
		_current_cpu->slice_ticks = 0;
    4000fb20:	b900203f 	str	wzr, [x1, #32]
    4000fb24:	17fffff7 	b	4000fb00 <z_time_slice+0x80>

000000004000fb28 <ready_thread>:
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    4000fb28:	39c06402 	ldrsb	w2, [x0, #25]
    4000fb2c:	39406401 	ldrb	w1, [x0, #25]
    4000fb30:	37f80482 	tbnz	w2, #31, 4000fbc0 <ready_thread+0x98>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    4000fb34:	f240103f 	tst	x1, #0x1f
    4000fb38:	54000441 	b.ne	4000fbc0 <ready_thread+0x98>  // b.any
    4000fb3c:	f9401402 	ldr	x2, [x0, #40]
    4000fb40:	b5000402 	cbnz	x2, 4000fbc0 <ready_thread+0x98>
	return list->head == list;
    4000fb44:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    4000fb48:	911d8042 	add	x2, x2, #0x760
	thread->base.thread_state |= _THREAD_QUEUED;
    4000fb4c:	32196021 	orr	w1, w1, #0xffffff80
    4000fb50:	39006401 	strb	w1, [x0, #25]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000fb54:	d0000083 	adrp	x3, 40021000 <k_sys_work_q+0x200>
    4000fb58:	911e8063 	add	x3, x3, #0x7a0
	return (node == list->tail) ? NULL : node->next;
    4000fb5c:	a9441441 	ldp	x1, x5, [x2, #64]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000fb60:	eb03003f 	cmp	x1, x3
    4000fb64:	54000260 	b.eq	4000fbb0 <ready_thread+0x88>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fb68:	b4000241 	cbz	x1, 4000fbb0 <ready_thread+0x88>
	int32_t b1 = thread_1->base.prio;
    4000fb6c:	39c06806 	ldrsb	w6, [x0, #26]
	int32_t b2 = thread_2->base.prio;
    4000fb70:	39c06824 	ldrsb	w4, [x1, #26]
	if (b1 != b2) {
    4000fb74:	6b0400df 	cmp	w6, w4
    4000fb78:	54000140 	b.eq	4000fba0 <ready_thread+0x78>  // b.none
		return b2 - b1;
    4000fb7c:	4b060084 	sub	w4, w4, w6
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000fb80:	7100009f 	cmp	w4, #0x0
    4000fb84:	540000ed 	b.le	4000fba0 <ready_thread+0x78>
	sys_dnode_t *const prev = successor->prev;
    4000fb88:	f9400422 	ldr	x2, [x1, #8]
	node->prev = prev;
    4000fb8c:	a9000801 	stp	x1, x2, [x0]
	prev->next = node;
    4000fb90:	f9000040 	str	x0, [x2]
	successor->prev = node;
    4000fb94:	f9000420 	str	x0, [x1, #8]
		update_cache(0);
    4000fb98:	52800000 	mov	w0, #0x0                   	// #0
    4000fb9c:	17ffff6f 	b	4000f958 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    4000fba0:	eb05003f 	cmp	x1, x5
    4000fba4:	54000060 	b.eq	4000fbb0 <ready_thread+0x88>  // b.none
    4000fba8:	f9400021 	ldr	x1, [x1]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fbac:	b5fffe21 	cbnz	x1, 4000fb70 <ready_thread+0x48>
	node->prev = tail;
    4000fbb0:	a9001403 	stp	x3, x5, [x0]
	tail->next = node;
    4000fbb4:	f90000a0 	str	x0, [x5]
	list->tail = node;
    4000fbb8:	f9002440 	str	x0, [x2, #72]
}
    4000fbbc:	17fffff7 	b	4000fb98 <ready_thread+0x70>
}
    4000fbc0:	d65f03c0 	ret

000000004000fbc4 <z_ready_thread>:
{
    4000fbc4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fbc8:	910003fd 	mov	x29, sp
    4000fbcc:	f9000bf3 	str	x19, [sp, #16]
    4000fbd0:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fbd4:	d50342df 	msr	daifset, #0x2
			ready_thread(thread);
    4000fbd8:	97ffffd4 	bl	4000fb28 <ready_thread>
MAKE_REG_HELPER(daif)
    4000fbdc:	92407e73 	and	x19, x19, #0xffffffff
    4000fbe0:	d51b4233 	msr	daif, x19
}
    4000fbe4:	f9400bf3 	ldr	x19, [sp, #16]
    4000fbe8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000fbec:	d65f03c0 	ret

000000004000fbf0 <z_thread_timeout>:
{
    4000fbf0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fbf4:	910003fd 	mov	x29, sp
    4000fbf8:	f9000bf3 	str	x19, [sp, #16]
    4000fbfc:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fc00:	d50342df 	msr	daifset, #0x2
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
    4000fc04:	d100a004 	sub	x4, x0, #0x28
		if (!killed) {
    4000fc08:	52800501 	mov	w1, #0x28                  	// #40
    4000fc0c:	39406480 	ldrb	w0, [x4, #25]
    4000fc10:	6a00003f 	tst	w1, w0
    4000fc14:	54000161 	b.ne	4000fc40 <z_thread_timeout+0x50>  // b.any
			if (thread->base.pended_on != NULL) {
    4000fc18:	f9400880 	ldr	x0, [x4, #16]
    4000fc1c:	b4000060 	cbz	x0, 4000fc28 <z_thread_timeout+0x38>
				unpend_thread_no_timeout(thread);
    4000fc20:	aa0403e0 	mov	x0, x4
    4000fc24:	97fffee3 	bl	4000f7b0 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    4000fc28:	39406480 	ldrb	w0, [x4, #25]
    4000fc2c:	12800281 	mov	w1, #0xffffffeb            	// #-21
    4000fc30:	0a010000 	and	w0, w0, w1
    4000fc34:	39006480 	strb	w0, [x4, #25]
			ready_thread(thread);
    4000fc38:	aa0403e0 	mov	x0, x4
    4000fc3c:	97ffffbb 	bl	4000fb28 <ready_thread>
MAKE_REG_HELPER(daif)
    4000fc40:	92407e73 	and	x19, x19, #0xffffffff
    4000fc44:	d51b4233 	msr	daif, x19
}
    4000fc48:	f9400bf3 	ldr	x19, [sp, #16]
    4000fc4c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000fc50:	d65f03c0 	ret

000000004000fc54 <unready_thread>:
	if (z_is_thread_queued(thread)) {
    4000fc54:	39c06402 	ldrsb	w2, [x0, #25]
{
    4000fc58:	aa0003e3 	mov	x3, x0
	return (thread->base.thread_state & state) != 0U;
    4000fc5c:	39406401 	ldrb	w1, [x0, #25]
	if (z_is_thread_queued(thread)) {
    4000fc60:	36f80182 	tbz	w2, #31, 4000fc90 <unready_thread+0x3c>
{
    4000fc64:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000fc68:	12001821 	and	w1, w1, #0x7f
{
    4000fc6c:	910003fd 	mov	x29, sp
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000fc70:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000fc74:	97fffeca 	bl	4000f79c <sys_dlist_remove>
	update_cache(thread == _current);
    4000fc78:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000fc7c:	f943b800 	ldr	x0, [x0, #1904]
}
    4000fc80:	a8c17bfd 	ldp	x29, x30, [sp], #16
	update_cache(thread == _current);
    4000fc84:	eb03001f 	cmp	x0, x3
    4000fc88:	1a9f17e0 	cset	w0, eq  // eq = none
    4000fc8c:	17ffff33 	b	4000f958 <update_cache>
    4000fc90:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000fc94:	f943b800 	ldr	x0, [x0, #1904]
    4000fc98:	eb03001f 	cmp	x0, x3
    4000fc9c:	1a9f17e0 	cset	w0, eq  // eq = none
    4000fca0:	17fffffb 	b	4000fc8c <unready_thread+0x38>

000000004000fca4 <add_to_waitq_locked>:
{
    4000fca4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fca8:	910003fd 	mov	x29, sp
    4000fcac:	a90153f3 	stp	x19, x20, [sp, #16]
    4000fcb0:	aa0003f3 	mov	x19, x0
    4000fcb4:	aa0103f4 	mov	x20, x1
	unready_thread(thread);
    4000fcb8:	97ffffe7 	bl	4000fc54 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    4000fcbc:	39406660 	ldrb	w0, [x19, #25]
    4000fcc0:	321f0000 	orr	w0, w0, #0x2
    4000fcc4:	39006660 	strb	w0, [x19, #25]
	if (wait_q != NULL) {
    4000fcc8:	b4000234 	cbz	x20, 4000fd0c <add_to_waitq_locked+0x68>
	return list->head == list;
    4000fccc:	f9400280 	ldr	x0, [x20]
		thread->base.pended_on = wait_q;
    4000fcd0:	f9000a74 	str	x20, [x19, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000fcd4:	eb00029f 	cmp	x20, x0
    4000fcd8:	540002a0 	b.eq	4000fd2c <add_to_waitq_locked+0x88>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fcdc:	b4000280 	cbz	x0, 4000fd2c <add_to_waitq_locked+0x88>
	int32_t b1 = thread_1->base.prio;
    4000fce0:	39c06a62 	ldrsb	w2, [x19, #26]
	int32_t b2 = thread_2->base.prio;
    4000fce4:	39c06801 	ldrsb	w1, [x0, #26]
	if (b1 != b2) {
    4000fce8:	6b01005f 	cmp	w2, w1
    4000fcec:	54000160 	b.eq	4000fd18 <add_to_waitq_locked+0x74>  // b.none
		return b2 - b1;
    4000fcf0:	4b020021 	sub	w1, w1, w2
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000fcf4:	7100003f 	cmp	w1, #0x0
    4000fcf8:	5400010d 	b.le	4000fd18 <add_to_waitq_locked+0x74>
	sys_dnode_t *const prev = successor->prev;
    4000fcfc:	f9400401 	ldr	x1, [x0, #8]
	node->prev = prev;
    4000fd00:	a9000660 	stp	x0, x1, [x19]
	prev->next = node;
    4000fd04:	f9000033 	str	x19, [x1]
	successor->prev = node;
    4000fd08:	f9000413 	str	x19, [x0, #8]
}
    4000fd0c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000fd10:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000fd14:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
    4000fd18:	f9400681 	ldr	x1, [x20, #8]
    4000fd1c:	eb01001f 	cmp	x0, x1
    4000fd20:	54000060 	b.eq	4000fd2c <add_to_waitq_locked+0x88>  // b.none
    4000fd24:	f9400000 	ldr	x0, [x0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fd28:	b5fffde0 	cbnz	x0, 4000fce4 <add_to_waitq_locked+0x40>
	sys_dnode_t *const tail = list->tail;
    4000fd2c:	f9400680 	ldr	x0, [x20, #8]
	node->prev = tail;
    4000fd30:	a9000274 	stp	x20, x0, [x19]
	tail->next = node;
    4000fd34:	f9000013 	str	x19, [x0]
	list->tail = node;
    4000fd38:	f9000693 	str	x19, [x20, #8]
}
    4000fd3c:	17fffff4 	b	4000fd0c <add_to_waitq_locked+0x68>

000000004000fd40 <pend>:
{
    4000fd40:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000fd44:	910003fd 	mov	x29, sp
    4000fd48:	a90153f3 	stp	x19, x20, [sp, #16]
    4000fd4c:	aa0003f4 	mov	x20, x0
    4000fd50:	aa0203f3 	mov	x19, x2
    4000fd54:	f90013f5 	str	x21, [sp, #32]
    4000fd58:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fd5c:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(daif)
    4000fd60:	92407eb5 	and	x21, x21, #0xffffffff
		add_to_waitq_locked(thread, wait_q);
    4000fd64:	97ffffd0 	bl	4000fca4 <add_to_waitq_locked>
    4000fd68:	d51b4235 	msr	daif, x21
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    4000fd6c:	b100067f 	cmn	x19, #0x1
    4000fd70:	54000120 	b.eq	4000fd94 <pend+0x54>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    4000fd74:	aa1303e2 	mov	x2, x19
    4000fd78:	9100a280 	add	x0, x20, #0x28
}
    4000fd7c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000fd80:	90000001 	adrp	x1, 4000f000 <z_impl_k_msgq_get+0xdc>
    4000fd84:	912fc021 	add	x1, x1, #0xbf0
    4000fd88:	f94013f5 	ldr	x21, [sp, #32]
    4000fd8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000fd90:	14000297 	b	400107ec <z_add_timeout>
    4000fd94:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000fd98:	f94013f5 	ldr	x21, [sp, #32]
    4000fd9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000fda0:	d65f03c0 	ret

000000004000fda4 <z_set_prio>:
{
    4000fda4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fda8:	aa0003e3 	mov	x3, x0
    4000fdac:	910003fd 	mov	x29, sp
    4000fdb0:	f9000bf3 	str	x19, [sp, #16]
    4000fdb4:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fdb8:	d50342df 	msr	daifset, #0x2
	uint8_t state = thread->base.thread_state;
    4000fdbc:	39406402 	ldrb	w2, [x0, #25]
				thread->base.prio = prio;
    4000fdc0:	13001c24 	sxtb	w4, w1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    4000fdc4:	f240105f 	tst	x2, #0x1f
    4000fdc8:	540005c1 	b.ne	4000fe80 <z_set_prio+0xdc>  // b.any
		if (need_sched) {
    4000fdcc:	f9401401 	ldr	x1, [x0, #40]
    4000fdd0:	b5000581 	cbnz	x1, 4000fe80 <z_set_prio+0xdc>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000fdd4:	12001842 	and	w2, w2, #0x7f
    4000fdd8:	39006402 	strb	w2, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000fddc:	97fffe70 	bl	4000f79c <sys_dlist_remove>
				thread->base.prio = prio;
    4000fde0:	39006804 	strb	w4, [x0, #26]
	thread->base.thread_state |= _THREAD_QUEUED;
    4000fde4:	39406400 	ldrb	w0, [x0, #25]
	return list->head == list;
    4000fde8:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000fdec:	911d8021 	add	x1, x1, #0x760
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000fdf0:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    4000fdf4:	911e8042 	add	x2, x2, #0x7a0
    4000fdf8:	32196000 	orr	w0, w0, #0xffffff80
    4000fdfc:	39006460 	strb	w0, [x3, #25]
	return list->head == list;
    4000fe00:	f9402020 	ldr	x0, [x1, #64]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000fe04:	eb02001f 	cmp	x0, x2
    4000fe08:	54000320 	b.eq	4000fe6c <z_set_prio+0xc8>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fe0c:	b4000300 	cbz	x0, 4000fe6c <z_set_prio+0xc8>
	return (node == list->tail) ? NULL : node->next;
    4000fe10:	f9402426 	ldr	x6, [x1, #72]
	int32_t b2 = thread_2->base.prio;
    4000fe14:	39c06805 	ldrsb	w5, [x0, #26]
	if (b1 != b2) {
    4000fe18:	6b05009f 	cmp	w4, w5
    4000fe1c:	54000200 	b.eq	4000fe5c <z_set_prio+0xb8>  // b.none
		return b2 - b1;
    4000fe20:	4b0400a5 	sub	w5, w5, w4
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000fe24:	710000bf 	cmp	w5, #0x0
    4000fe28:	540001ad 	b.le	4000fe5c <z_set_prio+0xb8>
	sys_dnode_t *const prev = successor->prev;
    4000fe2c:	f9400401 	ldr	x1, [x0, #8]
	node->prev = prev;
    4000fe30:	a9000460 	stp	x0, x1, [x3]
	prev->next = node;
    4000fe34:	f9000023 	str	x3, [x1]
	successor->prev = node;
    4000fe38:	f9000403 	str	x3, [x0, #8]
			update_cache(1);
    4000fe3c:	52800020 	mov	w0, #0x1                   	// #1
    4000fe40:	97fffec6 	bl	4000f958 <update_cache>
    4000fe44:	52800020 	mov	w0, #0x1                   	// #1
MAKE_REG_HELPER(daif)
    4000fe48:	92407e73 	and	x19, x19, #0xffffffff
    4000fe4c:	d51b4233 	msr	daif, x19
}
    4000fe50:	f9400bf3 	ldr	x19, [sp, #16]
    4000fe54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000fe58:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
    4000fe5c:	eb06001f 	cmp	x0, x6
    4000fe60:	54000060 	b.eq	4000fe6c <z_set_prio+0xc8>  // b.none
    4000fe64:	f9400000 	ldr	x0, [x0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fe68:	b5fffd60 	cbnz	x0, 4000fe14 <z_set_prio+0x70>
	sys_dnode_t *const tail = list->tail;
    4000fe6c:	f9402420 	ldr	x0, [x1, #72]
	node->prev = tail;
    4000fe70:	a9000062 	stp	x2, x0, [x3]
	tail->next = node;
    4000fe74:	f9000003 	str	x3, [x0]
	list->tail = node;
    4000fe78:	f9002423 	str	x3, [x1, #72]
}
    4000fe7c:	17fffff0 	b	4000fe3c <z_set_prio+0x98>
			thread->base.prio = prio;
    4000fe80:	52800000 	mov	w0, #0x0                   	// #0
    4000fe84:	39006864 	strb	w4, [x3, #26]
    4000fe88:	17fffff0 	b	4000fe48 <z_set_prio+0xa4>

000000004000fe8c <z_unpend1_no_timeout>:
{
    4000fe8c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000fe90:	910003fd 	mov	x29, sp
    4000fe94:	d53b4225 	mrs	x5, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fe98:	d50342df 	msr	daifset, #0x2
		thread = _priq_wait_best(&wait_q->waitq);
    4000fe9c:	97fffeab 	bl	4000f948 <z_priq_dumb_best>
    4000fea0:	aa0003e4 	mov	x4, x0
		if (thread != NULL) {
    4000fea4:	b4000040 	cbz	x0, 4000feac <z_unpend1_no_timeout+0x20>
			unpend_thread_no_timeout(thread);
    4000fea8:	97fffe42 	bl	4000f7b0 <unpend_thread_no_timeout>
MAKE_REG_HELPER(daif)
    4000feac:	92407ca5 	and	x5, x5, #0xffffffff
    4000feb0:	d51b4225 	msr	daif, x5
}
    4000feb4:	aa0403e0 	mov	x0, x4
    4000feb8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000febc:	d65f03c0 	ret

000000004000fec0 <z_unpend_first_thread>:
{
    4000fec0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fec4:	910003fd 	mov	x29, sp
    4000fec8:	a90153f3 	stp	x19, x20, [sp, #16]
    4000fecc:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fed0:	d50342df 	msr	daifset, #0x2
		thread = _priq_wait_best(&wait_q->waitq);
    4000fed4:	97fffe9d 	bl	4000f948 <z_priq_dumb_best>
    4000fed8:	aa0003f3 	mov	x19, x0
		if (thread != NULL) {
    4000fedc:	b4000080 	cbz	x0, 4000feec <z_unpend_first_thread+0x2c>
			unpend_thread_no_timeout(thread);
    4000fee0:	97fffe34 	bl	4000f7b0 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
    4000fee4:	9100a260 	add	x0, x19, #0x28
    4000fee8:	94000288 	bl	40010908 <z_abort_timeout>
MAKE_REG_HELPER(daif)
    4000feec:	92407e94 	and	x20, x20, #0xffffffff
    4000fef0:	d51b4234 	msr	daif, x20
}
    4000fef4:	aa1303e0 	mov	x0, x19
    4000fef8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000fefc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000ff00:	d65f03c0 	ret

000000004000ff04 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    4000ff04:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000ff08:	911d8000 	add	x0, x0, #0x760
    4000ff0c:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000ff10:	911e8021 	add	x1, x1, #0x7a0
	list->tail = (sys_dnode_t *)list;
    4000ff14:	a9040401 	stp	x1, x1, [x0, #64]
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    4000ff18:	52800001 	mov	w1, #0x0                   	// #0
    4000ff1c:	52800000 	mov	w0, #0x0                   	// #0
    4000ff20:	17fffe47 	b	4000f83c <k_sched_time_slice_set>

000000004000ff24 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    4000ff24:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4000ff28:	f943b800 	ldr	x0, [x0, #1904]
    4000ff2c:	d65f03c0 	ret

000000004000ff30 <z_impl_k_is_preempt_thread>:
MAKE_REG_HELPER(tpidrro_el0);
    4000ff30:	d53bd060 	mrs	x0, tpidrro_el0
    4000ff34:	927db000 	and	x0, x0, #0xfffffffffff8
#include <syscalls/z_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
	return !arch_is_in_isr() && is_preempt(_current);
    4000ff38:	b9400000 	ldr	w0, [x0]
    4000ff3c:	350000e0 	cbnz	w0, 4000ff58 <z_impl_k_is_preempt_thread+0x28>
    4000ff40:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    4000ff44:	f943b800 	ldr	x0, [x0, #1904]
	return !arch_is_in_isr() && is_preempt(_current);
    4000ff48:	79403400 	ldrh	w0, [x0, #26]
    4000ff4c:	7101fc1f 	cmp	w0, #0x7f
    4000ff50:	1a9f87e0 	cset	w0, ls  // ls = plast
}
    4000ff54:	d65f03c0 	ret
	return !arch_is_in_isr() && is_preempt(_current);
    4000ff58:	52800000 	mov	w0, #0x0                   	// #0
    4000ff5c:	17fffffe 	b	4000ff54 <z_impl_k_is_preempt_thread+0x24>

000000004000ff60 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
    4000ff60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000ff64:	2a0103e3 	mov	w3, w1
    4000ff68:	910003fd 	mov	x29, sp
    4000ff6c:	a90153f3 	stp	x19, x20, [sp, #16]
MAKE_REG_HELPER(daif)
    4000ff70:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ff74:	d50342df 	msr	daifset, #0x2
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
    4000ff78:	97fffe74 	bl	4000f948 <z_priq_dumb_best>

		if (thread != NULL) {
    4000ff7c:	b40001e0 	cbz	x0, 4000ffb8 <z_sched_wake+0x58>
	thread->base.swap_data = data;
    4000ff80:	f9001002 	str	x2, [x0, #32]
    4000ff84:	aa0003f3 	mov	x19, x0
	thread->swap_retval = value;
    4000ff88:	b9014003 	str	w3, [x0, #320]
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
    4000ff8c:	97fffe09 	bl	4000f7b0 <unpend_thread_no_timeout>
    4000ff90:	9100a260 	add	x0, x19, #0x28
    4000ff94:	9400025d 	bl	40010908 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
    4000ff98:	aa1303e0 	mov	x0, x19
    4000ff9c:	97fffee3 	bl	4000fb28 <ready_thread>
			ret = true;
    4000ffa0:	52800020 	mov	w0, #0x1                   	// #1
MAKE_REG_HELPER(daif)
    4000ffa4:	92407e94 	and	x20, x20, #0xffffffff
    4000ffa8:	d51b4234 	msr	daif, x20
		}
	}

	return ret;
}
    4000ffac:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ffb0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000ffb4:	d65f03c0 	ret
	bool ret = false;
    4000ffb8:	52800000 	mov	w0, #0x0                   	// #0
    4000ffbc:	17fffffa 	b	4000ffa4 <z_sched_wake+0x44>

000000004000ffc0 <z_sched_usage_start>:
	/* Edge case: we use a zero as a null ("stop() already called") */
	return (now == 0) ? 1 : now;
}

void z_sched_usage_start(struct k_thread *thread)
{
    4000ffc0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000ffc4:	910003fd 	mov	x29, sp
#if defined(CONFIG_BOARD_HAS_TIMING_FUNCTIONS)
	return board_timing_counter_get();
#elif defined(CONFIG_SOC_HAS_TIMING_FUNCTIONS)
	return soc_timing_counter_get();
#else
	return arch_timing_counter_get();
    4000ffc8:	97ffee9a 	bl	4000ba30 <arch_timing_counter_get>
	/* One write through a volatile pointer doesn't require
	 * synchronization as long as _usage() treats it as volatile
	 * (we can't race with _stop() by design).
	 */
	_current_cpu->usage0 = usage_now();
    4000ffcc:	7100001f 	cmp	w0, #0x0
    4000ffd0:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    4000ffd4:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
}
    4000ffd8:	a8c17bfd 	ldp	x29, x30, [sp], #16
	_current_cpu->usage0 = usage_now();
    4000ffdc:	b9078820 	str	w0, [x1, #1928]
}
    4000ffe0:	d65f03c0 	ret

000000004000ffe4 <z_sched_usage_stop>:

void z_sched_usage_stop(void)
{
    4000ffe4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000ffe8:	910003fd 	mov	x29, sp
    4000ffec:	a90153f3 	stp	x19, x20, [sp, #16]
    4000fff0:	f90013f5 	str	x21, [sp, #32]
    4000fff4:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fff8:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t k = k_spin_lock(&usage_lock);
	uint32_t u0 = _current_cpu->usage0;
    4000fffc:	d0000093 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    40010000:	911d8273 	add	x19, x19, #0x760
    40010004:	b9402a75 	ldr	w21, [x19, #40]

	if (u0 != 0) {
    40010008:	34000215 	cbz	w21, 40010048 <z_sched_usage_stop+0x64>
    4001000c:	97ffee89 	bl	4000ba30 <arch_timing_counter_get>
		uint32_t dt = usage_now() - u0;
    40010010:	7100001f 	cmp	w0, #0x0

#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
		if (z_is_idle_thread_object(_current)) {
    40010014:	f9400a61 	ldr	x1, [x19, #16]
		uint32_t dt = usage_now() - u0;
    40010018:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
		if (z_is_idle_thread_object(_current)) {
    4001001c:	90000082 	adrp	x2, 40020000 <logging_thread>
    40010020:	911c0042 	add	x2, x2, #0x700
			_kernel.idle_thread_usage += dt;
    40010024:	4b150000 	sub	w0, w0, w21
		if (z_is_idle_thread_object(_current)) {
    40010028:	eb02003f 	cmp	x1, x2
    4001002c:	540001c1 	b.ne	40010064 <z_sched_usage_stop+0x80>  // b.any
			_kernel.idle_thread_usage += dt;
    40010030:	f9403662 	ldr	x2, [x19, #104]
    40010034:	8b000042 	add	x2, x2, x0
    40010038:	f9003662 	str	x2, [x19, #104]
		} else {
			_kernel.all_thread_usage += dt;
		}
#endif
		_current->base.usage += dt;
    4001003c:	f9402422 	ldr	x2, [x1, #72]
    40010040:	8b000040 	add	x0, x2, x0
    40010044:	f9002420 	str	x0, [x1, #72]
MAKE_REG_HELPER(daif)
    40010048:	92407e94 	and	x20, x20, #0xffffffff
	}

	_current_cpu->usage0 = 0;
    4001004c:	b9002a7f 	str	wzr, [x19, #40]
    40010050:	d51b4234 	msr	daif, x20
	k_spin_unlock(&usage_lock, k);
}
    40010054:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010058:	f94013f5 	ldr	x21, [sp, #32]
    4001005c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40010060:	d65f03c0 	ret
			_kernel.all_thread_usage += dt;
    40010064:	f9403262 	ldr	x2, [x19, #96]
    40010068:	8b000042 	add	x2, x2, x0
    4001006c:	f9003262 	str	x2, [x19, #96]
    40010070:	17fffff3 	b	4001003c <z_sched_usage_stop+0x58>

0000000040010074 <z_swap_irqlock>:
{
    40010074:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40010078:	910003fd 	mov	x29, sp
    4001007c:	a90153f3 	stp	x19, x20, [sp, #16]
	old_thread = _current;
    40010080:	b0000093 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    40010084:	911d8273 	add	x19, x19, #0x760
{
    40010088:	a9025bf5 	stp	x21, x22, [sp, #32]
    4001008c:	2a0003f4 	mov	w20, w0
	old_thread->swap_retval = -EAGAIN;
    40010090:	12800140 	mov	w0, #0xfffffff5            	// #-11
	old_thread = _current;
    40010094:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    40010098:	b90142c0 	str	w0, [x22, #320]
    4001009c:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400100a0:	d50342df 	msr	daifset, #0x2
	return _kernel.ready_q.cache;
    400100a4:	f9401e75 	ldr	x21, [x19, #56]
	if (new_thread != old_thread) {
    400100a8:	eb1502df 	cmp	x22, x21
    400100ac:	54000120 	b.eq	400100d0 <z_swap_irqlock+0x5c>  // b.none
		z_reset_time_slice();
    400100b0:	97fffdd0 	bl	4000f7f0 <z_reset_time_slice>
	z_sched_usage_stop();
    400100b4:	97ffffcc 	bl	4000ffe4 <z_sched_usage_stop>
	z_sched_usage_start(thread);
    400100b8:	aa1503e0 	mov	x0, x21
    400100bc:	97ffffc1 	bl	4000ffc0 <z_sched_usage_start>
    400100c0:	f940a6a0 	ldr	x0, [x21, #328]
    400100c4:	910522c1 	add	x1, x22, #0x148
		_current_cpu->current = new_thread;
    400100c8:	f9000a75 	str	x21, [x19, #16]
    400100cc:	97fff06a 	bl	4000c274 <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    400100d0:	d51b4234 	msr	daif, x20
	return _current->swap_retval;
    400100d4:	f9400a60 	ldr	x0, [x19, #16]
}
    400100d8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400100dc:	b9414000 	ldr	w0, [x0, #320]
    400100e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400100e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400100e8:	d65f03c0 	ret

00000000400100ec <z_reschedule_irqlock>:
{
    400100ec:	2a0003e1 	mov	w1, w0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    400100f0:	36380061 	tbz	w1, #7, 400100fc <z_reschedule_irqlock+0x10>
    400100f4:	d51b4221 	msr	daif, x1
}
    400100f8:	d65f03c0 	ret
MAKE_REG_HELPER(tpidrro_el0);
    400100fc:	d53bd062 	mrs	x2, tpidrro_el0
    40010100:	927db042 	and	x2, x2, #0xfffffffffff8
	if (resched(key)) {
    40010104:	b9400042 	ldr	w2, [x2]
    40010108:	35ffff62 	cbnz	w2, 400100f4 <z_reschedule_irqlock+0x8>
		z_swap_irqlock(key);
    4001010c:	17ffffda 	b	40010074 <z_swap_irqlock>

0000000040010110 <z_reschedule_unlocked>:
MAKE_REG_HELPER(daif)
    40010110:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010114:	d50342df 	msr	daifset, #0x2
	(void) z_reschedule_irqlock(arch_irq_lock());
    40010118:	17fffff5 	b	400100ec <z_reschedule_irqlock>

000000004001011c <z_impl_k_thread_suspend>:
{
    4001011c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40010120:	910003fd 	mov	x29, sp
    40010124:	a90153f3 	stp	x19, x20, [sp, #16]
    40010128:	aa0003f3 	mov	x19, x0
    4001012c:	9100a000 	add	x0, x0, #0x28
    40010130:	f90013f5 	str	x21, [sp, #32]
    40010134:	940001f5 	bl	40010908 <z_abort_timeout>
MAKE_REG_HELPER(daif)
    40010138:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4001013c:	d50342df 	msr	daifset, #0x2
		if (z_is_thread_queued(thread)) {
    40010140:	39c06661 	ldrsb	w1, [x19, #25]
	return (thread->base.thread_state & state) != 0U;
    40010144:	39406660 	ldrb	w0, [x19, #25]
    40010148:	36f800a1 	tbz	w1, #31, 4001015c <z_impl_k_thread_suspend+0x40>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4001014c:	12001800 	and	w0, w0, #0x7f
    40010150:	39006660 	strb	w0, [x19, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    40010154:	aa1303e0 	mov	x0, x19
    40010158:	97fffd91 	bl	4000f79c <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    4001015c:	39406660 	ldrb	w0, [x19, #25]
		update_cache(thread == _current);
    40010160:	b0000094 	adrp	x20, 40021000 <k_sys_work_q+0x200>
    40010164:	911d8294 	add	x20, x20, #0x760
MAKE_REG_HELPER(daif)
    40010168:	92407eb5 	and	x21, x21, #0xffffffff
    4001016c:	321c0000 	orr	w0, w0, #0x10
    40010170:	39006660 	strb	w0, [x19, #25]
    40010174:	f9400a80 	ldr	x0, [x20, #16]
    40010178:	eb13001f 	cmp	x0, x19
    4001017c:	1a9f17e0 	cset	w0, eq  // eq = none
    40010180:	97fffdf6 	bl	4000f958 <update_cache>
    40010184:	d51b4235 	msr	daif, x21
	if (thread == _current) {
    40010188:	f9400a80 	ldr	x0, [x20, #16]
    4001018c:	eb13001f 	cmp	x0, x19
    40010190:	540000a1 	b.ne	400101a4 <z_impl_k_thread_suspend+0x88>  // b.any
}
    40010194:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010198:	f94013f5 	ldr	x21, [sp, #32]
    4001019c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule_unlocked();
    400101a0:	17ffffdc 	b	40010110 <z_reschedule_unlocked>
}
    400101a4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400101a8:	f94013f5 	ldr	x21, [sp, #32]
    400101ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400101b0:	d65f03c0 	ret

00000000400101b4 <k_sched_unlock>:
{
    400101b4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400101b8:	910003fd 	mov	x29, sp
    400101bc:	f9000bf3 	str	x19, [sp, #16]
    400101c0:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400101c4:	d50342df 	msr	daifset, #0x2
		++_current->base.sched_locked;
    400101c8:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    400101cc:	f943b801 	ldr	x1, [x0, #1904]
MAKE_REG_HELPER(daif)
    400101d0:	92407e73 	and	x19, x19, #0xffffffff
    400101d4:	39406c20 	ldrb	w0, [x1, #27]
    400101d8:	11000400 	add	w0, w0, #0x1
    400101dc:	39006c20 	strb	w0, [x1, #27]
		update_cache(0);
    400101e0:	52800000 	mov	w0, #0x0                   	// #0
    400101e4:	97fffddd 	bl	4000f958 <update_cache>
    400101e8:	d51b4233 	msr	daif, x19
}
    400101ec:	f9400bf3 	ldr	x19, [sp, #16]
    400101f0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule_unlocked();
    400101f4:	17ffffc7 	b	40010110 <z_reschedule_unlocked>

00000000400101f8 <z_get_next_switch_handle>:
{
    400101f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400101fc:	910003fd 	mov	x29, sp
    40010200:	a90153f3 	stp	x19, x20, [sp, #16]
	z_sched_usage_switch(_kernel.ready_q.cache);
    40010204:	b0000093 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    40010208:	911d8273 	add	x19, x19, #0x760
{
    4001020c:	f90013f5 	str	x21, [sp, #32]
    40010210:	aa0003f4 	mov	x20, x0
	z_sched_usage_switch(_kernel.ready_q.cache);
    40010214:	f9401e75 	ldr	x21, [x19, #56]
	z_sched_usage_stop();
    40010218:	97ffff73 	bl	4000ffe4 <z_sched_usage_stop>
	z_sched_usage_start(thread);
    4001021c:	aa1503e0 	mov	x0, x21
    40010220:	97ffff68 	bl	4000ffc0 <z_sched_usage_start>
	_current->switch_handle = interrupted;
    40010224:	f9400a60 	ldr	x0, [x19, #16]
}
    40010228:	f94013f5 	ldr	x21, [sp, #32]
	_current->switch_handle = interrupted;
    4001022c:	f900a414 	str	x20, [x0, #328]
	set_current(_kernel.ready_q.cache);
    40010230:	f9401e60 	ldr	x0, [x19, #56]
	_current_cpu->current = new_thread;
    40010234:	f9000a60 	str	x0, [x19, #16]
}
    40010238:	a94153f3 	ldp	x19, x20, [sp, #16]
    4001023c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40010240:	f940a400 	ldr	x0, [x0, #328]
    40010244:	d65f03c0 	ret

0000000040010248 <z_swap>:
{
    40010248:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4001024c:	910003fd 	mov	x29, sp
    40010250:	a90153f3 	stp	x19, x20, [sp, #16]
	old_thread = _current;
    40010254:	b0000093 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    40010258:	911d8273 	add	x19, x19, #0x760
{
    4001025c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40010260:	2a0103f4 	mov	w20, w1
	old_thread->swap_retval = -EAGAIN;
    40010264:	12800141 	mov	w1, #0xfffffff5            	// #-11
	old_thread = _current;
    40010268:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    4001026c:	b90142c1 	str	w1, [x22, #320]
	if (!is_spinlock || lock != &sched_spinlock) {
    40010270:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40010274:	912fb021 	add	x1, x1, #0xbec
    40010278:	eb00003f 	cmp	x1, x0
    4001027c:	54000060 	b.eq	40010288 <z_swap+0x40>  // b.none
    40010280:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010284:	d50342df 	msr	daifset, #0x2
	return _kernel.ready_q.cache;
    40010288:	f9401e75 	ldr	x21, [x19, #56]
	if (new_thread != old_thread) {
    4001028c:	eb1502df 	cmp	x22, x21
    40010290:	54000120 	b.eq	400102b4 <z_swap+0x6c>  // b.none
		z_reset_time_slice();
    40010294:	97fffd57 	bl	4000f7f0 <z_reset_time_slice>
	z_sched_usage_stop();
    40010298:	97ffff53 	bl	4000ffe4 <z_sched_usage_stop>
	z_sched_usage_start(thread);
    4001029c:	aa1503e0 	mov	x0, x21
    400102a0:	97ffff48 	bl	4000ffc0 <z_sched_usage_start>
    400102a4:	f940a6a0 	ldr	x0, [x21, #328]
    400102a8:	910522c1 	add	x1, x22, #0x148
		_current_cpu->current = new_thread;
    400102ac:	f9000a75 	str	x21, [x19, #16]
    400102b0:	97ffeff1 	bl	4000c274 <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    400102b4:	d51b4234 	msr	daif, x20
	return _current->swap_retval;
    400102b8:	f9400a60 	ldr	x0, [x19, #16]
}
    400102bc:	a94153f3 	ldp	x19, x20, [sp, #16]
    400102c0:	b9414000 	ldr	w0, [x0, #320]
    400102c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400102c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400102cc:	d65f03c0 	ret

00000000400102d0 <z_pend_curr>:
{
    400102d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400102d4:	910003fd 	mov	x29, sp
    400102d8:	a90153f3 	stp	x19, x20, [sp, #16]
    400102dc:	aa0003f3 	mov	x19, x0
	pend(_current, wait_q, timeout);
    400102e0:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    400102e4:	f943b800 	ldr	x0, [x0, #1904]
{
    400102e8:	2a0103f4 	mov	w20, w1
    400102ec:	aa0203e1 	mov	x1, x2
    400102f0:	aa0303e2 	mov	x2, x3
	pend(_current, wait_q, timeout);
    400102f4:	97fffe93 	bl	4000fd40 <pend>
	return z_swap(lock, key);
    400102f8:	2a1403e1 	mov	w1, w20
    400102fc:	aa1303e0 	mov	x0, x19
}
    40010300:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010304:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return z_swap(lock, key);
    40010308:	17ffffd0 	b	40010248 <z_swap>

000000004001030c <z_sched_wait>:
{
    4001030c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40010310:	910003fd 	mov	x29, sp
    40010314:	f9000bf3 	str	x19, [sp, #16]
    40010318:	aa0403f3 	mov	x19, x4
	int ret = z_pend_curr(lock, key, wait_q, timeout);
    4001031c:	97ffffed 	bl	400102d0 <z_pend_curr>
	if (data != NULL) {
    40010320:	b40000b3 	cbz	x19, 40010334 <z_sched_wait+0x28>
		*data = _current->base.swap_data;
    40010324:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40010328:	f943b821 	ldr	x1, [x1, #1904]
    4001032c:	f9401021 	ldr	x1, [x1, #32]
    40010330:	f9000261 	str	x1, [x19]
}
    40010334:	f9400bf3 	ldr	x19, [sp, #16]
    40010338:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4001033c:	d65f03c0 	ret

0000000040010340 <z_reschedule>:
{
    40010340:	2a0103e2 	mov	w2, w1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    40010344:	36380062 	tbz	w2, #7, 40010350 <z_reschedule+0x10>
    40010348:	d51b4222 	msr	daif, x2
}
    4001034c:	d65f03c0 	ret
MAKE_REG_HELPER(tpidrro_el0);
    40010350:	d53bd063 	mrs	x3, tpidrro_el0
    40010354:	927db063 	and	x3, x3, #0xfffffffffff8
	if (resched(key.key) && need_swap()) {
    40010358:	b9400063 	ldr	w3, [x3]
    4001035c:	35ffff63 	cbnz	w3, 40010348 <z_reschedule+0x8>
	new_thread = _kernel.ready_q.cache;
    40010360:	b0000083 	adrp	x3, 40021000 <k_sys_work_q+0x200>
    40010364:	911d8063 	add	x3, x3, #0x760
	if (resched(key.key) && need_swap()) {
    40010368:	f9401c64 	ldr	x4, [x3, #56]
    4001036c:	f9400863 	ldr	x3, [x3, #16]
    40010370:	eb03009f 	cmp	x4, x3
    40010374:	54fffea0 	b.eq	40010348 <z_reschedule+0x8>  // b.none
		z_swap(lock, key);
    40010378:	17ffffb4 	b	40010248 <z_swap>

000000004001037c <z_sched_start>:
{
    4001037c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40010380:	910003fd 	mov	x29, sp
    40010384:	f9000bf3 	str	x19, [sp, #16]
MAKE_REG_HELPER(daif)
    40010388:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4001038c:	d50342df 	msr	daifset, #0x2
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    40010390:	39406402 	ldrb	w2, [x0, #25]
	if (z_has_thread_started(thread)) {
    40010394:	371000c2 	tbnz	w2, #2, 400103ac <z_sched_start+0x30>
MAKE_REG_HELPER(daif)
    40010398:	92407e73 	and	x19, x19, #0xffffffff
    4001039c:	d51b4233 	msr	daif, x19
}
    400103a0:	f9400bf3 	ldr	x19, [sp, #16]
    400103a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400103a8:	d65f03c0 	ret
	thread->base.thread_state &= ~_THREAD_PRESTART;
    400103ac:	121d7842 	and	w2, w2, #0xfffffffb
    400103b0:	39006402 	strb	w2, [x0, #25]
	ready_thread(thread);
    400103b4:	97fffddd 	bl	4000fb28 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    400103b8:	2a1303e1 	mov	w1, w19
    400103bc:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    400103c0:	912fb000 	add	x0, x0, #0xbec
}
    400103c4:	f9400bf3 	ldr	x19, [sp, #16]
    400103c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule(&sched_spinlock, key);
    400103cc:	17ffffdd 	b	40010340 <z_reschedule>

00000000400103d0 <z_impl_k_yield>:
{
    400103d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400103d4:	910003fd 	mov	x29, sp
    400103d8:	f9000bf3 	str	x19, [sp, #16]
    400103dc:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400103e0:	d50342df 	msr	daifset, #0x2
		dequeue_thread(_current);
    400103e4:	b0000083 	adrp	x3, 40021000 <k_sys_work_q+0x200>
    400103e8:	911d8063 	add	x3, x3, #0x760
    400103ec:	f9400860 	ldr	x0, [x3, #16]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    400103f0:	39406401 	ldrb	w1, [x0, #25]
    400103f4:	12001821 	and	w1, w1, #0x7f
    400103f8:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    400103fc:	97fffce8 	bl	4000f79c <sys_dlist_remove>
	queue_thread(_current);
    40010400:	f9400860 	ldr	x0, [x3, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40010404:	b0000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    40010408:	911e8042 	add	x2, x2, #0x7a0
	thread->base.thread_state |= _THREAD_QUEUED;
    4001040c:	39406401 	ldrb	w1, [x0, #25]
    40010410:	32196021 	orr	w1, w1, #0xffffff80
    40010414:	39006401 	strb	w1, [x0, #25]
	return list->head == list;
    40010418:	f9402061 	ldr	x1, [x3, #64]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4001041c:	eb02003f 	cmp	x1, x2
    40010420:	54000340 	b.eq	40010488 <z_impl_k_yield+0xb8>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    40010424:	b4000321 	cbz	x1, 40010488 <z_impl_k_yield+0xb8>
	int32_t b1 = thread_1->base.prio;
    40010428:	39c06805 	ldrsb	w5, [x0, #26]
	return (node == list->tail) ? NULL : node->next;
    4001042c:	f9402466 	ldr	x6, [x3, #72]
	int32_t b2 = thread_2->base.prio;
    40010430:	39c06824 	ldrsb	w4, [x1, #26]
	if (b1 != b2) {
    40010434:	6b0400bf 	cmp	w5, w4
    40010438:	54000200 	b.eq	40010478 <z_impl_k_yield+0xa8>  // b.none
		return b2 - b1;
    4001043c:	4b050084 	sub	w4, w4, w5
		if (z_sched_prio_cmp(thread, t) > 0) {
    40010440:	7100009f 	cmp	w4, #0x0
    40010444:	540001ad 	b.le	40010478 <z_impl_k_yield+0xa8>
	sys_dnode_t *const prev = successor->prev;
    40010448:	f9400422 	ldr	x2, [x1, #8]
	node->prev = prev;
    4001044c:	a9000801 	stp	x1, x2, [x0]
	prev->next = node;
    40010450:	f9000040 	str	x0, [x2]
	successor->prev = node;
    40010454:	f9000420 	str	x0, [x1, #8]
	update_cache(1);
    40010458:	52800020 	mov	w0, #0x1                   	// #1
    4001045c:	97fffd3f 	bl	4000f958 <update_cache>
	z_swap(&sched_spinlock, key);
    40010460:	2a1303e1 	mov	w1, w19
    40010464:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40010468:	912fb000 	add	x0, x0, #0xbec
}
    4001046c:	f9400bf3 	ldr	x19, [sp, #16]
    40010470:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_swap(&sched_spinlock, key);
    40010474:	17ffff75 	b	40010248 <z_swap>
	return (node == list->tail) ? NULL : node->next;
    40010478:	eb06003f 	cmp	x1, x6
    4001047c:	54000060 	b.eq	40010488 <z_impl_k_yield+0xb8>  // b.none
    40010480:	f9400021 	ldr	x1, [x1]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    40010484:	b5fffd61 	cbnz	x1, 40010430 <z_impl_k_yield+0x60>
	sys_dnode_t *const tail = list->tail;
    40010488:	f9402461 	ldr	x1, [x3, #72]
	node->prev = tail;
    4001048c:	a9000402 	stp	x2, x1, [x0]
	tail->next = node;
    40010490:	f9000020 	str	x0, [x1]
	list->tail = node;
    40010494:	f9002460 	str	x0, [x3, #72]
}
    40010498:	17fffff0 	b	40010458 <z_impl_k_yield+0x88>

000000004001049c <z_tick_sleep>:
{
    4001049c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400104a0:	910003fd 	mov	x29, sp
    400104a4:	a90153f3 	stp	x19, x20, [sp, #16]
    400104a8:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (ticks == 0) {
    400104ac:	b50000e0 	cbnz	x0, 400104c8 <z_tick_sleep+0x2c>
	z_impl_k_yield();
    400104b0:	97ffffc8 	bl	400103d0 <z_impl_k_yield>
		return 0;
    400104b4:	52800000 	mov	w0, #0x0                   	// #0
}
    400104b8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400104bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400104c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400104c4:	d65f03c0 	ret
    400104c8:	aa0003f4 	mov	x20, x0
	if (Z_TICK_ABS(ticks) <= 0) {
    400104cc:	92800033 	mov	x19, #0xfffffffffffffffe    	// #-2
    400104d0:	cb000260 	sub	x0, x19, x0
    400104d4:	f100001f 	cmp	x0, #0x0
    400104d8:	5400038c 	b.gt	40010548 <z_tick_sleep+0xac>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    400104dc:	94000175 	bl	40010ab0 <sys_clock_tick_get_32>
    400104e0:	0b140013 	add	w19, w0, w20
MAKE_REG_HELPER(daif)
    400104e4:	d53b4236 	mrs	x22, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400104e8:	d50342df 	msr	daifset, #0x2
	unready_thread(_current);
    400104ec:	b0000095 	adrp	x21, 40021000 <k_sys_work_q+0x200>
    400104f0:	911d82b5 	add	x21, x21, #0x760
    400104f4:	f9400aa0 	ldr	x0, [x21, #16]
    400104f8:	97fffdd7 	bl	4000fc54 <unready_thread>
	z_add_thread_timeout(_current, timeout);
    400104fc:	f9400aa0 	ldr	x0, [x21, #16]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    40010500:	aa1403e2 	mov	x2, x20
    40010504:	f0ffffe1 	adrp	x1, 4000f000 <z_impl_k_msgq_get+0xdc>
    40010508:	912fc021 	add	x1, x1, #0xbf0
    4001050c:	9100a000 	add	x0, x0, #0x28
    40010510:	940000b7 	bl	400107ec <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    40010514:	f9400aa1 	ldr	x1, [x21, #16]
	thread->base.thread_state |= _THREAD_SUSPENDED;
    40010518:	39406420 	ldrb	w0, [x1, #25]
    4001051c:	321c0000 	orr	w0, w0, #0x10
    40010520:	39006420 	strb	w0, [x1, #25]
	(void)z_swap(&sched_spinlock, key);
    40010524:	2a1603e1 	mov	w1, w22
    40010528:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4001052c:	912fb000 	add	x0, x0, #0xbec
    40010530:	97ffff46 	bl	40010248 <z_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    40010534:	9400015f 	bl	40010ab0 <sys_clock_tick_get_32>
    40010538:	cb204260 	sub	x0, x19, w0, uxtw
		return ticks;
    4001053c:	f100001f 	cmp	x0, #0x0
    40010540:	1a9fc000 	csel	w0, w0, wzr, gt
    40010544:	17ffffdd 	b	400104b8 <z_tick_sleep+0x1c>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
    40010548:	4b140273 	sub	w19, w19, w20
    4001054c:	17ffffe6 	b	400104e4 <z_tick_sleep+0x48>

0000000040010550 <z_impl_k_sleep>:
{
    40010550:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    40010554:	b100041f 	cmn	x0, #0x1
{
    40010558:	910003fd 	mov	x29, sp
    4001055c:	f9000bf3 	str	x19, [sp, #16]
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    40010560:	54000121 	b.ne	40010584 <z_impl_k_sleep+0x34>  // b.any
    40010564:	aa0003f3 	mov	x19, x0
		k_thread_suspend(_current);
    40010568:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    4001056c:	f943b800 	ldr	x0, [x0, #1904]
	z_impl_k_thread_suspend(thread);
    40010570:	97fffeeb 	bl	4001011c <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
    40010574:	2a1303e0 	mov	w0, w19
}
    40010578:	f9400bf3 	ldr	x19, [sp, #16]
    4001057c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40010580:	d65f03c0 	ret
	int32_t ret = k_ticks_to_ms_floor64(ticks);
    40010584:	52800153 	mov	w19, #0xa                   	// #10
	ticks = z_tick_sleep(ticks);
    40010588:	97ffffc5 	bl	4001049c <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
    4001058c:	1b137c00 	mul	w0, w0, w19
	return ret;
    40010590:	17fffffa 	b	40010578 <z_impl_k_sleep+0x28>

0000000040010594 <z_thread_abort>:
{
    40010594:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40010598:	910003fd 	mov	x29, sp
    4001059c:	a90153f3 	stp	x19, x20, [sp, #16]
    400105a0:	a9025bf5 	stp	x21, x22, [sp, #32]
MAKE_REG_HELPER(daif)
    400105a4:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400105a8:	d50342df 	msr	daifset, #0x2
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    400105ac:	39406401 	ldrb	w1, [x0, #25]
    400105b0:	361800e1 	tbz	w1, #3, 400105cc <z_thread_abort+0x38>
MAKE_REG_HELPER(daif)
    400105b4:	92407e94 	and	x20, x20, #0xffffffff
    400105b8:	d51b4234 	msr	daif, x20
}
    400105bc:	a94153f3 	ldp	x19, x20, [sp, #16]
    400105c0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400105c4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400105c8:	d65f03c0 	ret
		thread->base.thread_state &= ~_THREAD_ABORTING;
    400105cc:	121a7822 	and	w2, w1, #0xffffffdf
    400105d0:	aa0003f3 	mov	x19, x0
    400105d4:	321d0043 	orr	w3, w2, #0x8
		if (z_is_thread_queued(thread)) {
    400105d8:	373803c2 	tbnz	w2, #7, 40010650 <z_thread_abort+0xbc>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    400105dc:	39006403 	strb	w3, [x0, #25]
		if (thread->base.pended_on != NULL) {
    400105e0:	f9400a60 	ldr	x0, [x19, #16]
    400105e4:	b4000060 	cbz	x0, 400105f0 <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
    400105e8:	aa1303e0 	mov	x0, x19
    400105ec:	97fffc71 	bl	4000f7b0 <unpend_thread_no_timeout>

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    400105f0:	91030276 	add	x22, x19, #0xc0
	return z_abort_timeout(&thread->base.timeout);
    400105f4:	9100a260 	add	x0, x19, #0x28
    400105f8:	940000c4 	bl	40010908 <z_abort_timeout>
	return list->head == list;
    400105fc:	f9406275 	ldr	x21, [x19, #192]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40010600:	eb1602bf 	cmp	x21, x22
    40010604:	54000040 	b.eq	4001060c <z_thread_abort+0x78>  // b.none
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    40010608:	b5000315 	cbnz	x21, 40010668 <z_thread_abort+0xd4>
		update_cache(1);
    4001060c:	52800020 	mov	w0, #0x1                   	// #1
    40010610:	97fffcd2 	bl	4000f958 <update_cache>
		z_thread_monitor_exit(thread);
    40010614:	aa1303e0 	mov	x0, x19
    40010618:	97fff8e5 	bl	4000e9ac <z_thread_monitor_exit>
	if (thread == _current && !arch_is_in_isr()) {
    4001061c:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40010620:	f943b800 	ldr	x0, [x0, #1904]
    40010624:	eb13001f 	cmp	x0, x19
    40010628:	54fffc61 	b.ne	400105b4 <z_thread_abort+0x20>  // b.any
MAKE_REG_HELPER(tpidrro_el0);
    4001062c:	d53bd060 	mrs	x0, tpidrro_el0
    40010630:	927db000 	and	x0, x0, #0xfffffffffff8
    40010634:	b9400000 	ldr	w0, [x0]
    40010638:	35fffbe0 	cbnz	w0, 400105b4 <z_thread_abort+0x20>
		z_swap(&sched_spinlock, key);
    4001063c:	2a1403e1 	mov	w1, w20
    40010640:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40010644:	912fb000 	add	x0, x0, #0xbec
    40010648:	97ffff00 	bl	40010248 <z_swap>
    4001064c:	17ffffda 	b	400105b4 <z_thread_abort+0x20>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    40010650:	52800be2 	mov	w2, #0x5f                  	// #95
    40010654:	0a020021 	and	w1, w1, w2
    40010658:	321d0021 	orr	w1, w1, #0x8
    4001065c:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    40010660:	97fffc4f 	bl	4000f79c <sys_dlist_remove>
}
    40010664:	17ffffdf 	b	400105e0 <z_thread_abort+0x4c>
		unpend_thread_no_timeout(thread);
    40010668:	aa1503e0 	mov	x0, x21
    4001066c:	97fffc51 	bl	4000f7b0 <unpend_thread_no_timeout>
    40010670:	9100a2a0 	add	x0, x21, #0x28
    40010674:	940000a5 	bl	40010908 <z_abort_timeout>
    40010678:	b90142bf 	str	wzr, [x21, #320]
		ready_thread(thread);
    4001067c:	aa1503e0 	mov	x0, x21
    40010680:	97fffd2a 	bl	4000fb28 <ready_thread>
    40010684:	17ffffde 	b	400105fc <z_thread_abort+0x68>

0000000040010688 <z_impl_k_thread_abort>:
	z_thread_abort(thread);
    40010688:	17ffffc3 	b	40010594 <z_thread_abort>

000000004001068c <z_sched_thread_usage>:

uint64_t z_sched_thread_usage(struct k_thread *thread)
{
    4001068c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40010690:	910003fd 	mov	x29, sp
    40010694:	a90153f3 	stp	x19, x20, [sp, #16]
    40010698:	a9025bf5 	stp	x21, x22, [sp, #32]
    4001069c:	aa0003f5 	mov	x21, x0
MAKE_REG_HELPER(daif)
    400106a0:	d53b4236 	mrs	x22, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400106a4:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t k = k_spin_lock(&usage_lock);
	uint32_t u0 = _current_cpu->usage0, now = usage_now();
    400106a8:	b0000093 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    400106ac:	911d8273 	add	x19, x19, #0x760
    400106b0:	b9402a74 	ldr	w20, [x19, #40]
    400106b4:	97ffecdf 	bl	4000ba30 <arch_timing_counter_get>
    400106b8:	aa0003e1 	mov	x1, x0
	uint64_t ret = thread->base.usage;
    400106bc:	f94026a0 	ldr	x0, [x21, #72]

	if (u0 != 0) {
    400106c0:	340001d4 	cbz	w20, 400106f8 <z_sched_thread_usage+0x6c>
    400106c4:	7100003f 	cmp	w1, #0x0
		uint32_t dt = now - u0;

#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
		if (z_is_idle_thread_object(thread)) {
    400106c8:	90000083 	adrp	x3, 40020000 <logging_thread>
    400106cc:	911c0063 	add	x3, x3, #0x700
    400106d0:	1a9f1421 	csinc	w1, w1, wzr, ne  // ne = any
			_kernel.idle_thread_usage += dt;
    400106d4:	4b140022 	sub	w2, w1, w20
		if (z_is_idle_thread_object(thread)) {
    400106d8:	eb0302bf 	cmp	x21, x3
    400106dc:	540001a1 	b.ne	40010710 <z_sched_thread_usage+0x84>  // b.any
			_kernel.idle_thread_usage += dt;
    400106e0:	f9403663 	ldr	x3, [x19, #104]
    400106e4:	8b020063 	add	x3, x3, x2
    400106e8:	f9003663 	str	x3, [x19, #104]
		} else {
			_kernel.all_thread_usage += dt;
		}
#endif

		ret += dt;
    400106ec:	8b020000 	add	x0, x0, x2
		thread->base.usage = ret;
		_current_cpu->usage0 = now;
    400106f0:	b9002a61 	str	w1, [x19, #40]
		thread->base.usage = ret;
    400106f4:	f90026a0 	str	x0, [x21, #72]
MAKE_REG_HELPER(daif)
    400106f8:	92407ed6 	and	x22, x22, #0xffffffff
    400106fc:	d51b4236 	msr	daif, x22
	}

	k_spin_unlock(&usage_lock, k);
	return ret;
}
    40010700:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010704:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010708:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4001070c:	d65f03c0 	ret
			_kernel.all_thread_usage += dt;
    40010710:	f9403263 	ldr	x3, [x19, #96]
    40010714:	8b020063 	add	x3, x3, x2
    40010718:	f9003263 	str	x3, [x19, #96]
    4001071c:	17fffff4 	b	400106ec <z_sched_thread_usage+0x60>

0000000040010720 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    40010720:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40010724:	b9481800 	ldr	w0, [x0, #2072]
    40010728:	35000040 	cbnz	w0, 40010730 <elapsed+0x10>
    4001072c:	17fff699 	b	4000e190 <sys_clock_elapsed>
}
    40010730:	52800000 	mov	w0, #0x0                   	// #0
    40010734:	d65f03c0 	ret

0000000040010738 <next_timeout>:

static int32_t next_timeout(void)
{
    40010738:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return list->head == list;
    4001073c:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40010740:	91326001 	add	x1, x0, #0xc98
    40010744:	910003fd 	mov	x29, sp
    40010748:	f9000bf3 	str	x19, [sp, #16]
    4001074c:	f9464c13 	ldr	x19, [x0, #3224]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40010750:	eb01027f 	cmp	x19, x1
    40010754:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    40010758:	97fffff2 	bl	40010720 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
    4001075c:	b4000213 	cbz	x19, 4001079c <next_timeout+0x64>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    40010760:	f9400e61 	ldr	x1, [x19, #24]
    40010764:	cb20c020 	sub	x0, x1, w0, sxtw
	int32_t ret = to == NULL ? MAX_WAIT
    40010768:	f100001f 	cmp	x0, #0x0
    4001076c:	540001cd 	b.le	400107a4 <next_timeout+0x6c>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    40010770:	b2407be1 	mov	x1, #0x7fffffff            	// #2147483647
    40010774:	eb01001f 	cmp	x0, x1
	int32_t ret = to == NULL ? MAX_WAIT
    40010778:	9a81d000 	csel	x0, x0, x1, le

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    4001077c:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40010780:	b9478021 	ldr	w1, [x1, #1920]
    40010784:	34000061 	cbz	w1, 40010790 <next_timeout+0x58>
    40010788:	6b01001f 	cmp	w0, w1
    4001078c:	1a81d000 	csel	w0, w0, w1, le
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    40010790:	f9400bf3 	ldr	x19, [sp, #16]
    40010794:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40010798:	d65f03c0 	ret
	int32_t ret = to == NULL ? MAX_WAIT
    4001079c:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    400107a0:	17fffff7 	b	4001077c <next_timeout+0x44>
    400107a4:	52800000 	mov	w0, #0x0                   	// #0
    400107a8:	17fffff5 	b	4001077c <next_timeout+0x44>

00000000400107ac <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
    400107ac:	f9400001 	ldr	x1, [x0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    400107b0:	b4000140 	cbz	x0, 400107d8 <remove_timeout+0x2c>
	return (node == list->tail) ? NULL : node->next;
    400107b4:	f00002e2 	adrp	x2, 4006f000 <sys_work_q_stack+0xc10>
    400107b8:	f9465042 	ldr	x2, [x2, #3232]
    400107bc:	eb02001f 	cmp	x0, x2
    400107c0:	540000c0 	b.eq	400107d8 <remove_timeout+0x2c>  // b.none
	if (next(t) != NULL) {
    400107c4:	b40000a1 	cbz	x1, 400107d8 <remove_timeout+0x2c>
		next(t)->dticks += t->dticks;
    400107c8:	f9400c03 	ldr	x3, [x0, #24]
    400107cc:	f9400c22 	ldr	x2, [x1, #24]
    400107d0:	8b030042 	add	x2, x2, x3
    400107d4:	f9000c22 	str	x2, [x1, #24]
	sys_dnode_t *const prev = node->prev;
    400107d8:	f9400402 	ldr	x2, [x0, #8]
	prev->next = next;
    400107dc:	f9000041 	str	x1, [x2]
	next->prev = prev;
    400107e0:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
    400107e4:	a9007c1f 	stp	xzr, xzr, [x0]
}
    400107e8:	d65f03c0 	ret

00000000400107ec <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    400107ec:	b100045f 	cmn	x2, #0x1
    400107f0:	540008a0 	b.eq	40010904 <z_add_timeout+0x118>  // b.none
{
    400107f4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400107f8:	910003fd 	mov	x29, sp
    400107fc:	a90153f3 	stp	x19, x20, [sp, #16]
    40010800:	aa0003f3 	mov	x19, x0
    40010804:	aa0203f4 	mov	x20, x2
    40010808:	f90013f5 	str	x21, [sp, #32]
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    4001080c:	f9000801 	str	x1, [x0, #16]
    40010810:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010814:	d50342df 	msr	daifset, #0x2

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    40010818:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    4001081c:	eb02001f 	cmp	x0, x2
    40010820:	54000244 	b.mi	40010868 <z_add_timeout+0x7c>  // b.first
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    40010824:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40010828:	f943f022 	ldr	x2, [x1, #2016]
    4001082c:	cb020000 	sub	x0, x0, x2
    40010830:	cb140002 	sub	x2, x0, x20

			to->dticks = MAX(1, ticks);
    40010834:	f100005f 	cmp	x2, #0x0
    40010838:	9a9fc442 	csinc	x2, x2, xzr, gt
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    4001083c:	f9000e62 	str	x2, [x19, #24]
	return list->head == list;
    40010840:	f00002e2 	adrp	x2, 4006f000 <sys_work_q_stack+0xc10>
    40010844:	91326041 	add	x1, x2, #0xc98
    40010848:	f9464c40 	ldr	x0, [x2, #3224]
	sys_dnode_t *const tail = list->tail;
    4001084c:	f9400425 	ldr	x5, [x1, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40010850:	eb01001f 	cmp	x0, x1
    40010854:	540001c1 	b.ne	4001088c <z_add_timeout+0xa0>  // b.any
	node->prev = tail;
    40010858:	a9001661 	stp	x1, x5, [x19]
	tail->next = node;
    4001085c:	f90000b3 	str	x19, [x5]
	list->tail = node;
    40010860:	f9000433 	str	x19, [x1, #8]
}
    40010864:	14000015 	b	400108b8 <z_add_timeout+0xcc>
    40010868:	97ffffae 	bl	40010720 <elapsed>
    4001086c:	91000682 	add	x2, x20, #0x1
    40010870:	8b20c042 	add	x2, x2, w0, sxtw
    40010874:	17fffff2 	b	4001083c <z_add_timeout+0x50>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
    40010878:	cb040063 	sub	x3, x3, x4
    4001087c:	f9000e63 	str	x3, [x19, #24]
	return (node == list->tail) ? NULL : node->next;
    40010880:	eb0000bf 	cmp	x5, x0
    40010884:	54fffea0 	b.eq	40010858 <z_add_timeout+0x6c>  // b.none
    40010888:	f9400000 	ldr	x0, [x0]
		for (t = first(); t != NULL; t = next(t)) {
    4001088c:	b4fffe60 	cbz	x0, 40010858 <z_add_timeout+0x6c>
			if (t->dticks > to->dticks) {
    40010890:	f9400c04 	ldr	x4, [x0, #24]
    40010894:	f9400e63 	ldr	x3, [x19, #24]
    40010898:	eb03009f 	cmp	x4, x3
    4001089c:	54fffeed 	b.le	40010878 <z_add_timeout+0x8c>
				t->dticks -= to->dticks;
    400108a0:	cb030083 	sub	x3, x4, x3
    400108a4:	f9000c03 	str	x3, [x0, #24]
	sys_dnode_t *const prev = successor->prev;
    400108a8:	f9400403 	ldr	x3, [x0, #8]
	node->prev = prev;
    400108ac:	a9000e60 	stp	x0, x3, [x19]
	prev->next = node;
    400108b0:	f9000073 	str	x19, [x3]
	successor->prev = node;
    400108b4:	f9000413 	str	x19, [x0, #8]
	return list->head == list;
    400108b8:	f9464c40 	ldr	x0, [x2, #3224]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    400108bc:	eb01001f 	cmp	x0, x1
    400108c0:	54000160 	b.eq	400108ec <z_add_timeout+0x100>  // b.none

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    400108c4:	eb00027f 	cmp	x19, x0
    400108c8:	54000121 	b.ne	400108ec <z_add_timeout+0x100>  // b.any
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    400108cc:	97ffff9b 	bl	40010738 <next_timeout>

			if (next_time == 0 ||
    400108d0:	340000a0 	cbz	w0, 400108e4 <z_add_timeout+0xf8>
			    _current_cpu->slice_ticks != next_time) {
    400108d4:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
			if (next_time == 0 ||
    400108d8:	b9478021 	ldr	w1, [x1, #1920]
    400108dc:	6b00003f 	cmp	w1, w0
    400108e0:	54000060 	b.eq	400108ec <z_add_timeout+0x100>  // b.none
				sys_clock_set_timeout(next_time, false);
    400108e4:	52800001 	mov	w1, #0x0                   	// #0
    400108e8:	97fff604 	bl	4000e0f8 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    400108ec:	92407eb5 	and	x21, x21, #0xffffffff
    400108f0:	d51b4235 	msr	daif, x21
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    400108f4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400108f8:	f94013f5 	ldr	x21, [sp, #32]
    400108fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40010900:	d65f03c0 	ret
    40010904:	d65f03c0 	ret

0000000040010908 <z_abort_timeout>:
    40010908:	d53b4224 	mrs	x4, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4001090c:	d50342df 	msr	daifset, #0x2
int z_abort_timeout(struct _timeout *to)
{
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    40010910:	f9400001 	ldr	x1, [x0]
    40010914:	b4000121 	cbz	x1, 40010938 <z_abort_timeout+0x30>
{
    40010918:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER(daif)
    4001091c:	92407c84 	and	x4, x4, #0xffffffff
    40010920:	910003fd 	mov	x29, sp
			remove_timeout(to);
    40010924:	97ffffa2 	bl	400107ac <remove_timeout>
			ret = 0;
    40010928:	52800000 	mov	w0, #0x0                   	// #0
    4001092c:	d51b4224 	msr	daif, x4
		}
	}

	return ret;
}
    40010930:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40010934:	d65f03c0 	ret
	int ret = -EINVAL;
    40010938:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4001093c:	92407c84 	and	x4, x4, #0xffffffff
    40010940:	d51b4224 	msr	daif, x4
}
    40010944:	d65f03c0 	ret

0000000040010948 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    40010948:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4001094c:	910003fd 	mov	x29, sp
    40010950:	a90153f3 	stp	x19, x20, [sp, #16]
    40010954:	2a0003f3 	mov	w19, w0
    40010958:	f90013f5 	str	x21, [sp, #32]
    4001095c:	12001c35 	and	w21, w1, #0xff
    40010960:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010964:	d50342df 	msr	daifset, #0x2
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    40010968:	97ffff74 	bl	40010738 <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    4001096c:	6b13001f 	cmp	w0, w19
    40010970:	3a41b804 	ccmn	w0, #0x1, #0x4, lt  // lt = tstop
    40010974:	7a410804 	ccmp	w0, #0x1, #0x4, eq  // eq = none
    40010978:	540000ad 	b.le	4001098c <z_set_timeout_expiry+0x44>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    4001097c:	6b13001f 	cmp	w0, w19
    40010980:	2a1503e1 	mov	w1, w21
    40010984:	1a93d000 	csel	w0, w0, w19, le
    40010988:	97fff5dc 	bl	4000e0f8 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    4001098c:	92407e94 	and	x20, x20, #0xffffffff
    40010990:	d51b4234 	msr	daif, x20
		}
	}
}
    40010994:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010998:	f94013f5 	ldr	x21, [sp, #32]
    4001099c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400109a0:	d65f03c0 	ret

00000000400109a4 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    400109a4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400109a8:	910003fd 	mov	x29, sp
    400109ac:	a90153f3 	stp	x19, x20, [sp, #16]
    400109b0:	a9025bf5 	stp	x21, x22, [sp, #32]
    400109b4:	2a0003f5 	mov	w21, w0
    400109b8:	a90363f7 	stp	x23, x24, [sp, #48]
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    400109bc:	97fffc31 	bl	4000fa80 <z_time_slice>
    400109c0:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400109c4:	d50342df 	msr	daifset, #0x2
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    400109c8:	b0000094 	adrp	x20, 40021000 <k_sys_work_q+0x200>

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    400109cc:	b0000096 	adrp	x22, 40021000 <k_sys_work_q+0x200>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    400109d0:	91206297 	add	x23, x20, #0x818
    400109d4:	aa1603f8 	mov	x24, x22
	announce_remaining = ticks;
    400109d8:	b9081a95 	str	w21, [x20, #2072]
	return list->head == list;
    400109dc:	f00002f5 	adrp	x21, 4006f000 <sys_work_q_stack+0xc10>
    400109e0:	913262b5 	add	x21, x21, #0xc98
	while (first() != NULL && first()->dticks <= announce_remaining) {
    400109e4:	b94002e4 	ldr	w4, [x23]
	return key;
}

static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	write_daif(key);
    400109e8:	2a1303f3 	mov	w19, w19
    400109ec:	f94002a0 	ldr	x0, [x21]
		curr_tick += dt;
    400109f0:	f943f2c3 	ldr	x3, [x22, #2016]
    400109f4:	93407c82 	sxtw	x2, w4
	return sys_dlist_is_empty(list) ? NULL : list->head;
    400109f8:	eb15001f 	cmp	x0, x21
    400109fc:	540000e0 	b.eq	40010a18 <sys_clock_announce+0x74>  // b.none
	while (first() != NULL && first()->dticks <= announce_remaining) {
    40010a00:	b40000c0 	cbz	x0, 40010a18 <sys_clock_announce+0x74>
    40010a04:	f9400c01 	ldr	x1, [x0, #24]
    40010a08:	eb02003f 	cmp	x1, x2
    40010a0c:	540001ed 	b.le	40010a48 <sys_clock_announce+0xa4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    40010a10:	cb020021 	sub	x1, x1, x2
    40010a14:	f9000c01 	str	x1, [x0, #24]
	}

	curr_tick += announce_remaining;
    40010a18:	8b030042 	add	x2, x2, x3
	announce_remaining = 0;
    40010a1c:	b9081a9f 	str	wzr, [x20, #2072]
	curr_tick += announce_remaining;
    40010a20:	f903f302 	str	x2, [x24, #2016]

	sys_clock_set_timeout(next_timeout(), false);
    40010a24:	97ffff45 	bl	40010738 <next_timeout>
    40010a28:	52800001 	mov	w1, #0x0                   	// #0
    40010a2c:	97fff5b3 	bl	4000e0f8 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    40010a30:	d51b4233 	msr	daif, x19

	k_spin_unlock(&timeout_lock, key);
}
    40010a34:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010a38:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010a3c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40010a40:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40010a44:	d65f03c0 	ret
		curr_tick += dt;
    40010a48:	8b21c062 	add	x2, x3, w1, sxtw
		announce_remaining -= dt;
    40010a4c:	4b010081 	sub	w1, w4, w1
		t->dticks = 0;
    40010a50:	f9000c1f 	str	xzr, [x0, #24]
		curr_tick += dt;
    40010a54:	f903f2c2 	str	x2, [x22, #2016]
		announce_remaining -= dt;
    40010a58:	b90002e1 	str	w1, [x23]
		remove_timeout(t);
    40010a5c:	97ffff54 	bl	400107ac <remove_timeout>
    40010a60:	d51b4233 	msr	daif, x19
		t->fn(t);
    40010a64:	f9400801 	ldr	x1, [x0, #16]
    40010a68:	d63f0020 	blr	x1
    40010a6c:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010a70:	d50342df 	msr	daifset, #0x2
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    40010a74:	17ffffdc 	b	400109e4 <sys_clock_announce+0x40>

0000000040010a78 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    40010a78:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40010a7c:	910003fd 	mov	x29, sp
    40010a80:	f9000bf3 	str	x19, [sp, #16]
MAKE_REG_HELPER(daif)
    40010a84:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010a88:	d50342df 	msr	daifset, #0x2
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
    40010a8c:	97fff5c1 	bl	4000e190 <sys_clock_elapsed>
MAKE_REG_HELPER(daif)
    40010a90:	92407e73 	and	x19, x19, #0xffffffff
    40010a94:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40010a98:	f943f021 	ldr	x1, [x1, #2016]
    40010a9c:	8b204020 	add	x0, x1, w0, uxtw
    40010aa0:	d51b4233 	msr	daif, x19
	}
	return t;
}
    40010aa4:	f9400bf3 	ldr	x19, [sp, #16]
    40010aa8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40010aac:	d65f03c0 	ret

0000000040010ab0 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    40010ab0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40010ab4:	910003fd 	mov	x29, sp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    40010ab8:	97fffff0 	bl	40010a78 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    40010abc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40010ac0:	d65f03c0 	ret

0000000040010ac4 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
    40010ac4:	17ffffed 	b	40010a78 <sys_clock_tick_get>

0000000040010ac8 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    40010ac8:	34000040 	cbz	w0, 40010ad0 <z_impl_k_busy_wait+0x8>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    40010acc:	17fff5bf 	b	4000e1c8 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    40010ad0:	d65f03c0 	ret

0000000040010ad4 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
    40010ad4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40010ad8:	910003fd 	mov	x29, sp
    40010adc:	a90153f3 	stp	x19, x20, [sp, #16]
    40010ae0:	aa0003f3 	mov	x19, x0
    40010ae4:	f90013f5 	str	x21, [sp, #32]
    40010ae8:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010aec:	d50342df 	msr	daifset, #0x2

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
    40010af0:	f9402002 	ldr	x2, [x0, #64]
    40010af4:	91000441 	add	x1, x2, #0x1
    40010af8:	f100043f 	cmp	x1, #0x1
    40010afc:	54000089 	b.ls	40010b0c <z_timer_expiration_handler+0x38>  // b.plast
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    40010b00:	90000001 	adrp	x1, 40010000 <z_sched_usage_stop+0x1c>
    40010b04:	912b5021 	add	x1, x1, #0xad4
    40010b08:	97ffff39 	bl	400107ec <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
    40010b0c:	b9404a60 	ldr	w0, [x19, #72]
    40010b10:	11000400 	add	w0, w0, #0x1
    40010b14:	b9004a60 	str	w0, [x19, #72]

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
    40010b18:	f9401a60 	ldr	x0, [x19, #48]
    40010b1c:	b4000100 	cbz	x0, 40010b3c <z_timer_expiration_handler+0x68>
MAKE_REG_HELPER(daif)
    40010b20:	92407e94 	and	x20, x20, #0xffffffff
    40010b24:	d51b4234 	msr	daif, x20
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
    40010b28:	f9401a61 	ldr	x1, [x19, #48]
    40010b2c:	aa1303e0 	mov	x0, x19
    40010b30:	d63f0020 	blr	x1
    40010b34:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010b38:	d50342df 	msr	daifset, #0x2
	return list->head == list;
    40010b3c:	f8420e75 	ldr	x21, [x19, #32]!
    40010b40:	2a1403f4 	mov	w20, w20
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40010b44:	eb1302bf 	cmp	x21, x19
    40010b48:	54000040 	b.eq	40010b50 <z_timer_expiration_handler+0x7c>  // b.none
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
    40010b4c:	b50000d5 	cbnz	x21, 40010b64 <z_timer_expiration_handler+0x90>
MAKE_REG_HELPER(daif)
    40010b50:	d51b4234 	msr	daif, x20
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
    40010b54:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010b58:	f94013f5 	ldr	x21, [sp, #32]
    40010b5c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40010b60:	d65f03c0 	ret
	z_unpend_thread_no_timeout(thread);
    40010b64:	aa1503e0 	mov	x0, x21
    40010b68:	97fffb57 	bl	4000f8c4 <z_unpend_thread_no_timeout>
    40010b6c:	b90142bf 	str	wzr, [x21, #320]
    40010b70:	d51b4234 	msr	daif, x20
	z_ready_thread(thread);
    40010b74:	aa1503e0 	mov	x0, x21
}
    40010b78:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010b7c:	f94013f5 	ldr	x21, [sp, #32]
    40010b80:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_ready_thread(thread);
    40010b84:	17fffc10 	b	4000fbc4 <z_ready_thread>

0000000040010b88 <k_timer_init>:
	node->prev = NULL;
    40010b88:	a9007c1f 	stp	xzr, xzr, [x0]
void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
	timer->stop_fn = stop_fn;
    40010b8c:	a9030801 	stp	x1, x2, [x0, #48]
	sys_dlist_init(&w->waitq);
    40010b90:	91008001 	add	x1, x0, #0x20
	list->tail = (sys_dnode_t *)list;
    40010b94:	a9020401 	stp	x1, x1, [x0, #32]
	timer->status = 0U;
    40010b98:	b900481f 	str	wzr, [x0, #72]

	z_init_timeout(&timer->timeout);

	SYS_PORT_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
    40010b9c:	f900281f 	str	xzr, [x0, #80]

	z_object_init(timer);
}
    40010ba0:	d65f03c0 	ret

0000000040010ba4 <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
    40010ba4:	b100043f 	cmn	x1, #0x1
    40010ba8:	54000440 	b.eq	40010c30 <z_impl_k_timer_start+0x8c>  // b.none
{
    40010bac:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    40010bb0:	b100045f 	cmn	x2, #0x1
{
    40010bb4:	910003fd 	mov	x29, sp
    40010bb8:	a90153f3 	stp	x19, x20, [sp, #16]
    40010bbc:	aa0003f4 	mov	x20, x0
    40010bc0:	aa0203f3 	mov	x19, x2
    40010bc4:	f90013f5 	str	x21, [sp, #32]
    40010bc8:	aa0103f5 	mov	x21, x1
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    40010bcc:	54000100 	b.eq	40010bec <z_impl_k_timer_start+0x48>  // b.none
    40010bd0:	b40000e2 	cbz	x2, 40010bec <z_impl_k_timer_start+0x48>
    40010bd4:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    40010bd8:	eb02001f 	cmp	x0, x2
    40010bdc:	54000085 	b.pl	40010bec <z_impl_k_timer_start+0x48>  // b.nfrst
	    Z_TICK_ABS(period.ticks) < 0) {
		period.ticks = MAX(period.ticks - 1, 1);
    40010be0:	d1000453 	sub	x19, x2, #0x1
    40010be4:	f100027f 	cmp	x19, #0x0
    40010be8:	9a9fc673 	csinc	x19, x19, xzr, gt
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
    40010bec:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    40010bf0:	eb01001f 	cmp	x0, x1
    40010bf4:	54000065 	b.pl	40010c00 <z_impl_k_timer_start+0x5c>  // b.nfrst
		duration.ticks = MAX(duration.ticks - 1, 0);
    40010bf8:	f1000435 	subs	x21, x1, #0x1
    40010bfc:	9a9f52b5 	csel	x21, x21, xzr, pl  // pl = nfrst
	}

	(void)z_abort_timeout(&timer->timeout);
    40010c00:	aa1403e0 	mov	x0, x20
    40010c04:	97ffff41 	bl	40010908 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    40010c08:	aa1503e2 	mov	x2, x21
    40010c0c:	aa1403e0 	mov	x0, x20
		     duration);
}
    40010c10:	f94013f5 	ldr	x21, [sp, #32]
	timer->period = period;
    40010c14:	f9002293 	str	x19, [x20, #64]
	timer->status = 0U;
    40010c18:	b9004a9f 	str	wzr, [x20, #72]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    40010c1c:	90000001 	adrp	x1, 40010000 <z_sched_usage_stop+0x1c>
    40010c20:	912b5021 	add	x1, x1, #0xad4
}
    40010c24:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010c28:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    40010c2c:	17fffef0 	b	400107ec <z_add_timeout>
    40010c30:	d65f03c0 	ret

0000000040010c34 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
    40010c34:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40010c38:	910003fd 	mov	x29, sp
    40010c3c:	f9000bf3 	str	x19, [sp, #16]
    40010c40:	aa0003f3 	mov	x19, x0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
    40010c44:	97ffff31 	bl	40010908 <z_abort_timeout>

	if (inactive) {
    40010c48:	350001c0 	cbnz	w0, 40010c80 <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
    40010c4c:	f9401e61 	ldr	x1, [x19, #56]
    40010c50:	b4000061 	cbz	x1, 40010c5c <z_impl_k_timer_stop+0x28>
		timer->stop_fn(timer);
    40010c54:	aa1303e0 	mov	x0, x19
    40010c58:	d63f0020 	blr	x1
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
    40010c5c:	91008260 	add	x0, x19, #0x20
    40010c60:	97fffc8b 	bl	4000fe8c <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
    40010c64:	b40000e0 	cbz	x0, 40010c80 <z_impl_k_timer_stop+0x4c>
			z_ready_thread(pending_thread);
    40010c68:	97fffbd7 	bl	4000fbc4 <z_ready_thread>
    40010c6c:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010c70:	d50342df 	msr	daifset, #0x2
			z_reschedule_unlocked();
		}
	}
}
    40010c74:	f9400bf3 	ldr	x19, [sp, #16]
    40010c78:	a8c27bfd 	ldp	x29, x30, [sp], #32
	(void) z_reschedule_irqlock(arch_irq_lock());
    40010c7c:	17fffd1c 	b	400100ec <z_reschedule_irqlock>
    40010c80:	f9400bf3 	ldr	x19, [sp, #16]
    40010c84:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40010c88:	d65f03c0 	ret

0000000040010c8c <virt_region_free>:

	virt_region_inited = true;
}

static void virt_region_free(void *vaddr, size_t size)
{
    40010c8c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40010c90:	910003fd 	mov	x29, sp
    40010c94:	a90153f3 	stp	x19, x20, [sp, #16]
    40010c98:	aa0003f4 	mov	x20, x0
    40010c9c:	aa0103f3 	mov	x19, x1
    40010ca0:	a9025bf5 	stp	x21, x22, [sp, #32]
	size_t offset, num_bits;
	uint8_t *vaddr_u8 = (uint8_t *)vaddr;

	if (unlikely(!virt_region_inited)) {
    40010ca4:	b0000096 	adrp	x22, 40021000 <k_sys_work_q+0x200>
    40010ca8:	396fb2c0 	ldrb	w0, [x22, #3052]
    40010cac:	90000315 	adrp	x21, 40070000 <_end>
    40010cb0:	910002b5 	add	x21, x21, #0x0
    40010cb4:	35000180 	cbnz	w0, 40010ce4 <virt_region_free+0x58>
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    40010cb8:	b26287e1 	mov	x1, #0xffffffffc0000000    	// #-1073741824
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    40010cbc:	d2a81002 	mov	x2, #0x40800000            	// #1082130432
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    40010cc0:	8b0102a1 	add	x1, x21, x1
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    40010cc4:	cb150042 	sub	x2, x2, x21
	(void)sys_bitarray_set_region(&virt_region_bitmap,
    40010cc8:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40010ccc:	9132a000 	add	x0, x0, #0xca8
    40010cd0:	d34cfc42 	lsr	x2, x2, #12
    40010cd4:	d34cfc21 	lsr	x1, x1, #12
    40010cd8:	97ffc676 	bl	400026b0 <sys_bitarray_set_region>
	virt_region_inited = true;
    40010cdc:	52800020 	mov	w0, #0x1                   	// #1
    40010ce0:	392fb2c0 	strb	w0, [x22, #3052]
	}

	__ASSERT((vaddr_u8 >= Z_VIRT_REGION_START_ADDR)
		 && ((vaddr_u8 + size) < Z_VIRT_REGION_END_ADDR),
		 "invalid virtual address region %p (%zu)", vaddr_u8, size);
	if (!((vaddr_u8 >= Z_VIRT_REGION_START_ADDR)
    40010ce4:	eb15029f 	cmp	x20, x21
    40010ce8:	54000203 	b.cc	40010d28 <virt_region_free+0x9c>  // b.lo, b.ul, b.last
	      && ((vaddr_u8 + size) < Z_VIRT_REGION_END_ADDR))) {
    40010cec:	8b130281 	add	x1, x20, x19
	if (!((vaddr_u8 >= Z_VIRT_REGION_START_ADDR)
    40010cf0:	12b7f000 	mov	w0, #0x407fffff            	// #1082130431
    40010cf4:	eb00003f 	cmp	x1, x0
    40010cf8:	54000188 	b.hi	40010d28 <virt_region_free+0x9c>  // b.pmore
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    40010cfc:	d2a81002 	mov	x2, #0x40800000            	// #1082130432
    40010d00:	cb130042 	sub	x2, x2, x19
    40010d04:	cb140042 	sub	x2, x2, x20
		return;
	}

	offset = virt_to_bitmap_offset(vaddr, size);
	num_bits = size / CONFIG_MMU_PAGE_SIZE;
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    40010d08:	d34cfe61 	lsr	x1, x19, #12
}
    40010d0c:	a94153f3 	ldp	x19, x20, [sp, #16]
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    40010d10:	d34cfc42 	lsr	x2, x2, #12
}
    40010d14:	a9425bf5 	ldp	x21, x22, [sp, #32]
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    40010d18:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40010d1c:	9132a000 	add	x0, x0, #0xca8
}
    40010d20:	a8c37bfd 	ldp	x29, x30, [sp], #48
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    40010d24:	17ffc639 	b	40002608 <sys_bitarray_free>
}
    40010d28:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010d2c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010d30:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40010d34:	d65f03c0 	ret

0000000040010d38 <free_page_frame_list_put>:
	return list->tail;
    40010d38:	b0000083 	adrp	x3, 40021000 <k_sys_work_q+0x200>
    40010d3c:	911fa061 	add	x1, x3, #0x7e8
    40010d40:	f9400422 	ldr	x2, [x1, #8]
	parent->next = child;
    40010d44:	f900001f 	str	xzr, [x0]
Z_GENLIST_APPEND(slist, snode)
    40010d48:	b5000102 	cbnz	x2, 40010d68 <free_page_frame_list_put+0x30>
	list->head = node;
    40010d4c:	f903f460 	str	x0, [x3, #2024]
	list->tail = node;
    40010d50:	f9000420 	str	x0, [x1, #8]
static void free_page_frame_list_put(struct z_page_frame *pf)
{
	PF_ASSERT(pf, z_page_frame_is_available(pf),
		 "unavailable page put on free list");
	sys_slist_append(&free_page_frame_list, &pf->node);
	z_free_page_count++;
    40010d54:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x200>
    40010d58:	f943fc20 	ldr	x0, [x1, #2040]
    40010d5c:	91000400 	add	x0, x0, #0x1
    40010d60:	f903fc20 	str	x0, [x1, #2040]
}
    40010d64:	d65f03c0 	ret
	parent->next = child;
    40010d68:	f9000040 	str	x0, [x2]
	list->tail = node;
    40010d6c:	f9000420 	str	x0, [x1, #8]
}
    40010d70:	17fffff9 	b	40010d54 <free_page_frame_list_put+0x1c>

0000000040010d74 <virt_region_alloc>:
{
    40010d74:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40010d78:	910003fd 	mov	x29, sp
    40010d7c:	a90153f3 	stp	x19, x20, [sp, #16]
    40010d80:	a9025bf5 	stp	x21, x22, [sp, #32]
    40010d84:	aa0003f5 	mov	x21, x0
	if (unlikely(!virt_region_inited)) {
    40010d88:	b0000093 	adrp	x19, 40021000 <k_sys_work_q+0x200>
    40010d8c:	396fb260 	ldrb	w0, [x19, #3052]
{
    40010d90:	aa0103f6 	mov	x22, x1
    40010d94:	a90363f7 	stp	x23, x24, [sp, #48]
    40010d98:	f00002f7 	adrp	x23, 4006f000 <sys_work_q_stack+0xc10>
    40010d9c:	9132a2f7 	add	x23, x23, #0xca8
	if (unlikely(!virt_region_inited)) {
    40010da0:	350001a0 	cbnz	w0, 40010dd4 <virt_region_alloc+0x60>
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    40010da4:	90000302 	adrp	x2, 40070000 <_end>
    40010da8:	91000042 	add	x2, x2, #0x0
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    40010dac:	d2a81000 	mov	x0, #0x40800000            	// #1082130432
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    40010db0:	b26287e1 	mov	x1, #0xffffffffc0000000    	// #-1073741824
    40010db4:	8b010041 	add	x1, x2, x1
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    40010db8:	cb020002 	sub	x2, x0, x2
	(void)sys_bitarray_set_region(&virt_region_bitmap,
    40010dbc:	aa1703e0 	mov	x0, x23
    40010dc0:	d34cfc42 	lsr	x2, x2, #12
    40010dc4:	d34cfc21 	lsr	x1, x1, #12
    40010dc8:	97ffc63a 	bl	400026b0 <sys_bitarray_set_region>
	virt_region_inited = true;
    40010dcc:	52800020 	mov	w0, #0x1                   	// #1
    40010dd0:	392fb260 	strb	w0, [x19, #3052]
	num_bits = (size + align - CONFIG_MMU_PAGE_SIZE) / CONFIG_MMU_PAGE_SIZE;
    40010dd4:	d14006c1 	sub	x1, x22, #0x1, lsl #12
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
    40010dd8:	910123e2 	add	x2, sp, #0x48
	num_bits = (size + align - CONFIG_MMU_PAGE_SIZE) / CONFIG_MMU_PAGE_SIZE;
    40010ddc:	8b150021 	add	x1, x1, x21
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
    40010de0:	aa1703e0 	mov	x0, x23
	alloc_size = num_bits * CONFIG_MMU_PAGE_SIZE;
    40010de4:	9274cc38 	and	x24, x1, #0xfffffffffffff000
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
    40010de8:	d34cfc21 	lsr	x1, x1, #12
    40010dec:	97ffc5c2 	bl	400024f4 <sys_bitarray_alloc>
	if (ret != 0) {
    40010df0:	340002c0 	cbz	w0, 40010e48 <virt_region_alloc+0xd4>
		LOG_ERR("insufficient virtual address space (requested %zu)",
    40010df4:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40010df8:	91337002 	add	x2, x0, #0xcdc
    40010dfc:	b94cdc00 	ldr	w0, [x0, #3292]
    40010e00:	f240081f 	tst	x0, #0x7
    40010e04:	54000160 	b.eq	40010e30 <virt_region_alloc+0xbc>  // b.none
    40010e08:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40010e0c:	91334000 	add	x0, x0, #0xcd0
    40010e10:	cb000042 	sub	x2, x2, x0
    40010e14:	aa1503e1 	mov	x1, x21
    40010e18:	d0000020 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    40010e1c:	91230400 	add	x0, x0, #0x8c1
    40010e20:	d342fc42 	lsr	x2, x2, #2
    40010e24:	531a2442 	ubfiz	w2, w2, #6, #10
    40010e28:	32000042 	orr	w2, w2, #0x1
    40010e2c:	97ffceac 	bl	400048dc <log_1>
		return NULL;
    40010e30:	d2800000 	mov	x0, #0x0                   	// #0
}
    40010e34:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010e38:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010e3c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40010e40:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40010e44:	d65f03c0 	ret
	       - (offset * CONFIG_MMU_PAGE_SIZE) - size;
    40010e48:	f94027e0 	ldr	x0, [sp, #72]
    40010e4c:	d2810014 	mov	x20, #0x800                 	// #2048
    40010e50:	f2a00094 	movk	x20, #0x4, lsl #16
	if (alloc_size > size) {
    40010e54:	eb15031f 	cmp	x24, x21
	       - (offset * CONFIG_MMU_PAGE_SIZE) - size;
    40010e58:	cb000294 	sub	x20, x20, x0
    40010e5c:	d374ce94 	lsl	x20, x20, #12
    40010e60:	cb180280 	sub	x0, x20, x24
	if (alloc_size > size) {
    40010e64:	540002e9 	b.ls	40010ec0 <virt_region_alloc+0x14c>  // b.plast
		uintptr_t aligned_dest_addr = ROUND_UP(dest_addr, align);
    40010e68:	d10006d3 	sub	x19, x22, #0x1
    40010e6c:	cb1603f6 	neg	x22, x22
    40010e70:	8b000273 	add	x19, x19, x0
		virt_region_free(UINT_TO_POINTER(dest_addr),
    40010e74:	cb140301 	sub	x1, x24, x20
		uintptr_t aligned_dest_addr = ROUND_UP(dest_addr, align);
    40010e78:	8a160273 	and	x19, x19, x22
		virt_region_free(UINT_TO_POINTER(dest_addr),
    40010e7c:	8b130021 	add	x1, x1, x19
    40010e80:	97ffff83 	bl	40010c8c <virt_region_free>
		if (((dest_addr + alloc_size) - (aligned_dest_addr + size)) > 0) {
    40010e84:	8b150260 	add	x0, x19, x21
    40010e88:	eb00029f 	cmp	x20, x0
    40010e8c:	54000060 	b.eq	40010e98 <virt_region_alloc+0x124>  // b.none
			virt_region_free(UINT_TO_POINTER(aligned_dest_addr + size),
    40010e90:	cb000281 	sub	x1, x20, x0
    40010e94:	97ffff7e 	bl	40010c8c <virt_region_free>
	if (dest_addr < POINTER_TO_UINT(Z_VIRT_REGION_START_ADDR)) {
    40010e98:	90000301 	adrp	x1, 40070000 <_end>
    40010e9c:	91000021 	add	x1, x1, #0x0
	return UINT_TO_POINTER(dest_addr);
    40010ea0:	aa1303e0 	mov	x0, x19
	if (dest_addr < POINTER_TO_UINT(Z_VIRT_REGION_START_ADDR)) {
    40010ea4:	eb01027f 	cmp	x19, x1
    40010ea8:	54fffc62 	b.cs	40010e34 <virt_region_alloc+0xc0>  // b.hs, b.nlast
		(void)sys_bitarray_free(&virt_region_bitmap, size, offset);
    40010eac:	f94027e2 	ldr	x2, [sp, #72]
    40010eb0:	aa1503e1 	mov	x1, x21
    40010eb4:	aa1703e0 	mov	x0, x23
    40010eb8:	97ffc5d4 	bl	40002608 <sys_bitarray_free>
		return NULL;
    40010ebc:	17ffffdd 	b	40010e30 <virt_region_alloc+0xbc>
	dest_addr = virt_from_bitmap_offset(offset, alloc_size);
    40010ec0:	aa0003f3 	mov	x19, x0
    40010ec4:	17fffff5 	b	40010e98 <virt_region_alloc+0x124>

0000000040010ec8 <z_phys_map>:
/* This may be called from arch early boot code before z_cstart() is invoked.
 * Data will be copied and BSS zeroed, but this must not rely on any
 * initialization functions being called prior to work correctly.
 */
void z_phys_map(uint8_t **virt_ptr, uintptr_t phys, size_t size, uint32_t flags)
{
    40010ec8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40010ecc:	910003fd 	mov	x29, sp
    40010ed0:	a9046bf9 	stp	x25, x26, [sp, #64]

	/* The actual mapped region must be page-aligned. Round down the
	 * physical address and pad the region size appropriately
	 */
	*aligned_addr = ROUND_DOWN(addr, align);
	addr_offset = addr - *aligned_addr;
    40010ed4:	92402c39 	and	x25, x1, #0xfff
{
    40010ed8:	a90153f3 	stp	x19, x20, [sp, #16]
	*aligned_size = ROUND_UP(size + addr_offset, align);
    40010edc:	8b020333 	add	x19, x25, x2
    40010ee0:	913ffe73 	add	x19, x19, #0xfff
    40010ee4:	9274ce73 	and	x19, x19, #0xfffffffffffff000
{
    40010ee8:	a9025bf5 	stp	x21, x22, [sp, #32]
    40010eec:	aa0103f5 	mov	x21, x1
    40010ef0:	f9002bfb 	str	x27, [sp, #80]
	*aligned_addr = ROUND_DOWN(addr, align);
    40010ef4:	9274cc3b 	and	x27, x1, #0xfffffffffffff000
	align_boundary = arch_virt_region_align(aligned_phys, aligned_size);
    40010ef8:	aa1303e1 	mov	x1, x19
{
    40010efc:	aa0203f6 	mov	x22, x2
    40010f00:	a90363f7 	stp	x23, x24, [sp, #48]
    40010f04:	aa0003f7 	mov	x23, x0
    40010f08:	2a0303f8 	mov	w24, w3
	align_boundary = arch_virt_region_align(aligned_phys, aligned_size);
    40010f0c:	aa1b03e0 	mov	x0, x27
    40010f10:	97ffeefc 	bl	4000cb00 <arch_virt_region_align>
    40010f14:	aa0003e1 	mov	x1, x0
MAKE_REG_HELPER(daif)
    40010f18:	d53b423a 	mrs	x26, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010f1c:	d50342df 	msr	daifset, #0x2
	dest_addr = virt_region_alloc(aligned_size, align_boundary);
    40010f20:	aa1303e0 	mov	x0, x19
    40010f24:	97ffff94 	bl	40010d74 <virt_region_alloc>
	if (!dest_addr) {
    40010f28:	b50002a0 	cbnz	x0, 40010f7c <z_phys_map+0xb4>
	LOG_ERR("memory mapping 0x%lx (size %zu, flags 0x%x) failed",
    40010f2c:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40010f30:	91337004 	add	x4, x0, #0xcdc
    40010f34:	b94cdc00 	ldr	w0, [x0, #3292]
    40010f38:	f240081f 	tst	x0, #0x7
    40010f3c:	540001a0 	b.eq	40010f70 <z_phys_map+0xa8>  // b.none
    40010f40:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xc10>
    40010f44:	91334000 	add	x0, x0, #0xcd0
    40010f48:	cb000084 	sub	x4, x4, x0
    40010f4c:	2a1803e3 	mov	w3, w24
    40010f50:	d0000020 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    40010f54:	9123d000 	add	x0, x0, #0x8f4
    40010f58:	d342fc84 	lsr	x4, x4, #2
    40010f5c:	aa1603e2 	mov	x2, x22
    40010f60:	aa1503e1 	mov	x1, x21
    40010f64:	531a2484 	ubfiz	w4, w4, #6, #10
    40010f68:	32000084 	orr	w4, w4, #0x1
    40010f6c:	97ffce8c 	bl	4000499c <log_3>
	k_panic();
    40010f70:	d2800088 	mov	x8, #0x4                   	// #4
    40010f74:	d4000041 	svc	#0x2
    40010f78:	1400000a 	b	40010fa0 <z_phys_map+0xd8>
    40010f7c:	aa0003f4 	mov	x20, x0
	arch_mem_map(dest_addr, aligned_phys, aligned_size, flags);
    40010f80:	2a1803e3 	mov	w3, w24
    40010f84:	aa1303e2 	mov	x2, x19
    40010f88:	aa1b03e1 	mov	x1, x27
MAKE_REG_HELPER(daif)
    40010f8c:	92407f5a 	and	x26, x26, #0xffffffff
    40010f90:	97ffeeab 	bl	4000ca3c <arch_mem_map>
    40010f94:	d51b423a 	msr	daif, x26
	*virt_ptr = dest_addr + addr_offset;
    40010f98:	8b190294 	add	x20, x20, x25
    40010f9c:	f90002f4 	str	x20, [x23]
}
    40010fa0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010fa4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010fa8:	a94363f7 	ldp	x23, x24, [sp, #48]
    40010fac:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40010fb0:	f9402bfb 	ldr	x27, [sp, #80]
    40010fb4:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40010fb8:	d65f03c0 	ret

0000000040010fbc <z_mem_manage_init>:
    40010fbc:	d53b4225 	mrs	x5, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010fc0:	d50342df 	msr	daifset, #0x2
	list->head = NULL;
    40010fc4:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x200>
    40010fc8:	911fa001 	add	x1, x0, #0x7e8

#ifdef CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT
	/* All pages composing the Zephyr image are mapped at boot in a
	 * predictable way. This can change at runtime.
	 */
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    40010fcc:	90000302 	adrp	x2, 40070000 <_end>
    40010fd0:	91000042 	add	x2, x2, #0x0
    40010fd4:	f903f41f 	str	xzr, [x0, #2024]
	list->tail = NULL;
    40010fd8:	b0000084 	adrp	x4, 40021000 <k_sys_work_q+0x200>
    40010fdc:	912fb484 	add	x4, x4, #0xbed
    40010fe0:	90ffff80 	adrp	x0, 40000000 <__text_region_start>
    40010fe4:	91000000 	add	x0, x0, #0x0
static inline struct z_page_frame *z_phys_to_page_frame(uintptr_t phys)
{
	__ASSERT(z_is_page_frame(phys),
		 "0x%lx not an SRAM physical address", phys);

	return &z_page_frames[(phys - Z_PHYS_RAM_START) /
    40010fe8:	b26287e7 	mov	x7, #0xffffffffc0000000    	// #-1073741824
		 * code/data pages which are pinned in memory and
		 * may not be evicted. This will contain critical CPU data
		 * structures, and any code used to perform page fault
		 * handling, page-ins, etc.
		 */
		pf->flags |= Z_PAGE_FRAME_PINNED;
    40010fec:	528000a8 	mov	w8, #0x5                   	// #5
    40010ff0:	f900043f 	str	xzr, [x1, #8]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    40010ff4:	eb02001f 	cmp	x0, x2
    40010ff8:	54000183 	b.cc	40011028 <z_mem_manage_init+0x6c>  // b.lo, b.ul, b.last
#endif

	/* Any remaining pages that aren't mapped, reserved, or pinned get
	 * added to the free pages list
	 */
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    40010ffc:	d2a80006 	mov	x6, #0x40000000            	// #1073741824
    40011000:	d2a90007 	mov	x7, #0x48000000            	// #1207959552
		if (z_page_frame_is_available(pf)) {
    40011004:	39402080 	ldrb	w0, [x4, #8]
    40011008:	340003c0 	cbz	w0, 40011080 <z_mem_manage_init+0xc4>
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    4001100c:	914004c6 	add	x6, x6, #0x1, lsl #12
    40011010:	91002484 	add	x4, x4, #0x9
    40011014:	eb0700df 	cmp	x6, x7
    40011018:	54ffff61 	b.ne	40011004 <z_mem_manage_init+0x48>  // b.any
MAKE_REG_HELPER(daif)
    4001101c:	92407ca5 	and	x5, x5, #0xffffffff
    40011020:	d51b4225 	msr	daif, x5
    40011024:	d65f03c0 	ret
    40011028:	8b070001 	add	x1, x0, x7
    4001102c:	d34cfc21 	lsr	x1, x1, #12
	pf->flags |= Z_PAGE_FRAME_MAPPED;
    40011030:	8b010c21 	add	x1, x1, x1, lsl #3
    40011034:	8b010086 	add	x6, x4, x1
	pf->addr = addr;
    40011038:	f8216880 	str	x0, [x4, x1]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    4001103c:	91400400 	add	x0, x0, #0x1, lsl #12
	pf->flags |= Z_PAGE_FRAME_MAPPED;
    40011040:	394020c3 	ldrb	w3, [x6, #8]
		pf->flags |= Z_PAGE_FRAME_PINNED;
    40011044:	2a080061 	orr	w1, w3, w8
    40011048:	390020c1 	strb	w1, [x6, #8]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    4001104c:	17ffffea 	b	40010ff4 <z_mem_manage_init+0x38>
		if (z_page_frame_is_available(pf)) {
    40011050:	39402080 	ldrb	w0, [x4, #8]
    40011054:	35000060 	cbnz	w0, 40011060 <z_mem_manage_init+0xa4>
			free_page_frame_list_put(pf);
    40011058:	aa0403e0 	mov	x0, x4
    4001105c:	97ffff37 	bl	40010d38 <free_page_frame_list_put>
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    40011060:	914004c6 	add	x6, x6, #0x1, lsl #12
    40011064:	91002484 	add	x4, x4, #0x9
    40011068:	eb0700df 	cmp	x6, x7
    4001106c:	54ffff21 	b.ne	40011050 <z_mem_manage_init+0x94>  // b.any
    40011070:	92407ca5 	and	x5, x5, #0xffffffff
    40011074:	d51b4225 	msr	daif, x5
	 * and the BSS pages can be brought into physical
	 * memory to be cleared.
	 */
	z_bss_zero();
#endif
}
    40011078:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4001107c:	d65f03c0 	ret
{
    40011080:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40011084:	910003fd 	mov	x29, sp
    40011088:	17fffff4 	b	40011058 <z_mem_manage_init+0x9c>

000000004001108c <z_mem_manage_boot_finish>:
	/* At the end of boot process, unpin the boot sections
	 * as they don't need to be in memory all the time anymore.
	 */
	mark_linker_section_pinned(lnkr_boot_start, lnkr_boot_end, false);
#endif
}
    4001108c:	d65f03c0 	ret

0000000040011090 <add_event>:
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
}

static inline void add_event(sys_dlist_t *events, struct k_poll_event *event,
			     struct z_poller *poller)
{
    40011090:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40011094:	910003fd 	mov	x29, sp
    40011098:	a90153f3 	stp	x19, x20, [sp, #16]
    4001109c:	aa0003f3 	mov	x19, x0
    400110a0:	aa0103f4 	mov	x20, x1
    400110a4:	a9025bf5 	stp	x21, x22, [sp, #32]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    400110a8:	f9400261 	ldr	x1, [x19]
    400110ac:	f9400400 	ldr	x0, [x0, #8]
    400110b0:	eb01027f 	cmp	x19, x1
    400110b4:	54000121 	b.ne	400110d8 <add_event+0x48>  // b.any
	sys_dnode_t *const tail = list->tail;
    400110b8:	f9400660 	ldr	x0, [x19, #8]
	node->prev = tail;
    400110bc:	a9000293 	stp	x19, x0, [x20]
	tail->next = node;
    400110c0:	f9000014 	str	x20, [x0]
	list->tail = node;
    400110c4:	f9000674 	str	x20, [x19, #8]
			return;
		}
	}

	sys_dlist_append(events, &event->_node);
}
    400110c8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400110cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400110d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400110d4:	d65f03c0 	ret
	if ((pending == NULL) ||
    400110d8:	b4ffff00 	cbz	x0, 400110b8 <add_event+0x28>
		(z_sched_prio_cmp(poller_thread(pending->poller),
    400110dc:	f9400800 	ldr	x0, [x0, #16]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
    400110e0:	aa0203f6 	mov	x22, x2
    400110e4:	b4000040 	cbz	x0, 400110ec <add_event+0x5c>
    400110e8:	d1034000 	sub	x0, x0, #0xd0
    400110ec:	b4000056 	cbz	x22, 400110f4 <add_event+0x64>
    400110f0:	d10342d6 	sub	x22, x22, #0xd0
		(z_sched_prio_cmp(poller_thread(pending->poller),
    400110f4:	aa1603e1 	mov	x1, x22
    400110f8:	97fff9b8 	bl	4000f7d8 <z_sched_prio_cmp>
	if ((pending == NULL) ||
    400110fc:	7100001f 	cmp	w0, #0x0
    40011100:	54fffdcc 	b.gt	400110b8 <add_event+0x28>
	return list->head == list;
    40011104:	f9400275 	ldr	x21, [x19]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40011108:	eb15027f 	cmp	x19, x21
    4001110c:	54fffd60 	b.eq	400110b8 <add_event+0x28>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    40011110:	b4fffd55 	cbz	x21, 400110b8 <add_event+0x28>
		if (z_sched_prio_cmp(poller_thread(poller),
    40011114:	f9400aa1 	ldr	x1, [x21, #16]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
    40011118:	b4000041 	cbz	x1, 40011120 <add_event+0x90>
    4001111c:	d1034021 	sub	x1, x1, #0xd0
		if (z_sched_prio_cmp(poller_thread(poller),
    40011120:	aa1603e0 	mov	x0, x22
    40011124:	97fff9ad 	bl	4000f7d8 <z_sched_prio_cmp>
    40011128:	7100001f 	cmp	w0, #0x0
    4001112c:	540000cd 	b.le	40011144 <add_event+0xb4>
	sys_dnode_t *const prev = successor->prev;
    40011130:	f94006a0 	ldr	x0, [x21, #8]
	node->prev = prev;
    40011134:	a9000295 	stp	x21, x0, [x20]
	prev->next = node;
    40011138:	f9000014 	str	x20, [x0]
	successor->prev = node;
    4001113c:	f90006b4 	str	x20, [x21, #8]
			return;
    40011140:	17ffffe2 	b	400110c8 <add_event+0x38>
	return (node == list->tail) ? NULL : node->next;
    40011144:	f9400660 	ldr	x0, [x19, #8]
    40011148:	eb15001f 	cmp	x0, x21
    4001114c:	54fffb60 	b.eq	400110b8 <add_event+0x28>  // b.none
    40011150:	f94002b5 	ldr	x21, [x21]
    40011154:	17ffffef 	b	40011110 <add_event+0x80>

0000000040011158 <register_events>:

static inline int register_events(struct k_poll_event *events,
				  int num_events,
				  struct z_poller *poller,
				  bool just_check)
{
    40011158:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4001115c:	910003fd 	mov	x29, sp
    40011160:	a90153f3 	stp	x19, x20, [sp, #16]
    40011164:	aa0203f4 	mov	x20, x2
    40011168:	aa0003f3 	mov	x19, x0
    4001116c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40011170:	2a0103f6 	mov	w22, w1
	int events_registered = 0;
    40011174:	52800015 	mov	w21, #0x0                   	// #0
{
    40011178:	a90363f7 	stp	x23, x24, [sp, #48]
	switch (event->type) {
    4001117c:	f0000018 	adrp	x24, 40014000 <shell_m_sub_colors+0x50>
    40011180:	9116c318 	add	x24, x24, #0x5b0
{
    40011184:	a9046bf9 	stp	x25, x26, [sp, #64]
	switch (event->type) {
    40011188:	f0000019 	adrp	x25, 40014000 <shell_m_sub_colors+0x50>
    4001118c:	9116a339 	add	x25, x25, #0x5a8
{
    40011190:	f9002bfb 	str	x27, [sp, #80]
    40011194:	12001c7b 	and	w27, w3, #0xff

	for (int ii = 0; ii < num_events; ii++) {
    40011198:	52800017 	mov	w23, #0x0                   	// #0
    4001119c:	6b1602ff 	cmp	w23, w22
    400111a0:	5400012b 	b.lt	400111c4 <register_events+0x6c>  // b.tstop
		}
		k_spin_unlock(&lock, key);
	}

	return events_registered;
}
    400111a4:	2a1503e0 	mov	w0, w21
    400111a8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400111ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400111b0:	a94363f7 	ldp	x23, x24, [sp, #48]
    400111b4:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400111b8:	f9402bfb 	ldr	x27, [sp, #80]
    400111bc:	a8c67bfd 	ldp	x29, x30, [sp], #96
    400111c0:	d65f03c0 	ret
    400111c4:	d53b423a 	mrs	x26, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400111c8:	d50342df 	msr	daifset, #0x2
	switch (event->type) {
    400111cc:	f9400e60 	ldr	x0, [x19, #24]
    400111d0:	53083000 	ubfx	w0, w0, #8, #5
    400111d4:	51000400 	sub	w0, w0, #0x1
    400111d8:	71001c1f 	cmp	w0, #0x7
    400111dc:	540001a8 	b.hi	40011210 <register_events+0xb8>  // b.pmore
    400111e0:	38604b20 	ldrb	w0, [x25, w0, uxtw]
    400111e4:	10000061 	adr	x1, 400111f0 <register_events+0x98>
    400111e8:	8b208820 	add	x0, x1, w0, sxtb #2
    400111ec:	d61f0000 	br	x0
		if (k_sem_count_get(event->sem) > 0U) {
    400111f0:	f9401260 	ldr	x0, [x19, #32]
    400111f4:	b9401000 	ldr	w0, [x0, #16]
    400111f8:	340000c0 	cbz	w0, 40011210 <register_events+0xb8>
			*state = K_POLL_STATE_SEM_AVAILABLE;
    400111fc:	52800040 	mov	w0, #0x2                   	// #2
    40011200:	14000019 	b	40011264 <register_events+0x10c>
		if (!k_queue_is_empty(event->queue)) {
    40011204:	f9401260 	ldr	x0, [x19, #32]
    40011208:	f9400000 	ldr	x0, [x0]
    4001120c:	b5000460 	cbnz	x0, 40011298 <register_events+0x140>
		} else if (!just_check && poller->is_polling) {
    40011210:	350003bb 	cbnz	w27, 40011284 <register_events+0x12c>
    40011214:	39400280 	ldrb	w0, [x20]
    40011218:	34000360 	cbz	w0, 40011284 <register_events+0x12c>
	switch (event->type) {
    4001121c:	f9400e60 	ldr	x0, [x19, #24]
    40011220:	53083000 	ubfx	w0, w0, #8, #5
    40011224:	51000400 	sub	w0, w0, #0x1
    40011228:	71001c1f 	cmp	w0, #0x7
    4001122c:	54000448 	b.hi	400112b4 <register_events+0x15c>  // b.pmore
    40011230:	38604b00 	ldrb	w0, [x24, w0, uxtw]
    40011234:	10000061 	adr	x1, 40011240 <register_events+0xe8>
    40011238:	8b208820 	add	x0, x1, w0, sxtb #2
    4001123c:	d61f0000 	br	x0
		if (event->signal->signaled != 0U) {
    40011240:	f9401260 	ldr	x0, [x19, #32]
    40011244:	b9401000 	ldr	w0, [x0, #16]
    40011248:	34fffe40 	cbz	w0, 40011210 <register_events+0xb8>
			*state = K_POLL_STATE_SIGNALED;
    4001124c:	52800020 	mov	w0, #0x1                   	// #1
    40011250:	14000005 	b	40011264 <register_events+0x10c>
		if (event->msgq->used_msgs > 0) {
    40011254:	f9401260 	ldr	x0, [x19, #32]
    40011258:	b9404000 	ldr	w0, [x0, #64]
    4001125c:	34fffda0 	cbz	w0, 40011210 <register_events+0xb8>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
    40011260:	52800200 	mov	w0, #0x10                  	// #16
	event->state |= state;
    40011264:	f9400e61 	ldr	x1, [x19, #24]
	event->poller = NULL;
    40011268:	f9000a7f 	str	xzr, [x19, #16]
	event->state |= state;
    4001126c:	d34d4821 	ubfx	x1, x1, #13, #6
    40011270:	2a010000 	orr	w0, w0, w1
    40011274:	b9401a61 	ldr	w1, [x19, #24]
    40011278:	33131401 	bfi	w1, w0, #13, #6
    4001127c:	b9001a61 	str	w1, [x19, #24]
			poller->is_polling = false;
    40011280:	3900029f 	strb	wzr, [x20]
MAKE_REG_HELPER(daif)
    40011284:	92407f5a 	and	x26, x26, #0xffffffff
    40011288:	d51b423a 	msr	daif, x26
	for (int ii = 0; ii < num_events; ii++) {
    4001128c:	110006f7 	add	w23, w23, #0x1
    40011290:	9100a273 	add	x19, x19, #0x28
    40011294:	17ffffc2 	b	4001119c <register_events+0x44>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
    40011298:	52800080 	mov	w0, #0x4                   	// #4
    4001129c:	17fffff2 	b	40011264 <register_events+0x10c>
		add_event(&event->sem->poll_events, event, poller);
    400112a0:	f9401260 	ldr	x0, [x19, #32]
    400112a4:	aa1403e2 	mov	x2, x20
    400112a8:	aa1303e1 	mov	x1, x19
    400112ac:	91006000 	add	x0, x0, #0x18
		add_event(&event->msgq->poll_events, event, poller);
    400112b0:	97ffff78 	bl	40011090 <add_event>
			events_registered += 1;
    400112b4:	110006b5 	add	w21, w21, #0x1
	event->poller = poller;
    400112b8:	f9000a74 	str	x20, [x19, #16]
			events_registered += 1;
    400112bc:	17fffff2 	b	40011284 <register_events+0x12c>
		add_event(&event->queue->poll_events, event, poller);
    400112c0:	f9401260 	ldr	x0, [x19, #32]
    400112c4:	aa1403e2 	mov	x2, x20
    400112c8:	aa1303e1 	mov	x1, x19
    400112cc:	91008000 	add	x0, x0, #0x20
    400112d0:	17fffff8 	b	400112b0 <register_events+0x158>
		add_event(&event->signal->poll_events, event, poller);
    400112d4:	aa1403e2 	mov	x2, x20
    400112d8:	aa1303e1 	mov	x1, x19
    400112dc:	f9401260 	ldr	x0, [x19, #32]
    400112e0:	17fffff4 	b	400112b0 <register_events+0x158>
		add_event(&event->msgq->poll_events, event, poller);
    400112e4:	f9401260 	ldr	x0, [x19, #32]
    400112e8:	aa1403e2 	mov	x2, x20
    400112ec:	aa1303e1 	mov	x1, x19
    400112f0:	91012000 	add	x0, x0, #0x48
    400112f4:	17ffffef 	b	400112b0 <register_events+0x158>

00000000400112f8 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
    400112f8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400112fc:	910003fd 	mov	x29, sp
    40011300:	a90153f3 	stp	x19, x20, [sp, #16]
    40011304:	aa0003f4 	mov	x20, x0
	struct z_poller *poller = event->poller;
    40011308:	f9400813 	ldr	x19, [x0, #16]
{
    4001130c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40011310:	2a0103f5 	mov	w21, w1
    40011314:	f9001bf7 	str	x23, [sp, #48]
	int retcode = 0;

	if (poller != NULL) {
    40011318:	b4000113 	cbz	x19, 40011338 <signal_poll_event+0x40>
		if (poller->mode == MODE_POLL) {
    4001131c:	39400660 	ldrb	w0, [x19, #1]
    40011320:	7100041f 	cmp	w0, #0x1
    40011324:	540004c1 	b.ne	400113bc <signal_poll_event+0xc4>  // b.any
	if (!z_is_thread_pending(thread)) {
    40011328:	38549260 	ldurb	w0, [x19, #-183]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
    4001132c:	d1034276 	sub	x22, x19, #0xd0
    40011330:	37080160 	tbnz	w0, #1, 4001135c <signal_poll_event+0x64>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
    40011334:	3900027f 	strb	wzr, [x19]
	event->state |= state;
    40011338:	f9400e81 	ldr	x1, [x20, #24]
	event->poller = NULL;
    4001133c:	f9000a9f 	str	xzr, [x20, #16]
	event->state |= state;
    40011340:	b9401a80 	ldr	w0, [x20, #24]
    40011344:	d34d4821 	ubfx	x1, x1, #13, #6
    40011348:	2a0102b5 	orr	w21, w21, w1
    4001134c:	331316a0 	bfi	w0, w21, #13, #6
    40011350:	b9001a80 	str	w0, [x20, #24]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
    40011354:	52800000 	mov	w0, #0x0                   	// #0
    40011358:	14000006 	b	40011370 <signal_poll_event+0x78>
	if (z_is_thread_timeout_expired(thread)) {
    4001135c:	f94022c0 	ldr	x0, [x22, #64]
    40011360:	b100081f 	cmn	x0, #0x2
    40011364:	54000101 	b.ne	40011384 <signal_poll_event+0x8c>  // b.any
		return -EAGAIN;
    40011368:	12800140 	mov	w0, #0xfffffff5            	// #-11
		poller->is_polling = false;
    4001136c:	3900027f 	strb	wzr, [x19]
}
    40011370:	a94153f3 	ldp	x19, x20, [sp, #16]
    40011374:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40011378:	f9401bf7 	ldr	x23, [sp, #48]
    4001137c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40011380:	d65f03c0 	ret
	z_unpend_thread(thread);
    40011384:	aa1603e0 	mov	x0, x22
    40011388:	97fff958 	bl	4000f8e8 <z_unpend_thread>
	arch_thread_return_value_set(thread,
    4001138c:	710022bf 	cmp	w21, #0x8
    40011390:	12800060 	mov	w0, #0xfffffffc            	// #-4
    40011394:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
    40011398:	b90142c0 	str	w0, [x22, #320]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    4001139c:	394066c0 	ldrb	w0, [x22, #25]
    400113a0:	f240101f 	tst	x0, #0x1f
    400113a4:	54fffc81 	b.ne	40011334 <signal_poll_event+0x3c>  // b.any
	if (!z_is_thread_ready(thread)) {
    400113a8:	f8558260 	ldur	x0, [x19, #-168]
    400113ac:	b5fffc40 	cbnz	x0, 40011334 <signal_poll_event+0x3c>
	z_ready_thread(thread);
    400113b0:	aa1603e0 	mov	x0, x22
    400113b4:	97fffa04 	bl	4000fbc4 <z_ready_thread>
		poller->is_polling = false;
    400113b8:	17ffffdf 	b	40011334 <signal_poll_event+0x3c>
		} else if (poller->mode == MODE_TRIGGERED) {
    400113bc:	7100081f 	cmp	w0, #0x2
    400113c0:	54fffba1 	b.ne	40011334 <signal_poll_event+0x3c>  // b.any
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
    400113c4:	39400260 	ldrb	w0, [x19]
    400113c8:	34fffb80 	cbz	w0, 40011338 <signal_poll_event+0x40>
    400113cc:	f85f8277 	ldur	x23, [x19, #-8]
    400113d0:	d100a276 	sub	x22, x19, #0x28
    400113d4:	b4fffb17 	cbz	x23, 40011334 <signal_poll_event+0x3c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
    400113d8:	91008260 	add	x0, x19, #0x20
    400113dc:	97fffd4b 	bl	40010908 <z_abort_timeout>
		twork->poll_result = 0;
    400113e0:	b900427f 	str	wzr, [x19, #64]
		k_work_submit_to_queue(work_q, &twork->work);
    400113e4:	aa1603e1 	mov	x1, x22
    400113e8:	aa1703e0 	mov	x0, x23
    400113ec:	97fff8a9 	bl	4000f690 <k_work_submit_to_queue>
		poller->is_polling = false;
    400113f0:	17ffffd1 	b	40011334 <signal_poll_event+0x3c>

00000000400113f4 <clear_event_registrations>:
	while (num_events--) {
    400113f4:	51000421 	sub	w1, w1, #0x1
		clear_event_registration(&events[num_events]);
    400113f8:	52800507 	mov	w7, #0x28                  	// #40
    400113fc:	d2800028 	mov	x8, #0x1                   	// #1
    40011400:	d28022c9 	mov	x9, #0x116                 	// #278
	while (num_events--) {
    40011404:	3100043f 	cmn	w1, #0x1
    40011408:	54000041 	b.ne	40011410 <clear_event_registrations+0x1c>  // b.any
}
    4001140c:	d65f03c0 	ret
		clear_event_registration(&events[num_events]);
    40011410:	9b277c25 	smull	x5, w1, w7
    40011414:	8b050003 	add	x3, x0, x5
	switch (event->type) {
    40011418:	f9400c64 	ldr	x4, [x3, #24]
	event->poller = NULL;
    4001141c:	f900087f 	str	xzr, [x3, #16]
	switch (event->type) {
    40011420:	d3483086 	ubfx	x6, x4, #8, #5
    40011424:	53083084 	ubfx	w4, w4, #8, #5
    40011428:	7100209f 	cmp	w4, #0x8
    4001142c:	54000168 	b.hi	40011458 <clear_event_registrations+0x64>  // b.pmore
    40011430:	9ac62104 	lsl	x4, x8, x6
    40011434:	ea09009f 	tst	x4, x9
    40011438:	54000100 	b.eq	40011458 <clear_event_registrations+0x64>  // b.none
	return node->next != NULL;
    4001143c:	f8656804 	ldr	x4, [x0, x5]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
    40011440:	b40000c4 	cbz	x4, 40011458 <clear_event_registrations+0x64>
	sys_dnode_t *const prev = node->prev;
    40011444:	f9400466 	ldr	x6, [x3, #8]
	prev->next = next;
    40011448:	f90000c4 	str	x4, [x6]
	next->prev = prev;
    4001144c:	f9000486 	str	x6, [x4, #8]
	node->next = NULL;
    40011450:	f825681f 	str	xzr, [x0, x5]
	node->prev = NULL;
    40011454:	f900047f 	str	xzr, [x3, #8]
    40011458:	2a0203e2 	mov	w2, w2
    4001145c:	d51b4222 	msr	daif, x2
    40011460:	d53b4222 	mrs	x2, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40011464:	d50342df 	msr	daifset, #0x2
    40011468:	51000421 	sub	w1, w1, #0x1
    4001146c:	17ffffe6 	b	40011404 <clear_event_registrations+0x10>

0000000040011470 <k_poll_event_init>:
	event->type = type;
    40011470:	53181021 	ubfiz	w1, w1, #8, #5
    40011474:	530d0042 	ubfiz	w2, w2, #19, #1
    40011478:	2a010042 	orr	w2, w2, w1
    4001147c:	39406001 	ldrb	w1, [x0, #24]
	event->poller = NULL;
    40011480:	f900081f 	str	xzr, [x0, #16]
	event->type = type;
    40011484:	2a010042 	orr	w2, w2, w1
    40011488:	b9001802 	str	w2, [x0, #24]
	event->obj = obj;
    4001148c:	f9001003 	str	x3, [x0, #32]
}
    40011490:	d65f03c0 	ret

0000000040011494 <z_impl_k_poll>:
{
    40011494:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	poller->is_polling = true;
    40011498:	52802023 	mov	w3, #0x101                 	// #257
{
    4001149c:	910003fd 	mov	x29, sp
    400114a0:	a90153f3 	stp	x19, x20, [sp, #16]
    400114a4:	aa0203f3 	mov	x19, x2
	events_registered = register_events(events, num_events, poller,
    400114a8:	f100027f 	cmp	x19, #0x0
{
    400114ac:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct z_poller *poller = &_current->poller;
    400114b0:	90000082 	adrp	x2, 40021000 <k_sys_work_q+0x200>
    400114b4:	f943b856 	ldr	x22, [x2, #1904]
{
    400114b8:	aa0003f4 	mov	x20, x0
	poller->is_polling = true;
    400114bc:	aa1603e2 	mov	x2, x22
    400114c0:	780d0c43 	strh	w3, [x2, #208]!
	events_registered = register_events(events, num_events, poller,
    400114c4:	1a9f17e3 	cset	w3, eq  // eq = none
    400114c8:	97ffff24 	bl	40011158 <register_events>
    400114cc:	2a0003f5 	mov	w21, w0
MAKE_REG_HELPER(daif)
    400114d0:	d53b422a 	mrs	x10, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400114d4:	d50342df 	msr	daifset, #0x2
	if (!poller->is_polling) {
    400114d8:	394342c0 	ldrb	w0, [x22, #208]
    400114dc:	350001a0 	cbnz	w0, 40011510 <z_impl_k_poll+0x7c>
		clear_event_registrations(events, events_registered, key);
    400114e0:	2a0a03e2 	mov	w2, w10
    400114e4:	2a1503e1 	mov	w1, w21
    400114e8:	aa1403e0 	mov	x0, x20
MAKE_REG_HELPER(daif)
    400114ec:	92407d4a 	and	x10, x10, #0xffffffff
    400114f0:	97ffffc1 	bl	400113f4 <clear_event_registrations>
    400114f4:	d51b422a 	msr	daif, x10
		return 0;
    400114f8:	5280000a 	mov	w10, #0x0                   	// #0
}
    400114fc:	2a0a03e0 	mov	w0, w10
    40011500:	a94153f3 	ldp	x19, x20, [sp, #16]
    40011504:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40011508:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4001150c:	d65f03c0 	ret
	poller->is_polling = false;
    40011510:	390342df 	strb	wzr, [x22, #208]
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    40011514:	b50000b3 	cbnz	x19, 40011528 <z_impl_k_poll+0x94>
    40011518:	92407d4a 	and	x10, x10, #0xffffffff
    4001151c:	d51b422a 	msr	daif, x10
		return -EAGAIN;
    40011520:	1280014a 	mov	w10, #0xfffffff5            	// #-11
    40011524:	17fffff6 	b	400114fc <z_impl_k_poll+0x68>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
    40011528:	2a0a03e1 	mov	w1, w10
    4001152c:	aa1303e3 	mov	x3, x19
    40011530:	d00002e2 	adrp	x2, 4006f000 <sys_work_q_stack+0xc10>
    40011534:	9132e042 	add	x2, x2, #0xcb8
    40011538:	900002c0 	adrp	x0, 40069000 <z_page_frames+0x47413>
    4001153c:	912fb400 	add	x0, x0, #0xbed
    40011540:	97fffb64 	bl	400102d0 <z_pend_curr>
    40011544:	2a0003ea 	mov	w10, w0
    40011548:	d53b422b 	mrs	x11, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4001154c:	d50342df 	msr	daifset, #0x2
	clear_event_registrations(events, events_registered, key);
    40011550:	2a0b03e2 	mov	w2, w11
    40011554:	2a1503e1 	mov	w1, w21
    40011558:	aa1403e0 	mov	x0, x20
MAKE_REG_HELPER(daif)
    4001155c:	92407d6b 	and	x11, x11, #0xffffffff
    40011560:	97ffffa5 	bl	400113f4 <clear_event_registrations>
    40011564:	d51b422b 	msr	daif, x11
	return swap_rc;
    40011568:	17ffffe5 	b	400114fc <z_impl_k_poll+0x68>

000000004001156c <z_handle_obj_poll_events>:
{
    4001156c:	aa0003e2 	mov	x2, x0
	return list->head == list;
    40011570:	f9400000 	ldr	x0, [x0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
    40011574:	eb00005f 	cmp	x2, x0
    40011578:	540000c0 	b.eq	40011590 <z_handle_obj_poll_events+0x24>  // b.none
	sys_dnode_t *const prev = node->prev;
    4001157c:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
    40011580:	f9000062 	str	x2, [x3]
	next->prev = prev;
    40011584:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
    40011588:	a9007c1f 	stp	xzr, xzr, [x0]
		(void) signal_poll_event(poll_event, state);
    4001158c:	17ffff5b 	b	400112f8 <signal_poll_event>
}
    40011590:	d65f03c0 	ret

0000000040011594 <z_impl_k_poll_signal_init>:
	list->tail = (sys_dnode_t *)list;
    40011594:	a9000000 	stp	x0, x0, [x0]
	sig->signaled = 0U;
    40011598:	b900101f 	str	wzr, [x0, #16]
}
    4001159c:	d65f03c0 	ret

00000000400115a0 <z_impl_k_poll_signal_reset>:
	sig->signaled = 0U;
    400115a0:	b900101f 	str	wzr, [x0, #16]
}
    400115a4:	d65f03c0 	ret

00000000400115a8 <z_impl_k_poll_signal_check>:
	*signaled = sig->signaled;
    400115a8:	b9401003 	ldr	w3, [x0, #16]
    400115ac:	b9000023 	str	w3, [x1]
	*result = sig->result;
    400115b0:	b9401400 	ldr	w0, [x0, #20]
    400115b4:	b9000040 	str	w0, [x2]
}
    400115b8:	d65f03c0 	ret

00000000400115bc <z_impl_k_poll_signal_raise>:
{
    400115bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400115c0:	aa0003e2 	mov	x2, x0
    400115c4:	910003fd 	mov	x29, sp
    400115c8:	a90153f3 	stp	x19, x20, [sp, #16]
    400115cc:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400115d0:	d50342df 	msr	daifset, #0x2
	sig->result = result;
    400115d4:	b9001401 	str	w1, [x0, #20]
	sig->signaled = 1U;
    400115d8:	52800021 	mov	w1, #0x1                   	// #1
    400115dc:	b9001001 	str	w1, [x0, #16]
	return list->head == list;
    400115e0:	f9400000 	ldr	x0, [x0]
	if (!sys_dlist_is_empty(list)) {
    400115e4:	eb00005f 	cmp	x2, x0
    400115e8:	54000101 	b.ne	40011608 <z_impl_k_poll_signal_raise+0x4c>  // b.any
MAKE_REG_HELPER(daif)
    400115ec:	92407e94 	and	x20, x20, #0xffffffff
    400115f0:	d51b4234 	msr	daif, x20
		return 0;
    400115f4:	52800013 	mov	w19, #0x0                   	// #0
}
    400115f8:	2a1303e0 	mov	w0, w19
    400115fc:	a94153f3 	ldp	x19, x20, [sp, #16]
    40011600:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40011604:	d65f03c0 	ret
	sys_dnode_t *const prev = node->prev;
    40011608:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
    4001160c:	f9000062 	str	x2, [x3]
	next->prev = prev;
    40011610:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
    40011614:	a9007c1f 	stp	xzr, xzr, [x0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
    40011618:	97ffff38 	bl	400112f8 <signal_poll_event>
    4001161c:	2a0003f3 	mov	w19, w0
	z_reschedule(&lock, key);
    40011620:	2a1403e1 	mov	w1, w20
    40011624:	900002c0 	adrp	x0, 40069000 <z_page_frames+0x47413>
    40011628:	912fb400 	add	x0, x0, #0xbed
    4001162c:	97fffb45 	bl	40010340 <z_reschedule>
	return rc;
    40011630:	17fffff2 	b	400115f8 <z_impl_k_poll_signal_raise+0x3c>

0000000040011634 <boot_banner>:
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
    40011634:	d65f03c0 	ret

0000000040011638 <k_heap_init>:
    40011638:	91006004 	add	x4, x0, #0x18
	list->tail = (sys_dnode_t *)list;
    4001163c:	a9019004 	stp	x4, x4, [x0, #24]
#include <linker/linker-defs.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
    40011640:	17ffc2bb 	b	4000212c <sys_heap_init>

0000000040011644 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
    40011644:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40011648:	910003fd 	mov	x29, sp
    4001164c:	a90153f3 	stp	x19, x20, [sp, #16]
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
    40011650:	d00002f3 	adrp	x19, 4006f000 <sys_work_q_stack+0xc10>
    40011654:	91350273 	add	x19, x19, #0xd40
    40011658:	d00002f4 	adrp	x20, 4006f000 <sys_work_q_stack+0xc10>
    4001165c:	91350294 	add	x20, x20, #0xd40
    40011660:	eb14027f 	cmp	x19, x20
    40011664:	540000a3 	b.cc	40011678 <statics_init+0x34>  // b.lo, b.ul, b.last
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
    40011668:	52800000 	mov	w0, #0x0                   	// #0
    4001166c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40011670:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40011674:	d65f03c0 	ret
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    40011678:	a9408a61 	ldp	x1, x2, [x19, #8]
    4001167c:	aa1303e0 	mov	x0, x19
	STRUCT_SECTION_FOREACH(k_heap, h) {
    40011680:	9100a273 	add	x19, x19, #0x28
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    40011684:	97ffffed 	bl	40011638 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
    40011688:	17fffff6 	b	40011660 <statics_init+0x1c>

000000004001168c <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
    4001168c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
    40011690:	b0000020 	adrp	x0, 40016000 <cmd_get_terminal_size.0+0x1f4>
    40011694:	91249c00 	add	x0, x0, #0x927
{
    40011698:	910003fd 	mov	x29, sp
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
    4001169c:	910043e4 	add	x4, sp, #0x10
    400116a0:	12800003 	mov	w3, #0xffffffff            	// #-1
    400116a4:	d2820002 	mov	x2, #0x1000                	// #4096
    400116a8:	b00002e1 	adrp	x1, 4006e000 <z_interrupt_stacks+0xc10>
    400116ac:	910fc021 	add	x1, x1, #0x3f0
	struct k_work_queue_config cfg = {
    400116b0:	f9000be0 	str	x0, [sp, #16]
	k_work_queue_start(&k_sys_work_q,
    400116b4:	f0000060 	adrp	x0, 40020000 <logging_thread>
    400116b8:	91380000 	add	x0, x0, #0xe00
	struct k_work_queue_config cfg = {
    400116bc:	390063ff 	strb	wzr, [sp, #24]
	k_work_queue_start(&k_sys_work_q,
    400116c0:	97fff80d 	bl	4000f6f4 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
    400116c4:	52800000 	mov	w0, #0x0                   	// #0
    400116c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400116cc:	d65f03c0 	ret
	...
