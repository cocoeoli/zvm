
zephyr.elf:     file format elf64-littleaarch64


Disassembly of section text:

0000000040000000 <__text_region_start>:
#define HEADER_FLAGS	(HEADER_PGSIZE << 1)

_ASM_FILE_PROLOGUE

SECTION_SUBSEC_FUNC(image_header,_image_header_section,_image_header)
	b	__start				// branch to kernel start
    40000000:	14000425 	b	40001094 <__reset>
	...
    40000010:	40066fa8 	.word	0x40066fa8
    40000014:	00000000 	.word	0x00000000
    40000018:	00000002 	.word	0x00000002
	...
    40000038:	644d5241 	.word	0x644d5241
    4000003c:	00000000 	.word	0x00000000

0000000040000040 <_vector_start>:
	...

0000000040000800 <_vector_table>:
	/* The whole table must be 2K aligned */
	.align 11

	/* Current EL with SP0 / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000800:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000810:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000820:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000830:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000840:	927ff800 8b010000 d51bd060 94001df5     ........`.......
	b	z_arm64_sync_exc
    40000850:	14001dac d503201f d503201f d503201f     ..... ... ... ..
    40000860:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000870:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SP0 / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000880:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000890:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    400008a0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    400008b0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    400008c0:	927ff800 8b010000 d51bd060 94001dd5     ........`.......
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    400008d0:	14000212 d503201f d503201f d503201f     ..... ... ... ..
    400008e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    400008f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Current EL with SP0 / FIQ */
	.align 7
	b 	.
    40000900:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000910:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000920:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000930:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000940:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000950:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000960:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000970:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SP0 / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000980:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000990:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    400009a0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    400009b0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    400009c0:	927ff800 8b010000 d51bd060 94001d95     ........`.......
	b	z_arm64_serror
    400009d0:	14001d79 d503201f d503201f d503201f     y.... ... ... ..
    400009e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    400009f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000a00:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000a10:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000a20:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000a30:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000a40:	927ff800 8b010000 d51bd060 94001d75     ........`...u...
	b	z_arm64_sync_exc
    40000a50:	14001d2c d503201f d503201f d503201f     ,.... ... ... ..
    40000a60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000a70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000a80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000a90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000aa0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000ab0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000ac0:	927ff800 8b010000 d51bd060 94001d55     ........`...U...
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    40000ad0:	14000192 d503201f d503201f d503201f     ..... ... ... ..
    40000ae0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000af0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Current EL with SPx / FIQ */
	.align 7
	b	.
    40000b00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000b10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000b80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000b90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000ba0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000bb0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000bc0:	927ff800 8b010000 d51bd060 94001d15     ........`.......
	b	z_arm64_serror
    40000bd0:	14001cf9 d503201f d503201f d503201f     ..... ... ... ..
    40000be0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000bf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000c00:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000c10:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000c20:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000c30:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000c40:	927ff800 8b010000 d51bd060 94001cf5     ........`.......
	b	z_arm64_sync_exc
    40000c50:	14001cac d503201f d503201f d503201f     ..... ... ... ..
    40000c60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000c70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000c80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000c90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000ca0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000cb0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000cc0:	927ff800 8b010000 d51bd060 94001cd5     ........`.......
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    40000cd0:	14000112 d503201f d503201f d503201f     ..... ... ... ..
    40000ce0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000cf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Lower EL using AArch64 / FIQ */
	.align 7
	b	.
    40000d00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000d10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000d80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000d90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000da0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000db0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000dc0:	927ff800 8b010000 d51bd060 94001c95     ........`.......
	b	z_arm64_serror
    40000dd0:	14001c79 d503201f d503201f d503201f     y.... ... ... ..
    40000de0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000df0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / Synchronous */
	.align 7
	b	.
    40000e00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000e10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / IRQ */
	.align 7
	b	.
    40000e80:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000e90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ea0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000eb0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ec0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ed0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ee0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ef0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / FIQ */
	.align 7
	b	.
    40000f00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000f10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / SError */
	.align 7
	b	.
    40000f80:	14000000                                ....

0000000040000f84 <_vector_end>:
	...

0000000040000f90 <__aarch64_swp8_acq_rel>:
    40000f90:	d503245f 	bti	c
    40000f94:	90000090 	adrp	x16, 40010000 <__aarch64_have_lse_atomics>
    40000f98:	39400210 	ldrb	w16, [x16]
    40000f9c:	34000070 	cbz	w16, 40000fa8 <__aarch64_swp8_acq_rel+0x18>
    40000fa0:	f8e08020 	swpal	x0, x0, [x1]
    40000fa4:	d65f03c0 	ret
    40000fa8:	aa0003f0 	mov	x16, x0
    40000fac:	c85ffc20 	ldaxr	x0, [x1]
    40000fb0:	c811fc30 	stlxr	w17, x16, [x1]
    40000fb4:	35ffffd1 	cbnz	w17, 40000fac <__aarch64_swp8_acq_rel+0x1c>
    40000fb8:	d65f03c0 	ret
    40000fbc:	00000000 	udf	#0

0000000040000fc0 <__aarch64_ldclr8_acq_rel>:
    40000fc0:	d503245f 	bti	c
    40000fc4:	90000090 	adrp	x16, 40010000 <__aarch64_have_lse_atomics>
    40000fc8:	39400210 	ldrb	w16, [x16]
    40000fcc:	34000070 	cbz	w16, 40000fd8 <__aarch64_ldclr8_acq_rel+0x18>
    40000fd0:	f8e01020 	ldclral	x0, x0, [x1]
    40000fd4:	d65f03c0 	ret
    40000fd8:	aa0003f0 	mov	x16, x0
    40000fdc:	c85ffc20 	ldaxr	x0, [x1]
    40000fe0:	8a300011 	bic	x17, x0, x16
    40000fe4:	c80ffc31 	stlxr	w15, x17, [x1]
    40000fe8:	35ffffaf 	cbnz	w15, 40000fdc <__aarch64_ldclr8_acq_rel+0x1c>
    40000fec:	d65f03c0 	ret

0000000040000ff0 <__aarch64_ldset8_acq_rel>:
    40000ff0:	d503245f 	bti	c
    40000ff4:	90000090 	adrp	x16, 40010000 <__aarch64_have_lse_atomics>
    40000ff8:	39400210 	ldrb	w16, [x16]
    40000ffc:	34000070 	cbz	w16, 40001008 <__aarch64_ldset8_acq_rel+0x18>
    40001000:	f8e03020 	ldsetal	x0, x0, [x1]
    40001004:	d65f03c0 	ret
    40001008:	aa0003f0 	mov	x16, x0
    4000100c:	c85ffc20 	ldaxr	x0, [x1]
    40001010:	aa100011 	orr	x17, x0, x16
    40001014:	c80ffc31 	stlxr	w15, x17, [x1]
    40001018:	35ffffaf 	cbnz	w15, 4000100c <__aarch64_ldset8_acq_rel+0x1c>
    4000101c:	d65f03c0 	ret

0000000040001020 <__reset_prep_c>:
 */

GTEXT(__reset_prep_c)
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__reset_prep_c)
	/* return address: x23 */
	mov	x23, x30
    40001020:	aa1e03f7 	mov	x23, x30

	switch_el x0, 3f, 2f, 1f
    40001024:	d5384240 	mrs	x0, currentel
    40001028:	f100301f 	cmp	x0, #0xc
    4000102c:	540000a0 	b.eq	40001040 <__reset_prep_c+0x20>  // b.none
    40001030:	f100201f 	cmp	x0, #0x8
    40001034:	54000100 	b.eq	40001054 <__reset_prep_c+0x34>  // b.none
    40001038:	f100101f 	cmp	x0, #0x4
    4000103c:	54000180 	b.eq	4000106c <__reset_prep_c+0x4c>  // b.none
3:
	/* Reinitialize SCTLR from scratch in EL3 */
	ldr	w0, =(SCTLR_EL3_RES1 | SCTLR_I_BIT | SCTLR_SA_BIT)
    40001040:	18000600 	ldr	w0, 40001100 <switch_el+0x58>
	msr	sctlr_el3, x0
    40001044:	d51e1000 	msr	sctlr_el3, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el3_plat_prep_c
    40001048:	94001b2b 	bl	40007cf4 <z_arm64_el3_plat_prep_c>

	/* Set SP_EL1 */
	msr     sp_el1, x24
    4000104c:	d51c4118 	msr	sp_el1, x24

	b	out
    40001050:	1400000d 	b	40001084 <out>
2:
	/* Disable alignment fault checking */
	mrs	x0, sctlr_el2
    40001054:	d53c1000 	mrs	x0, sctlr_el2
	bic	x0, x0, SCTLR_A_BIT
    40001058:	927ef800 	and	x0, x0, #0xfffffffffffffffd
	msr	sctlr_el2, x0
    4000105c:	d51c1000 	msr	sctlr_el2, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el2_plat_prep_c
    40001060:	94001b26 	bl	40007cf8 <z_arm64_el2_plat_prep_c>

	/* Set SP_EL1 */
	msr     sp_el1, x24
    40001064:	d51c4118 	msr	sp_el1, x24

	b	out
    40001068:	14000007 	b	40001084 <out>
1:
	/* Disable alignment fault checking */
	mrs	x0, sctlr_el1
    4000106c:	d5381000 	mrs	x0, sctlr_el1
	bic	x0, x0, SCTLR_A_BIT
    40001070:	927ef800 	and	x0, x0, #0xfffffffffffffffd
	msr	sctlr_el1, x0
    40001074:	d5181000 	msr	sctlr_el1, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el1_plat_prep_c
    40001078:	94001b21 	bl	40007cfc <z_arm64_el1_plat_prep_c>

	/* Set SP_EL1. We cannot use sp_el1 at EL1 */
	msr     SPSel, #1
    4000107c:	d50041bf 	msr	spsel, #0x1
	mov     sp, x24
    40001080:	9100031f 	mov	sp, x24

0000000040001084 <out>:
out:
	isb
    40001084:	d5033fdf 	isb

	/* Select SP_EL0 */
	msr	SPSel, #0
    40001088:	d50040bf 	msr	spsel, #0x0

	/* Initialize stack */
	mov	sp, x24
    4000108c:	9100031f 	mov	sp, x24

	ret	x23
    40001090:	d65f02e0 	ret	x23

0000000040001094 <__reset>:
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__reset)

GTEXT(__start)
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)
	/* Mask all exceptions */
	msr	DAIFSet, #0xf
    40001094:	d5034fdf 	msr	daifset, #0xf
primary_core:
	/* advertise ourself */
	str	x1, [x0, #BOOT_PARAM_MPID_OFFSET]
#endif
	/* load primary stack and entry point */
	ldr	x24, =(z_interrupt_stacks + CONFIG_ISR_STACK_SIZE)
    40001098:	58000398 	ldr	x24, 40001108 <switch_el+0x60>
	ldr	x25, =z_arm64_prep_c
    4000109c:	580003b9 	ldr	x25, 40001110 <switch_el+0x68>
2:
	/* Prepare for calling C code */
	bl	__reset_prep_c
    400010a0:	97ffffe0 	bl	40001020 <__reset_prep_c>

	/* Platform hook for highest EL */
	bl	z_arm64_el_highest_init
    400010a4:	94001b24 	bl	40007d34 <z_arm64_el_highest_init>

00000000400010a8 <switch_el>:

switch_el:
	switch_el x0, 3f, 2f, 1f
    400010a8:	d5384240 	mrs	x0, currentel
    400010ac:	f100301f 	cmp	x0, #0xc
    400010b0:	540000a0 	b.eq	400010c4 <switch_el+0x1c>  // b.none
    400010b4:	f100201f 	cmp	x0, #0x8
    400010b8:	540000e0 	b.eq	400010d4 <switch_el+0x2c>  // b.none
    400010bc:	f100101f 	cmp	x0, #0x4
    400010c0:	54000180 	b.eq	400010f0 <switch_el+0x48>  // b.none
3:
	/* EL3 init */
	bl	z_arm64_el3_init
    400010c4:	94001b41 	bl	40007dc8 <z_arm64_el3_init>

	/* Get next EL */
	adr	x0, switch_el
    400010c8:	10ffff00 	adr	x0, 400010a8 <switch_el>
	bl	z_arm64_el3_get_next_el
    400010cc:	94001b68 	bl	40007e6c <z_arm64_el3_get_next_el>
	eret
    400010d0:	d69f03e0 	eret

2:
	/* EL2 init */
	bl	z_arm64_el2_init
    400010d4:	94001b2a 	bl	40007d7c <z_arm64_el2_init>

	/* Move to EL1 with all exceptions masked */
	mov_imm	x0, (SPSR_DAIF_MASK | SPSR_MODE_EL1T)
    400010d8:	d2a00000 	movz	x0, #0x0, lsl #16
    400010dc:	f2807880 	movk	x0, #0x3c4
	msr	spsr_el2, x0
    400010e0:	d51c4000 	msr	spsr_el2, x0

	adr	x0, 1f
    400010e4:	10000060 	adr	x0, 400010f0 <switch_el+0x48>
	msr	elr_el2, x0
    400010e8:	d51c4020 	msr	elr_el2, x0
	eret
    400010ec:	d69f03e0 	eret

1:
	/* EL1 init */
	bl	z_arm64_el1_init
    400010f0:	94001b4c 	bl	40007e20 <z_arm64_el1_init>

	/* Enable SError interrupts */
	msr	DAIFClr, #(DAIFCLR_ABT_BIT)
    400010f4:	d50344ff 	msr	daifclr, #0x4
	isb
    400010f8:	d5033fdf 	isb

	ret	x25  /* either z_arm64_prep_c or z_arm64_secondary_prep_c */
    400010fc:	d65f0320 	ret	x25
    40001100:	30c51838 	.word	0x30c51838
    40001104:	00000000 	udf	#0
    40001108:	40065c30 	.word	0x40065c30
    4000110c:	00000000 	.word	0x00000000
    40001110:	40007cb0 	.word	0x40007cb0
    40001114:	00000000 	.word	0x00000000

0000000040001118 <_isr_wrapper>:

GTEXT(_isr_wrapper)
SECTION_FUNC(TEXT, _isr_wrapper)

	/* ++(_kernel->nested) to be checked by arch_is_in_isr() */
	inc_nest_counter x0, x1
    40001118:	d53bd060 	mrs	x0, tpidrro_el0
    4000111c:	927db000 	and	x0, x0, #0xfffffffffff8
    40001120:	f9400001 	ldr	x1, [x0]
    40001124:	91000421 	add	x1, x1, #0x1
    40001128:	f9000001 	str	x1, [x0]
	bl	sys_trace_isr_enter
#endif

	/* Get active IRQ number from the interrupt controller */
#if !defined(CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER)
	bl	arm_gic_get_active
    4000112c:	94002047 	bl	40009248 <arm_gic_get_active>
#if CONFIG_GIC_VER >= 3
	/*
	 * Ignore Special INTIDs 1020..1023 see 2.2.1 of Arm Generic Interrupt Controller
	 * Architecture Specification GIC architecture version 3 and version 4
	 */
	cmp	x0, 1019
    40001130:	f10fec1f 	cmp	x0, #0x3fb
	b.le	oob
    40001134:	5400008d 	b.le	40001144 <oob>
	cmp	x0, 1023
    40001138:	f10ffc1f 	cmp	x0, #0x3ff
	b.gt	oob
    4000113c:	5400004c 	b.gt	40001144 <oob>
	b	spurious_continue
    40001140:	1400000c 	b	40001170 <spurious_continue>

0000000040001144 <oob>:

oob:
#endif
	/* IRQ out of bounds */
	mov	x1, #(CONFIG_NUM_IRQS - 1)
    40001144:	d2801b61 	mov	x1, #0xdb                  	// #219
	cmp	x0, x1
    40001148:	eb01001f 	cmp	x0, x1
	b.hi	spurious_continue
    4000114c:	54000128 	b.hi	40001170 <spurious_continue>  // b.pmore

	stp	x0, xzr, [sp, #-16]!
    40001150:	a9bf7fe0 	stp	x0, xzr, [sp, #-16]!

	/* Retrieve the interrupt service routine */
	ldr	x1, =_sw_isr_table
    40001154:	580002e1 	ldr	x1, 400011b0 <exit+0x8>
	add	x1, x1, x0, lsl #4	/* table is 16-byte wide */
    40001158:	8b001021 	add	x1, x1, x0, lsl #4
	ldp	x0, x3, [x1] /* arg in x0, ISR in x3 */
    4000115c:	a9400c20 	ldp	x0, x3, [x1]

	/*
	 * Call the ISR. Unmask and mask again the IRQs to support nested
	 * exception handlers
	 */
	msr	daifclr, #(DAIFCLR_IRQ_BIT)
    40001160:	d50342ff 	msr	daifclr, #0x2
	blr	x3
    40001164:	d63f0060 	blr	x3
	msr	daifset, #(DAIFSET_IRQ_BIT)
    40001168:	d50342df 	msr	daifset, #0x2

	/* Signal end-of-interrupt */
	ldp	x0, xzr, [sp], #16
    4000116c:	a8c17fe0 	ldp	x0, xzr, [sp], #16

0000000040001170 <spurious_continue>:

spurious_continue:
#if !defined(CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER)
	bl	arm_gic_eoi
    40001170:	94002038 	bl	40009250 <arm_gic_eoi>
#ifdef CONFIG_TRACING
	bl	sys_trace_isr_exit
#endif

	/* if (--(_kernel->nested) != 0) exit */
	dec_nest_counter x0, x1
    40001174:	d53bd060 	mrs	x0, tpidrro_el0
    40001178:	927db000 	and	x0, x0, #0xfffffffffff8
    4000117c:	f9400001 	ldr	x1, [x0]
    40001180:	f1000421 	subs	x1, x1, #0x1
    40001184:	f9000001 	str	x1, [x0]

	bne	exit
    40001188:	54000101 	b.ne	400011a8 <exit>  // b.any
	 * - The next thread to schedule in x0
	 * - The current thread in x1. This value is returned using the
	 *   **old_thread parameter, so we need to make space on the stack for
	 *   that.
	 */
	sub	sp, sp, #16
    4000118c:	d10043ff 	sub	sp, sp, #0x10
	mov	x0, sp
    40001190:	910003e0 	mov	x0, sp
	bl	z_arch_get_next_switch_handle
    40001194:	94001b83 	bl	40007fa0 <z_arch_get_next_switch_handle>
	ldp	x1, xzr, [sp], #16
    40001198:	a8c17fe1 	ldp	x1, xzr, [sp], #16

	/*
	 * x0: 1st thread in the ready queue
	 * x1: _current thread
	 */
	cmp	x0, x1
    4000119c:	eb01001f 	cmp	x0, x1
	beq	exit
    400011a0:	54000040 	b.eq	400011a8 <exit>  // b.none

	/* Switch thread */
	bl	z_arm64_context_switch
    400011a4:	94001b3d 	bl	40007e98 <z_arm64_context_switch>

00000000400011a8 <exit>:

exit:
#ifdef CONFIG_STACK_SENTINEL
	bl	z_check_stack_sentinel
#endif
	b	z_arm64_exit_exc
    400011a8:	14001b87 	b	40007fc4 <z_arm64_exit_exc>
    400011ac:	00000000 	udf	#0
    400011b0:	4000d0c0 	.word	0x4000d0c0
    400011b4:	00000000 	.word	0x00000000

00000000400011b8 <_OffsetAbsSyms>:
GEN_NAMED_OFFSET_SYM(arm_smccc_res_t, a4, a4_a5);
GEN_NAMED_OFFSET_SYM(arm_smccc_res_t, a6, a6_a7);

#endif /* CONFIG_HAS_ARM_SMCCC */

GEN_ABS_SYM_END
    400011b8:	d65f03c0 	ret

00000000400011bc <main>:
#include <sys/printk.h>
#include <shell/shell.h>
#include <hypervisor/hypervisor.h>

int main(int argc, char **argv)
{
    400011bc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   printk("Hypervisor test.../n");
    400011c0:	b0000060 	adrp	x0, 4000e000 <mmu_regions+0x38>
    400011c4:	912bb000 	add	x0, x0, #0xaec
{
    400011c8:	910003fd 	mov	x29, sp
   printk("Hypervisor test.../n");
    400011cc:	94000031 	bl	40001290 <printk>
   return 0;
}
    400011d0:	52800000 	mov	w0, #0x0                   	// #0
    400011d4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400011d8:	d65f03c0 	ret

00000000400011dc <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    400011dc:	52800000 	mov	w0, #0x0                   	// #0
    400011e0:	d65f03c0 	ret

00000000400011e4 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    400011e4:	b9400022 	ldr	w2, [x1]
    400011e8:	11000442 	add	w2, w2, #0x1
    400011ec:	b9000022 	str	w2, [x1]
	return _char_out(c);
    400011f0:	b0000321 	adrp	x1, 40066000 <sys_work_q_stack+0x3d0>
    400011f4:	f9473c21 	ldr	x1, [x1, #3704]
    400011f8:	aa0103f0 	mov	x16, x1
    400011fc:	d61f0200 	br	x16

0000000040001200 <str_out>:
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    40001200:	f9400024 	ldr	x4, [x1]
    40001204:	b9400c22 	ldr	w2, [x1, #12]
		ctx->count++;
		return c;
	}

	if (ctx->count == ctx->max - 1) {
		ctx->str[ctx->count++] = '\0';
    40001208:	11000445 	add	w5, w2, #0x1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    4000120c:	b4000084 	cbz	x4, 4000121c <str_out+0x1c>
    40001210:	b9400823 	ldr	w3, [x1, #8]
    40001214:	6b02007f 	cmp	w3, w2
    40001218:	5400006c 	b.gt	40001224 <str_out+0x24>
		ctx->count++;
    4000121c:	b9000c25 	str	w5, [x1, #12]
	} else {
		ctx->str[ctx->count++] = c;
	}

	return c;
}
    40001220:	d65f03c0 	ret
		ctx->str[ctx->count++] = '\0';
    40001224:	b9000c25 	str	w5, [x1, #12]
	if (ctx->count == ctx->max - 1) {
    40001228:	51000463 	sub	w3, w3, #0x1
		ctx->str[ctx->count++] = '\0';
    4000122c:	93407c46 	sxtw	x6, w2
	if (ctx->count == ctx->max - 1) {
    40001230:	6b02007f 	cmp	w3, w2
    40001234:	54000061 	b.ne	40001240 <str_out+0x40>  // b.any
		ctx->str[ctx->count++] = '\0';
    40001238:	3826689f 	strb	wzr, [x4, x6]
    4000123c:	17fffff9 	b	40001220 <str_out+0x20>
		ctx->str[ctx->count++] = c;
    40001240:	38266880 	strb	w0, [x4, x6]
    40001244:	17fffff7 	b	40001220 <str_out+0x20>

0000000040001248 <__printk_hook_install>:
	_char_out = fn;
    40001248:	b0000321 	adrp	x1, 40066000 <sys_work_q_stack+0x3d0>
    4000124c:	f9073c20 	str	x0, [x1, #3704]
}
    40001250:	d65f03c0 	ret

0000000040001254 <vprintk>:
{
    40001254:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40001258:	910003fd 	mov	x29, sp
	cbvprintf(char_out, &ctx, fmt, ap);
    4000125c:	a9400c22 	ldp	x2, x3, [x1]
    40001260:	a9010fe2 	stp	x2, x3, [sp, #16]
    40001264:	a9410c22 	ldp	x2, x3, [x1, #16]
    40001268:	9100e3e1 	add	x1, sp, #0x38
    4000126c:	a9020fe2 	stp	x2, x3, [sp, #32]
    40001270:	910043e3 	add	x3, sp, #0x10
    40001274:	aa0003e2 	mov	x2, x0
    40001278:	90000000 	adrp	x0, 40001000 <__aarch64_ldset8_acq_rel+0x10>
    4000127c:	91079000 	add	x0, x0, #0x1e4
	struct out_context ctx = { 0 };
    40001280:	b9003bff 	str	wzr, [sp, #56]
	cbvprintf(char_out, &ctx, fmt, ap);
    40001284:	940001f4 	bl	40001a54 <cbvprintf>
}
    40001288:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000128c:	d65f03c0 	ret

0000000040001290 <printk>:
{
    40001290:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
    40001294:	910003fd 	mov	x29, sp
    40001298:	a90d8be1 	stp	x1, x2, [sp, #216]
	va_start(ap, fmt);
    4000129c:	910443e1 	add	x1, sp, #0x110
    400012a0:	a90307e1 	stp	x1, x1, [sp, #48]
    400012a4:	910343e1 	add	x1, sp, #0xd0
    400012a8:	f90023e1 	str	x1, [sp, #64]
    400012ac:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    400012b0:	b9004be1 	str	w1, [sp, #72]
    400012b4:	12800fe1 	mov	w1, #0xffffff80            	// #-128
    400012b8:	b9004fe1 	str	w1, [sp, #76]
		vprintk(fmt, ap);
    400012bc:	910043e1 	add	x1, sp, #0x10
{
    400012c0:	a90e93e3 	stp	x3, x4, [sp, #232]
		vprintk(fmt, ap);
    400012c4:	a9430fe2 	ldp	x2, x3, [sp, #48]
    400012c8:	a9010fe2 	stp	x2, x3, [sp, #16]
    400012cc:	a9440fe2 	ldp	x2, x3, [sp, #64]
    400012d0:	a9020fe2 	stp	x2, x3, [sp, #32]
{
    400012d4:	3d8017e0 	str	q0, [sp, #80]
    400012d8:	3d801be1 	str	q1, [sp, #96]
    400012dc:	3d801fe2 	str	q2, [sp, #112]
    400012e0:	3d8023e3 	str	q3, [sp, #128]
    400012e4:	3d8027e4 	str	q4, [sp, #144]
    400012e8:	3d802be5 	str	q5, [sp, #160]
    400012ec:	3d802fe6 	str	q6, [sp, #176]
    400012f0:	3d8033e7 	str	q7, [sp, #192]
    400012f4:	a90f9be5 	stp	x5, x6, [sp, #248]
    400012f8:	f90087e7 	str	x7, [sp, #264]
		vprintk(fmt, ap);
    400012fc:	97ffffd6 	bl	40001254 <vprintk>
}
    40001300:	a8d17bfd 	ldp	x29, x30, [sp], #272
    40001304:	d65f03c0 	ret

0000000040001308 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    40001308:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000130c:	910003fd 	mov	x29, sp
    40001310:	f9000bf3 	str	x19, [sp, #16]
    40001314:	aa0003f3 	mov	x19, x0
	struct str_context ctx = { str, size, 0 };
    40001318:	f90023e0 	str	x0, [sp, #64]
    4000131c:	29097fe1 	stp	w1, wzr, [sp, #72]

	cbvprintf(str_out, &ctx, fmt, ap);
    40001320:	a9400460 	ldp	x0, x1, [x3]
    40001324:	a90207e0 	stp	x0, x1, [sp, #32]
    40001328:	a9410460 	ldp	x0, x1, [x3, #16]
    4000132c:	910083e3 	add	x3, sp, #0x20
    40001330:	a90307e0 	stp	x0, x1, [sp, #48]
    40001334:	910103e1 	add	x1, sp, #0x40
    40001338:	90000000 	adrp	x0, 40001000 <__aarch64_ldset8_acq_rel+0x10>
    4000133c:	91080000 	add	x0, x0, #0x200
    40001340:	940001c5 	bl	40001a54 <cbvprintf>

	if (ctx.count < ctx.max) {
    40001344:	294903e1 	ldp	w1, w0, [sp, #72]
    40001348:	6b01001f 	cmp	w0, w1
    4000134c:	5400004a 	b.ge	40001354 <vsnprintk+0x4c>  // b.tcont
		str[ctx.count] = '\0';
    40001350:	3820ca7f 	strb	wzr, [x19, w0, sxtw]
	}

	return ctx.count;
}
    40001354:	f9400bf3 	ldr	x19, [sp, #16]
    40001358:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4000135c:	d65f03c0 	ret

0000000040001360 <snprintk>:
{
    40001360:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40001364:	910003fd 	mov	x29, sp
    40001368:	a90d93e3 	stp	x3, x4, [sp, #216]
	va_start(ap, fmt);
    4000136c:	910403e3 	add	x3, sp, #0x100
    40001370:	a9030fe3 	stp	x3, x3, [sp, #48]
    40001374:	910343e3 	add	x3, sp, #0xd0
    40001378:	f90023e3 	str	x3, [sp, #64]
    4000137c:	128004e3 	mov	w3, #0xffffffd8            	// #-40
    40001380:	b9004be3 	str	w3, [sp, #72]
    40001384:	12800fe3 	mov	w3, #0xffffff80            	// #-128
    40001388:	b9004fe3 	str	w3, [sp, #76]
	ret = vsnprintk(str, size, fmt, ap);
    4000138c:	910043e3 	add	x3, sp, #0x10
{
    40001390:	a90e9be5 	stp	x5, x6, [sp, #232]
	ret = vsnprintk(str, size, fmt, ap);
    40001394:	a94317e4 	ldp	x4, x5, [sp, #48]
    40001398:	a90117e4 	stp	x4, x5, [sp, #16]
    4000139c:	a94417e4 	ldp	x4, x5, [sp, #64]
    400013a0:	a90217e4 	stp	x4, x5, [sp, #32]
{
    400013a4:	3d8017e0 	str	q0, [sp, #80]
    400013a8:	3d801be1 	str	q1, [sp, #96]
    400013ac:	3d801fe2 	str	q2, [sp, #112]
    400013b0:	3d8023e3 	str	q3, [sp, #128]
    400013b4:	3d8027e4 	str	q4, [sp, #144]
    400013b8:	3d802be5 	str	q5, [sp, #160]
    400013bc:	3d802fe6 	str	q6, [sp, #176]
    400013c0:	3d8033e7 	str	q7, [sp, #192]
    400013c4:	f9007fe7 	str	x7, [sp, #248]
	ret = vsnprintk(str, size, fmt, ap);
    400013c8:	97ffffd0 	bl	40001308 <vsnprintk>
}
    400013cc:	a8d07bfd 	ldp	x29, x30, [sp], #256
    400013d0:	d65f03c0 	ret

00000000400013d4 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    400013d4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400013d8:	aa0003e4 	mov	x4, x0
    400013dc:	aa0103e0 	mov	x0, x1
    400013e0:	910003fd 	mov	x29, sp
    400013e4:	aa0203e1 	mov	x1, x2
    400013e8:	aa0303e2 	mov	x2, x3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    400013ec:	d63f0080 	blr	x4
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
    400013f0:	9400268d 	bl	4000ae24 <z_impl_z_current_get>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
    400013f4:	940026d8 	bl	4000af54 <z_impl_k_thread_abort>

00000000400013f8 <setup_bundle_data.constprop.0>:
			      size_t offset, size_t num_bits)
{
	bd->sidx = offset / bundle_bitness(bitarray);
	bd->soff = offset % bundle_bitness(bitarray);

	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    400013f8:	d1000442 	sub	x2, x2, #0x1
	bd->sidx = offset / bundle_bitness(bitarray);
    400013fc:	d345fc25 	lsr	x5, x1, #5
	bd->soff = offset % bundle_bitness(bitarray);
    40001400:	92401023 	and	x3, x1, #0x1f
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    40001404:	8b010041 	add	x1, x2, x1
	bd->eoff = (offset + num_bits - 1) % bundle_bitness(bitarray);

	bd->smask = ~(BIT(bd->soff) - 1);
    40001408:	d2800022 	mov	x2, #0x1                   	// #1
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    4000140c:	d345fc24 	lsr	x4, x1, #5
	bd->eoff = (offset + num_bits - 1) % bundle_bitness(bitarray);
    40001410:	92401021 	and	x1, x1, #0x1f
    40001414:	a9010403 	stp	x3, x1, [x0, #16]
	bd->smask = ~(BIT(bd->soff) - 1);
    40001418:	9ac32043 	lsl	x3, x2, x3
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
    4000141c:	9ac12042 	lsl	x2, x2, x1
    40001420:	51000441 	sub	w1, w2, #0x1
	bd->smask = ~(BIT(bd->soff) - 1);
    40001424:	4b0303e3 	neg	w3, w3
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
    40001428:	2a020021 	orr	w1, w1, w2

	if (bd->sidx == bd->eidx) {
		/* The region lies within the same bundle. So combine the masks. */
		bd->smask &= bd->emask;
    4000142c:	eb0400bf 	cmp	x5, x4
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
    40001430:	b9002401 	str	w1, [x0, #36]
		bd->smask &= bd->emask;
    40001434:	0a010061 	and	w1, w3, w1
    40001438:	1a830021 	csel	w1, w1, w3, eq  // eq = none
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    4000143c:	a9001005 	stp	x5, x4, [x0]
		bd->smask &= bd->emask;
    40001440:	b9002001 	str	w1, [x0, #32]
	}
}
    40001444:	d65f03c0 	ret

0000000040001448 <set_region>:
 *                 prior call to match_region().
 */
static void set_region(sys_bitarray_t *bitarray, size_t offset,
		       size_t num_bits, bool to_set,
		       struct bundle_data *bd)
{
    40001448:	aa0003e7 	mov	x7, x0
    4000144c:	12001c69 	and	w9, w3, #0xff
	int idx;
	struct bundle_data bdata;

	if (bd == NULL) {
    40001450:	b50005e4 	cbnz	x4, 4000150c <set_region+0xc4>
{
    40001454:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
		bd = &bdata;
		setup_bundle_data(bitarray, bd, offset, num_bits);
    40001458:	910063e0 	add	x0, sp, #0x18
{
    4000145c:	910003fd 	mov	x29, sp
		setup_bundle_data(bitarray, bd, offset, num_bits);
    40001460:	97ffffe6 	bl	400013f8 <setup_bundle_data.constprop.0>
	}

	if (bd->sidx == bd->eidx) {
		/* Start/end at same bundle */
		if (to_set) {
			bitarray->bundles[bd->sidx] |= bd->smask;
    40001464:	f94004e2 	ldr	x2, [x7, #8]
	if (bd->sidx == bd->eidx) {
    40001468:	a9401801 	ldp	x1, x6, [x0]
			bitarray->bundles[bd->sidx] |= bd->smask;
    4000146c:	b9402004 	ldr	w4, [x0, #32]
    40001470:	d37ef428 	lsl	x8, x1, #2
	if (bd->sidx == bd->eidx) {
    40001474:	eb06003f 	cmp	x1, x6
			bitarray->bundles[bd->sidx] |= bd->smask;
    40001478:	b8686845 	ldr	w5, [x2, x8]
	if (bd->sidx == bd->eidx) {
    4000147c:	54000101 	b.ne	4000149c <set_region+0x54>  // b.any
			bitarray->bundles[bd->sidx] |= bd->smask;
    40001480:	0a2400a0 	bic	w0, w5, w4
    40001484:	7100013f 	cmp	w9, #0x0
    40001488:	2a0400a5 	orr	w5, w5, w4
    4000148c:	1a8010a5 	csel	w5, w5, w0, ne  // ne = any
    40001490:	b8286845 	str	w5, [x2, x8]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
				bitarray->bundles[idx] = 0U;
			}
		}
	}
}
    40001494:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40001498:	d65f03c0 	ret
			bitarray->bundles[bd->eidx] |= bd->emask;
    4000149c:	d37ef4c7 	lsl	x7, x6, #2
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400014a0:	11000421 	add	w1, w1, #0x1
		if (to_set) {
    400014a4:	340001c9 	cbz	w9, 400014dc <set_region+0x94>
			bitarray->bundles[bd->sidx] |= bd->smask;
    400014a8:	2a0400a5 	orr	w5, w5, w4
    400014ac:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] |= bd->emask;
    400014b0:	b8676843 	ldr	w3, [x2, x7]
    400014b4:	b9402400 	ldr	w0, [x0, #36]
    400014b8:	2a000063 	orr	w3, w3, w0
    400014bc:	b8276843 	str	w3, [x2, x7]
				bitarray->bundles[idx] = ~0U;
    400014c0:	12800003 	mov	w3, #0xffffffff            	// #-1
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400014c4:	93407c20 	sxtw	x0, w1
    400014c8:	eb21c0df 	cmp	x6, w1, sxtw
    400014cc:	54fffe49 	b.ls	40001494 <set_region+0x4c>  // b.plast
    400014d0:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = ~0U;
    400014d4:	b8207843 	str	w3, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400014d8:	17fffffb 	b	400014c4 <set_region+0x7c>
			bitarray->bundles[bd->sidx] &= ~bd->smask;
    400014dc:	0a2400a5 	bic	w5, w5, w4
    400014e0:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] &= ~bd->emask;
    400014e4:	b8676843 	ldr	w3, [x2, x7]
    400014e8:	b9402400 	ldr	w0, [x0, #36]
    400014ec:	0a200060 	bic	w0, w3, w0
    400014f0:	b8276840 	str	w0, [x2, x7]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400014f4:	93407c20 	sxtw	x0, w1
    400014f8:	eb21c0df 	cmp	x6, w1, sxtw
    400014fc:	54fffcc9 	b.ls	40001494 <set_region+0x4c>  // b.plast
    40001500:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = 0U;
    40001504:	b820785f 	str	wzr, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40001508:	17fffffb 	b	400014f4 <set_region+0xac>
    4000150c:	aa0403e0 	mov	x0, x4
			bitarray->bundles[bd->sidx] |= bd->smask;
    40001510:	b9402084 	ldr	w4, [x4, #32]
    40001514:	f94004e2 	ldr	x2, [x7, #8]
	if (bd->sidx == bd->eidx) {
    40001518:	a9401801 	ldp	x1, x6, [x0]
			bitarray->bundles[bd->sidx] |= bd->smask;
    4000151c:	d37ef428 	lsl	x8, x1, #2
	if (bd->sidx == bd->eidx) {
    40001520:	eb06003f 	cmp	x1, x6
			bitarray->bundles[bd->sidx] |= bd->smask;
    40001524:	b8686845 	ldr	w5, [x2, x8]
	if (bd->sidx == bd->eidx) {
    40001528:	540000e1 	b.ne	40001544 <set_region+0xfc>  // b.any
			bitarray->bundles[bd->sidx] |= bd->smask;
    4000152c:	0a2400a0 	bic	w0, w5, w4
    40001530:	7100013f 	cmp	w9, #0x0
    40001534:	2a0400a5 	orr	w5, w5, w4
    40001538:	1a8010a5 	csel	w5, w5, w0, ne  // ne = any
    4000153c:	b8286845 	str	w5, [x2, x8]
    40001540:	d65f03c0 	ret
			bitarray->bundles[bd->eidx] |= bd->emask;
    40001544:	d37ef4c7 	lsl	x7, x6, #2
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40001548:	11000421 	add	w1, w1, #0x1
		if (to_set) {
    4000154c:	340001e9 	cbz	w9, 40001588 <set_region+0x140>
			bitarray->bundles[bd->sidx] |= bd->smask;
    40001550:	2a0400a5 	orr	w5, w5, w4
    40001554:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] |= bd->emask;
    40001558:	b8676843 	ldr	w3, [x2, x7]
    4000155c:	b9402400 	ldr	w0, [x0, #36]
    40001560:	2a000063 	orr	w3, w3, w0
    40001564:	b8276843 	str	w3, [x2, x7]
				bitarray->bundles[idx] = ~0U;
    40001568:	12800003 	mov	w3, #0xffffffff            	// #-1
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    4000156c:	93407c20 	sxtw	x0, w1
    40001570:	eb21c0df 	cmp	x6, w1, sxtw
    40001574:	54000048 	b.hi	4000157c <set_region+0x134>  // b.pmore
    40001578:	d65f03c0 	ret
    4000157c:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = ~0U;
    40001580:	b8207843 	str	w3, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40001584:	17fffffa 	b	4000156c <set_region+0x124>
			bitarray->bundles[bd->sidx] &= ~bd->smask;
    40001588:	0a2400a5 	bic	w5, w5, w4
    4000158c:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] &= ~bd->emask;
    40001590:	b8676843 	ldr	w3, [x2, x7]
    40001594:	b9402400 	ldr	w0, [x0, #36]
    40001598:	0a200060 	bic	w0, w3, w0
    4000159c:	b8276840 	str	w0, [x2, x7]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400015a0:	93407c20 	sxtw	x0, w1
    400015a4:	eb21c0df 	cmp	x6, w1, sxtw
    400015a8:	54000048 	b.hi	400015b0 <set_region+0x168>  // b.pmore
    400015ac:	d65f03c0 	ret
    400015b0:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = 0U;
    400015b4:	b820785f 	str	wzr, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400015b8:	17fffffa 	b	400015a0 <set_region+0x158>

00000000400015bc <set_clear_region>:
	return is_region_set_clear(bitarray, num_bits, offset, false);
}

static int set_clear_region(sys_bitarray_t *bitarray, size_t num_bits,
			    size_t offset, bool to_set)
{
    400015bc:	aa0103e5 	mov	x5, x1
    400015c0:	aa0203e1 	mov	x1, x2
	int ret;
	size_t off_end = offset + num_bits - 1;
    400015c4:	d10004a2 	sub	x2, x5, #0x1
    400015c8:	8b010042 	add	x2, x2, x1
MAKE_REG_HELPER(cntv_ctl_el0)
MAKE_REG_HELPER(cntv_cval_el0)
MAKE_REG_HELPER(cntvct_el0);
MAKE_REG_HELPER(cntvoff_el2);
MAKE_REG_HELPER(currentel);
MAKE_REG_HELPER(daif)
    400015cc:	d53b422a 	mrs	x10, daif
			  :: "i" (DAIFCLR_IRQ_BIT) : "memory");
}

static ALWAYS_INLINE void disable_irq(void)
{
	__asm__ volatile ("msr DAIFSet, %0"
    400015d0:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&bitarray->lock);

	__ASSERT_NO_MSG(bitarray->num_bits > 0);

	if ((num_bits == 0)
    400015d4:	b4000265 	cbz	x5, 40001620 <set_clear_region+0x64>
	    || (num_bits > bitarray->num_bits)
    400015d8:	b9400004 	ldr	w4, [x0]
    400015dc:	eb05009f 	cmp	x4, x5
    400015e0:	54000203 	b.cc	40001620 <set_clear_region+0x64>  // b.lo, b.ul, b.last
	    || (offset >= bitarray->num_bits)
    400015e4:	eb01009f 	cmp	x4, x1
    400015e8:	540001c9 	b.ls	40001620 <set_clear_region+0x64>  // b.plast
	    || (off_end >= bitarray->num_bits)) {
    400015ec:	eb02009f 	cmp	x4, x2
    400015f0:	54000189 	b.ls	40001620 <set_clear_region+0x64>  // b.plast
{
    400015f4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400015f8:	12001c63 	and	w3, w3, #0xff
		ret = -EINVAL;
		goto out;
	}

	set_region(bitarray, offset, num_bits, to_set, NULL);
    400015fc:	aa0503e2 	mov	x2, x5
{
    40001600:	910003fd 	mov	x29, sp
	set_region(bitarray, offset, num_bits, to_set, NULL);
    40001604:	d2800004 	mov	x4, #0x0                   	// #0
    40001608:	97ffff90 	bl	40001448 <set_region>
	ret = 0;
    4000160c:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    40001610:	92407d4a 	and	x10, x10, #0xffffffff
    40001614:	d51b422a 	msr	daif, x10

out:
	k_spin_unlock(&bitarray->lock, key);
	return ret;
}
    40001618:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000161c:	d65f03c0 	ret
		ret = -EINVAL;
    40001620:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40001624:	92407d4a 	and	x10, x10, #0xffffffff
    40001628:	d51b422a 	msr	daif, x10
}
    4000162c:	d65f03c0 	ret

0000000040001630 <match_region>:
{
    40001630:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40001634:	aa0003e8 	mov	x8, x0
    40001638:	aa0403e0 	mov	x0, x4
    4000163c:	910003fd 	mov	x29, sp
    40001640:	12001c67 	and	w7, w3, #0xff
    40001644:	aa0503e6 	mov	x6, x5
	setup_bundle_data(bitarray, bd, offset, num_bits);
    40001648:	97ffff6c 	bl	400013f8 <setup_bundle_data.constprop.0>
	if (bd->sidx == bd->eidx) {
    4000164c:	a9401002 	ldp	x2, x4, [x0]
    40001650:	b9402001 	ldr	w1, [x0, #32]
    40001654:	f9400503 	ldr	x3, [x8, #8]
    40001658:	eb04005f 	cmp	x2, x4
    4000165c:	54000221 	b.ne	400016a0 <match_region+0x70>  // b.any
		bundle = bitarray->bundles[bd->sidx];
    40001660:	b8627860 	ldr	w0, [x3, x2, lsl #2]
		if (!match_set) {
    40001664:	35000047 	cbnz	w7, 4000166c <match_region+0x3c>
			bundle = ~bundle;
    40001668:	2a2003e0 	mvn	w0, w0
		if ((bundle & bd->smask) != bd->smask) {
    4000166c:	6a20003f 	bics	wzr, w1, w0
    40001670:	54000400 	b.eq	400016f0 <match_region+0xc0>  // b.none
			mismatch_bundle = ~bundle & bd->smask;
    40001674:	0a200020 	bic	w0, w1, w0
	if (mismatch != NULL) {
    40001678:	b4000106 	cbz	x6, 40001698 <match_region+0x68>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
    4000167c:	7100001f 	cmp	w0, #0x0
    40001680:	5ac00000 	rbit	w0, w0
    40001684:	5ac01000 	clz	w0, w0
    40001688:	1a8007e0 	csinc	w0, wzr, w0, eq  // eq = none
		mismatch_bit_off = find_lsb_set(mismatch_bundle) - 1;
    4000168c:	51000400 	sub	w0, w0, #0x1
		*mismatch = (uint32_t)mismatch_bit_off;
    40001690:	0b021400 	add	w0, w0, w2, lsl #5
    40001694:	f90000c0 	str	x0, [x6]
	return false;
    40001698:	52800000 	mov	w0, #0x0                   	// #0
    4000169c:	14000016 	b	400016f4 <match_region+0xc4>
	bundle = bitarray->bundles[bd->sidx];
    400016a0:	b8627865 	ldr	w5, [x3, x2, lsl #2]
	if (!match_set) {
    400016a4:	35000047 	cbnz	w7, 400016ac <match_region+0x7c>
		bundle = ~bundle;
    400016a8:	2a2503e5 	mvn	w5, w5
	if ((bundle & bd->smask) != bd->smask) {
    400016ac:	6a25003f 	bics	wzr, w1, w5
    400016b0:	54000060 	b.eq	400016bc <match_region+0x8c>  // b.none
		mismatch_bundle = ~bundle & bd->smask;
    400016b4:	0a250020 	bic	w0, w1, w5
		goto mismatch;
    400016b8:	17fffff0 	b	40001678 <match_region+0x48>
	bundle = bitarray->bundles[bd->eidx];
    400016bc:	b8647861 	ldr	w1, [x3, x4, lsl #2]
	if (!match_set) {
    400016c0:	35000047 	cbnz	w7, 400016c8 <match_region+0x98>
		bundle = ~bundle;
    400016c4:	2a2103e1 	mvn	w1, w1
	if ((bundle & bd->emask) != bd->emask) {
    400016c8:	b9402400 	ldr	w0, [x0, #36]
    400016cc:	6a21001f 	bics	wzr, w0, w1
    400016d0:	54000080 	b.eq	400016e0 <match_region+0xb0>  // b.none
		mismatch_bundle = ~bundle & bd->emask;
    400016d4:	0a210000 	bic	w0, w0, w1
		goto mismatch;
    400016d8:	aa0403e2 	mov	x2, x4
    400016dc:	17ffffe7 	b	40001678 <match_region+0x48>
	for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400016e0:	11000441 	add	w1, w2, #0x1
    400016e4:	93407c22 	sxtw	x2, w1
    400016e8:	eb21c09f 	cmp	x4, w1, sxtw
    400016ec:	54000088 	b.hi	400016fc <match_region+0xcc>  // b.pmore
	return true;
    400016f0:	52800020 	mov	w0, #0x1                   	// #1
}
    400016f4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400016f8:	d65f03c0 	ret
		bundle = bitarray->bundles[idx];
    400016fc:	b8627860 	ldr	w0, [x3, x2, lsl #2]
		if (match_set) {
    40001700:	34000047 	cbz	w7, 40001708 <match_region+0xd8>
			bundle = ~bundle;
    40001704:	2a2003e0 	mvn	w0, w0
		if (bundle != 0U) {
    40001708:	34000060 	cbz	w0, 40001714 <match_region+0xe4>
			mismatch_bundle = ~bundle;
    4000170c:	2a2003e0 	mvn	w0, w0
			goto mismatch;
    40001710:	17ffffda 	b	40001678 <match_region+0x48>
	for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40001714:	11000421 	add	w1, w1, #0x1
    40001718:	17fffff3 	b	400016e4 <match_region+0xb4>

000000004000171c <sys_bitarray_alloc>:
    4000171c:	d53b422d 	mrs	x13, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40001720:	d50342df 	msr	daifset, #0x2
	CHECKIF(offset == NULL) {
    40001724:	b4000502 	cbz	x2, 400017c4 <sys_bitarray_alloc+0xa8>
    40001728:	aa0103ea 	mov	x10, x1
	if ((num_bits == 0) || (num_bits > bitarray->num_bits)) {
    4000172c:	b40004c1 	cbz	x1, 400017c4 <sys_bitarray_alloc+0xa8>
    40001730:	b9400001 	ldr	w1, [x0]
    40001734:	aa0003e9 	mov	x9, x0
    40001738:	eb0a003f 	cmp	x1, x10
    4000173c:	54000443 	b.cc	400017c4 <sys_bitarray_alloc+0xa8>  // b.lo, b.ul, b.last
    40001740:	aa0203ec 	mov	x12, x2
    40001744:	b9400522 	ldr	w2, [x9, #4]
	for (ret = 0; ret < bitarray->num_bundles; ret++) {
    40001748:	52800000 	mov	w0, #0x0                   	// #0
    4000174c:	531b6804 	lsl	w4, w0, #5
    40001750:	6b02001f 	cmp	w0, w2
    40001754:	540001e0 	b.eq	40001790 <sys_bitarray_alloc+0x74>  // b.none
		if (~bitarray->bundles[ret] == 0U) {
    40001758:	f9400523 	ldr	x3, [x9, #8]
    4000175c:	b860d863 	ldr	w3, [x3, w0, sxtw #2]
    40001760:	3100047f 	cmn	w3, #0x1
    40001764:	54000061 	b.ne	40001770 <sys_bitarray_alloc+0x54>  // b.any
	for (ret = 0; ret < bitarray->num_bundles; ret++) {
    40001768:	11000400 	add	w0, w0, #0x1
    4000176c:	17fffff8 	b	4000174c <sys_bitarray_alloc+0x30>
		if (bitarray->bundles[ret] != 0U) {
    40001770:	34000103 	cbz	w3, 40001790 <sys_bitarray_alloc+0x74>
			off_start = find_lsb_set(~bitarray->bundles[ret]) - 1;
    40001774:	2a2303e3 	mvn	w3, w3
			bit_idx += off_start;
    40001778:	51000484 	sub	w4, w4, #0x1
    4000177c:	7100007f 	cmp	w3, #0x0
    40001780:	5ac00063 	rbit	w3, w3
    40001784:	5ac01063 	clz	w3, w3
    40001788:	1a8307e3 	csinc	w3, wzr, w3, eq  // eq = none
    4000178c:	0b030084 	add	w4, w4, w3
	off_end = bitarray->num_bits - num_bits;
    40001790:	cb0a002b 	sub	x11, x1, x10
	while (bit_idx <= off_end) {
    40001794:	2a0403ee 	mov	w14, w4
    40001798:	eb24417f 	cmp	x11, w4, uxtw
    4000179c:	540001c2 	b.cs	400017d4 <sys_bitarray_alloc+0xb8>  // b.hs, b.nlast
	ret = -ENOSPC;
    400017a0:	12800360 	mov	w0, #0xffffffe4            	// #-28
    400017a4:	14000009 	b	400017c8 <sys_bitarray_alloc+0xac>
		bit_idx = mismatch + 1;
    400017a8:	f9400be4 	ldr	x4, [sp, #16]
    400017ac:	11000484 	add	w4, w4, #0x1
	while (bit_idx <= off_end) {
    400017b0:	2a0403ee 	mov	w14, w4
    400017b4:	eb24417f 	cmp	x11, w4, uxtw
    400017b8:	54000122 	b.cs	400017dc <sys_bitarray_alloc+0xc0>  // b.hs, b.nlast
	ret = -ENOSPC;
    400017bc:	12800360 	mov	w0, #0xffffffe4            	// #-28
out:
    400017c0:	14000018 	b	40001820 <sys_bitarray_alloc+0x104>
		ret = -EINVAL;
    400017c4:	128002a0 	mov	w0, #0xffffffea            	// #-22
MAKE_REG_HELPER(daif)
    400017c8:	92407dad 	and	x13, x13, #0xffffffff
    400017cc:	d51b422d 	msr	daif, x13
}
    400017d0:	d65f03c0 	ret
{
    400017d4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400017d8:	910003fd 	mov	x29, sp
		if (match_region(bitarray, bit_idx, num_bits, false,
    400017dc:	910043e5 	add	x5, sp, #0x10
    400017e0:	910063e4 	add	x4, sp, #0x18
    400017e4:	aa0a03e2 	mov	x2, x10
    400017e8:	aa0e03e1 	mov	x1, x14
    400017ec:	aa0903e0 	mov	x0, x9
    400017f0:	52800003 	mov	w3, #0x0                   	// #0
    400017f4:	97ffff8f 	bl	40001630 <match_region>
    400017f8:	72001c1f 	tst	w0, #0xff
    400017fc:	54fffd60 	b.eq	400017a8 <sys_bitarray_alloc+0x8c>  // b.none
			set_region(bitarray, bit_idx, num_bits, true, &bd);
    40001800:	aa0903e0 	mov	x0, x9
    40001804:	910063e4 	add	x4, sp, #0x18
    40001808:	aa0a03e2 	mov	x2, x10
    4000180c:	aa0e03e1 	mov	x1, x14
    40001810:	52800023 	mov	w3, #0x1                   	// #1
    40001814:	97ffff0d 	bl	40001448 <set_region>
			ret = 0;
    40001818:	52800000 	mov	w0, #0x0                   	// #0
			*offset = bit_idx;
    4000181c:	f900018e 	str	x14, [x12]
    40001820:	92407dad 	and	x13, x13, #0xffffffff
    40001824:	d51b422d 	msr	daif, x13
}
    40001828:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000182c:	d65f03c0 	ret

0000000040001830 <sys_bitarray_free>:
{
    40001830:	aa0103e9 	mov	x9, x1
	size_t off_end = offset + num_bits - 1;
    40001834:	d1000421 	sub	x1, x1, #0x1
    40001838:	8b020021 	add	x1, x1, x2
    4000183c:	d53b422c 	mrs	x12, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40001840:	d50342df 	msr	daifset, #0x2
	if ((num_bits == 0)
    40001844:	b40003e9 	cbz	x9, 400018c0 <sys_bitarray_free+0x90>
    40001848:	aa0203ea 	mov	x10, x2
	    || (num_bits > bitarray->num_bits)
    4000184c:	b9400002 	ldr	w2, [x0]
    40001850:	aa0003eb 	mov	x11, x0
    40001854:	eb09005f 	cmp	x2, x9
    40001858:	54000343 	b.cc	400018c0 <sys_bitarray_free+0x90>  // b.lo, b.ul, b.last
	    || (offset >= bitarray->num_bits)
    4000185c:	eb0a005f 	cmp	x2, x10
    40001860:	54000309 	b.ls	400018c0 <sys_bitarray_free+0x90>  // b.plast
	    || (off_end >= bitarray->num_bits)) {
    40001864:	eb01005f 	cmp	x2, x1
    40001868:	540002c9 	b.ls	400018c0 <sys_bitarray_free+0x90>  // b.plast
{
    4000186c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	if (match_region(bitarray, offset, num_bits, true, &bd, NULL)) {
    40001870:	aa0903e2 	mov	x2, x9
    40001874:	aa0a03e1 	mov	x1, x10
{
    40001878:	910003fd 	mov	x29, sp
	if (match_region(bitarray, offset, num_bits, true, &bd, NULL)) {
    4000187c:	910063e4 	add	x4, sp, #0x18
    40001880:	d2800005 	mov	x5, #0x0                   	// #0
    40001884:	52800023 	mov	w3, #0x1                   	// #1
    40001888:	97ffff6a 	bl	40001630 <match_region>
    4000188c:	72001c1f 	tst	w0, #0xff
    40001890:	54000200 	b.eq	400018d0 <sys_bitarray_free+0xa0>  // b.none
		set_region(bitarray, offset, num_bits, false, &bd);
    40001894:	aa0b03e0 	mov	x0, x11
    40001898:	910063e4 	add	x4, sp, #0x18
    4000189c:	aa0903e2 	mov	x2, x9
    400018a0:	aa0a03e1 	mov	x1, x10
    400018a4:	52800003 	mov	w3, #0x0                   	// #0
    400018a8:	97fffee8 	bl	40001448 <set_region>
		ret = 0;
    400018ac:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    400018b0:	92407d8c 	and	x12, x12, #0xffffffff
    400018b4:	d51b422c 	msr	daif, x12
}
    400018b8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400018bc:	d65f03c0 	ret
		ret = -EINVAL;
    400018c0:	128002a0 	mov	w0, #0xffffffea            	// #-22
    400018c4:	92407d8c 	and	x12, x12, #0xffffffff
    400018c8:	d51b422c 	msr	daif, x12
}
    400018cc:	d65f03c0 	ret
		ret = -EFAULT;
    400018d0:	128001a0 	mov	w0, #0xfffffff2            	// #-14
    400018d4:	17fffff7 	b	400018b0 <sys_bitarray_free+0x80>

00000000400018d8 <sys_bitarray_set_region>:

int sys_bitarray_set_region(sys_bitarray_t *bitarray, size_t num_bits,
			    size_t offset)
{
	return set_clear_region(bitarray, num_bits, offset, true);
    400018d8:	52800023 	mov	w3, #0x1                   	// #1
    400018dc:	17ffff38 	b	400015bc <set_clear_region>

00000000400018e0 <_get_digit>:

/* Extract the next decimal character in the converted representation of a
 * fractional component.
 */
static char _get_digit(uint64_t *fr, int *digit_count)
{
    400018e0:	aa0003e3 	mov	x3, x0
	char rval;

	if (*digit_count > 0) {
    400018e4:	b9400020 	ldr	w0, [x1]
    400018e8:	7100001f 	cmp	w0, #0x0
    400018ec:	5400016d 	b.le	40001918 <_get_digit+0x38>
		--*digit_count;
    400018f0:	51000400 	sub	w0, w0, #0x1
    400018f4:	b9000020 	str	w0, [x1]
		*fr *= 10U;
    400018f8:	f9400061 	ldr	x1, [x3]
    400018fc:	d2800140 	mov	x0, #0xa                   	// #10
    40001900:	9b007c21 	mul	x1, x1, x0
		rval = ((*fr >> 60) & 0xF) + '0';
    40001904:	d37cfc22 	lsr	x2, x1, #60
		*fr &= (BIT64(60) - 1U);
    40001908:	9240ec21 	and	x1, x1, #0xfffffffffffffff
		rval = ((*fr >> 60) & 0xF) + '0';
    4000190c:	1100c040 	add	w0, w2, #0x30
		*fr &= (BIT64(60) - 1U);
    40001910:	f9000061 	str	x1, [x3]
	} else {
		rval = '0';
	}

	return rval;
}
    40001914:	d65f03c0 	ret
		rval = '0';
    40001918:	52800600 	mov	w0, #0x30                  	// #48
    4000191c:	17fffffe 	b	40001914 <_get_digit+0x34>

0000000040001920 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
    40001920:	aa0003e5 	mov	x5, x0
    40001924:	aa0303e0 	mov	x0, x3
	bool upcase = isupper((int)conv->specifier);
    40001928:	39400c23 	ldrb	w3, [x1, #3]
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    4000192c:	51010468 	sub	w8, w3, #0x41
	switch (specifier) {
    40001930:	7101bc7f 	cmp	w3, #0x6f
    40001934:	54000380 	b.eq	400019a4 <encode_uint+0x84>  // b.none
    40001938:	54000308 	b.hi	40001998 <encode_uint+0x78>  // b.pmore
		return 16;
    4000193c:	7101607f 	cmp	w3, #0x58
    40001940:	d2800144 	mov	x4, #0xa                   	// #10
    40001944:	d2800203 	mov	x3, #0x10                  	// #16
    40001948:	9a831084 	csel	x4, x4, x3, ne  // ne = any
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
    4000194c:	9ac408a7 	udiv	x7, x5, x4
    40001950:	9b0494e6 	msub	x6, x7, x4, x5

		*--bp = (lsv <= 9) ? ('0' + lsv)
    40001954:	12001cc3 	and	w3, w6, #0xff
    40001958:	f10024df 	cmp	x6, #0x9
    4000195c:	540002c8 	b.hi	400019b4 <encode_uint+0x94>  // b.pmore
    40001960:	1100c063 	add	w3, w3, #0x30
    40001964:	12001c63 	and	w3, w3, #0xff
    40001968:	381ffc03 	strb	w3, [x0, #-1]!
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
	} while ((value != 0) && (bps < bp));
    4000196c:	eb0400bf 	cmp	x5, x4
    40001970:	fa422000 	ccmp	x0, x2, #0x0, cs  // cs = hs, nlast
    40001974:	540001c8 	b.hi	400019ac <encode_uint+0x8c>  // b.pmore

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
    40001978:	79400022 	ldrh	w2, [x1]
    4000197c:	362800c2 	tbz	w2, #5, 40001994 <encode_uint+0x74>
		if (radix == 8) {
    40001980:	f100209f 	cmp	x4, #0x8
    40001984:	54000261 	b.ne	400019d0 <encode_uint+0xb0>  // b.any
			conv->altform_0 = true;
    40001988:	39400822 	ldrb	w2, [x1, #2]
    4000198c:	321d0042 	orr	w2, w2, #0x8
		} else if (radix == 16) {
			conv->altform_0c = true;
    40001990:	39000822 	strb	w2, [x1, #2]
			;
		}
	}

	return bp;
}
    40001994:	d65f03c0 	ret
	switch (specifier) {
    40001998:	121c7863 	and	w3, w3, #0xfffffff7
		return 16;
    4000199c:	7101c07f 	cmp	w3, #0x70
    400019a0:	17ffffe8 	b	40001940 <encode_uint+0x20>
	switch (specifier) {
    400019a4:	d2800104 	mov	x4, #0x8                   	// #8
	char *bp = bps + (bpe - bps);
    400019a8:	17ffffe9 	b	4000194c <encode_uint+0x2c>
		value /= radix;
    400019ac:	aa0703e5 	mov	x5, x7
    400019b0:	17ffffe7 	b	4000194c <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    400019b4:	1100dc66 	add	w6, w3, #0x37
    400019b8:	11015c63 	add	w3, w3, #0x57
    400019bc:	12001cc6 	and	w6, w6, #0xff
    400019c0:	12001c63 	and	w3, w3, #0xff
    400019c4:	7100651f 	cmp	w8, #0x19
    400019c8:	1a868063 	csel	w3, w3, w6, hi  // hi = pmore
    400019cc:	17ffffe7 	b	40001968 <encode_uint+0x48>
		} else if (radix == 16) {
    400019d0:	f100409f 	cmp	x4, #0x10
    400019d4:	54fffe01 	b.ne	40001994 <encode_uint+0x74>  // b.any
			conv->altform_0c = true;
    400019d8:	39400822 	ldrb	w2, [x1, #2]
    400019dc:	321c0042 	orr	w2, w2, #0x10
    400019e0:	17ffffec 	b	40001990 <encode_uint+0x70>

00000000400019e4 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    400019e4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400019e8:	910003fd 	mov	x29, sp
    400019ec:	a90153f3 	stp	x19, x20, [sp, #16]
    400019f0:	aa0203f4 	mov	x20, x2
	size_t count = 0;
    400019f4:	d2800013 	mov	x19, #0x0                   	// #0
{
    400019f8:	a9025bf5 	stp	x21, x22, [sp, #32]
    400019fc:	aa0003f6 	mov	x22, x0
    40001a00:	aa0303f5 	mov	x21, x3
    40001a04:	f9001bf7 	str	x23, [sp, #48]
    40001a08:	aa0103f7 	mov	x23, x1

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    40001a0c:	8b130280 	add	x0, x20, x19
    40001a10:	eb0002bf 	cmp	x21, x0
    40001a14:	54000148 	b.hi	40001a3c <outs+0x58>  // b.pmore
    40001a18:	b40000f5 	cbz	x21, 40001a34 <outs+0x50>
			return rc;
		}
		++count;
	}

	return (int)count;
    40001a1c:	2a1303e0 	mov	w0, w19
}
    40001a20:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001a24:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40001a28:	f9401bf7 	ldr	x23, [sp, #48]
    40001a2c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40001a30:	d65f03c0 	ret
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    40001a34:	38736a80 	ldrb	w0, [x20, x19]
    40001a38:	34ffff20 	cbz	w0, 40001a1c <outs+0x38>
		int rc = out((int)*sp++, ctx);
    40001a3c:	38736a80 	ldrb	w0, [x20, x19]
    40001a40:	aa1703e1 	mov	x1, x23
    40001a44:	d63f02c0 	blr	x22
		if (rc < 0) {
    40001a48:	37fffec0 	tbnz	w0, #31, 40001a20 <outs+0x3c>
		++count;
    40001a4c:	91000673 	add	x19, x19, #0x1
    40001a50:	17ffffef 	b	40001a0c <outs+0x28>

0000000040001a54 <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    40001a54:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
    40001a58:	910003fd 	mov	x29, sp
    40001a5c:	a90153f3 	stp	x19, x20, [sp, #16]
    40001a60:	aa0003f4 	mov	x20, x0
    40001a64:	a90363f7 	stp	x23, x24, [sp, #48]
    40001a68:	a9406073 	ldp	x19, x24, [x3]
    40001a6c:	a90573fb 	stp	x27, x28, [sp, #80]
    40001a70:	b940187c 	ldr	w28, [x3, #24]
    40001a74:	f9400860 	ldr	x0, [x3, #16]
    40001a78:	a9025bf5 	stp	x21, x22, [sp, #32]
    40001a7c:	aa0103f5 	mov	x21, x1
    40001a80:	f90037e0 	str	x0, [sp, #104]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    40001a84:	d280001b 	mov	x27, #0x0                   	// #0
    40001a88:	b9401c60 	ldr	w0, [x3, #28]
{
    40001a8c:	a9046bf9 	stp	x25, x26, [sp, #64]
    40001a90:	b9007be0 	str	w0, [sp, #120]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    40001a94:	39400040 	ldrb	w0, [x2]
    40001a98:	35000060 	cbnz	w0, 40001aa4 <cbvprintf+0x50>
			OUTC(' ');
			--width;
		}
	}

	return count;
    40001a9c:	2a1b03e0 	mov	w0, w27
    40001aa0:	14000425 	b	40002b34 <cbvprintf+0x10e0>
			OUTC(*fp++);
    40001aa4:	91000456 	add	x22, x2, #0x1
		if (*fp != '%') {
    40001aa8:	7100941f 	cmp	w0, #0x25
    40001aac:	540000c0 	b.eq	40001ac4 <cbvprintf+0x70>  // b.none
			OUTC(*fp++);
    40001ab0:	aa1503e1 	mov	x1, x21
			OUTC('%');
    40001ab4:	d63f0280 	blr	x20
    40001ab8:	37f883e0 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40001abc:	9100077b 	add	x27, x27, #0x1
		if (bps == NULL) {
    40001ac0:	14000195 	b	40002114 <cbvprintf+0x6c0>
	if (*sp == '%') {
    40001ac4:	39400440 	ldrb	w0, [x2, #1]
		} state = {
    40001ac8:	a90b7fff 	stp	xzr, xzr, [sp, #176]
	if (*sp == '%') {
    40001acc:	7100941f 	cmp	w0, #0x25
		} state = {
    40001ad0:	a90c7fff 	stp	xzr, xzr, [sp, #192]
	if (*sp == '%') {
    40001ad4:	540006a1 	b.ne	40001ba8 <cbvprintf+0x154>  // b.any
		conv->specifier = *sp++;
    40001ad8:	91000856 	add	x22, x2, #0x2
    40001adc:	39030fe0 	strb	w0, [sp, #195]
		if (conv->width_star) {
    40001ae0:	794183e0 	ldrh	w0, [sp, #192]
    40001ae4:	36402900 	tbz	w0, #8, 40002004 <cbvprintf+0x5b0>
			width = va_arg(ap, int);
    40001ae8:	37f8279c 	tbnz	w28, #31, 40001fd8 <cbvprintf+0x584>
    40001aec:	91002e61 	add	x1, x19, #0xb
    40001af0:	aa1303e0 	mov	x0, x19
    40001af4:	927df033 	and	x19, x1, #0xfffffffffffffff8
    40001af8:	b9400017 	ldr	w23, [x0]
			if (width < 0) {
    40001afc:	36f800b7 	tbz	w23, #31, 40001b10 <cbvprintf+0xbc>
				conv->flag_dash = true;
    40001b00:	794183e0 	ldrh	w0, [sp, #192]
				width = -width;
    40001b04:	4b1703f7 	neg	w23, w23
				conv->flag_dash = true;
    40001b08:	321e0000 	orr	w0, w0, #0x4
    40001b0c:	790183e0 	strh	w0, [sp, #192]
		if (conv->prec_star) {
    40001b10:	794183e0 	ldrh	w0, [sp, #192]
    40001b14:	36502960 	tbz	w0, #10, 40002040 <cbvprintf+0x5ec>
			int arg = va_arg(ap, int);
    40001b18:	37f827fc 	tbnz	w28, #31, 40002014 <cbvprintf+0x5c0>
    40001b1c:	91002e61 	add	x1, x19, #0xb
    40001b20:	aa1303e0 	mov	x0, x19
    40001b24:	927df033 	and	x19, x1, #0xfffffffffffffff8
    40001b28:	b9400009 	ldr	w9, [x0]
			if (arg < 0) {
    40001b2c:	36f800a9 	tbz	w9, #31, 40001b40 <cbvprintf+0xec>
				conv->prec_present = false;
    40001b30:	794183e0 	ldrh	w0, [sp, #192]
		int precision = -1;
    40001b34:	12800009 	mov	w9, #0xffffffff            	// #-1
				conv->prec_present = false;
    40001b38:	12167800 	and	w0, w0, #0xfffffdff
    40001b3c:	790183e0 	strh	w0, [sp, #192]
		    && (conv->specifier_cat == SPECIFIER_FP)
    40001b40:	39430be0 	ldrb	w0, [sp, #194]
		conv->pad0_value = 0;
    40001b44:	f80c43ff 	stur	xzr, [sp, #196]
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)
    40001b48:	12000800 	and	w0, w0, #0x7
    40001b4c:	7100101f 	cmp	w0, #0x4
    40001b50:	f94063e3 	ldr	x3, [sp, #192]
    40001b54:	54000101 	b.ne	40001b74 <cbvprintf+0x120>  // b.any
		    && !conv->prec_present) {
    40001b58:	7217007f 	tst	w3, #0x200
    40001b5c:	540000c1 	b.ne	40001b74 <cbvprintf+0x120>  // b.any
			if (conv->specifier_a) {
    40001b60:	79c183e0 	ldrsh	w0, [sp, #192]
				precision = 6;
    40001b64:	528001a9 	mov	w9, #0xd                   	// #13
    40001b68:	7100001f 	cmp	w0, #0x0
    40001b6c:	528000c0 	mov	w0, #0x6                   	// #6
    40001b70:	1a80b129 	csel	w9, w9, w0, lt  // lt = tstop
		enum specifier_cat_enum specifier_cat
    40001b74:	53104860 	ubfx	w0, w3, #16, #3
			= (enum length_mod_enum)conv->length_mod;
    40001b78:	530b3861 	ubfx	w1, w3, #11, #4
		if (specifier_cat == SPECIFIER_SINT) {
    40001b7c:	7100041f 	cmp	w0, #0x1
    40001b80:	54002ce1 	b.ne	4000211c <cbvprintf+0x6c8>  // b.any
			switch (length_mod) {
    40001b84:	51000c24 	sub	w4, w1, #0x3
    40001b88:	7100109f 	cmp	w4, #0x4
    40001b8c:	54002628 	b.hi	40002050 <cbvprintf+0x5fc>  // b.pmore
    40001b90:	b0000060 	adrp	x0, 4000e000 <mmu_regions+0x38>
    40001b94:	91274000 	add	x0, x0, #0x9d0
    40001b98:	78645800 	ldrh	w0, [x0, w4, uxtw #1]
    40001b9c:	10000064 	adr	x4, 40001ba8 <cbvprintf+0x154>
    40001ba0:	8b20a880 	add	x0, x4, w0, sxth #2
    40001ba4:	d61f0000 	br	x0
    40001ba8:	52800003 	mov	w3, #0x0                   	// #0
    40001bac:	52800005 	mov	w5, #0x0                   	// #0
    40001bb0:	52800004 	mov	w4, #0x0                   	// #0
    40001bb4:	52800006 	mov	w6, #0x0                   	// #0
    40001bb8:	52800001 	mov	w1, #0x0                   	// #0
		switch (*sp) {
    40001bbc:	394002c0 	ldrb	w0, [x22]
    40001bc0:	7100ac1f 	cmp	w0, #0x2b
    40001bc4:	540009a0 	b.eq	40001cf8 <cbvprintf+0x2a4>  // b.none
    40001bc8:	540008c8 	b.hi	40001ce0 <cbvprintf+0x28c>  // b.pmore
    40001bcc:	7100801f 	cmp	w0, #0x20
    40001bd0:	540009a0 	b.eq	40001d04 <cbvprintf+0x2b0>  // b.none
    40001bd4:	71008c1f 	cmp	w0, #0x23
    40001bd8:	540009a0 	b.eq	40001d0c <cbvprintf+0x2b8>  // b.none
    40001bdc:	34000081 	cbz	w1, 40001bec <cbvprintf+0x198>
    40001be0:	794183e1 	ldrh	w1, [sp, #192]
    40001be4:	321e0021 	orr	w1, w1, #0x4
    40001be8:	790183e1 	strh	w1, [sp, #192]
    40001bec:	34000086 	cbz	w6, 40001bfc <cbvprintf+0x1a8>
    40001bf0:	794183e1 	ldrh	w1, [sp, #192]
    40001bf4:	321d0021 	orr	w1, w1, #0x8
    40001bf8:	790183e1 	strh	w1, [sp, #192]
    40001bfc:	34000084 	cbz	w4, 40001c0c <cbvprintf+0x1b8>
    40001c00:	794183e1 	ldrh	w1, [sp, #192]
    40001c04:	321c0021 	orr	w1, w1, #0x10
    40001c08:	790183e1 	strh	w1, [sp, #192]
    40001c0c:	34000085 	cbz	w5, 40001c1c <cbvprintf+0x1c8>
    40001c10:	794183e1 	ldrh	w1, [sp, #192]
    40001c14:	321b0021 	orr	w1, w1, #0x20
    40001c18:	790183e1 	strh	w1, [sp, #192]
    40001c1c:	34000083 	cbz	w3, 40001c2c <cbvprintf+0x1d8>
    40001c20:	794183e1 	ldrh	w1, [sp, #192]
    40001c24:	321a0021 	orr	w1, w1, #0x40
    40001c28:	790183e1 	strh	w1, [sp, #192]
	if (conv->flag_zero && conv->flag_dash) {
    40001c2c:	b940c3e1 	ldr	w1, [sp, #192]
    40001c30:	52800883 	mov	w3, #0x44                  	// #68
    40001c34:	0a030021 	and	w1, w1, w3
    40001c38:	6b03003f 	cmp	w1, w3
    40001c3c:	54000081 	b.ne	40001c4c <cbvprintf+0x1f8>  // b.any
		conv->flag_zero = false;
    40001c40:	794183e1 	ldrh	w1, [sp, #192]
    40001c44:	12197821 	and	w1, w1, #0xffffffbf
    40001c48:	790183e1 	strh	w1, [sp, #192]
	conv->width_present = true;
    40001c4c:	794183e3 	ldrh	w3, [sp, #192]
	if (*sp == '*') {
    40001c50:	7100a81f 	cmp	w0, #0x2a
	conv->width_present = true;
    40001c54:	32190061 	orr	w1, w3, #0x80
    40001c58:	790183e1 	strh	w1, [sp, #192]
	if (*sp == '*') {
    40001c5c:	54000861 	b.ne	40001d68 <cbvprintf+0x314>  // b.any
			++sp;
    40001c60:	910006c1 	add	x1, x22, #0x1
		conv->width_star = true;
    40001c64:	32190463 	orr	w3, w3, #0x180
    40001c68:	790183e3 	strh	w3, [sp, #192]
	conv->prec_present = (*sp == '.');
    40001c6c:	39400020 	ldrb	w0, [x1]
    40001c70:	7100b81f 	cmp	w0, #0x2e
    40001c74:	794183e0 	ldrh	w0, [sp, #192]
    40001c78:	1a9f17e3 	cset	w3, eq  // eq = none
    40001c7c:	33170060 	bfi	w0, w3, #9, #1
    40001c80:	790183e0 	strh	w0, [sp, #192]
	if (!conv->prec_present) {
    40001c84:	54000841 	b.ne	40001d8c <cbvprintf+0x338>  // b.any
	if (*sp == '*') {
    40001c88:	39400423 	ldrb	w3, [x1, #1]
    40001c8c:	7100a87f 	cmp	w3, #0x2a
    40001c90:	54000780 	b.eq	40001d80 <cbvprintf+0x32c>  // b.none
	++sp;
    40001c94:	91000421 	add	x1, x1, #0x1
	size_t val = 0;
    40001c98:	d2800000 	mov	x0, #0x0                   	// #0
		val = 10U * val + *sp++ - '0';
    40001c9c:	d2800146 	mov	x6, #0xa                   	// #10
	while (isdigit((int)(unsigned char)*sp)) {
    40001ca0:	aa0103e3 	mov	x3, x1
    40001ca4:	38401464 	ldrb	w4, [x3], #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    40001ca8:	5100c085 	sub	w5, w4, #0x30
    40001cac:	710024bf 	cmp	w5, #0x9
    40001cb0:	54000c49 	b.ls	40001e38 <cbvprintf+0x3e4>  // b.plast
	conv->unsupported |= ((conv->prec_value < 0)
    40001cb4:	f94063e3 	ldr	x3, [sp, #192]
	conv->prec_value = prec;
    40001cb8:	b900cbe0 	str	w0, [sp, #200]
	conv->unsupported |= ((conv->prec_value < 0)
    40001cbc:	53010463 	ubfx	w3, w3, #1, #1
			      || (prec != (size_t)conv->prec_value));
    40001cc0:	37f80c60 	tbnz	w0, #31, 40001e4c <cbvprintf+0x3f8>
    40001cc4:	eb20c01f 	cmp	x0, w0, sxtw
    40001cc8:	1a9f07e0 	cset	w0, ne  // ne = any
	conv->unsupported |= ((conv->prec_value < 0)
    40001ccc:	2a000060 	orr	w0, w3, w0
    40001cd0:	794183e3 	ldrh	w3, [sp, #192]
    40001cd4:	331f0003 	bfi	w3, w0, #1, #1
    40001cd8:	790183e3 	strh	w3, [sp, #192]
	return sp;
    40001cdc:	1400002c 	b	40001d8c <cbvprintf+0x338>
		switch (*sp) {
    40001ce0:	7100b41f 	cmp	w0, #0x2d
    40001ce4:	54000180 	b.eq	40001d14 <cbvprintf+0x2c0>  // b.none
    40001ce8:	7100c01f 	cmp	w0, #0x30
    40001cec:	54fff781 	b.ne	40001bdc <cbvprintf+0x188>  // b.any
			conv->flag_zero = true;
    40001cf0:	52800023 	mov	w3, #0x1                   	// #1
    40001cf4:	14000002 	b	40001cfc <cbvprintf+0x2a8>
			conv->flag_plus = true;
    40001cf8:	52800026 	mov	w6, #0x1                   	// #1
			++sp;
    40001cfc:	910006d6 	add	x22, x22, #0x1
	} while (loop);
    40001d00:	17ffffaf 	b	40001bbc <cbvprintf+0x168>
			conv->flag_space = true;
    40001d04:	52800024 	mov	w4, #0x1                   	// #1
    40001d08:	17fffffd 	b	40001cfc <cbvprintf+0x2a8>
			conv->flag_hash = true;
    40001d0c:	52800025 	mov	w5, #0x1                   	// #1
    40001d10:	17fffffb 	b	40001cfc <cbvprintf+0x2a8>
		switch (*sp) {
    40001d14:	52800021 	mov	w1, #0x1                   	// #1
    40001d18:	17fffff9 	b	40001cfc <cbvprintf+0x2a8>
		val = 10U * val + *sp++ - '0';
    40001d1c:	9b067c00 	mul	x0, x0, x6
    40001d20:	aa0303e1 	mov	x1, x3
    40001d24:	d100c000 	sub	x0, x0, #0x30
    40001d28:	8b240000 	add	x0, x0, w4, uxtb
	while (isdigit((int)(unsigned char)*sp)) {
    40001d2c:	aa0103e3 	mov	x3, x1
    40001d30:	38401464 	ldrb	w4, [x3], #1
    40001d34:	5100c085 	sub	w5, w4, #0x30
    40001d38:	710024bf 	cmp	w5, #0x9
    40001d3c:	54ffff09 	b.ls	40001d1c <cbvprintf+0x2c8>  // b.plast
	if (sp != wp) {
    40001d40:	eb0102df 	cmp	x22, x1
    40001d44:	54fff940 	b.eq	40001c6c <cbvprintf+0x218>  // b.none
		conv->width_value = width;
    40001d48:	b900c7e0 	str	w0, [sp, #196]
				      || (width != (size_t)conv->width_value));
    40001d4c:	37f80160 	tbnz	w0, #31, 40001d78 <cbvprintf+0x324>
    40001d50:	eb20c01f 	cmp	x0, w0, sxtw
    40001d54:	1a9f07e3 	cset	w3, ne  // ne = any
		conv->unsupported |= ((conv->width_value < 0)
    40001d58:	794183e0 	ldrh	w0, [sp, #192]
    40001d5c:	331f0060 	bfi	w0, w3, #1, #1
    40001d60:	790183e0 	strh	w0, [sp, #192]
    40001d64:	17ffffc2 	b	40001c6c <cbvprintf+0x218>
    40001d68:	aa1603e1 	mov	x1, x22
	size_t val = 0;
    40001d6c:	d2800000 	mov	x0, #0x0                   	// #0
		val = 10U * val + *sp++ - '0';
    40001d70:	d2800146 	mov	x6, #0xa                   	// #10
    40001d74:	17ffffee 	b	40001d2c <cbvprintf+0x2d8>
				      || (width != (size_t)conv->width_value));
    40001d78:	52800023 	mov	w3, #0x1                   	// #1
    40001d7c:	17fffff7 	b	40001d58 <cbvprintf+0x304>
		return ++sp;
    40001d80:	91000821 	add	x1, x1, #0x2
		conv->prec_star = true;
    40001d84:	32160000 	orr	w0, w0, #0x400
    40001d88:	790183e0 	strh	w0, [sp, #192]
	switch (*sp) {
    40001d8c:	aa0103f6 	mov	x22, x1
    40001d90:	384016c0 	ldrb	w0, [x22], #1
    40001d94:	7101b01f 	cmp	w0, #0x6c
    40001d98:	54000860 	b.eq	40001ea4 <cbvprintf+0x450>  // b.none
    40001d9c:	540005c8 	b.hi	40001e54 <cbvprintf+0x400>  // b.pmore
    40001da0:	7101a01f 	cmp	w0, #0x68
    40001da4:	54000660 	b.eq	40001e70 <cbvprintf+0x41c>  // b.none
    40001da8:	7101a81f 	cmp	w0, #0x6a
    40001dac:	540008c0 	b.eq	40001ec4 <cbvprintf+0x470>  // b.none
    40001db0:	7101301f 	cmp	w0, #0x4c
    40001db4:	54000940 	b.eq	40001edc <cbvprintf+0x488>  // b.none
    40001db8:	aa0103f6 	mov	x22, x1
	conv->specifier = *sp++;
    40001dbc:	384016c0 	ldrb	w0, [x22], #1
    40001dc0:	39030fe0 	strb	w0, [sp, #195]
	switch (conv->specifier) {
    40001dc4:	7101e01f 	cmp	w0, #0x78
    40001dc8:	54001008 	b.hi	40001fc8 <cbvprintf+0x574>  // b.pmore
    40001dcc:	71015c1f 	cmp	w0, #0x57
    40001dd0:	54000928 	b.hi	40001ef4 <cbvprintf+0x4a0>  // b.pmore
    40001dd4:	7101041f 	cmp	w0, #0x41
    40001dd8:	540000a0 	b.eq	40001dec <cbvprintf+0x398>  // b.none
    40001ddc:	51011401 	sub	w1, w0, #0x45
    40001de0:	12001c21 	and	w1, w1, #0xff
    40001de4:	7100083f 	cmp	w1, #0x2
    40001de8:	54000f08 	b.hi	40001fc8 <cbvprintf+0x574>  // b.pmore
			|| (conv->specifier == 'A');
    40001dec:	121a7800 	and	w0, w0, #0xffffffdf
		conv->specifier_a = (conv->specifier == 'a')
    40001df0:	784c13e1 	ldurh	w1, [sp, #193]
			|| (conv->specifier == 'A');
    40001df4:	7101041f 	cmp	w0, #0x41
    40001df8:	1a9f17e0 	cset	w0, eq  // eq = none
		conv->specifier_a = (conv->specifier == 'a')
    40001dfc:	12156c21 	and	w1, w1, #0xfffff87f
    40001e00:	53196000 	lsl	w0, w0, #7
    40001e04:	32160000 	orr	w0, w0, #0x400
    40001e08:	2a010000 	orr	w0, w0, w1
    40001e0c:	780c13e0 	sturh	w0, [sp, #193]
		if (conv->specifier_a
    40001e10:	79c183e1 	ldrsh	w1, [sp, #192]
    40001e14:	794183e0 	ldrh	w0, [sp, #192]
    40001e18:	37f80dc1 	tbnz	w1, #31, 40001fd0 <cbvprintf+0x57c>
		if (conv->length_mod == LENGTH_L) {
    40001e1c:	12150c03 	and	w3, w0, #0x7800
    40001e20:	52830001 	mov	w1, #0x1800                	// #6144
    40001e24:	6b01007f 	cmp	w3, w1
    40001e28:	54000a61 	b.ne	40001f74 <cbvprintf+0x520>  // b.any
			conv->length_mod = LENGTH_NONE;
    40001e2c:	12116c00 	and	w0, w0, #0xffff87ff
    40001e30:	790183e0 	strh	w0, [sp, #192]
    40001e34:	14000045 	b	40001f48 <cbvprintf+0x4f4>
		val = 10U * val + *sp++ - '0';
    40001e38:	9b067c00 	mul	x0, x0, x6
    40001e3c:	aa0303e1 	mov	x1, x3
    40001e40:	d100c000 	sub	x0, x0, #0x30
    40001e44:	8b240000 	add	x0, x0, w4, uxtb
    40001e48:	17ffff96 	b	40001ca0 <cbvprintf+0x24c>
			      || (prec != (size_t)conv->prec_value));
    40001e4c:	52800020 	mov	w0, #0x1                   	// #1
    40001e50:	17ffff9f 	b	40001ccc <cbvprintf+0x278>
	switch (*sp) {
    40001e54:	7101d01f 	cmp	w0, #0x74
    40001e58:	540003c0 	b.eq	40001ed0 <cbvprintf+0x47c>  // b.none
    40001e5c:	7101e81f 	cmp	w0, #0x7a
    40001e60:	54fffac1 	b.ne	40001db8 <cbvprintf+0x364>  // b.any
		conv->length_mod = LENGTH_Z;
    40001e64:	794183e0 	ldrh	w0, [sp, #192]
    40001e68:	528000c1 	mov	w1, #0x6                   	// #6
    40001e6c:	1400000b 	b	40001e98 <cbvprintf+0x444>
		if (*++sp == 'h') {
    40001e70:	39400420 	ldrb	w0, [x1, #1]
    40001e74:	7101a01f 	cmp	w0, #0x68
    40001e78:	794183e0 	ldrh	w0, [sp, #192]
    40001e7c:	540000c1 	b.ne	40001e94 <cbvprintf+0x440>  // b.any
			conv->length_mod = LENGTH_HH;
    40001e80:	52800023 	mov	w3, #0x1                   	// #1
			conv->length_mod = LENGTH_LL;
    40001e84:	33150c60 	bfi	w0, w3, #11, #4
			++sp;
    40001e88:	91000836 	add	x22, x1, #0x2
			conv->length_mod = LENGTH_LL;
    40001e8c:	790183e0 	strh	w0, [sp, #192]
			++sp;
    40001e90:	17ffffcb 	b	40001dbc <cbvprintf+0x368>
			conv->length_mod = LENGTH_H;
    40001e94:	52800041 	mov	w1, #0x2                   	// #2
		conv->length_mod = LENGTH_T;
    40001e98:	33150c20 	bfi	w0, w1, #11, #4
		conv->unsupported = true;
    40001e9c:	790183e0 	strh	w0, [sp, #192]
		break;
    40001ea0:	17ffffc7 	b	40001dbc <cbvprintf+0x368>
		if (*++sp == 'l') {
    40001ea4:	39400420 	ldrb	w0, [x1, #1]
    40001ea8:	7101b01f 	cmp	w0, #0x6c
    40001eac:	794183e0 	ldrh	w0, [sp, #192]
    40001eb0:	54000061 	b.ne	40001ebc <cbvprintf+0x468>  // b.any
			conv->length_mod = LENGTH_LL;
    40001eb4:	52800083 	mov	w3, #0x4                   	// #4
    40001eb8:	17fffff3 	b	40001e84 <cbvprintf+0x430>
			conv->length_mod = LENGTH_L;
    40001ebc:	52800061 	mov	w1, #0x3                   	// #3
    40001ec0:	17fffff6 	b	40001e98 <cbvprintf+0x444>
		conv->length_mod = LENGTH_J;
    40001ec4:	794183e0 	ldrh	w0, [sp, #192]
    40001ec8:	528000a1 	mov	w1, #0x5                   	// #5
    40001ecc:	17fffff3 	b	40001e98 <cbvprintf+0x444>
		conv->length_mod = LENGTH_T;
    40001ed0:	794183e0 	ldrh	w0, [sp, #192]
    40001ed4:	528000e1 	mov	w1, #0x7                   	// #7
    40001ed8:	17fffff0 	b	40001e98 <cbvprintf+0x444>
		conv->unsupported = true;
    40001edc:	794183e0 	ldrh	w0, [sp, #192]
    40001ee0:	128f0041 	mov	w1, #0xffff87fd            	// #-30723
    40001ee4:	0a010000 	and	w0, w0, w1
    40001ee8:	52880041 	mov	w1, #0x4002                	// #16386
    40001eec:	2a010000 	orr	w0, w0, w1
    40001ef0:	17ffffeb 	b	40001e9c <cbvprintf+0x448>
	switch (conv->specifier) {
    40001ef4:	51016003 	sub	w3, w0, #0x58
    40001ef8:	7100807f 	cmp	w3, #0x20
    40001efc:	54000668 	b.hi	40001fc8 <cbvprintf+0x574>  // b.pmore
    40001f00:	b0000061 	adrp	x1, 4000e000 <mmu_regions+0x38>
    40001f04:	91277021 	add	x1, x1, #0x9dc
    40001f08:	38634821 	ldrb	w1, [x1, w3, uxtw]
    40001f0c:	10000063 	adr	x3, 40001f18 <cbvprintf+0x4c4>
    40001f10:	8b218861 	add	x1, x3, w1, sxtb #2
    40001f14:	d61f0020 	br	x1
		conv->specifier_cat = SPECIFIER_SINT;
    40001f18:	39430be1 	ldrb	w1, [sp, #194]
    40001f1c:	52800023 	mov	w3, #0x1                   	// #1
		conv->specifier_cat = SPECIFIER_UINT;
    40001f20:	33000861 	bfxil	w1, w3, #0, #3
    40001f24:	39030be1 	strb	w1, [sp, #194]
		if (conv->length_mod == LENGTH_UPPER_L) {
    40001f28:	794183e1 	ldrh	w1, [sp, #192]
    40001f2c:	12150c23 	and	w3, w1, #0x7800
    40001f30:	7140107f 	cmp	w3, #0x4, lsl #12
    40001f34:	54000061 	b.ne	40001f40 <cbvprintf+0x4ec>  // b.any
			conv->invalid = true;
    40001f38:	32000021 	orr	w1, w1, #0x1
    40001f3c:	790183e1 	strh	w1, [sp, #192]
		if (conv->specifier == 'c') {
    40001f40:	71018c1f 	cmp	w0, #0x63
    40001f44:	540003a0 	b.eq	40001fb8 <cbvprintf+0x564>  // b.none
	bool unsupported = false;
    40001f48:	52800000 	mov	w0, #0x0                   	// #0
	conv->unsupported |= unsupported;
    40001f4c:	f94063e1 	ldr	x1, [sp, #192]
    40001f50:	d3410421 	ubfx	x1, x1, #1, #1
    40001f54:	2a010000 	orr	w0, w0, w1
    40001f58:	794183e1 	ldrh	w1, [sp, #192]
    40001f5c:	331f0001 	bfi	w1, w0, #1, #1
    40001f60:	790183e1 	strh	w1, [sp, #192]
	return sp;
    40001f64:	17fffedf 	b	40001ae0 <cbvprintf+0x8c>
		conv->specifier_cat = SPECIFIER_UINT;
    40001f68:	39430be1 	ldrb	w1, [sp, #194]
    40001f6c:	52800043 	mov	w3, #0x2                   	// #2
    40001f70:	17ffffec 	b	40001f20 <cbvprintf+0x4cc>
		} else if ((conv->length_mod != LENGTH_NONE)
    40001f74:	7215081f 	tst	w0, #0x3800
    40001f78:	54fffe80 	b.eq	40001f48 <cbvprintf+0x4f4>  // b.none
		conv->invalid = true;
    40001f7c:	32000000 	orr	w0, w0, #0x1
    40001f80:	17ffffac 	b	40001e30 <cbvprintf+0x3dc>
		conv->specifier_cat = SPECIFIER_PTR;
    40001f84:	39430be0 	ldrb	w0, [sp, #194]
    40001f88:	52800061 	mov	w1, #0x3                   	// #3
    40001f8c:	33000820 	bfxil	w0, w1, #0, #3
    40001f90:	39030be0 	strb	w0, [sp, #194]
		if (conv->length_mod == LENGTH_UPPER_L) {
    40001f94:	794183e0 	ldrh	w0, [sp, #192]
    40001f98:	12150c00 	and	w0, w0, #0x7800
    40001f9c:	7140101f 	cmp	w0, #0x4, lsl #12
    40001fa0:	1a9f17e0 	cset	w0, eq  // eq = none
    40001fa4:	17ffffea 	b	40001f4c <cbvprintf+0x4f8>
		conv->specifier_cat = SPECIFIER_PTR;
    40001fa8:	39430be0 	ldrb	w0, [sp, #194]
    40001fac:	52800061 	mov	w1, #0x3                   	// #3
    40001fb0:	33000820 	bfxil	w0, w1, #0, #3
    40001fb4:	39030be0 	strb	w0, [sp, #194]
		if (conv->length_mod != LENGTH_NONE) {
    40001fb8:	794183e0 	ldrh	w0, [sp, #192]
    40001fbc:	72150c1f 	tst	w0, #0x7800
    40001fc0:	1a9f07e0 	cset	w0, ne  // ne = any
    40001fc4:	17ffffe2 	b	40001f4c <cbvprintf+0x4f8>
		conv->invalid = true;
    40001fc8:	794183e0 	ldrh	w0, [sp, #192]
    40001fcc:	17ffffec 	b	40001f7c <cbvprintf+0x528>
			unsupported = true;
    40001fd0:	52800020 	mov	w0, #0x1                   	// #1
    40001fd4:	17ffffde 	b	40001f4c <cbvprintf+0x4f8>
			width = va_arg(ap, int);
    40001fd8:	11002381 	add	w1, w28, #0x8
    40001fdc:	7100003f 	cmp	w1, #0x0
    40001fe0:	540000cd 	b.le	40001ff8 <cbvprintf+0x5a4>
    40001fe4:	91002e63 	add	x3, x19, #0xb
    40001fe8:	aa1303e0 	mov	x0, x19
    40001fec:	2a0103fc 	mov	w28, w1
    40001ff0:	927df073 	and	x19, x3, #0xfffffffffffffff8
    40001ff4:	17fffec1 	b	40001af8 <cbvprintf+0xa4>
    40001ff8:	8b3cc300 	add	x0, x24, w28, sxtw
    40001ffc:	2a0103fc 	mov	w28, w1
    40002000:	17fffebe 	b	40001af8 <cbvprintf+0xa4>
			width = conv->width_value;
    40002004:	b940c7f7 	ldr	w23, [sp, #196]
    40002008:	f279001f 	tst	x0, #0x80
    4000200c:	5a9f12f7 	csinv	w23, w23, wzr, ne  // ne = any
    40002010:	17fffec0 	b	40001b10 <cbvprintf+0xbc>
			int arg = va_arg(ap, int);
    40002014:	11002381 	add	w1, w28, #0x8
    40002018:	7100003f 	cmp	w1, #0x0
    4000201c:	540000cd 	b.le	40002034 <cbvprintf+0x5e0>
    40002020:	91002e63 	add	x3, x19, #0xb
    40002024:	aa1303e0 	mov	x0, x19
    40002028:	2a0103fc 	mov	w28, w1
    4000202c:	927df073 	and	x19, x3, #0xfffffffffffffff8
    40002030:	17fffebe 	b	40001b28 <cbvprintf+0xd4>
    40002034:	8b3cc300 	add	x0, x24, w28, sxtw
    40002038:	2a0103fc 	mov	w28, w1
    4000203c:	17fffebb 	b	40001b28 <cbvprintf+0xd4>
			precision = conv->prec_value;
    40002040:	b940cbe9 	ldr	w9, [sp, #200]
    40002044:	f277001f 	tst	x0, #0x200
    40002048:	5a9f1129 	csinv	w9, w9, wzr, ne  // ne = any
    4000204c:	17fffebd 	b	40001b40 <cbvprintf+0xec>
				value->sint = va_arg(ap, int);
    40002050:	37f8019c 	tbnz	w28, #31, 40002080 <cbvprintf+0x62c>
    40002054:	91002e60 	add	x0, x19, #0xb
    40002058:	2a1c03e4 	mov	w4, w28
    4000205c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002060:	b9800265 	ldrsw	x5, [x19]
				value->sint =
    40002064:	f9005be5 	str	x5, [sp, #176]
				break;
    40002068:	2a0403fc 	mov	w28, w4
    4000206c:	aa0003f3 	mov	x19, x0
			if (length_mod == LENGTH_HH) {
    40002070:	7100043f 	cmp	w1, #0x1
    40002074:	54000361 	b.ne	400020e0 <cbvprintf+0x68c>  // b.any
				value->uint = (unsigned char)value->uint;
    40002078:	3942c3e0 	ldrb	w0, [sp, #176]
    4000207c:	1400001c 	b	400020ec <cbvprintf+0x698>
				value->sint = va_arg(ap, int);
    40002080:	11002384 	add	w4, w28, #0x8
    40002084:	7100009f 	cmp	w4, #0x0
    40002088:	5400008d 	b.le	40002098 <cbvprintf+0x644>
    4000208c:	91002e60 	add	x0, x19, #0xb
    40002090:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002094:	17fffff3 	b	40002060 <cbvprintf+0x60c>
    40002098:	aa1303e0 	mov	x0, x19
    4000209c:	8b3cc313 	add	x19, x24, w28, sxtw
    400020a0:	17fffff0 	b	40002060 <cbvprintf+0x60c>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    400020a4:	37f800dc 	tbnz	w28, #31, 400020bc <cbvprintf+0x668>
    400020a8:	91003e60 	add	x0, x19, #0xf
    400020ac:	2a1c03e4 	mov	w4, w28
    400020b0:	927df000 	and	x0, x0, #0xfffffffffffffff8
				value->sint =
    400020b4:	f9400265 	ldr	x5, [x19]
    400020b8:	17ffffeb 	b	40002064 <cbvprintf+0x610>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    400020bc:	11002384 	add	w4, w28, #0x8
    400020c0:	7100009f 	cmp	w4, #0x0
    400020c4:	5400008d 	b.le	400020d4 <cbvprintf+0x680>
    400020c8:	91003e60 	add	x0, x19, #0xf
    400020cc:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400020d0:	17fffff9 	b	400020b4 <cbvprintf+0x660>
    400020d4:	aa1303e0 	mov	x0, x19
    400020d8:	8b3cc313 	add	x19, x24, w28, sxtw
    400020dc:	17fffff6 	b	400020b4 <cbvprintf+0x660>
			} else if (length_mod == LENGTH_H) {
    400020e0:	7100083f 	cmp	w1, #0x2
    400020e4:	54000061 	b.ne	400020f0 <cbvprintf+0x69c>  // b.any
				value->sint = (short)value->sint;
    400020e8:	798163e0 	ldrsh	x0, [sp, #176]
				value->uint = (unsigned short)value->uint;
    400020ec:	f9005be0 	str	x0, [sp, #176]
		if (conv->invalid || conv->unsupported) {
    400020f0:	b940c3e0 	ldr	w0, [sp, #192]
    400020f4:	f240041f 	tst	x0, #0x3
    400020f8:	540011c0 	b.eq	40002330 <cbvprintf+0x8dc>  // b.none
			OUTS(sp, fp);
    400020fc:	aa1603e3 	mov	x3, x22
    40002100:	aa1503e1 	mov	x1, x21
    40002104:	aa1403e0 	mov	x0, x20
    40002108:	97fffe37 	bl	400019e4 <outs>
    4000210c:	37f85140 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40002110:	8b20c37b 	add	x27, x27, w0, sxtw
			while (pad_len-- > 0) {
    40002114:	aa1603e2 	mov	x2, x22
    40002118:	17fffe5f 	b	40001a94 <cbvprintf+0x40>
		} else if (specifier_cat == SPECIFIER_UINT) {
    4000211c:	7100081f 	cmp	w0, #0x2
    40002120:	54000881 	b.ne	40002230 <cbvprintf+0x7dc>  // b.any
			switch (length_mod) {
    40002124:	51000c24 	sub	w4, w1, #0x3
    40002128:	7100109f 	cmp	w4, #0x4
    4000212c:	540000e8 	b.hi	40002148 <cbvprintf+0x6f4>  // b.pmore
    40002130:	90000060 	adrp	x0, 4000e000 <mmu_regions+0x38>
    40002134:	91280000 	add	x0, x0, #0xa00
    40002138:	38644800 	ldrb	w0, [x0, w4, uxtw]
    4000213c:	10000064 	adr	x4, 40002148 <cbvprintf+0x6f4>
    40002140:	8b208880 	add	x0, x4, w0, sxtb #2
    40002144:	d61f0000 	br	x0
				value->uint = va_arg(ap, unsigned int);
    40002148:	37f801dc 	tbnz	w28, #31, 40002180 <cbvprintf+0x72c>
    4000214c:	91002e60 	add	x0, x19, #0xb
    40002150:	2a1c03e4 	mov	w4, w28
    40002154:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002158:	b9400265 	ldr	w5, [x19]
				value->uint =
    4000215c:	f9005be5 	str	x5, [sp, #176]
				break;
    40002160:	2a0403fc 	mov	w28, w4
    40002164:	aa0003f3 	mov	x19, x0
			if (length_mod == LENGTH_HH) {
    40002168:	7100043f 	cmp	w1, #0x1
    4000216c:	54fff860 	b.eq	40002078 <cbvprintf+0x624>  // b.none
			} else if (length_mod == LENGTH_H) {
    40002170:	7100083f 	cmp	w1, #0x2
    40002174:	54fffbe1 	b.ne	400020f0 <cbvprintf+0x69c>  // b.any
				value->uint = (unsigned short)value->uint;
    40002178:	794163e0 	ldrh	w0, [sp, #176]
    4000217c:	17ffffdc 	b	400020ec <cbvprintf+0x698>
				value->uint = va_arg(ap, unsigned int);
    40002180:	11002384 	add	w4, w28, #0x8
    40002184:	7100009f 	cmp	w4, #0x0
    40002188:	5400008d 	b.le	40002198 <cbvprintf+0x744>
    4000218c:	91002e60 	add	x0, x19, #0xb
    40002190:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002194:	17fffff1 	b	40002158 <cbvprintf+0x704>
    40002198:	aa1303e0 	mov	x0, x19
    4000219c:	8b3cc313 	add	x19, x24, w28, sxtw
    400021a0:	17ffffee 	b	40002158 <cbvprintf+0x704>
				if ((!WCHAR_IS_SIGNED)
    400021a4:	39430fe0 	ldrb	w0, [sp, #195]
    400021a8:	71018c1f 	cmp	w0, #0x63
    400021ac:	54000a41 	b.ne	400022f4 <cbvprintf+0x8a0>  // b.any
					value->uint = (wchar_t)va_arg(ap,
    400021b0:	37f8011c 	tbnz	w28, #31, 400021d0 <cbvprintf+0x77c>
    400021b4:	91002e60 	add	x0, x19, #0xb
    400021b8:	2a1c03e4 	mov	w4, w28
    400021bc:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400021c0:	b9400265 	ldr	w5, [x19]
			value->ptr = va_arg(ap, void *);
    400021c4:	2a0403fc 	mov	w28, w4
    400021c8:	f9005be5 	str	x5, [sp, #176]
    400021cc:	1400003a 	b	400022b4 <cbvprintf+0x860>
					value->uint = (wchar_t)va_arg(ap,
    400021d0:	11002384 	add	w4, w28, #0x8
    400021d4:	7100009f 	cmp	w4, #0x0
    400021d8:	5400008d 	b.le	400021e8 <cbvprintf+0x794>
    400021dc:	91002e60 	add	x0, x19, #0xb
    400021e0:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400021e4:	17fffff7 	b	400021c0 <cbvprintf+0x76c>
    400021e8:	aa1303e0 	mov	x0, x19
    400021ec:	8b3cc313 	add	x19, x24, w28, sxtw
    400021f0:	17fffff4 	b	400021c0 <cbvprintf+0x76c>
					(uint_value_type)va_arg(ap, size_t);
    400021f4:	37f800dc 	tbnz	w28, #31, 4000220c <cbvprintf+0x7b8>
    400021f8:	91003e60 	add	x0, x19, #0xf
    400021fc:	2a1c03e4 	mov	w4, w28
    40002200:	927df000 	and	x0, x0, #0xfffffffffffffff8
				value->uint =
    40002204:	f9400265 	ldr	x5, [x19]
    40002208:	17ffffd5 	b	4000215c <cbvprintf+0x708>
					(uint_value_type)va_arg(ap, size_t);
    4000220c:	11002384 	add	w4, w28, #0x8
    40002210:	7100009f 	cmp	w4, #0x0
    40002214:	5400008d 	b.le	40002224 <cbvprintf+0x7d0>
    40002218:	91003e60 	add	x0, x19, #0xf
    4000221c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002220:	17fffff9 	b	40002204 <cbvprintf+0x7b0>
    40002224:	aa1303e0 	mov	x0, x19
    40002228:	8b3cc313 	add	x19, x24, w28, sxtw
    4000222c:	17fffff6 	b	40002204 <cbvprintf+0x7b0>
		} else if (specifier_cat == SPECIFIER_FP) {
    40002230:	7100101f 	cmp	w0, #0x4
    40002234:	540005c1 	b.ne	400022ec <cbvprintf+0x898>  // b.any
				value->ldbl = va_arg(ap, long double);
    40002238:	b9407be0 	ldr	w0, [sp, #120]
			if (length_mod == LENGTH_UPPER_L) {
    4000223c:	7100203f 	cmp	w1, #0x8
    40002240:	540002c1 	b.ne	40002298 <cbvprintf+0x844>  // b.any
				value->ldbl = va_arg(ap, long double);
    40002244:	37f80120 	tbnz	w0, #31, 40002268 <cbvprintf+0x814>
    40002248:	91003e60 	add	x0, x19, #0xf
    4000224c:	b9407be4 	ldr	w4, [sp, #120]
    40002250:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    40002254:	91004013 	add	x19, x0, #0x10
    40002258:	3dc00000 	ldr	q0, [x0]
    4000225c:	b9007be4 	str	w4, [sp, #120]
    40002260:	3d802fe0 	str	q0, [sp, #176]
    40002264:	17ffffa3 	b	400020f0 <cbvprintf+0x69c>
    40002268:	b9407be0 	ldr	w0, [sp, #120]
    4000226c:	11004004 	add	w4, w0, #0x10
    40002270:	7100009f 	cmp	w4, #0x0
    40002274:	540000ad 	b.le	40002288 <cbvprintf+0x834>
    40002278:	91003e60 	add	x0, x19, #0xf
    4000227c:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    40002280:	91004013 	add	x19, x0, #0x10
    40002284:	17fffff5 	b	40002258 <cbvprintf+0x804>
    40002288:	f94037e5 	ldr	x5, [sp, #104]
    4000228c:	b9407be0 	ldr	w0, [sp, #120]
    40002290:	8b20c0a0 	add	x0, x5, w0, sxtw
    40002294:	17fffff1 	b	40002258 <cbvprintf+0x804>
				value->dbl = va_arg(ap, double);
    40002298:	37f80120 	tbnz	w0, #31, 400022bc <cbvprintf+0x868>
    4000229c:	91003e60 	add	x0, x19, #0xf
    400022a0:	b9407be4 	ldr	w4, [sp, #120]
    400022a4:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400022a8:	fd400260 	ldr	d0, [x19]
    400022ac:	b9007be4 	str	w4, [sp, #120]
    400022b0:	fd005be0 	str	d0, [sp, #176]
			value->ptr = va_arg(ap, void *);
    400022b4:	aa0003f3 	mov	x19, x0
    400022b8:	17ffff8e 	b	400020f0 <cbvprintf+0x69c>
				value->dbl = va_arg(ap, double);
    400022bc:	b9407be0 	ldr	w0, [sp, #120]
    400022c0:	11004004 	add	w4, w0, #0x10
    400022c4:	7100009f 	cmp	w4, #0x0
    400022c8:	5400008d 	b.le	400022d8 <cbvprintf+0x884>
    400022cc:	91003e60 	add	x0, x19, #0xf
    400022d0:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400022d4:	17fffff5 	b	400022a8 <cbvprintf+0x854>
    400022d8:	f94037e6 	ldr	x6, [sp, #104]
    400022dc:	aa1303e0 	mov	x0, x19
    400022e0:	b9407be5 	ldr	w5, [sp, #120]
    400022e4:	8b25c0d3 	add	x19, x6, w5, sxtw
    400022e8:	17fffff0 	b	400022a8 <cbvprintf+0x854>
		} else if (specifier_cat == SPECIFIER_PTR) {
    400022ec:	71000c1f 	cmp	w0, #0x3
    400022f0:	54fff001 	b.ne	400020f0 <cbvprintf+0x69c>  // b.any
			value->ptr = va_arg(ap, void *);
    400022f4:	37f800dc 	tbnz	w28, #31, 4000230c <cbvprintf+0x8b8>
    400022f8:	91003e60 	add	x0, x19, #0xf
    400022fc:	2a1c03e4 	mov	w4, w28
    40002300:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002304:	f9400265 	ldr	x5, [x19]
    40002308:	17ffffaf 	b	400021c4 <cbvprintf+0x770>
    4000230c:	11002384 	add	w4, w28, #0x8
    40002310:	7100009f 	cmp	w4, #0x0
    40002314:	5400008d 	b.le	40002324 <cbvprintf+0x8d0>
    40002318:	91003e60 	add	x0, x19, #0xf
    4000231c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002320:	17fffff9 	b	40002304 <cbvprintf+0x8b0>
    40002324:	aa1303e0 	mov	x0, x19
    40002328:	8b3cc313 	add	x19, x24, w28, sxtw
    4000232c:	17fffff6 	b	40002304 <cbvprintf+0x8b0>
		switch (conv->specifier) {
    40002330:	39430fe5 	ldrb	w5, [sp, #195]
    40002334:	7101e0bf 	cmp	w5, #0x78
    40002338:	54ffeee8 	b.hi	40002114 <cbvprintf+0x6c0>  // b.pmore
    4000233c:	71015cbf 	cmp	w5, #0x57
    40002340:	54000468 	b.hi	400023cc <cbvprintf+0x978>  // b.pmore
    40002344:	710094bf 	cmp	w5, #0x25
    40002348:	54000540 	b.eq	400023f0 <cbvprintf+0x99c>  // b.none
    4000234c:	710090bf 	cmp	w5, #0x24
    40002350:	54ffee29 	b.ls	40002114 <cbvprintf+0x6c0>  // b.plast
    40002354:	710104bf 	cmp	w5, #0x41
    40002358:	540000a0 	b.eq	4000236c <cbvprintf+0x918>  // b.none
    4000235c:	510114a0 	sub	w0, w5, #0x45
    40002360:	12001c00 	and	w0, w0, #0xff
    40002364:	7100081f 	cmp	w0, #0x2
    40002368:	54ffed68 	b.hi	40002114 <cbvprintf+0x6c0>  // b.pmore
	} u = {
    4000236c:	f9405be0 	ldr	x0, [sp, #176]
	if ((u.u64 & SIGN_MASK) != 0U) {
    40002370:	b7f81240 	tbnz	x0, #63, 400025b8 <cbvprintf+0xb64>
	} else if (conv->flag_plus) {
    40002374:	794183e4 	ldrh	w4, [sp, #192]
    40002378:	37181244 	tbnz	w4, #3, 400025c0 <cbvprintf+0xb6c>
		*sign = ' ';
    4000237c:	d3441084 	ubfx	x4, x4, #4, #1
    40002380:	531b6884 	lsl	w4, w4, #5
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    40002384:	d374f801 	ubfx	x1, x0, #52, #11
	uint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);
    40002388:	9240cc00 	and	x0, x0, #0xfffffffffffff
    4000238c:	f90047e0 	str	x0, [sp, #136]
	if (expo == BIT_MASK(EXPONENT_BITS)) {
    40002390:	711ffc3f 	cmp	w1, #0x7ff
    40002394:	54001341 	b.ne	400025fc <cbvprintf+0xba8>  // b.any
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    40002398:	510104a5 	sub	w5, w5, #0x41
			if (isupper((int)c)) {
    4000239c:	710064bf 	cmp	w5, #0x19
		if (fract == 0) {
    400023a0:	b50011c0 	cbnz	x0, 400025d8 <cbvprintf+0xb84>
			if (isupper((int)c)) {
    400023a4:	54001128 	b.hi	400025c8 <cbvprintf+0xb74>  // b.pmore
				*buf++ = 'I';
    400023a8:	5289c920 	mov	w0, #0x4e49                	// #20041
    400023ac:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'F';
    400023b0:	528008c0 	mov	w0, #0x46                  	// #70
				*buf++ = 'n';
    400023b4:	39024be0 	strb	w0, [sp, #146]
		*bpe = buf;
    400023b8:	91024ff9 	add	x25, sp, #0x93
		conv->flag_zero = false;
    400023bc:	794183e0 	ldrh	w0, [sp, #192]
    400023c0:	12197800 	and	w0, w0, #0xffffffbf
    400023c4:	790183e0 	strh	w0, [sp, #192]
		return bps;
    400023c8:	1400001d 	b	4000243c <cbvprintf+0x9e8>
		switch (conv->specifier) {
    400023cc:	510160a2 	sub	w2, w5, #0x58
    400023d0:	7100805f 	cmp	w2, #0x20
    400023d4:	54ffea08 	b.hi	40002114 <cbvprintf+0x6c0>  // b.pmore
    400023d8:	90000060 	adrp	x0, 4000e000 <mmu_regions+0x38>
    400023dc:	91282000 	add	x0, x0, #0xa08
    400023e0:	78625800 	ldrh	w0, [x0, w2, uxtw #1]
    400023e4:	10000062 	adr	x2, 400023f0 <cbvprintf+0x99c>
    400023e8:	8b20a840 	add	x0, x2, w0, sxth #2
    400023ec:	d61f0000 	br	x0
			OUTC('%');
    400023f0:	aa1503e1 	mov	x1, x21
    400023f4:	2a0503e0 	mov	w0, w5
    400023f8:	17fffdaf 	b	40001ab4 <cbvprintf+0x60>
			bps = (const char *)value->ptr;
    400023fc:	f9405bfa 	ldr	x26, [sp, #176]
			if (precision >= 0) {
    40002400:	37f80109 	tbnz	w9, #31, 40002420 <cbvprintf+0x9cc>
				len = strnlen(bps, precision);
    40002404:	93407d21 	sxtw	x1, w9
    40002408:	aa1a03e0 	mov	x0, x26
    4000240c:	94001a19 	bl	40008c70 <strnlen>
			bpe = bps + len;
    40002410:	8b000359 	add	x25, x26, x0
		char sign = 0;
    40002414:	52800004 	mov	w4, #0x0                   	// #0
		if (bps == NULL) {
    40002418:	b500015a 	cbnz	x26, 40002440 <cbvprintf+0x9ec>
    4000241c:	17ffff3e 	b	40002114 <cbvprintf+0x6c0>
				len = strlen(bps);
    40002420:	aa1a03e0 	mov	x0, x26
    40002424:	94001a0c 	bl	40008c54 <strlen>
    40002428:	17fffffa 	b	40002410 <cbvprintf+0x9bc>
			bpe = buf + 1;
    4000242c:	910247f9 	add	x25, sp, #0x91
		char sign = 0;
    40002430:	52800004 	mov	w4, #0x0                   	// #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    40002434:	f9405be0 	ldr	x0, [sp, #176]
    40002438:	390243e0 	strb	w0, [sp, #144]
				bps = encode_float(value->dbl, conv, precision,
    4000243c:	910243fa 	add	x26, sp, #0x90
		size_t nj_len = (bpe - bps);
    40002440:	cb1a0320 	sub	x0, x25, x26
		if (sign != 0) {
    40002444:	34000044 	cbz	w4, 4000244c <cbvprintf+0x9f8>
			nj_len += 1U;
    40002448:	91000400 	add	x0, x0, #0x1
		if (conv->altform_0c) {
    4000244c:	39430be5 	ldrb	w5, [sp, #194]
    40002450:	36202b85 	tbz	w5, #4, 400029c0 <cbvprintf+0xf6c>
			nj_len += 2U;
    40002454:	91000800 	add	x0, x0, #0x2
		nj_len += conv->pad0_value;
    40002458:	b980c7e1 	ldrsw	x1, [sp, #196]
    4000245c:	8b000020 	add	x0, x1, x0
		if (conv->pad_fp) {
    40002460:	36300065 	tbz	w5, #6, 4000246c <cbvprintf+0xa18>
			nj_len += conv->pad0_pre_exp;
    40002464:	b980cbe1 	ldrsw	x1, [sp, #200]
    40002468:	8b010000 	add	x0, x0, x1
		if (width > 0) {
    4000246c:	710002ff 	cmp	w23, #0x0
    40002470:	54002c8d 	b.le	40002a00 <cbvprintf+0xfac>
			width -= (int)nj_len;
    40002474:	4b0002f7 	sub	w23, w23, w0
			if (!conv->flag_dash) {
    40002478:	f94063e0 	ldr	x0, [sp, #192]
    4000247c:	721e001f 	tst	w0, #0x4
    40002480:	54002c01 	b.ne	40002a00 <cbvprintf+0xfac>  // b.any
				if (conv->flag_zero) {
    40002484:	794183e0 	ldrh	w0, [sp, #192]
    40002488:	36303080 	tbz	w0, #6, 40002a98 <cbvprintf+0x1044>
					if (sign != 0) {
    4000248c:	340000e4 	cbz	w4, 400024a8 <cbvprintf+0xa54>
						OUTC(sign);
    40002490:	aa1503e1 	mov	x1, x21
    40002494:	2a0403e0 	mov	w0, w4
    40002498:	d63f0280 	blr	x20
    4000249c:	37f834c0 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    400024a0:	9100077b 	add	x27, x27, #0x1
						sign = 0;
    400024a4:	52800004 	mov	w4, #0x0                   	// #0
					pad = '0';
    400024a8:	52800605 	mov	w5, #0x30                  	// #48
    400024ac:	1400017c 	b	40002a9c <cbvprintf+0x1048>
			if (conv->flag_plus) {
    400024b0:	794183e4 	ldrh	w4, [sp, #192]
    400024b4:	37180384 	tbnz	w4, #3, 40002524 <cbvprintf+0xad0>
				sign = ' ';
    400024b8:	d3441084 	ubfx	x4, x4, #4, #1
    400024bc:	531b6884 	lsl	w4, w4, #5
			sint = value->sint;
    400024c0:	f9405be0 	ldr	x0, [sp, #176]
			if (sint < 0) {
    400024c4:	b6f80080 	tbz	x0, #63, 400024d4 <cbvprintf+0xa80>
				value->uint = (uint_value_type)-sint;
    400024c8:	cb0003e0 	neg	x0, x0
				sign = '-';
    400024cc:	528005a4 	mov	w4, #0x2d                  	// #45
				value->uint = (uint_value_type)-sint;
    400024d0:	f9005be0 	str	x0, [sp, #176]
			bps = encode_uint(value->uint, conv, buf, bpe);
    400024d4:	f9405be0 	ldr	x0, [sp, #176]
    400024d8:	9102a7e3 	add	x3, sp, #0xa9
    400024dc:	910243e2 	add	x2, sp, #0x90
    400024e0:	910303e1 	add	x1, sp, #0xc0
    400024e4:	b90073e4 	str	w4, [sp, #112]
    400024e8:	97fffd0e 	bl	40001920 <encode_uint>
    400024ec:	aa0003fa 	mov	x26, x0
    400024f0:	b94073e4 	ldr	w4, [sp, #112]
			if (precision >= 0) {
    400024f4:	9102a7e3 	add	x3, sp, #0xa9
    400024f8:	37f80129 	tbnz	w9, #31, 4000251c <cbvprintf+0xac8>
				conv->flag_zero = false;
    400024fc:	794183e1 	ldrh	w1, [sp, #192]
				size_t len = bpe - bps;
    40002500:	cb1a0060 	sub	x0, x3, x26
				if (len < (size_t)precision) {
    40002504:	eb29c01f 	cmp	x0, w9, sxtw
				conv->flag_zero = false;
    40002508:	12197821 	and	w1, w1, #0xffffffbf
    4000250c:	790183e1 	strh	w1, [sp, #192]
				if (len < (size_t)precision) {
    40002510:	54000062 	b.cs	4000251c <cbvprintf+0xac8>  // b.hs, b.nlast
					conv->pad0_value = precision - (int)len;
    40002514:	4b000120 	sub	w0, w9, w0
    40002518:	b900c7e0 	str	w0, [sp, #196]
		const char *bpe = buf + sizeof(buf);
    4000251c:	aa0303f9 	mov	x25, x3
    40002520:	17ffffbe 	b	40002418 <cbvprintf+0x9c4>
				sign = '+';
    40002524:	52800564 	mov	w4, #0x2b                  	// #43
    40002528:	17ffffe6 	b	400024c0 <cbvprintf+0xa6c>
		switch (conv->specifier) {
    4000252c:	52800004 	mov	w4, #0x0                   	// #0
    40002530:	17ffffe9 	b	400024d4 <cbvprintf+0xa80>
			if (value->ptr != NULL) {
    40002534:	f9405be0 	ldr	x0, [sp, #176]
    40002538:	b4002380 	cbz	x0, 400029a8 <cbvprintf+0xf54>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    4000253c:	910303e1 	add	x1, sp, #0xc0
    40002540:	9102a7e3 	add	x3, sp, #0xa9
    40002544:	910243e2 	add	x2, sp, #0x90
    40002548:	97fffcf6 	bl	40001920 <encode_uint>
    4000254c:	aa0003fa 	mov	x26, x0
				conv->altform_0c = true;
    40002550:	794187e0 	ldrh	w0, [sp, #194]
    40002554:	52801de1 	mov	w1, #0xef                  	// #239
		char sign = 0;
    40002558:	52800004 	mov	w4, #0x0                   	// #0
				conv->altform_0c = true;
    4000255c:	0a010000 	and	w0, w0, w1
    40002560:	528f0201 	mov	w1, #0x7810                	// #30736
    40002564:	2a010000 	orr	w0, w0, w1
    40002568:	790187e0 	strh	w0, [sp, #194]
				goto prec_int_pad0;
    4000256c:	17ffffe2 	b	400024f4 <cbvprintf+0xaa0>
				store_count(conv, value->ptr, count);
    40002570:	93407f60 	sxtw	x0, w27
	switch ((enum length_mod_enum)conv->length_mod) {
    40002574:	71001c3f 	cmp	w1, #0x7
				store_count(conv, value->ptr, count);
    40002578:	f9405be2 	ldr	x2, [sp, #176]
	switch ((enum length_mod_enum)conv->length_mod) {
    4000257c:	54ffdcc8 	b.hi	40002114 <cbvprintf+0x6c0>  // b.pmore
    40002580:	90000063 	adrp	x3, 4000e000 <mmu_regions+0x38>
    40002584:	91293063 	add	x3, x3, #0xa4c
    40002588:	38614861 	ldrb	w1, [x3, w1, uxtw]
    4000258c:	10000063 	adr	x3, 40002598 <cbvprintf+0xb44>
    40002590:	8b218861 	add	x1, x3, w1, sxtb #2
    40002594:	d61f0020 	br	x1
		*(int *)dp = count;
    40002598:	b9000040 	str	w0, [x2]
		break;
    4000259c:	17fffede 	b	40002114 <cbvprintf+0x6c0>
		*(signed char *)dp = (signed char)count;
    400025a0:	3900005b 	strb	w27, [x2]
		break;
    400025a4:	17fffedc 	b	40002114 <cbvprintf+0x6c0>
		*(short *)dp = (short)count;
    400025a8:	7900005b 	strh	w27, [x2]
		break;
    400025ac:	17fffeda 	b	40002114 <cbvprintf+0x6c0>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    400025b0:	f9000040 	str	x0, [x2]
		break;
    400025b4:	17fffed8 	b	40002114 <cbvprintf+0x6c0>
		*sign = '-';
    400025b8:	528005a4 	mov	w4, #0x2d                  	// #45
    400025bc:	17ffff72 	b	40002384 <cbvprintf+0x930>
		*sign = '+';
    400025c0:	52800564 	mov	w4, #0x2b                  	// #43
    400025c4:	17ffff70 	b	40002384 <cbvprintf+0x930>
				*buf++ = 'i';
    400025c8:	528dcd20 	mov	w0, #0x6e69                	// #28265
    400025cc:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'f';
    400025d0:	52800cc0 	mov	w0, #0x66                  	// #102
    400025d4:	17ffff78 	b	400023b4 <cbvprintf+0x960>
			if (isupper((int)c)) {
    400025d8:	540000a8 	b.hi	400025ec <cbvprintf+0xb98>  // b.pmore
				*buf++ = 'N';
    400025dc:	528829c0 	mov	w0, #0x414e                	// #16718
    400025e0:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'N';
    400025e4:	528009c0 	mov	w0, #0x4e                  	// #78
    400025e8:	17ffff73 	b	400023b4 <cbvprintf+0x960>
				*buf++ = 'n';
    400025ec:	528c2dc0 	mov	w0, #0x616e                	// #24942
    400025f0:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'n';
    400025f4:	52800dc0 	mov	w0, #0x6e                  	// #110
    400025f8:	17ffff6f 	b	400023b4 <cbvprintf+0x960>
		c = 'f';
    400025fc:	52800cc2 	mov	w2, #0x66                  	// #102
    40002600:	710118bf 	cmp	w5, #0x46
    40002604:	1a8210a5 	csel	w5, w5, w2, ne  // ne = any
	fract <<= EXPONENT_BITS;
    40002608:	d375d002 	lsl	x2, x0, #11
	fract &= ~SIGN_MASK;
    4000260c:	f90047e2 	str	x2, [sp, #136]
	if ((expo | fract) != 0) {
    40002610:	93407c26 	sxtw	x6, w1
    40002614:	aa0200c6 	orr	x6, x6, x2
    40002618:	b4000f66 	cbz	x6, 40002804 <cbvprintf+0xdb0>
	bool is_subnormal = (expo == 0) && (fract != 0);
    4000261c:	7100003f 	cmp	w1, #0x0
		if (is_subnormal) {
    40002620:	fa400804 	ccmp	x0, #0x0, #0x4, eq  // eq = none
    40002624:	54000c61 	b.ne	400027b0 <cbvprintf+0xd5c>  // b.any
		fract |= BIT_63;
    40002628:	f94047e2 	ldr	x2, [sp, #136]
		expo -= (1023 - 1);	/* +1 since .1 vs 1. */
    4000262c:	510ff821 	sub	w1, w1, #0x3fe
		fract |= BIT_63;
    40002630:	52800000 	mov	w0, #0x0                   	// #0
    40002634:	52800006 	mov	w6, #0x0                   	// #0
    40002638:	b2410042 	orr	x2, x2, #0x8000000000000000
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    4000263c:	3200e7e7 	mov	w7, #0x33333333            	// #858993459
		fract |= BIT_63;
    40002640:	f90047e2 	str	x2, [sp, #136]
	while (expo < -2) {
    40002644:	3100083f 	cmn	w1, #0x2
    40002648:	54000b8b 	b.lt	400027b8 <cbvprintf+0xd64>  // b.tstop
    4000264c:	34000040 	cbz	w0, 40002654 <cbvprintf+0xc00>
    40002650:	f90047e2 	str	x2, [sp, #136]
    40002654:	f94047e0 	ldr	x0, [sp, #136]
		decexp--;
    40002658:	52800002 	mov	w2, #0x0                   	// #0
	*v /= 5U;
    4000265c:	d28000a7 	mov	x7, #0x5                   	// #5
	while (expo > 0) {
    40002660:	7100003f 	cmp	w1, #0x0
    40002664:	54000bec 	b.gt	400027e0 <cbvprintf+0xd8c>
    40002668:	34000042 	cbz	w2, 40002670 <cbvprintf+0xc1c>
    4000266c:	f90047e0 	str	x0, [sp, #136]
	fract >>= (4 - expo);
    40002670:	52800080 	mov	w0, #0x4                   	// #4
    40002674:	4b010000 	sub	w0, w0, w1
    40002678:	f94047e1 	ldr	x1, [sp, #136]
    4000267c:	9ac02421 	lsr	x1, x1, x0
	if ((c == 'g') || (c == 'G')) {
    40002680:	121a78a0 	and	w0, w5, #0xffffffdf
    40002684:	12001c00 	and	w0, w0, #0xff
    40002688:	71011c1f 	cmp	w0, #0x47
    4000268c:	54000c81 	b.ne	4000281c <cbvprintf+0xdc8>  // b.any
		if (decexp < (-4 + 1) || decexp > precision) {
    40002690:	6b06013f 	cmp	w9, w6
    40002694:	3a43a8c1 	ccmn	w6, #0x3, #0x1, ge  // ge = tcont
    40002698:	54000bca 	b.ge	40002810 <cbvprintf+0xdbc>  // b.tcont
				precision--;
    4000269c:	7100013f 	cmp	w9, #0x0
			c += 'e' - 'g';  /* e or E */
    400026a0:	510008a5 	sub	w5, w5, #0x2
				precision--;
    400026a4:	1a9fd7e0 	cset	w0, gt
			c += 'e' - 'g';  /* e or E */
    400026a8:	12001ca5 	and	w5, w5, #0xff
				precision--;
    400026ac:	4b000129 	sub	w9, w9, w0
		if (!conv->flag_hash && (precision > 0)) {
    400026b0:	721b007f 	tst	w3, #0x20
    400026b4:	54000b41 	b.ne	4000281c <cbvprintf+0xdc8>  // b.any
    400026b8:	7100013f 	cmp	w9, #0x0
    400026bc:	1a9fd7e7 	cset	w7, gt
	if (c == 'f') {
    400026c0:	710198bf 	cmp	w5, #0x66
    400026c4:	54000b01 	b.ne	40002824 <cbvprintf+0xdd0>  // b.any
		if (decimals < 0) {
    400026c8:	2b060120 	adds	w0, w9, w6
    400026cc:	54000ae5 	b.pl	40002828 <cbvprintf+0xdd4>  // b.nfrst
			decimals = 0;
    400026d0:	52800000 	mov	w0, #0x0                   	// #0
    400026d4:	52800202 	mov	w2, #0x10                  	// #16
	*v /= 5U;
    400026d8:	d28000a3 	mov	x3, #0x5                   	// #5
    400026dc:	b90087e2 	str	w2, [sp, #132]
			decimals = 0;
    400026e0:	d2e10002 	mov	x2, #0x800000000000000     	// #576460752303423488
	while (decimals--) {
    400026e4:	51000400 	sub	w0, w0, #0x1
    400026e8:	3100041f 	cmn	w0, #0x1
    400026ec:	54000a61 	b.ne	40002838 <cbvprintf+0xde4>  // b.any
	fract += round;
    400026f0:	8b020021 	add	x1, x1, x2
	if (fract >= BIT64(60)) {
    400026f4:	92fe0000 	mov	x0, #0xfffffffffffffff     	// #1152921504606846975
    400026f8:	eb00003f 	cmp	x1, x0
    400026fc:	54000a48 	b.hi	40002844 <cbvprintf+0xdf0>  // b.pmore
	fract += round;
    40002700:	f90047e1 	str	x1, [sp, #136]
	if (c == 'f') {
    40002704:	710198bf 	cmp	w5, #0x66
    40002708:	54000b21 	b.ne	4000286c <cbvprintf+0xe18>  // b.any
		if (decexp > 0) {
    4000270c:	710000df 	cmp	w6, #0x0
    40002710:	54000a6d 	b.le	4000285c <cbvprintf+0xe08>
	char *buf = bps;
    40002714:	910243f9 	add	x25, sp, #0x90
				*buf++ = _get_digit(&fract, &digit_count);
    40002718:	910213e1 	add	x1, sp, #0x84
    4000271c:	910223e0 	add	x0, sp, #0x88
    40002720:	97fffc70 	bl	400018e0 <_get_digit>
    40002724:	38001720 	strb	w0, [x25], #1
			while (decexp > 0 && digit_count > 0) {
    40002728:	b94087e0 	ldr	w0, [sp, #132]
				decexp--;
    4000272c:	510004c6 	sub	w6, w6, #0x1
			while (decexp > 0 && digit_count > 0) {
    40002730:	7100001f 	cmp	w0, #0x0
    40002734:	7a40c8c4 	ccmp	w6, #0x0, #0x4, gt
    40002738:	54ffff0c 	b.gt	40002718 <cbvprintf+0xcc4>
			conv->pad0_value = decexp;
    4000273c:	b900c7e6 	str	w6, [sp, #196]
			decexp = 0;
    40002740:	52800006 	mov	w6, #0x0                   	// #0
		if (conv->flag_hash || (precision > 0)) {
    40002744:	794183e0 	ldrh	w0, [sp, #192]
    40002748:	37280060 	tbnz	w0, #5, 40002754 <cbvprintf+0xd00>
    4000274c:	7100013f 	cmp	w9, #0x0
    40002750:	54000c2d 	b.le	400028d4 <cbvprintf+0xe80>
			*buf++ = '.';
    40002754:	aa1903e3 	mov	x3, x25
    40002758:	528005c0 	mov	w0, #0x2e                  	// #46
		if (decexp < 0 && precision > 0) {
    4000275c:	710000df 	cmp	w6, #0x0
    40002760:	7a40b924 	ccmp	w9, #0x0, #0x4, lt  // lt = tstop
			*buf++ = '.';
    40002764:	38001460 	strb	w0, [x3], #1
		if (decexp < 0 && precision > 0) {
    40002768:	5400016d 	b.le	40002794 <cbvprintf+0xd40>
			conv->pad0_value = -decexp;
    4000276c:	4b0603e1 	neg	w1, w6
			conv->pad_postdp = (conv->pad0_value > 0);
    40002770:	39430be0 	ldrb	w0, [sp, #194]
			conv->pad0_value = -decexp;
    40002774:	6b01013f 	cmp	w9, w1
    40002778:	1a81b121 	csel	w1, w9, w1, lt  // lt = tstop
    4000277c:	b900c7e1 	str	w1, [sp, #196]
			conv->pad_postdp = (conv->pad0_value > 0);
    40002780:	7100003f 	cmp	w1, #0x0
			precision -= conv->pad0_value;
    40002784:	4b010129 	sub	w9, w9, w1
			conv->pad_postdp = (conv->pad0_value > 0);
    40002788:	1a9fd7e1 	cset	w1, gt
    4000278c:	331b0020 	bfi	w0, w1, #5, #1
    40002790:	39030be0 	strb	w0, [sp, #194]
			*buf++ = '.';
    40002794:	aa0303f9 	mov	x25, x3
    40002798:	1400004a 	b	400028c0 <cbvprintf+0xe6c>
				expo--;
    4000279c:	51000421 	sub	w1, w1, #0x1
			while (((fract <<= 1) & BIT_63) == 0) {
    400027a0:	d37ff842 	lsl	x2, x2, #1
    400027a4:	b6ffffc2 	tbz	x2, #63, 4000279c <cbvprintf+0xd48>
    400027a8:	f90047e2 	str	x2, [sp, #136]
    400027ac:	17ffff9f 	b	40002628 <cbvprintf+0xbd4>
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    400027b0:	52800001 	mov	w1, #0x0                   	// #0
    400027b4:	17fffffb 	b	400027a0 <cbvprintf+0xd4c>
			expo++;
    400027b8:	2a0103e8 	mov	w8, w1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    400027bc:	eb4284ff 	cmp	x7, x2, lsr #33
			expo++;
    400027c0:	11000421 	add	w1, w1, #0x1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    400027c4:	d341fc42 	lsr	x2, x2, #1
    400027c8:	54ffff89 	b.ls	400027b8 <cbvprintf+0xd64>  // b.plast
		fract *= 5U;
    400027cc:	8b020842 	add	x2, x2, x2, lsl #2
		expo++;
    400027d0:	11000901 	add	w1, w8, #0x2
		decexp--;
    400027d4:	510004c6 	sub	w6, w6, #0x1
    400027d8:	52800020 	mov	w0, #0x1                   	// #1
    400027dc:	17ffff9a 	b	40002644 <cbvprintf+0xbf0>
		fract += 2;
    400027e0:	91000800 	add	x0, x0, #0x2
		expo--;
    400027e4:	51000421 	sub	w1, w1, #0x1
		decexp++;
    400027e8:	110004c6 	add	w6, w6, #0x1
    400027ec:	52800022 	mov	w2, #0x1                   	// #1
	*v /= 5U;
    400027f0:	9ac70800 	udiv	x0, x0, x7
			fract <<= 1;
    400027f4:	d37ff800 	lsl	x0, x0, #1
			expo--;
    400027f8:	51000421 	sub	w1, w1, #0x1
		} while (!(fract & BIT_63));
    400027fc:	b6ffffc0 	tbz	x0, #63, 400027f4 <cbvprintf+0xda0>
    40002800:	17ffff98 	b	40002660 <cbvprintf+0xc0c>
    40002804:	52800006 	mov	w6, #0x0                   	// #0
    40002808:	52800001 	mov	w1, #0x0                   	// #0
    4000280c:	17ffff99 	b	40002670 <cbvprintf+0xc1c>
			precision -= decexp;
    40002810:	4b060129 	sub	w9, w9, w6
			c = 'f';
    40002814:	52800cc5 	mov	w5, #0x66                  	// #102
    40002818:	17ffffa6 	b	400026b0 <cbvprintf+0xc5c>
	bool prune_zero = false;
    4000281c:	52800007 	mov	w7, #0x0                   	// #0
    40002820:	17ffffa8 	b	400026c0 <cbvprintf+0xc6c>
		decimals = precision + 1;
    40002824:	11000520 	add	w0, w9, #0x1
	if (decimals > 16) {
    40002828:	7100401f 	cmp	w0, #0x10
    4000282c:	52800202 	mov	w2, #0x10                  	// #16
    40002830:	1a82d000 	csel	w0, w0, w2, le
    40002834:	17ffffa8 	b	400026d4 <cbvprintf+0xc80>
	*v >>= 1;
    40002838:	d341fc42 	lsr	x2, x2, #1
	*v /= 5U;
    4000283c:	9ac30842 	udiv	x2, x2, x3
}
    40002840:	17ffffa9 	b	400026e4 <cbvprintf+0xc90>
	*v >>= 1;
    40002844:	d341fc21 	lsr	x1, x1, #1
	*v /= 5U;
    40002848:	d28000a0 	mov	x0, #0x5                   	// #5
		decexp++;
    4000284c:	110004c6 	add	w6, w6, #0x1
	*v /= 5U;
    40002850:	9ac00821 	udiv	x1, x1, x0
    40002854:	f90047e1 	str	x1, [sp, #136]
		decexp++;
    40002858:	17ffffab 	b	40002704 <cbvprintf+0xcb0>
			*buf++ = '0';
    4000285c:	52800600 	mov	w0, #0x30                  	// #48
    40002860:	910247f9 	add	x25, sp, #0x91
    40002864:	390243e0 	strb	w0, [sp, #144]
    40002868:	17ffffb7 	b	40002744 <cbvprintf+0xcf0>
		*buf = _get_digit(&fract, &digit_count);
    4000286c:	910213e1 	add	x1, sp, #0x84
    40002870:	910223e0 	add	x0, sp, #0x88
    40002874:	97fffc1b 	bl	400018e0 <_get_digit>
    40002878:	12001c01 	and	w1, w0, #0xff
			decexp--;
    4000287c:	7100c03f 	cmp	w1, #0x30
		*buf = _get_digit(&fract, &digit_count);
    40002880:	390243e0 	strb	w0, [sp, #144]
			decexp--;
    40002884:	1a9f07e0 	cset	w0, ne  // ne = any
    40002888:	4b0000c6 	sub	w6, w6, w0
		if (conv->flag_hash || (precision > 0)) {
    4000288c:	794183e0 	ldrh	w0, [sp, #192]
    40002890:	37280060 	tbnz	w0, #5, 4000289c <cbvprintf+0xe48>
    40002894:	7100013f 	cmp	w9, #0x0
    40002898:	540006cd 	b.le	40002970 <cbvprintf+0xf1c>
			*buf++ = '.';
    4000289c:	528005c0 	mov	w0, #0x2e                  	// #46
    400028a0:	91024be3 	add	x3, sp, #0x92
    400028a4:	390247e0 	strb	w0, [sp, #145]
    400028a8:	17ffffbb 	b	40002794 <cbvprintf+0xd40>
		precision--;
    400028ac:	51000529 	sub	w9, w9, #0x1
		*buf++ = _get_digit(&fract, &digit_count);
    400028b0:	910213e1 	add	x1, sp, #0x84
    400028b4:	910223e0 	add	x0, sp, #0x88
    400028b8:	97fffc0a 	bl	400018e0 <_get_digit>
    400028bc:	38001720 	strb	w0, [x25], #1
	while (precision > 0 && digit_count > 0) {
    400028c0:	7100013f 	cmp	w9, #0x0
    400028c4:	5400008d 	b.le	400028d4 <cbvprintf+0xe80>
    400028c8:	b94087e0 	ldr	w0, [sp, #132]
    400028cc:	7100001f 	cmp	w0, #0x0
    400028d0:	54fffeec 	b.gt	400028ac <cbvprintf+0xe58>
	if (prune_zero) {
    400028d4:	35000527 	cbnz	w7, 40002978 <cbvprintf+0xf24>
	conv->pad0_pre_exp = precision;
    400028d8:	b900cbe9 	str	w9, [sp, #200]
	if ((c == 'e') || (c == 'E')) {
    400028dc:	121a78a0 	and	w0, w5, #0xffffffdf
    400028e0:	12001c00 	and	w0, w0, #0xff
    400028e4:	7101141f 	cmp	w0, #0x45
    400028e8:	540002e1 	b.ne	40002944 <cbvprintf+0xef0>  // b.any
		*buf++ = c;
    400028ec:	aa1903e1 	mov	x1, x25
    400028f0:	38002425 	strb	w5, [x1], #2
		if (decexp < 0) {
    400028f4:	36f80526 	tbz	w6, #31, 40002998 <cbvprintf+0xf44>
			decexp = -decexp;
    400028f8:	4b0603e6 	neg	w6, w6
			*buf++ = '-';
    400028fc:	528005a0 	mov	w0, #0x2d                  	// #45
    40002900:	39000720 	strb	w0, [x25, #1]
		if (decexp >= 100) {
    40002904:	71018cdf 	cmp	w6, #0x63
    40002908:	540000ed 	b.le	40002924 <cbvprintf+0xed0>
			*buf++ = (decexp / 100) + '0';
    4000290c:	52800c80 	mov	w0, #0x64                  	// #100
    40002910:	91000f21 	add	x1, x25, #0x3
    40002914:	1ac00cc2 	sdiv	w2, w6, w0
			decexp %= 100;
    40002918:	1b009846 	msub	w6, w2, w0, w6
			*buf++ = (decexp / 100) + '0';
    4000291c:	1100c045 	add	w5, w2, #0x30
    40002920:	39000b25 	strb	w5, [x25, #2]
		*buf++ = (decexp / 10) + '0';
    40002924:	52800142 	mov	w2, #0xa                   	// #10
    40002928:	aa0103f9 	mov	x25, x1
    4000292c:	1ac20cc0 	sdiv	w0, w6, w2
    40002930:	1100c005 	add	w5, w0, #0x30
		*buf++ = (decexp % 10) + '0';
    40002934:	1b029800 	msub	w0, w0, w2, w6
		*buf++ = (decexp / 10) + '0';
    40002938:	38002725 	strb	w5, [x25], #2
		*buf++ = (decexp % 10) + '0';
    4000293c:	1100c000 	add	w0, w0, #0x30
    40002940:	39000420 	strb	w0, [x1, #1]
		|| (conv->pad0_pre_exp > 0);
    40002944:	b940c7e0 	ldr	w0, [sp, #196]
    40002948:	7100001f 	cmp	w0, #0x0
    4000294c:	540002ac 	b.gt	400029a0 <cbvprintf+0xf4c>
    40002950:	b940cbe0 	ldr	w0, [sp, #200]
    40002954:	7100001f 	cmp	w0, #0x0
    40002958:	1a9fd7e1 	cset	w1, gt
	conv->pad_fp = (conv->pad0_value > 0)
    4000295c:	39430be0 	ldrb	w0, [sp, #194]
    40002960:	331a0020 	bfi	w0, w1, #6, #1
    40002964:	39030be0 	strb	w0, [sp, #194]
	*buf = 0;
    40002968:	3900033f 	strb	wzr, [x25]
	return bps;
    4000296c:	17fffeb4 	b	4000243c <cbvprintf+0x9e8>
		if (*buf++ != '0') {
    40002970:	910247f9 	add	x25, sp, #0x91
    40002974:	17ffffd8 	b	400028d4 <cbvprintf+0xe80>
		conv->pad0_pre_exp = 0;
    40002978:	b900cbff 	str	wzr, [sp, #200]
		while (*--buf == '0') {
    4000297c:	aa1903e1 	mov	x1, x25
    40002980:	385fff20 	ldrb	w0, [x25, #-1]!
    40002984:	7100c01f 	cmp	w0, #0x30
    40002988:	54ffffa0 	b.eq	4000297c <cbvprintf+0xf28>  // b.none
		if (*buf != '.') {
    4000298c:	7100b81f 	cmp	w0, #0x2e
    40002990:	9a810339 	csel	x25, x25, x1, eq  // eq = none
    40002994:	17ffffd2 	b	400028dc <cbvprintf+0xe88>
			*buf++ = '+';
    40002998:	52800560 	mov	w0, #0x2b                  	// #43
    4000299c:	17ffffd9 	b	40002900 <cbvprintf+0xeac>
		|| (conv->pad0_pre_exp > 0);
    400029a0:	52800021 	mov	w1, #0x1                   	// #1
    400029a4:	17ffffee 	b	4000295c <cbvprintf+0xf08>
			bpe = bps + 5;
    400029a8:	90000063 	adrp	x3, 4000e000 <mmu_regions+0x38>
    400029ac:	912c1879 	add	x25, x3, #0xb06
			bps = "(nil)";
    400029b0:	90000062 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400029b4:	912c045a 	add	x26, x2, #0xb01
		char sign = 0;
    400029b8:	52800004 	mov	w4, #0x0                   	// #0
    400029bc:	17fffea1 	b	40002440 <cbvprintf+0x9ec>
		} else if (conv->altform_0) {
    400029c0:	361fd4c5 	tbz	w5, #3, 40002458 <cbvprintf+0xa04>
			nj_len += 1U;
    400029c4:	91000400 	add	x0, x0, #0x1
    400029c8:	17fffea4 	b	40002458 <cbvprintf+0xa04>
					OUTC(pad);
    400029cc:	b90073e5 	str	w5, [sp, #112]
    400029d0:	aa1503e1 	mov	x1, x21
    400029d4:	b9007fe4 	str	w4, [sp, #124]
    400029d8:	2a0503e0 	mov	w0, w5
    400029dc:	d63f0280 	blr	x20
    400029e0:	37f80aa0 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    400029e4:	b94073e5 	ldr	w5, [sp, #112]
    400029e8:	9100077b 	add	x27, x27, #0x1
    400029ec:	b9407fe4 	ldr	w4, [sp, #124]
				while (width-- > 0) {
    400029f0:	2a1703e0 	mov	w0, w23
    400029f4:	510006f7 	sub	w23, w23, #0x1
    400029f8:	7100001f 	cmp	w0, #0x0
    400029fc:	54fffe8c 	b.gt	400029cc <cbvprintf+0xf78>
		if (sign != 0) {
    40002a00:	340000c4 	cbz	w4, 40002a18 <cbvprintf+0xfc4>
			OUTC(sign);
    40002a04:	aa1503e1 	mov	x1, x21
    40002a08:	2a0403e0 	mov	w0, w4
    40002a0c:	d63f0280 	blr	x20
    40002a10:	37f80920 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40002a14:	9100077b 	add	x27, x27, #0x1
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {
    40002a18:	39430be0 	ldrb	w0, [sp, #194]
    40002a1c:	36300e00 	tbz	w0, #6, 40002bdc <cbvprintf+0x1188>
			if (conv->specifier_a) {
    40002a20:	79c183e0 	ldrsh	w0, [sp, #192]
    40002a24:	cb1a037b 	sub	x27, x27, x26
    40002a28:	37f80460 	tbnz	w0, #31, 40002ab4 <cbvprintf+0x1060>
				while (isdigit((int)*cp)) {
    40002a2c:	39400340 	ldrb	w0, [x26]
    40002a30:	8b1b0344 	add	x4, x26, x27
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    40002a34:	5100c001 	sub	w1, w0, #0x30
    40002a38:	7100243f 	cmp	w1, #0x9
    40002a3c:	54000749 	b.ls	40002b24 <cbvprintf+0x10d0>  // b.plast
				if (!conv->pad_postdp) {
    40002a40:	f94063e0 	ldr	x0, [sp, #192]
				pad_len = conv->pad0_value;
    40002a44:	b940c7fb 	ldr	w27, [sp, #196]
				if (!conv->pad_postdp) {
    40002a48:	720b001f 	tst	w0, #0x200000
    40002a4c:	540000a1 	b.ne	40002a60 <cbvprintf+0x100c>  // b.any
					while (pad_len-- > 0) {
    40002a50:	51000765 	sub	w5, w27, #0x1
    40002a54:	7100037f 	cmp	w27, #0x0
    40002a58:	540007cc 	b.gt	40002b50 <cbvprintf+0x10fc>
    40002a5c:	2a0503fb 	mov	w27, w5
				if (*cp == '.') {
    40002a60:	39400340 	ldrb	w0, [x26]
    40002a64:	7100b81f 	cmp	w0, #0x2e
    40002a68:	54000141 	b.ne	40002a90 <cbvprintf+0x103c>  // b.any
    40002a6c:	f9003be4 	str	x4, [sp, #112]
					OUTC(*cp++);
    40002a70:	aa1503e1 	mov	x1, x21
    40002a74:	d63f0280 	blr	x20
						OUTC('0');
    40002a78:	37f805e0 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40002a7c:	f9403be4 	ldr	x4, [sp, #112]
					while (pad_len-- > 0) {
    40002a80:	7100037f 	cmp	w27, #0x0
						OUTC('0');
    40002a84:	91000484 	add	x4, x4, #0x1
					while (pad_len-- > 0) {
    40002a88:	540007ac 	b.gt	40002b7c <cbvprintf+0x1128>
					OUTC(*cp++);
    40002a8c:	9100075a 	add	x26, x26, #0x1
    40002a90:	cb1a009b 	sub	x27, x4, x26
    40002a94:	14000044 	b	40002ba4 <cbvprintf+0x1150>
				char pad = ' ';
    40002a98:	52800405 	mov	w5, #0x20                  	// #32
					pad = '0';
    40002a9c:	2a1703e0 	mov	w0, w23
    40002aa0:	17ffffd5 	b	400029f4 <cbvprintf+0xfa0>
					OUTC(*cp++);
    40002aa4:	9100075a 	add	x26, x26, #0x1
    40002aa8:	aa1503e1 	mov	x1, x21
    40002aac:	d63f0280 	blr	x20
    40002ab0:	37f80420 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
				while (*cp != 'p') {
    40002ab4:	39400340 	ldrb	w0, [x26]
    40002ab8:	8b1b0341 	add	x1, x26, x27
    40002abc:	7101c01f 	cmp	w0, #0x70
    40002ac0:	54ffff21 	b.ne	40002aa4 <cbvprintf+0x1050>  // b.any
			while (pad_len-- > 0) {
    40002ac4:	b940cbe4 	ldr	w4, [sp, #200]
    40002ac8:	aa0103fb 	mov	x27, x1
    40002acc:	0b010084 	add	w4, w4, w1
    40002ad0:	4b1b0080 	sub	w0, w4, w27
    40002ad4:	7100001f 	cmp	w0, #0x0
    40002ad8:	5400072c 	b.gt	40002bbc <cbvprintf+0x1168>
			OUTS(bps, bpe);
    40002adc:	aa1903e3 	mov	x3, x25
    40002ae0:	aa1a03e2 	mov	x2, x26
    40002ae4:	aa1503e1 	mov	x1, x21
    40002ae8:	aa1403e0 	mov	x0, x20
    40002aec:	97fffbbe 	bl	400019e4 <outs>
    40002af0:	37f80220 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40002af4:	8b20c360 	add	x0, x27, w0, sxtw
			while (pad_len-- > 0) {
    40002af8:	aa0003fb 	mov	x27, x0
    40002afc:	0b0002f7 	add	w23, w23, w0
		while (width > 0) {
    40002b00:	4b1b02e0 	sub	w0, w23, w27
    40002b04:	7100001f 	cmp	w0, #0x0
    40002b08:	54ffb06d 	b.le	40002114 <cbvprintf+0x6c0>
			OUTC(' ');
    40002b0c:	aa1503e1 	mov	x1, x21
    40002b10:	52800400 	mov	w0, #0x20                  	// #32
    40002b14:	d63f0280 	blr	x20
    40002b18:	37f800e0 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40002b1c:	9100077b 	add	x27, x27, #0x1
			--width;
    40002b20:	17fffff8 	b	40002b00 <cbvprintf+0x10ac>
					OUTC(*cp++);
    40002b24:	9100075a 	add	x26, x26, #0x1
    40002b28:	aa1503e1 	mov	x1, x21
    40002b2c:	d63f0280 	blr	x20
    40002b30:	36fff7e0 	tbz	w0, #31, 40002a2c <cbvprintf+0xfd8>
#undef OUTS
#undef OUTC
}
    40002b34:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002b38:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40002b3c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40002b40:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40002b44:	a94573fb 	ldp	x27, x28, [sp, #80]
    40002b48:	a8cd7bfd 	ldp	x29, x30, [sp], #208
    40002b4c:	d65f03c0 	ret
    40002b50:	f9003be4 	str	x4, [sp, #112]
						OUTC('0');
    40002b54:	aa1503e1 	mov	x1, x21
    40002b58:	b9007fe5 	str	w5, [sp, #124]
    40002b5c:	52800600 	mov	w0, #0x30                  	// #48
    40002b60:	d63f0280 	blr	x20
    40002b64:	37fffe80 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40002b68:	f9403be4 	ldr	x4, [sp, #112]
					while (pad_len-- > 0) {
    40002b6c:	b9407fe5 	ldr	w5, [sp, #124]
						OUTC('0');
    40002b70:	91000484 	add	x4, x4, #0x1
					while (pad_len-- > 0) {
    40002b74:	2a0503fb 	mov	w27, w5
    40002b78:	17ffffb6 	b	40002a50 <cbvprintf+0xffc>
    40002b7c:	f9003be4 	str	x4, [sp, #112]
						OUTC('0');
    40002b80:	aa1503e1 	mov	x1, x21
    40002b84:	5100077b 	sub	w27, w27, #0x1
    40002b88:	52800600 	mov	w0, #0x30                  	// #48
    40002b8c:	d63f0280 	blr	x20
    40002b90:	17ffffba 	b	40002a78 <cbvprintf+0x1024>
					OUTC(*cp++);
    40002b94:	9100075a 	add	x26, x26, #0x1
    40002b98:	aa1503e1 	mov	x1, x21
    40002b9c:	d63f0280 	blr	x20
    40002ba0:	37fffca0 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
				while (isdigit((int)*cp)) {
    40002ba4:	39400340 	ldrb	w0, [x26]
    40002ba8:	8b1b0341 	add	x1, x26, x27
    40002bac:	5100c004 	sub	w4, w0, #0x30
    40002bb0:	7100249f 	cmp	w4, #0x9
    40002bb4:	54ffff09 	b.ls	40002b94 <cbvprintf+0x1140>  // b.plast
    40002bb8:	17ffffc3 	b	40002ac4 <cbvprintf+0x1070>
    40002bbc:	b90073e4 	str	w4, [sp, #112]
				OUTC('0');
    40002bc0:	aa1503e1 	mov	x1, x21
    40002bc4:	52800600 	mov	w0, #0x30                  	// #48
    40002bc8:	d63f0280 	blr	x20
    40002bcc:	37fffb40 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40002bd0:	b94073e4 	ldr	w4, [sp, #112]
    40002bd4:	9100077b 	add	x27, x27, #0x1
    40002bd8:	17ffffbe 	b	40002ad0 <cbvprintf+0x107c>
			if (conv->altform_0c | conv->altform_0) {
    40002bdc:	f94063e0 	ldr	x0, [sp, #192]
    40002be0:	d3545001 	ubfx	x1, x0, #20, #1
    40002be4:	d3534c00 	ubfx	x0, x0, #19, #1
    40002be8:	2a000020 	orr	w0, w1, w0
    40002bec:	360000c0 	tbz	w0, #0, 40002c04 <cbvprintf+0x11b0>
				OUTC('0');
    40002bf0:	aa1503e1 	mov	x1, x21
    40002bf4:	52800600 	mov	w0, #0x30                  	// #48
    40002bf8:	d63f0280 	blr	x20
    40002bfc:	37fff9c0 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40002c00:	9100077b 	add	x27, x27, #0x1
			if (conv->altform_0c) {
    40002c04:	39430be0 	ldrb	w0, [sp, #194]
    40002c08:	362000c0 	tbz	w0, #4, 40002c20 <cbvprintf+0x11cc>
				OUTC(conv->specifier);
    40002c0c:	39430fe0 	ldrb	w0, [sp, #195]
    40002c10:	aa1503e1 	mov	x1, x21
    40002c14:	d63f0280 	blr	x20
    40002c18:	37fff8e0 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40002c1c:	9100077b 	add	x27, x27, #0x1
			while (pad_len-- > 0) {
    40002c20:	b940c7e4 	ldr	w4, [sp, #196]
    40002c24:	0b1b0084 	add	w4, w4, w27
    40002c28:	4b1b0080 	sub	w0, w4, w27
    40002c2c:	7100001f 	cmp	w0, #0x0
    40002c30:	54fff56d 	b.le	40002adc <cbvprintf+0x1088>
    40002c34:	b90073e4 	str	w4, [sp, #112]
				OUTC('0');
    40002c38:	aa1503e1 	mov	x1, x21
    40002c3c:	52800600 	mov	w0, #0x30                  	// #48
    40002c40:	d63f0280 	blr	x20
    40002c44:	37fff780 	tbnz	w0, #31, 40002b34 <cbvprintf+0x10e0>
    40002c48:	b94073e4 	ldr	w4, [sp, #112]
    40002c4c:	9100077b 	add	x27, x27, #0x1
    40002c50:	17fffff6 	b	40002c28 <cbvprintf+0x11d4>

0000000040002c54 <ring_buf_get_rewind_threshold>:
 * rewinding earlier.
 */
uint32_t __weak ring_buf_get_rewind_threshold(void)
{
	return RING_BUFFER_MAX_SIZE;
}
    40002c54:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
    40002c58:	d65f03c0 	ret

0000000040002c5c <ring_buf_put_claim>:

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
	uint32_t space, trail_size, allocated, tmp_trail_mod;

	tmp_trail_mod = mod(buf, buf->misc.byte_mode.tmp_tail);
    40002c5c:	b9402004 	ldr	w4, [x0, #32]
{
    40002c60:	aa0003e5 	mov	x5, x0
	tmp_trail_mod = mod(buf, buf->misc.byte_mode.tmp_tail);
    40002c64:	b9400806 	ldr	w6, [x0, #8]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40002c68:	b9401007 	ldr	w7, [x0, #16]
    40002c6c:	34000204 	cbz	w4, 40002cac <ring_buf_put_claim+0x50>
    40002c70:	0a0400c4 	and	w4, w6, w4
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
    40002c74:	b94000a3 	ldr	w3, [x5]
	trail_size = buf->size - tmp_trail_mod;
    40002c78:	4b0400e0 	sub	w0, w7, w4
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
    40002c7c:	0b0300e3 	add	w3, w7, w3
    40002c80:	4b060063 	sub	w3, w3, w6

	/* Limit requested size to available size. */
	size = MIN(size, space);
    40002c84:	6b02007f 	cmp	w3, w2
    40002c88:	1a829062 	csel	w2, w3, w2, ls  // ls = plast

	trail_size = buf->size - (tmp_trail_mod);

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
    40002c8c:	6b00005f 	cmp	w2, w0
    40002c90:	1a809040 	csel	w0, w2, w0, ls  // ls = plast
	*data = &buf->buf.buf8[tmp_trail_mod];
    40002c94:	f9400ca2 	ldr	x2, [x5, #24]

	buf->misc.byte_mode.tmp_tail =
		buf->misc.byte_mode.tmp_tail + allocated;
    40002c98:	0b0000c6 	add	w6, w6, w0
	*data = &buf->buf.buf8[tmp_trail_mod];
    40002c9c:	8b244044 	add	x4, x2, w4, uxtw
    40002ca0:	f9000024 	str	x4, [x1]
	buf->misc.byte_mode.tmp_tail =
    40002ca4:	b90008a6 	str	w6, [x5, #8]

	return allocated;
}
    40002ca8:	d65f03c0 	ret
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40002cac:	1ac708c4 	udiv	w4, w6, w7
    40002cb0:	1b079884 	msub	w4, w4, w7, w6
    40002cb4:	17fffff0 	b	40002c74 <ring_buf_put_claim+0x18>

0000000040002cb8 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
    40002cb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40002cbc:	910003fd 	mov	x29, sp
    40002cc0:	a90153f3 	stp	x19, x20, [sp, #16]
    40002cc4:	aa0003f4 	mov	x20, x0
    40002cc8:	2a0103f3 	mov	w19, w1
	uint32_t rew;
	uint32_t threshold = ring_buf_get_rewind_threshold();
    40002ccc:	97ffffe2 	bl	40002c54 <ring_buf_get_rewind_threshold>

	if ((buf->tail + size) > (buf->head + buf->size)) {
    40002cd0:	29401282 	ldp	w2, w4, [x20]
    40002cd4:	b9401283 	ldr	w3, [x20, #16]
    40002cd8:	0b130081 	add	w1, w4, w19
    40002cdc:	0b020062 	add	w2, w3, w2
    40002ce0:	6b02003f 	cmp	w1, w2
    40002ce4:	540001a8 	b.hi	40002d18 <ring_buf_put_finish+0x60>  // b.pmore
		return -EINVAL;
	}

	/* Check if indexes shall be rewind. */
	if (buf->tail > threshold) {
    40002ce8:	6b00009f 	cmp	w4, w0
    40002cec:	54000129 	b.ls	40002d10 <ring_buf_put_finish+0x58>  // b.plast
	return buf_size * (threshold / buf_size);
    40002cf0:	1ac30802 	udiv	w2, w0, w3
    40002cf4:	1b037c42 	mul	w2, w2, w3
		rew = get_rewind_value(buf->size, threshold);
	} else {
		rew = 0;
	}

	buf->tail += (size - rew);
    40002cf8:	4b020021 	sub	w1, w1, w2
	buf->misc.byte_mode.tmp_tail = buf->tail;

	return 0;
    40002cfc:	52800000 	mov	w0, #0x0                   	// #0
	buf->misc.byte_mode.tmp_tail = buf->tail;
    40002d00:	29008681 	stp	w1, w1, [x20, #4]
}
    40002d04:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002d08:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40002d0c:	d65f03c0 	ret
		rew = 0;
    40002d10:	52800002 	mov	w2, #0x0                   	// #0
    40002d14:	17fffff9 	b	40002cf8 <ring_buf_put_finish+0x40>
		return -EINVAL;
    40002d18:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40002d1c:	17fffffa 	b	40002d04 <ring_buf_put_finish+0x4c>

0000000040002d20 <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
    40002d20:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40002d24:	910003fd 	mov	x29, sp
    40002d28:	a90153f3 	stp	x19, x20, [sp, #16]
    40002d2c:	2a0203f4 	mov	w20, w2
    40002d30:	a9025bf5 	stp	x21, x22, [sp, #32]
    40002d34:	aa0103f5 	mov	x21, x1
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
    40002d38:	52800016 	mov	w22, #0x0                   	// #0
{
    40002d3c:	a90363f7 	stp	x23, x24, [sp, #48]
    40002d40:	aa0003f7 	mov	x23, x0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
    40002d44:	2a1403e2 	mov	w2, w20
    40002d48:	910123e1 	add	x1, sp, #0x48
    40002d4c:	aa1703e0 	mov	x0, x23
    40002d50:	97ffffc3 	bl	40002c5c <ring_buf_put_claim>
    40002d54:	2a0003f8 	mov	w24, w0
		memcpy(dst, data, partial_size);
    40002d58:	f94027e0 	ldr	x0, [sp, #72]
    40002d5c:	aa1503e1 	mov	x1, x21
    40002d60:	aa1803e2 	mov	x2, x24
		total_size += partial_size;
    40002d64:	0b1802d6 	add	w22, w22, w24
		size -= partial_size;
		data += partial_size;
    40002d68:	8b1802b5 	add	x21, x21, x24
		memcpy(dst, data, partial_size);
    40002d6c:	940017fd 	bl	40008d60 <memcpy>
	} while (size && partial_size);
    40002d70:	6b180294 	subs	w20, w20, w24
    40002d74:	7a401b04 	ccmp	w24, #0x0, #0x4, ne  // ne = any
    40002d78:	54fffe61 	b.ne	40002d44 <ring_buf_put+0x24>  // b.any

	err = ring_buf_put_finish(buf, total_size);
    40002d7c:	2a1603e1 	mov	w1, w22
    40002d80:	aa1703e0 	mov	x0, x23
    40002d84:	97ffffcd 	bl	40002cb8 <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
    40002d88:	2a1603e0 	mov	w0, w22
    40002d8c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002d90:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40002d94:	a94363f7 	ldp	x23, x24, [sp, #48]
    40002d98:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40002d9c:	d65f03c0 	ret

0000000040002da0 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
    40002da0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40002da4:	910003fd 	mov	x29, sp
    40002da8:	a90153f3 	stp	x19, x20, [sp, #16]
    40002dac:	aa0003f3 	mov	x19, x0
	uint32_t space, granted_size, trail_size, tmp_head_mod;
	uint32_t tail = buf->tail;
    40002db0:	b9400414 	ldr	w20, [x0, #4]

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
    40002db4:	b9400c00 	ldr	w0, [x0, #12]
{
    40002db8:	a9025bf5 	stp	x21, x22, [sp, #32]
    40002dbc:	aa0103f6 	mov	x22, x1
    40002dc0:	2a0203f5 	mov	w21, w2
    40002dc4:	f9001bf7 	str	x23, [sp, #48]
	if (tail < buf->misc.byte_mode.tmp_head) {
    40002dc8:	6b14001f 	cmp	w0, w20
    40002dcc:	540000a9 	b.ls	40002de0 <ring_buf_get_claim+0x40>  // b.plast
		/* Locally, increment it to pre-rewind value */
		tail += get_rewind_value(buf->size,
    40002dd0:	b9401277 	ldr	w23, [x19, #16]
    40002dd4:	97ffffa0 	bl	40002c54 <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
    40002dd8:	1ad70800 	udiv	w0, w0, w23
		tail += get_rewind_value(buf->size,
    40002ddc:	1b175014 	madd	w20, w0, w23, w20
					 ring_buf_get_rewind_threshold());
	}

	tmp_head_mod = mod(buf, buf->misc.byte_mode.tmp_head);
    40002de0:	b9402263 	ldr	w3, [x19, #32]
    40002de4:	29419265 	ldp	w5, w4, [x19, #12]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40002de8:	34000243 	cbz	w3, 40002e30 <ring_buf_get_claim+0x90>
    40002dec:	0a0300a3 	and	w3, w5, w3
	space = tail - buf->misc.byte_mode.tmp_head;
    40002df0:	4b050294 	sub	w20, w20, w5
	trail_size = buf->size - tmp_head_mod;
    40002df4:	4b030084 	sub	w4, w4, w3
	granted_size = MIN(size, space);

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);

	*data = &buf->buf.buf8[tmp_head_mod];
    40002df8:	f9400e61 	ldr	x1, [x19, #24]
	granted_size = MIN(size, space);
    40002dfc:	6b15029f 	cmp	w20, w21
    40002e00:	1a959280 	csel	w0, w20, w21, ls  // ls = plast
	granted_size = MIN(trail_size, granted_size);
    40002e04:	6b00009f 	cmp	w4, w0
    40002e08:	1a809080 	csel	w0, w4, w0, ls  // ls = plast
	*data = &buf->buf.buf8[tmp_head_mod];
    40002e0c:	8b234023 	add	x3, x1, w3, uxtw
	buf->misc.byte_mode.tmp_head += granted_size;

	return granted_size;
}
    40002e10:	f9401bf7 	ldr	x23, [sp, #48]
	*data = &buf->buf.buf8[tmp_head_mod];
    40002e14:	f90002c3 	str	x3, [x22]
	buf->misc.byte_mode.tmp_head += granted_size;
    40002e18:	0b0000a5 	add	w5, w5, w0
}
    40002e1c:	a9425bf5 	ldp	x21, x22, [sp, #32]
	buf->misc.byte_mode.tmp_head += granted_size;
    40002e20:	b9000e65 	str	w5, [x19, #12]
}
    40002e24:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002e28:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40002e2c:	d65f03c0 	ret
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40002e30:	1ac408a3 	udiv	w3, w5, w4
    40002e34:	1b049463 	msub	w3, w3, w4, w5
    40002e38:	17ffffee 	b	40002df0 <ring_buf_get_claim+0x50>

0000000040002e3c <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
    40002e3c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40002e40:	910003fd 	mov	x29, sp
    40002e44:	a90153f3 	stp	x19, x20, [sp, #16]
    40002e48:	aa0003f4 	mov	x20, x0
    40002e4c:	2a0103f3 	mov	w19, w1
    40002e50:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint32_t tail = buf->tail;
    40002e54:	b9400415 	ldr	w21, [x0, #4]
	uint32_t rew;

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
    40002e58:	b9400c00 	ldr	w0, [x0, #12]
    40002e5c:	6b15001f 	cmp	w0, w21
    40002e60:	54000249 	b.ls	40002ea8 <ring_buf_get_finish+0x6c>  // b.plast
		/* tail was rewinded. Locally, increment it to pre-rewind value */
		rew = get_rewind_value(buf->size,
    40002e64:	b9401296 	ldr	w22, [x20, #16]
    40002e68:	97ffff7b 	bl	40002c54 <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
    40002e6c:	1ad60800 	udiv	w0, w0, w22
    40002e70:	1b167c00 	mul	w0, w0, w22
				       ring_buf_get_rewind_threshold());
		tail += rew;
    40002e74:	0b0002b5 	add	w21, w21, w0
	} else {
		rew = 0;
	}

	if ((buf->head + size) > tail) {
    40002e78:	b9400281 	ldr	w1, [x20]
    40002e7c:	0b010261 	add	w1, w19, w1
    40002e80:	6b15003f 	cmp	w1, w21
    40002e84:	54000168 	b.hi	40002eb0 <ring_buf_get_finish+0x74>  // b.pmore
		return -EINVAL;
	}

	/* Include potential rewinding. */
	buf->head += (size - rew);
    40002e88:	4b000021 	sub	w1, w1, w0
	buf->misc.byte_mode.tmp_head = buf->head;

	return 0;
    40002e8c:	52800000 	mov	w0, #0x0                   	// #0
	buf->head += (size - rew);
    40002e90:	b9000281 	str	w1, [x20]
	buf->misc.byte_mode.tmp_head = buf->head;
    40002e94:	b9000e81 	str	w1, [x20, #12]
}
    40002e98:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002e9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40002ea0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40002ea4:	d65f03c0 	ret
		rew = 0;
    40002ea8:	52800000 	mov	w0, #0x0                   	// #0
    40002eac:	17fffff3 	b	40002e78 <ring_buf_get_finish+0x3c>
		return -EINVAL;
    40002eb0:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40002eb4:	17fffff9 	b	40002e98 <ring_buf_get_finish+0x5c>

0000000040002eb8 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
    40002eb8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40002ebc:	910003fd 	mov	x29, sp
    40002ec0:	a90153f3 	stp	x19, x20, [sp, #16]
    40002ec4:	2a0203f4 	mov	w20, w2
    40002ec8:	a9025bf5 	stp	x21, x22, [sp, #32]
    40002ecc:	aa0103f5 	mov	x21, x1
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
    40002ed0:	52800016 	mov	w22, #0x0                   	// #0
{
    40002ed4:	a90363f7 	stp	x23, x24, [sp, #48]
    40002ed8:	aa0003f7 	mov	x23, x0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
    40002edc:	2a1403e2 	mov	w2, w20
    40002ee0:	910123e1 	add	x1, sp, #0x48
    40002ee4:	aa1703e0 	mov	x0, x23
    40002ee8:	97ffffae 	bl	40002da0 <ring_buf_get_claim>
    40002eec:	2a0003f3 	mov	w19, w0
		if (data) {
    40002ef0:	b40000f5 	cbz	x21, 40002f0c <ring_buf_get+0x54>
			memcpy(data, src, partial_size);
    40002ef4:	f94027e1 	ldr	x1, [sp, #72]
    40002ef8:	2a0003f8 	mov	w24, w0
    40002efc:	aa1803e2 	mov	x2, x24
    40002f00:	aa1503e0 	mov	x0, x21
			data += partial_size;
    40002f04:	8b1802b5 	add	x21, x21, x24
			memcpy(data, src, partial_size);
    40002f08:	94001796 	bl	40008d60 <memcpy>
		}
		total_size += partial_size;
		size -= partial_size;
	} while (size && partial_size);
    40002f0c:	6b130294 	subs	w20, w20, w19
		total_size += partial_size;
    40002f10:	0b1302d6 	add	w22, w22, w19
	} while (size && partial_size);
    40002f14:	7a401a64 	ccmp	w19, #0x0, #0x4, ne  // ne = any
    40002f18:	54fffe21 	b.ne	40002edc <ring_buf_get+0x24>  // b.any

	err = ring_buf_get_finish(buf, total_size);
    40002f1c:	2a1603e1 	mov	w1, w22
    40002f20:	aa1703e0 	mov	x0, x23
    40002f24:	97ffffc6 	bl	40002e3c <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
    40002f28:	2a1603e0 	mov	w0, w22
    40002f2c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002f30:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40002f34:	a94363f7 	ldp	x23, x24, [sp, #48]
    40002f38:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40002f3c:	d65f03c0 	ret

0000000040002f40 <foldcase>:
#define EOS    '\0'

static inline int foldcase(int ch, int flags)
{

    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
    40002f40:	361800a1 	tbz	w1, #3, 40002f54 <foldcase+0x14>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    40002f44:	51010401 	sub	w1, w0, #0x41
    40002f48:	7100643f 	cmp	w1, #0x19
    40002f4c:	54000048 	b.hi	40002f54 <foldcase+0x14>  // b.pmore
			((ua | 32U) - (unsigned)'a' < 6U));
}

static inline int tolower(int chr)
{
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
    40002f50:	11008000 	add	w0, w0, #0x20
        return tolower(ch);
    return ch;
}
    40002f54:	d65f03c0 	ret

0000000040002f58 <fnmatchx>:
static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
    const char *stringstart, *r;
    char c, test;

    if ((pattern == NULL) || (string == NULL))
    40002f58:	f100001f 	cmp	x0, #0x0
    40002f5c:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
    40002f60:	54000061 	b.ne	40002f6c <fnmatchx+0x14>  // b.any
    {
        return FNM_NOMATCH;
    40002f64:	52800020 	mov	w0, #0x1                   	// #1
                return FNM_NOMATCH;
            break;
        }
    }
    /* NOTREACHED */
}
    40002f68:	d65f03c0 	ret
{
    40002f6c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40002f70:	910003fd 	mov	x29, sp
    40002f74:	a90153f3 	stp	x19, x20, [sp, #16]
    40002f78:	a9025bf5 	stp	x21, x22, [sp, #32]
    40002f7c:	a90363f7 	stp	x23, x24, [sp, #48]
    40002f80:	aa0303f7 	mov	x23, x3
    40002f84:	f90023f9 	str	x25, [sp, #64]
    if (recursion-- == 0)
    40002f88:	b40019c3 	cbz	x3, 400032c0 <fnmatchx+0x368>
    40002f8c:	aa0003e4 	mov	x4, x0
    40002f90:	aa0103f6 	mov	x22, x1
    40002f94:	2a0203f3 	mov	w19, w2
    40002f98:	aa0103f4 	mov	x20, x1
            if (*string == '.' && (flags & FNM_PERIOD) &&
    40002f9c:	121e0058 	and	w24, w2, #0x4
            ok = 1;
    40002fa0:	52800039 	mov	w25, #0x1                   	// #1
        switch (c = FOLDCASE(*pattern++, flags)) {
    40002fa4:	aa0403f5 	mov	x21, x4
    40002fa8:	2a1303e1 	mov	w1, w19
    40002fac:	384016a0 	ldrb	w0, [x21], #1
    40002fb0:	97ffffe4 	bl	40002f40 <foldcase>
    40002fb4:	2a0003e1 	mov	w1, w0
    40002fb8:	12001c02 	and	w2, w0, #0xff
    40002fbc:	12001c00 	and	w0, w0, #0xff
            if ((flags & FNM_LEADING_DIR) && *string == '/')
    40002fc0:	39400283 	ldrb	w3, [x20]
        switch (c = FOLDCASE(*pattern++, flags)) {
    40002fc4:	7100fc1f 	cmp	w0, #0x3f
    40002fc8:	540003e0 	b.eq	40003044 <fnmatchx+0xec>  // b.none
    40002fcc:	721a043f 	tst	w1, #0xc0
    40002fd0:	54000161 	b.ne	40002ffc <fnmatchx+0xa4>  // b.any
    40002fd4:	340002c0 	cbz	w0, 4000302c <fnmatchx+0xd4>
    40002fd8:	7100a81f 	cmp	w0, #0x2a
    40002fdc:	54000620 	b.eq	400030a0 <fnmatchx+0x148>  // b.none
            if (c != FOLDCASE(*string++, flags))
    40002fe0:	2a1303e1 	mov	w1, w19
    40002fe4:	2a0303e0 	mov	w0, w3
    40002fe8:	91000694 	add	x20, x20, #0x1
    40002fec:	97ffffd5 	bl	40002f40 <foldcase>
    40002ff0:	6b00005f 	cmp	w2, w0
    40002ff4:	54000520 	b.eq	40003098 <fnmatchx+0x140>  // b.none
    40002ff8:	14000017 	b	40003054 <fnmatchx+0xfc>
        switch (c = FOLDCASE(*pattern++, flags)) {
    40002ffc:	71016c1f 	cmp	w0, #0x5b
    40003000:	54000be0 	b.eq	4000317c <fnmatchx+0x224>  // b.none
    40003004:	7101701f 	cmp	w0, #0x5c
    40003008:	54fffec1 	b.ne	40002fe0 <fnmatchx+0x88>  // b.any
            if (!(flags & FNM_NOESCAPE)) {
    4000300c:	3707feb3 	tbnz	w19, #0, 40002fe0 <fnmatchx+0x88>
                if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
    40003010:	39400480 	ldrb	w0, [x4, #1]
    40003014:	2a1303e1 	mov	w1, w19
    40003018:	97ffffca 	bl	40002f40 <foldcase>
    4000301c:	72001c02 	ands	w2, w0, #0xff
    40003020:	54fffe00 	b.eq	40002fe0 <fnmatchx+0x88>  // b.none
    40003024:	91000895 	add	x21, x4, #0x2
    40003028:	17ffffee 	b	40002fe0 <fnmatchx+0x88>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
    4000302c:	36200073 	tbz	w19, #4, 40003038 <fnmatchx+0xe0>
    40003030:	7100bc7f 	cmp	w3, #0x2f
    40003034:	54000120 	b.eq	40003058 <fnmatchx+0x100>  // b.none
            return *string == EOS ? 0 : FNM_NOMATCH;
    40003038:	7100007f 	cmp	w3, #0x0
                        0 : FNM_NOMATCH;
    4000303c:	1a9f07e0 	cset	w0, ne  // ne = any
    40003040:	14000006 	b	40003058 <fnmatchx+0x100>
            if (*string == EOS)
    40003044:	34000083 	cbz	w3, 40003054 <fnmatchx+0xfc>
            if (*string == '/' && (flags & FNM_PATHNAME))
    40003048:	7100bc7f 	cmp	w3, #0x2f
    4000304c:	54000121 	b.ne	40003070 <fnmatchx+0x118>  // b.any
    40003050:	36080233 	tbz	w19, #1, 40003094 <fnmatchx+0x13c>
        return FNM_NOMATCH;
    40003054:	52800020 	mov	w0, #0x1                   	// #1
}
    40003058:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000305c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003060:	a94363f7 	ldp	x23, x24, [sp, #48]
    40003064:	f94023f9 	ldr	x25, [sp, #64]
    40003068:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4000306c:	d65f03c0 	ret
            if (*string == '.' && (flags & FNM_PERIOD) &&
    40003070:	7100b87f 	cmp	w3, #0x2e
    40003074:	54000101 	b.ne	40003094 <fnmatchx+0x13c>  // b.any
    40003078:	340000f8 	cbz	w24, 40003094 <fnmatchx+0x13c>
    4000307c:	eb16029f 	cmp	x20, x22
    40003080:	54fffea0 	b.eq	40003054 <fnmatchx+0xfc>  // b.none
                (string == stringstart ||
    40003084:	36080093 	tbz	w19, #1, 40003094 <fnmatchx+0x13c>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
    40003088:	385ff280 	ldurb	w0, [x20, #-1]
    4000308c:	7100bc1f 	cmp	w0, #0x2f
    40003090:	54fffe20 	b.eq	40003054 <fnmatchx+0xfc>  // b.none
            ++string;
    40003094:	91000694 	add	x20, x20, #0x1
            break;
    40003098:	aa1503e4 	mov	x4, x21
    4000309c:	17ffffc2 	b	40002fa4 <fnmatchx+0x4c>
            c = FOLDCASE(*pattern, flags);
    400030a0:	39400480 	ldrb	w0, [x4, #1]
    400030a4:	2a1303e1 	mov	w1, w19
                c = FOLDCASE(*++pattern, flags);
    400030a8:	97ffffa6 	bl	40002f40 <foldcase>
    400030ac:	12001c01 	and	w1, w0, #0xff
            while (c == '*')
    400030b0:	7100a83f 	cmp	w1, #0x2a
    400030b4:	54000260 	b.eq	40003100 <fnmatchx+0x1a8>  // b.none
            if (*string == '.' && (flags & FNM_PERIOD) &&
    400030b8:	7100b87f 	cmp	w3, #0x2e
    400030bc:	54000101 	b.ne	400030dc <fnmatchx+0x184>  // b.any
    400030c0:	340000f8 	cbz	w24, 400030dc <fnmatchx+0x184>
    400030c4:	eb16029f 	cmp	x20, x22
    400030c8:	54fffc60 	b.eq	40003054 <fnmatchx+0xfc>  // b.none
                (string == stringstart ||
    400030cc:	36080093 	tbz	w19, #1, 400030dc <fnmatchx+0x184>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
    400030d0:	385ff280 	ldurb	w0, [x20, #-1]
    400030d4:	7100bc1f 	cmp	w0, #0x2f
    400030d8:	54fffbe0 	b.eq	40003054 <fnmatchx+0xfc>  // b.none
            if (c == EOS) {
    400030dc:	35000181 	cbnz	w1, 4000310c <fnmatchx+0x1b4>
                if (flags & FNM_PATHNAME)
    400030e0:	121f0260 	and	w0, w19, #0x2
    400030e4:	360ffbb3 	tbz	w19, #1, 40003058 <fnmatchx+0x100>
                        0 : FNM_NOMATCH;
    400030e8:	37200f13 	tbnz	w19, #4, 400032c8 <fnmatchx+0x370>
                        strchr(string, '/') == NULL ?
    400030ec:	aa1403e0 	mov	x0, x20
    400030f0:	528005e1 	mov	w1, #0x2f                  	// #47
    400030f4:	940016ce 	bl	40008c2c <strchr>
                        0 : FNM_NOMATCH;
    400030f8:	f100001f 	cmp	x0, #0x0
    400030fc:	17ffffd0 	b	4000303c <fnmatchx+0xe4>
                c = FOLDCASE(*++pattern, flags);
    40003100:	38401ea0 	ldrb	w0, [x21, #1]!
    40003104:	2a1303e1 	mov	w1, w19
    40003108:	17ffffe8 	b	400030a8 <fnmatchx+0x150>
            } else if (c == '/' && flags & FNM_PATHNAME) {
    4000310c:	7100bc3f 	cmp	w1, #0x2f
    40003110:	540002a0 	b.eq	40003164 <fnmatchx+0x20c>  // b.none
    if (recursion-- == 0)
    40003114:	d10006f7 	sub	x23, x23, #0x1
                switch ((e = fnmatchx(pattern, string,
    40003118:	121d7a78 	and	w24, w19, #0xfffffffb
                if (test == '/' && flags & FNM_PATHNAME)
    4000311c:	121f0279 	and	w25, w19, #0x2
            while ((test = FOLDCASE(*string, flags)) != EOS) {
    40003120:	39400280 	ldrb	w0, [x20]
    40003124:	2a1303e1 	mov	w1, w19
    40003128:	97ffff86 	bl	40002f40 <foldcase>
    4000312c:	72001c16 	ands	w22, w0, #0xff
    40003130:	54fff920 	b.eq	40003054 <fnmatchx+0xfc>  // b.none
                switch ((e = fnmatchx(pattern, string,
    40003134:	aa1703e3 	mov	x3, x23
    40003138:	2a1803e2 	mov	w2, w24
    4000313c:	aa1403e1 	mov	x1, x20
    40003140:	aa1503e0 	mov	x0, x21
    40003144:	97ffff85 	bl	40002f58 <fnmatchx>
    40003148:	7100041f 	cmp	w0, #0x1
    4000314c:	54fff861 	b.ne	40003058 <fnmatchx+0x100>  // b.any
                if (test == '/' && flags & FNM_PATHNAME)
    40003150:	7100bedf 	cmp	w22, #0x2f
    40003154:	54000041 	b.ne	4000315c <fnmatchx+0x204>  // b.any
    40003158:	35fff7f9 	cbnz	w25, 40003054 <fnmatchx+0xfc>
                ++string;
    4000315c:	91000694 	add	x20, x20, #0x1
    40003160:	17fffff0 	b	40003120 <fnmatchx+0x1c8>
            } else if (c == '/' && flags & FNM_PATHNAME) {
    40003164:	360ffd93 	tbz	w19, #1, 40003114 <fnmatchx+0x1bc>
                if ((string = strchr(string, '/')) == NULL)
    40003168:	aa1403e0 	mov	x0, x20
    4000316c:	940016b0 	bl	40008c2c <strchr>
    40003170:	aa0003f4 	mov	x20, x0
    40003174:	b5fff920 	cbnz	x0, 40003098 <fnmatchx+0x140>
    40003178:	17ffffb7 	b	40003054 <fnmatchx+0xfc>
            if (*string == EOS)
    4000317c:	34fff6c3 	cbz	w3, 40003054 <fnmatchx+0xfc>
            if (*string == '/' && flags & FNM_PATHNAME)
    40003180:	7100bc7f 	cmp	w3, #0x2f
    40003184:	54000041 	b.ne	4000318c <fnmatchx+0x234>  // b.any
    40003188:	370ff673 	tbnz	w19, #1, 40003054 <fnmatchx+0xfc>
            if ((r = rangematch(pattern,
    4000318c:	2a1303e1 	mov	w1, w19
    40003190:	2a0303e0 	mov	w0, w3
    40003194:	97ffff6b 	bl	40002f40 <foldcase>
    40003198:	2a0003e7 	mov	w7, w0
    if (pattern == NULL)
    4000319c:	b4fff5d5 	cbz	x21, 40003054 <fnmatchx+0xfc>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    400031a0:	39400480 	ldrb	w0, [x4, #1]
        ++pattern;
    400031a4:	91000884 	add	x4, x4, #0x2
            ok = 1;
    400031a8:	52800029 	mov	w9, #0x1                   	// #1
        if (c == '\\' && !(flags & FNM_NOESCAPE))
    400031ac:	0a09026a 	and	w10, w19, w9
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    400031b0:	7100841f 	cmp	w0, #0x21
            ok = 1;
    400031b4:	52800006 	mov	w6, #0x0                   	// #0
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    400031b8:	1a9f17e8 	cset	w8, eq  // eq = none
    400031bc:	7101781f 	cmp	w0, #0x5e
    400031c0:	1a9f17e0 	cset	w0, eq  // eq = none
    400031c4:	2a000108 	orr	w8, w8, w0
        ++pattern;
    400031c8:	7100011f 	cmp	w8, #0x0
    400031cc:	9a951084 	csel	x4, x4, x21, ne  // ne = any
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
    400031d0:	aa0403e2 	mov	x2, x4
    400031d4:	2a1303e1 	mov	w1, w19
    400031d8:	38401440 	ldrb	w0, [x2], #1
    400031dc:	97ffff59 	bl	40002f40 <foldcase>
    400031e0:	12001c05 	and	w5, w0, #0xff
    400031e4:	710174bf 	cmp	w5, #0x5d
    400031e8:	540001a1 	b.ne	4000321c <fnmatchx+0x2c4>  // b.any
    400031ec:	350002e9 	cbnz	w9, 40003248 <fnmatchx+0x2f0>
    return ok == negate ? NULL : pattern;
    400031f0:	6b06011f 	cmp	w8, w6
    400031f4:	54fff300 	b.eq	40003054 <fnmatchx+0xfc>  // b.none
            if ((r = rangematch(pattern,
    400031f8:	b4fff2e2 	cbz	x2, 40003054 <fnmatchx+0xfc>
            if (r == (void *)-1) {
    400031fc:	b100045f 	cmn	x2, #0x1
    40003200:	54000081 	b.ne	40003210 <fnmatchx+0x2b8>  // b.any
                if (*string != '[')
    40003204:	71016c7f 	cmp	w3, #0x5b
    40003208:	54fff261 	b.ne	40003054 <fnmatchx+0xfc>  // b.any
    4000320c:	aa1503e2 	mov	x2, x21
            ++string;
    40003210:	91000694 	add	x20, x20, #0x1
            break;
    40003214:	aa0203f5 	mov	x21, x2
    40003218:	17ffffa0 	b	40003098 <fnmatchx+0x140>
        if (c == '/')
    4000321c:	7100bcbf 	cmp	w5, #0x2f
    40003220:	54ffff20 	b.eq	40003204 <fnmatchx+0x2ac>  // b.none
        if (c == '\\' && !(flags & FNM_NOESCAPE))
    40003224:	710170bf 	cmp	w5, #0x5c
    40003228:	540000e1 	b.ne	40003244 <fnmatchx+0x2ec>  // b.any
    4000322c:	350000ea 	cbnz	w10, 40003248 <fnmatchx+0x2f0>
            c = FOLDCASE(*pattern++, flags);
    40003230:	39400480 	ldrb	w0, [x4, #1]
    40003234:	2a1303e1 	mov	w1, w19
    40003238:	91000882 	add	x2, x4, #0x2
    4000323c:	97ffff41 	bl	40002f40 <foldcase>
    40003240:	12001c05 	and	w5, w0, #0xff
        if (c == EOS)
    40003244:	34fff085 	cbz	w5, 40003054 <fnmatchx+0xfc>
        if (*pattern == '-' 
    40003248:	39400040 	ldrb	w0, [x2]
    4000324c:	7100b41f 	cmp	w0, #0x2d
    40003250:	54000301 	b.ne	400032b0 <fnmatchx+0x358>  // b.any
            && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
    40003254:	39400440 	ldrb	w0, [x2, #1]
    40003258:	2a1303e1 	mov	w1, w19
    4000325c:	97ffff39 	bl	40002f40 <foldcase>
    40003260:	72001c01 	ands	w1, w0, #0xff
    40003264:	54000260 	b.eq	400032b0 <fnmatchx+0x358>  // b.none
    40003268:	7101743f 	cmp	w1, #0x5d
    4000326c:	54000220 	b.eq	400032b0 <fnmatchx+0x358>  // b.none
            pattern += 2;
    40003270:	91000844 	add	x4, x2, #0x2
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
    40003274:	7101703f 	cmp	w1, #0x5c
    40003278:	54000101 	b.ne	40003298 <fnmatchx+0x340>  // b.any
    4000327c:	350000ea 	cbnz	w10, 40003298 <fnmatchx+0x340>
                c2 = FOLDCASE(*pattern++, flags);
    40003280:	39400840 	ldrb	w0, [x2, #2]
    40003284:	2a1303e1 	mov	w1, w19
    40003288:	91000c44 	add	x4, x2, #0x3
    4000328c:	97ffff2d 	bl	40002f40 <foldcase>
            if (c2 == EOS)
    40003290:	72001c01 	ands	w1, w0, #0xff
    40003294:	54ffee00 	b.eq	40003054 <fnmatchx+0xfc>  // b.none
            if (c <= test && test <= c2)
    40003298:	6b0500ff 	cmp	w7, w5
    4000329c:	5400006b 	b.lt	400032a8 <fnmatchx+0x350>  // b.tstop
                ok = 1;
    400032a0:	6b0100ff 	cmp	w7, w1
    400032a4:	1a99c0c6 	csel	w6, w6, w25, gt
            ok = 1;
    400032a8:	52800009 	mov	w9, #0x0                   	// #0
    400032ac:	17ffffc9 	b	400031d0 <fnmatchx+0x278>
        } else if (c == test)
    400032b0:	6b0500ff 	cmp	w7, w5
    400032b4:	aa0203e4 	mov	x4, x2
    400032b8:	1a9910c6 	csel	w6, w6, w25, ne  // ne = any
    400032bc:	17fffffb 	b	400032a8 <fnmatchx+0x350>
        return FNM_NORES;
    400032c0:	52800060 	mov	w0, #0x3                   	// #3
    400032c4:	17ffff65 	b	40003058 <fnmatchx+0x100>
                return 0;
    400032c8:	52800000 	mov	w0, #0x0                   	// #0
    400032cc:	17ffff63 	b	40003058 <fnmatchx+0x100>

00000000400032d0 <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
    return fnmatchx(pattern, string, flags, 64);
    400032d0:	d2800803 	mov	x3, #0x40                  	// #64
    400032d4:	17ffff21 	b	40002f58 <fnmatchx>

00000000400032d8 <getopt_init>:
#define	BADARG	((int)':')
#define	EMSG	""

void getopt_init(struct getopt_state *state)
{
	state->opterr = 1;
    400032d8:	b20003e1 	mov	x1, #0x100000001           	// #4294967297
	state->optind = 1;
	state->optopt = 0;
    400032dc:	a9007c01 	stp	x1, xzr, [x0]
	state->optreset = 0;
	state->optarg = NULL;

	state->place = ""; /* EMSG */
    400032e0:	f0000041 	adrp	x1, 4000e000 <mmu_regions+0x38>
    400032e4:	91317821 	add	x1, x1, #0xc5e
	state->optarg = NULL;
    400032e8:	f900081f 	str	xzr, [x0, #16]
	state->place = ""; /* EMSG */
    400032ec:	f9000c01 	str	x1, [x0, #24]
}
    400032f0:	d65f03c0 	ret

00000000400032f4 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    400032f4:	d65f03c0 	ret

00000000400032f8 <z_arm64_el3_plat_init>:
	uint64_t reg = 0;

	reg = (ICC_SRE_ELx_DFB_BIT | ICC_SRE_ELx_DIB_BIT |
	       ICC_SRE_ELx_SRE_BIT | ICC_SRE_EL3_EN_BIT);

	write_sysreg(reg, ICC_SRE_EL3);
    400032f8:	d28001e0 	mov	x0, #0xf                   	// #15
    400032fc:	d51ecca0 	msr	s3_6_c12_c12_5, x0
}
    40003300:	d65f03c0 	ret

0000000040003304 <cmd_kernel_version>:
#include <drivers/timer/system_timer.h>
#include <kernel.h>

static int cmd_kernel_version(const struct shell *shell,
			      size_t argc, char **argv)
{
    40003304:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003308:	910003fd 	mov	x29, sp
    4000330c:	f9000bf3 	str	x19, [sp, #16]
    40003310:	aa0003f3 	mov	x19, x0
	uint32_t version = sys_kernel_version_get();
    40003314:	94001b81 	bl	4000a118 <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Zephyr version %d.%d.%d",
    40003318:	d3483c05 	ubfx	x5, x0, #8, #8
    4000331c:	d3505c04 	ubfx	x4, x0, #16, #8
    40003320:	53187c03 	lsr	w3, w0, #24
    40003324:	52800101 	mov	w1, #0x8                   	// #8
    40003328:	aa1303e0 	mov	x0, x19
    4000332c:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003330:	912c4042 	add	x2, x2, #0xb10
    40003334:	94000907 	bl	40005750 <shell_fprintf>
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
    40003338:	52800000 	mov	w0, #0x0                   	// #0
    4000333c:	f9400bf3 	ldr	x19, [sp, #16]
    40003340:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003344:	d65f03c0 	ret

0000000040003348 <cmd_kernel_uptime>:

static int cmd_kernel_uptime(const struct shell *shell,
			     size_t argc, char **argv)
{
    40003348:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000334c:	910003fd 	mov	x29, sp
    40003350:	f9000bf3 	str	x19, [sp, #16]
    40003354:	aa0003f3 	mov	x19, x0
		/* coverity[OVERRUN] */
		return (int64_t) arch_syscall_invoke0(K_SYSCALL_K_UPTIME_TICKS);
	}
#endif
	compiler_barrier();
	return z_impl_k_uptime_ticks();
    40003358:	94002009 	bl	4000b37c <z_impl_k_uptime_ticks>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Uptime: %u ms", k_uptime_get_32());
    4000335c:	d2800143 	mov	x3, #0xa                   	// #10
    40003360:	52800101 	mov	w1, #0x8                   	// #8
    40003364:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003368:	912ca442 	add	x2, x2, #0xb29
    4000336c:	1b037c03 	mul	w3, w0, w3
    40003370:	aa1303e0 	mov	x0, x19
    40003374:	940008f7 	bl	40005750 <shell_fprintf>
	return 0;
}
    40003378:	52800000 	mov	w0, #0x0                   	// #0
    4000337c:	f9400bf3 	ldr	x19, [sp, #16]
    40003380:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003384:	d65f03c0 	ret

0000000040003388 <cmd_kernel_threads>:

}

static int cmd_kernel_threads(const struct shell *shell,
			      size_t argc, char **argv)
{
    40003388:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000338c:	910003fd 	mov	x29, sp
    40003390:	f9000bf3 	str	x19, [sp, #16]
    40003394:	aa0003f3 	mov	x19, x0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Scheduler: %u since last call", sys_clock_elapsed());
    40003398:	94001920 	bl	40009818 <sys_clock_elapsed>
    4000339c:	2a0003e3 	mov	w3, w0
    400033a0:	52800101 	mov	w1, #0x8                   	// #8
    400033a4:	aa1303e0 	mov	x0, x19
    400033a8:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400033ac:	912ce042 	add	x2, x2, #0xb38
    400033b0:	940008e8 	bl	40005750 <shell_fprintf>
	shell_print(shell, "Threads:");
    400033b4:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400033b8:	912d5c42 	add	x2, x2, #0xb57
    400033bc:	aa1303e0 	mov	x0, x19
    400033c0:	52800101 	mov	w1, #0x8                   	// #8
    400033c4:	940008e3 	bl	40005750 <shell_fprintf>
	k_thread_foreach(shell_tdata_dump, (void *)shell);
    400033c8:	aa1303e1 	mov	x1, x19
    400033cc:	90000000 	adrp	x0, 40003000 <fnmatchx+0xa8>
    400033d0:	9111d000 	add	x0, x0, #0x474
    400033d4:	94001a3f 	bl	40009cd0 <k_thread_foreach>
	return 0;
}
    400033d8:	52800000 	mov	w0, #0x0                   	// #0
    400033dc:	f9400bf3 	ldr	x19, [sp, #16]
    400033e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400033e4:	d65f03c0 	ret

00000000400033e8 <cmd_kernel_stacks>:
extern K_KERNEL_STACK_ARRAY_DEFINE(z_interrupt_stacks, CONFIG_MP_NUM_CPUS,
				   CONFIG_ISR_STACK_SIZE);

static int cmd_kernel_stacks(const struct shell *shell,
			     size_t argc, char **argv)
{
    400033e8:	d100c3ff 	sub	sp, sp, #0x30
	uint8_t *buf;
	size_t size, unused;

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	k_thread_foreach(shell_stack_dump, (void *)shell);
    400033ec:	aa0003e1 	mov	x1, x0
{
    400033f0:	a9017bfd 	stp	x29, x30, [sp, #16]
    400033f4:	910043fd 	add	x29, sp, #0x10
    400033f8:	f90013f3 	str	x19, [sp, #32]
    400033fc:	aa0003f3 	mov	x19, x0
	k_thread_foreach(shell_stack_dump, (void *)shell);
    40003400:	90000000 	adrp	x0, 40003000 <fnmatchx+0xa8>
    40003404:	91172000 	add	x0, x0, #0x5c8
    40003408:	94001a32 	bl	40009cd0 <k_thread_foreach>
		buf = Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]);
		size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]);

		unused = 0;
		for (size_t i = 0; i < size; i++) {
			if (buf[i] == 0xAAU) {
    4000340c:	b0000303 	adrp	x3, 40064000 <z_idle_stacks+0x3d0>
    40003410:	9130c063 	add	x3, x3, #0xc30
		unused = 0;
    40003414:	d2800006 	mov	x6, #0x0                   	// #0
			if (buf[i] == 0xAAU) {
    40003418:	386368c0 	ldrb	w0, [x6, x3]
    4000341c:	7102a81f 	cmp	w0, #0xaa
    40003420:	54000081 	b.ne	40003430 <cmd_kernel_stacks+0x48>  // b.any
				unused++;
    40003424:	910004c6 	add	x6, x6, #0x1
		for (size_t i = 0; i < size; i++) {
    40003428:	f14004df 	cmp	x6, #0x1, lsl #12
    4000342c:	54ffff61 	b.ne	40003418 <cmd_kernel_stacks+0x30>  // b.any
			} else {
				break;
			}
		}

		shell_print(shell,
    40003430:	d2820005 	mov	x5, #0x1000                	// #4096
    40003434:	cb0600a7 	sub	x7, x5, x6
    40003438:	d2800c82 	mov	x2, #0x64                  	// #100
    4000343c:	aa1303e0 	mov	x0, x19
    40003440:	52800004 	mov	w4, #0x0                   	// #0
    40003444:	52800101 	mov	w1, #0x8                   	// #8
    40003448:	9b027ce2 	mul	x2, x7, x2
    4000344c:	d34cfc42 	lsr	x2, x2, #12
    40003450:	a9000be5 	stp	x5, x2, [sp]
    40003454:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003458:	912d8442 	add	x2, x2, #0xb61
    4000345c:	940008bd 	bl	40005750 <shell_fprintf>
			      size - unused, size,
			      ((size - unused) * 100U) / size);
	}

	return 0;
}
    40003460:	52800000 	mov	w0, #0x0                   	// #0
    40003464:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40003468:	f94013f3 	ldr	x19, [sp, #32]
    4000346c:	9100c3ff 	add	sp, sp, #0x30
    40003470:	d65f03c0 	ret

0000000040003474 <shell_tdata_dump>:
{
    40003474:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40003478:	910003fd 	mov	x29, sp
    4000347c:	a90153f3 	stp	x19, x20, [sp, #16]
    40003480:	aa0003f3 	mov	x19, x0
    40003484:	aa0103f4 	mov	x20, x1
    40003488:	a9025bf5 	stp	x21, x22, [sp, #32]
	size_t size = thread->stack_info.size;
    4000348c:	f9409416 	ldr	x22, [x0, #296]
	tname = k_thread_name_get(thread);
    40003490:	94001a50 	bl	40009dd0 <k_thread_name_get>
    40003494:	aa0003f5 	mov	x21, x0
	return z_impl_z_current_get();
    40003498:	94001e63 	bl	4000ae24 <z_impl_z_current_get>
	shell_print(shell, "%s%p %-10s",
    4000349c:	eb00027f 	cmp	x19, x0
    400034a0:	90000063 	adrp	x3, 4000f000 <cfg_flags.0+0x5ac>
    400034a4:	f0000041 	adrp	x1, 4000e000 <mmu_regions+0x38>
    400034a8:	91033860 	add	x0, x3, #0xce
    400034ac:	912e9c23 	add	x3, x1, #0xba7
    400034b0:	9a800063 	csel	x3, x3, x0, eq  // eq = none
    400034b4:	b5000075 	cbnz	x21, 400034c0 <shell_tdata_dump+0x4c>
    400034b8:	f0000055 	adrp	x21, 4000e000 <mmu_regions+0x38>
    400034bc:	912ea6b5 	add	x21, x21, #0xba9
    400034c0:	aa1503e5 	mov	x5, x21
    400034c4:	aa1303e4 	mov	x4, x19
    400034c8:	aa1403e0 	mov	x0, x20
    400034cc:	52800101 	mov	w1, #0x8                   	// #8
    400034d0:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400034d4:	912eb042 	add	x2, x2, #0xbac
    400034d8:	9400089e 	bl	40005750 <shell_fprintf>
	shell_print(shell, "\toptions: 0x%x, priority: %d timeout: %" PRId64,
    400034dc:	39c06a64 	ldrsb	w4, [x19, #26]
    400034e0:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400034e4:	912ee042 	add	x2, x2, #0xbb8
    400034e8:	39406263 	ldrb	w3, [x19, #24]
    400034ec:	f9402265 	ldr	x5, [x19, #64]
    400034f0:	52800101 	mov	w1, #0x8                   	// #8
    400034f4:	aa1403e0 	mov	x0, x20
    400034f8:	94000896 	bl	40005750 <shell_fprintf>
	shell_print(shell, "\tstate: %s, entry: %p", k_thread_state_str(thread),
    400034fc:	aa1303e0 	mov	x0, x19
    40003500:	94001a36 	bl	40009dd8 <k_thread_state_str>
    40003504:	f9406a64 	ldr	x4, [x19, #208]
    40003508:	aa0003e3 	mov	x3, x0
    4000350c:	52800101 	mov	w1, #0x8                   	// #8
    40003510:	aa1403e0 	mov	x0, x20
    40003514:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003518:	912f9042 	add	x2, x2, #0xbe4
    4000351c:	9400088d 	bl	40005750 <shell_fprintf>
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
    40003520:	9100e3e1 	add	x1, sp, #0x38
    40003524:	aa1303e0 	mov	x0, x19
    40003528:	94001af0 	bl	4000a0e8 <z_impl_k_thread_stack_space_get>
    4000352c:	2a0003e3 	mov	w3, w0
	if (ret) {
    40003530:	34000140 	cbz	w0, 40003558 <shell_tdata_dump+0xe4>
		shell_print(shell,
    40003534:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003538:	912fec42 	add	x2, x2, #0xbfb
    4000353c:	aa1403e0 	mov	x0, x20
    40003540:	52800101 	mov	w1, #0x8                   	// #8
    40003544:	94000883 	bl	40005750 <shell_fprintf>
}
    40003548:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000354c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003550:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40003554:	d65f03c0 	ret
		pcnt = ((size - unused) * 100U) / size;
    40003558:	f9401fe4 	ldr	x4, [sp, #56]
    4000355c:	d2800c87 	mov	x7, #0x64                  	// #100
		shell_print(shell,
    40003560:	aa1603e6 	mov	x6, x22
    40003564:	aa1603e3 	mov	x3, x22
		pcnt = ((size - unused) * 100U) / size;
    40003568:	cb0402c5 	sub	x5, x22, x4
		shell_print(shell,
    4000356c:	aa1403e0 	mov	x0, x20
    40003570:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003574:	9130a042 	add	x2, x2, #0xc28
    40003578:	52800101 	mov	w1, #0x8                   	// #8
		pcnt = ((size - unused) * 100U) / size;
    4000357c:	9b077ca7 	mul	x7, x5, x7
		shell_print(shell,
    40003580:	9ad608e7 	udiv	x7, x7, x22
    40003584:	94000873 	bl	40005750 <shell_fprintf>
}
    40003588:	17fffff0 	b	40003548 <shell_tdata_dump+0xd4>

000000004000358c <cmd_kernel_cycles>:
{
    4000358c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003590:	910003fd 	mov	x29, sp
    40003594:	f9000bf3 	str	x19, [sp, #16]
    40003598:	aa0003f3 	mov	x19, x0
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
    4000359c:	940018ab 	bl	40009848 <sys_clock_cycle_get_32>
	shell_print(shell, "cycles: %u hw cycles", k_cycle_get_32());
    400035a0:	2a0003e3 	mov	w3, w0
    400035a4:	52800101 	mov	w1, #0x8                   	// #8
    400035a8:	aa1303e0 	mov	x0, x19
    400035ac:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400035b0:	91317c42 	add	x2, x2, #0xc5f
    400035b4:	94000867 	bl	40005750 <shell_fprintf>
}
    400035b8:	52800000 	mov	w0, #0x0                   	// #0
    400035bc:	f9400bf3 	ldr	x19, [sp, #16]
    400035c0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400035c4:	d65f03c0 	ret

00000000400035c8 <shell_stack_dump>:
{
    400035c8:	d10143ff 	sub	sp, sp, #0x50
    400035cc:	a9017bfd 	stp	x29, x30, [sp, #16]
    400035d0:	910043fd 	add	x29, sp, #0x10
    400035d4:	a90253f3 	stp	x19, x20, [sp, #32]
    400035d8:	aa0003f3 	mov	x19, x0
    400035dc:	aa0103f4 	mov	x20, x1
    400035e0:	f9001bf5 	str	x21, [sp, #48]
	size_t size = thread->stack_info.size;
    400035e4:	f9409415 	ldr	x21, [x0, #296]
    400035e8:	910123e1 	add	x1, sp, #0x48
    400035ec:	94001abf 	bl	4000a0e8 <z_impl_k_thread_stack_space_get>
	if (ret) {
    400035f0:	34000180 	cbz	w0, 40003620 <shell_stack_dump+0x58>
    400035f4:	2a0003e3 	mov	w3, w0
		shell_print(shell,
    400035f8:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400035fc:	912fec42 	add	x2, x2, #0xbfb
    40003600:	aa1403e0 	mov	x0, x20
    40003604:	52800101 	mov	w1, #0x8                   	// #8
    40003608:	94000852 	bl	40005750 <shell_fprintf>
}
    4000360c:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40003610:	a94253f3 	ldp	x19, x20, [sp, #32]
    40003614:	f9401bf5 	ldr	x21, [sp, #48]
    40003618:	910143ff 	add	sp, sp, #0x50
    4000361c:	d65f03c0 	ret
	tname = k_thread_name_get((struct k_thread *)thread);
    40003620:	aa1303e0 	mov	x0, x19
    40003624:	940019eb 	bl	40009dd0 <k_thread_name_get>
	pcnt = ((size - unused) * 100U) / size;
    40003628:	f94027e6 	ldr	x6, [sp, #72]
    4000362c:	d2800c82 	mov	x2, #0x64                  	// #100
	tname = k_thread_name_get((struct k_thread *)thread);
    40003630:	aa0003e4 	mov	x4, x0
	pcnt = ((size - unused) * 100U) / size;
    40003634:	cb0602a7 	sub	x7, x21, x6
    40003638:	9b027ce2 	mul	x2, x7, x2
    4000363c:	9ad50842 	udiv	x2, x2, x21
	shell_print((const struct shell *)user_data,
    40003640:	b5000060 	cbnz	x0, 4000364c <shell_stack_dump+0x84>
    40003644:	f0000044 	adrp	x4, 4000e000 <mmu_regions+0x38>
    40003648:	912ea484 	add	x4, x4, #0xba9
    4000364c:	f90003f5 	str	x21, [sp]
    40003650:	aa1503e5 	mov	x5, x21
    40003654:	b9000be2 	str	w2, [sp, #8]
    40003658:	aa1303e3 	mov	x3, x19
    4000365c:	aa1403e0 	mov	x0, x20
    40003660:	52800101 	mov	w1, #0x8                   	// #8
    40003664:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003668:	9131d442 	add	x2, x2, #0xc75
    4000366c:	94000839 	bl	40005750 <shell_fprintf>
    40003670:	17ffffe7 	b	4000360c <shell_stack_dump+0x44>

0000000040003674 <get_device_name>:
};

static const char *get_device_name(const struct device *dev,
				   char *buf,
				   size_t len)
{
    40003674:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003678:	aa0003e3 	mov	x3, x0
    4000367c:	910003fd 	mov	x29, sp
	const char *name = dev->name;
    40003680:	f9400000 	ldr	x0, [x0]
{
    40003684:	f9000bf3 	str	x19, [sp, #16]
    40003688:	aa0103f3 	mov	x19, x1
    4000368c:	aa0203e1 	mov	x1, x2

	if ((name == NULL) || (name[0] == 0)) {
    40003690:	b4000060 	cbz	x0, 4000369c <get_device_name+0x28>
    40003694:	39400002 	ldrb	w2, [x0]
    40003698:	350000c2 	cbnz	w2, 400036b0 <get_device_name+0x3c>
		snprintf(buf, len, "[%p]", dev);
    4000369c:	aa1303e0 	mov	x0, x19
    400036a0:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400036a4:	91353042 	add	x2, x2, #0xd4c
    400036a8:	940015d0 	bl	40008de8 <snprintf>
		name = buf;
    400036ac:	aa1303e0 	mov	x0, x19
	}

	return name;
}
    400036b0:	f9400bf3 	ldr	x19, [sp, #16]
    400036b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400036b8:	d65f03c0 	ret

00000000400036bc <cmd_device_list_visitor>:
	size_t buf_size;
};

static int cmd_device_list_visitor(const struct device *dev,
				   void *context)
{
    400036bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400036c0:	910003fd 	mov	x29, sp
	const struct cmd_device_list_visitor_context *ctx = context;

	shell_fprintf(ctx->shell, SHELL_NORMAL, "  requires: %s\n",
    400036c4:	f9400822 	ldr	x2, [x1, #16]
{
    400036c8:	f9000bf3 	str	x19, [sp, #16]
	shell_fprintf(ctx->shell, SHELL_NORMAL, "  requires: %s\n",
    400036cc:	a9400433 	ldp	x19, x1, [x1]
    400036d0:	97ffffe9 	bl	40003674 <get_device_name>
    400036d4:	aa0003e3 	mov	x3, x0
    400036d8:	52800101 	mov	w1, #0x8                   	// #8
    400036dc:	aa1303e0 	mov	x0, x19
    400036e0:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400036e4:	91354442 	add	x2, x2, #0xd51
    400036e8:	9400081a 	bl	40005750 <shell_fprintf>
		      get_device_name(dev, ctx->buf, ctx->buf_size));

	return 0;
}
    400036ec:	52800000 	mov	w0, #0x0                   	// #0
    400036f0:	f9400bf3 	ldr	x19, [sp, #16]
    400036f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400036f8:	d65f03c0 	ret

00000000400036fc <cmd_device_list>:

static int cmd_device_list(const struct shell *shell,
			   size_t argc, char **argv)
{
    400036fc:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    40003700:	910003fd 	mov	x29, sp
    40003704:	a90153f3 	stp	x19, x20, [sp, #16]
    40003708:	aa0003f4 	mov	x20, x0
	const struct device *devlist;
	size_t devcnt = z_device_get_all_static(&devlist);
    4000370c:	910123e0 	add	x0, sp, #0x48
{
    40003710:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (dev = devlist; dev < devlist_end; dev++) {
		char buf[20];
		const char *name = get_device_name(dev, buf, sizeof(buf));
		const char *state = "READY";

		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
    40003714:	f0000056 	adrp	x22, 4000e000 <mmu_regions+0x38>
    40003718:	9135ead6 	add	x22, x22, #0xd7a
{
    4000371c:	a90363f7 	stp	x23, x24, [sp, #48]
	size_t devcnt = z_device_get_all_static(&devlist);
    40003720:	940018a3 	bl	400099ac <z_device_get_all_static>
	const struct device *devlist_end = devlist + devcnt;
    40003724:	d2800602 	mov	x2, #0x30                  	// #48
    40003728:	f94027e1 	ldr	x1, [sp, #72]
		if (!device_is_ready(dev)) {
			state = "DISABLED";
    4000372c:	f0000057 	adrp	x23, 4000e000 <mmu_regions+0x38>
    40003730:	91359ef7 	add	x23, x23, #0xd67
		const char *name = get_device_name(dev, buf, sizeof(buf));
    40003734:	910143f8 	add	x24, sp, #0x50
	const struct device *devlist_end = devlist + devcnt;
    40003738:	9b020415 	madd	x21, x0, x2, x1
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
    4000373c:	aa1403e0 	mov	x0, x20
    40003740:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003744:	9135c042 	add	x2, x2, #0xd70
    40003748:	52800101 	mov	w1, #0x8                   	// #8
    4000374c:	94000801 	bl	40005750 <shell_fprintf>
	for (dev = devlist; dev < devlist_end; dev++) {
    40003750:	f94027f3 	ldr	x19, [sp, #72]
    40003754:	eb15027f 	cmp	x19, x21
    40003758:	540000e3 	b.cc	40003774 <cmd_device_list+0x78>  // b.lo, b.ul, b.last
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
		}
	}

	return 0;
}
    4000375c:	52800000 	mov	w0, #0x0                   	// #0
    40003760:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003764:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003768:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000376c:	a8c87bfd 	ldp	x29, x30, [sp], #128
    40003770:	d65f03c0 	ret
		const char *name = get_device_name(dev, buf, sizeof(buf));
    40003774:	aa1803e1 	mov	x1, x24
    40003778:	aa1303e0 	mov	x0, x19
    4000377c:	d2800282 	mov	x2, #0x14                  	// #20
    40003780:	97ffffbd 	bl	40003674 <get_device_name>
		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
    40003784:	aa1603e2 	mov	x2, x22
    40003788:	aa0003e3 	mov	x3, x0
    4000378c:	52800101 	mov	w1, #0x8                   	// #8
    40003790:	aa1403e0 	mov	x0, x20
    40003794:	940007ef 	bl	40005750 <shell_fprintf>
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
    40003798:	aa1303e0 	mov	x0, x19
    4000379c:	9400188f 	bl	400099d8 <z_device_ready>
			state = "DISABLED";
    400037a0:	72001c1f 	tst	w0, #0xff
    400037a4:	f0000043 	adrp	x3, 4000e000 <mmu_regions+0x38>
		shell_fprintf(shell, SHELL_NORMAL, " (%s)\n", state);
    400037a8:	91358463 	add	x3, x3, #0xd61
    400037ac:	aa1403e0 	mov	x0, x20
    400037b0:	9a971063 	csel	x3, x3, x23, ne  // ne = any
    400037b4:	52800101 	mov	w1, #0x8                   	// #8
    400037b8:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400037bc:	9135fc42 	add	x2, x2, #0xd7f
    400037c0:	940007e4 	bl	40005750 <shell_fprintf>
			struct cmd_device_list_visitor_context ctx = {
    400037c4:	a906e3f4 	stp	x20, x24, [sp, #104]
    400037c8:	d2800280 	mov	x0, #0x14                  	// #20
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
    400037cc:	9101a3e2 	add	x2, sp, #0x68
    400037d0:	90000001 	adrp	x1, 40003000 <fnmatchx+0xa8>
    400037d4:	911af021 	add	x1, x1, #0x6bc
			struct cmd_device_list_visitor_context ctx = {
    400037d8:	f9003fe0 	str	x0, [sp, #120]
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
    400037dc:	aa1303e0 	mov	x0, x19
	for (dev = devlist; dev < devlist_end; dev++) {
    400037e0:	9100c273 	add	x19, x19, #0x30
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
    400037e4:	94001886 	bl	400099fc <device_required_foreach>
	for (dev = devlist; dev < devlist_end; dev++) {
    400037e8:	17ffffdb 	b	40003754 <cmd_device_list+0x58>

00000000400037ec <device_get_config_level>:
{
    400037ec:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    400037f0:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400037f4:	91064042 	add	x2, x2, #0x190
{
    400037f8:	910003fd 	mov	x29, sp
    400037fc:	a90153f3 	stp	x19, x20, [sp, #16]
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40003800:	f861d853 	ldr	x19, [x2, w1, sxtw #3]
    40003804:	11000421 	add	w1, w1, #0x1
{
    40003808:	a90363f7 	stp	x23, x24, [sp, #48]
	bool devices = false;
    4000380c:	52800017 	mov	w23, #0x0                   	// #0
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40003810:	f861d858 	ldr	x24, [x2, w1, sxtw #3]
{
    40003814:	a9025bf5 	stp	x21, x22, [sp, #32]
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
    40003818:	f0000056 	adrp	x22, 4000e000 <mmu_regions+0x38>
    4000381c:	91361ad6 	add	x22, x22, #0xd86
{
    40003820:	aa0003f5 	mov	x21, x0
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40003824:	eb13031f 	cmp	x24, x19
    40003828:	540000e8 	b.hi	40003844 <device_get_config_level+0x58>  // b.pmore
}
    4000382c:	2a1703e0 	mov	w0, w23
    40003830:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003834:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003838:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000383c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40003840:	d65f03c0 	ret
    40003844:	aa1303e0 	mov	x0, x19
    40003848:	94001864 	bl	400099d8 <z_device_ready>
    4000384c:	72001c14 	ands	w20, w0, #0xff
    40003850:	54000160 	b.eq	4000387c <device_get_config_level+0x90>  // b.none
			devices = true;
    40003854:	2a1403f7 	mov	w23, w20
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
    40003858:	910123e1 	add	x1, sp, #0x48
    4000385c:	d2800282 	mov	x2, #0x14                  	// #20
    40003860:	aa1303e0 	mov	x0, x19
    40003864:	97ffff84 	bl	40003674 <get_device_name>
    40003868:	aa0003e3 	mov	x3, x0
    4000386c:	aa1603e2 	mov	x2, x22
    40003870:	aa1503e0 	mov	x0, x21
    40003874:	52800101 	mov	w1, #0x8                   	// #8
    40003878:	940007b6 	bl	40005750 <shell_fprintf>
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    4000387c:	9100c273 	add	x19, x19, #0x30
    40003880:	17ffffe9 	b	40003824 <device_get_config_level+0x38>

0000000040003884 <cmd_device_levels>:
{
    40003884:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
    40003888:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    4000388c:	91363042 	add	x2, x2, #0xd8c
{
    40003890:	910003fd 	mov	x29, sp
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
    40003894:	52800101 	mov	w1, #0x8                   	// #8
{
    40003898:	f9000bf3 	str	x19, [sp, #16]
    4000389c:	aa0003f3 	mov	x19, x0
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
    400038a0:	940007ac 	bl	40005750 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_1);
    400038a4:	aa1303e0 	mov	x0, x19
    400038a8:	52800001 	mov	w1, #0x0                   	// #0
    400038ac:	97ffffd0 	bl	400037ec <device_get_config_level>
	if (ret == false) {
    400038b0:	72001c1f 	tst	w0, #0xff
    400038b4:	540000c1 	b.ne	400038cc <cmd_device_levels+0x48>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    400038b8:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400038bc:	91366c42 	add	x2, x2, #0xd9b
    400038c0:	aa1303e0 	mov	x0, x19
    400038c4:	52800101 	mov	w1, #0x8                   	// #8
    400038c8:	940007a2 	bl	40005750 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 2:\n");
    400038cc:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400038d0:	91368c42 	add	x2, x2, #0xda3
    400038d4:	aa1303e0 	mov	x0, x19
    400038d8:	52800101 	mov	w1, #0x8                   	// #8
    400038dc:	9400079d 	bl	40005750 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_2);
    400038e0:	aa1303e0 	mov	x0, x19
    400038e4:	52800021 	mov	w1, #0x1                   	// #1
    400038e8:	97ffffc1 	bl	400037ec <device_get_config_level>
	if (ret == false) {
    400038ec:	72001c1f 	tst	w0, #0xff
    400038f0:	540000c1 	b.ne	40003908 <cmd_device_levels+0x84>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    400038f4:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400038f8:	91366c42 	add	x2, x2, #0xd9b
    400038fc:	aa1303e0 	mov	x0, x19
    40003900:	52800101 	mov	w1, #0x8                   	// #8
    40003904:	94000793 	bl	40005750 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "POST_KERNEL:\n");
    40003908:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    4000390c:	9136c842 	add	x2, x2, #0xdb2
    40003910:	aa1303e0 	mov	x0, x19
    40003914:	52800101 	mov	w1, #0x8                   	// #8
    40003918:	9400078e 	bl	40005750 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_POST_KERNEL);
    4000391c:	aa1303e0 	mov	x0, x19
    40003920:	52800041 	mov	w1, #0x2                   	// #2
    40003924:	97ffffb2 	bl	400037ec <device_get_config_level>
	if (ret == false) {
    40003928:	72001c1f 	tst	w0, #0xff
    4000392c:	540000c1 	b.ne	40003944 <cmd_device_levels+0xc0>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    40003930:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003934:	91366c42 	add	x2, x2, #0xd9b
    40003938:	aa1303e0 	mov	x0, x19
    4000393c:	52800101 	mov	w1, #0x8                   	// #8
    40003940:	94000784 	bl	40005750 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "APPLICATION:\n");
    40003944:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003948:	91370042 	add	x2, x2, #0xdc0
    4000394c:	aa1303e0 	mov	x0, x19
    40003950:	52800101 	mov	w1, #0x8                   	// #8
    40003954:	9400077f 	bl	40005750 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_APPLICATION);
    40003958:	aa1303e0 	mov	x0, x19
    4000395c:	52800061 	mov	w1, #0x3                   	// #3
    40003960:	97ffffa3 	bl	400037ec <device_get_config_level>
	if (ret == false) {
    40003964:	72001c1f 	tst	w0, #0xff
    40003968:	540000c1 	b.ne	40003980 <cmd_device_levels+0xfc>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    4000396c:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003970:	91366c42 	add	x2, x2, #0xd9b
    40003974:	aa1303e0 	mov	x0, x19
    40003978:	52800101 	mov	w1, #0x8                   	// #8
    4000397c:	94000775 	bl	40005750 <shell_fprintf>
}
    40003980:	52800000 	mov	w0, #0x0                   	// #0
    40003984:	f9400bf3 	ldr	x19, [sp, #16]
    40003988:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000398c:	d65f03c0 	ret

0000000040003990 <cmd_devmem>:
	return err;
}

/* The syntax of the command is similar to busybox's devmem */
static int cmd_devmem(const struct shell *sh, size_t argc, char **argv)
{
    40003990:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40003994:	910003fd 	mov	x29, sp
    40003998:	a90153f3 	stp	x19, x20, [sp, #16]
    4000399c:	aa0003f4 	mov	x20, x0
	mem_addr_t phys_addr, addr;
	uint32_t value = 0;
	uint8_t width;

	if (argc < 2 || argc > 4) {
    400039a0:	d1000820 	sub	x0, x1, #0x2
{
    400039a4:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (argc < 2 || argc > 4) {
    400039a8:	f100081f 	cmp	x0, #0x2
    400039ac:	54000868 	b.hi	40003ab8 <cmd_devmem+0x128>  // b.pmore
    400039b0:	aa0203f5 	mov	x21, x2
		return -EINVAL;
	}

	phys_addr = strtoul(argv[1], NULL, 16);
    400039b4:	aa0103f6 	mov	x22, x1
    400039b8:	52800202 	mov	w2, #0x10                  	// #16
    400039bc:	d2800001 	mov	x1, #0x0                   	// #0
    400039c0:	f94006a0 	ldr	x0, [x21, #8]
    400039c4:	94001401 	bl	400089c8 <strtoul>
{
#ifdef CONFIG_MMU
	/* Pass along flags and add that we want supervisor mode
	 * read-write access.
	 */
	z_phys_map((uint8_t **)virt_addr, phys_addr, size,
    400039c8:	aa0003e1 	mov	x1, x0
    400039cc:	aa0003f3 	mov	x19, x0
    400039d0:	52800143 	mov	w3, #0xa                   	// #10
    400039d4:	9100e3e0 	add	x0, sp, #0x38
    400039d8:	d2802002 	mov	x2, #0x100                 	// #256
    400039dc:	94001eeb 	bl	4000b588 <z_phys_map>

#if defined(CONFIG_MMU) || defined(CONFIG_PCIE)
	device_map((mm_reg_t *)&addr, phys_addr, 0x100, K_MEM_CACHE_NONE);

	shell_print(sh, "Mapped 0x%lx to 0x%lx\n", phys_addr, addr);
    400039e0:	f9401fe4 	ldr	x4, [sp, #56]
    400039e4:	aa1303e3 	mov	x3, x19
    400039e8:	aa1403e0 	mov	x0, x20
    400039ec:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400039f0:	91389042 	add	x2, x2, #0xe24
    400039f4:	52800101 	mov	w1, #0x8                   	// #8
    400039f8:	94000756 	bl	40005750 <shell_fprintf>
#else
	addr = phys_addr;
#endif /* defined(CONFIG_MMU) || defined(CONFIG_PCIE) */

	if (argc < 3) {
    400039fc:	f1000adf 	cmp	x22, #0x2
    40003a00:	54000440 	b.eq	40003a88 <cmd_devmem+0xf8>  // b.none
		width = 32;
	} else {
		width = strtoul(argv[2], NULL, 10);
    40003a04:	f9400aa0 	ldr	x0, [x21, #16]
    40003a08:	52800142 	mov	w2, #0xa                   	// #10
    40003a0c:	d2800001 	mov	x1, #0x0                   	// #0
    40003a10:	940013ee 	bl	400089c8 <strtoul>
    40003a14:	12001c13 	and	w19, w0, #0xff
	}

	shell_fprintf(sh, SHELL_NORMAL, "Using data width %d\n", width);
    40003a18:	2a1303e3 	mov	w3, w19
    40003a1c:	aa1403e0 	mov	x0, x20
    40003a20:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003a24:	9138f042 	add	x2, x2, #0xe3c
    40003a28:	52800101 	mov	w1, #0x8                   	// #8
    40003a2c:	94000749 	bl	40005750 <shell_fprintf>

	if (argc <= 3) {
    40003a30:	f10012df 	cmp	x22, #0x4
    40003a34:	54000460 	b.eq	40003ac0 <cmd_devmem+0x130>  // b.none
	switch (width) {
    40003a38:	7100427f 	cmp	w19, #0x10
		return memory_read(sh, addr, width);
    40003a3c:	f9401fe3 	ldr	x3, [sp, #56]
	switch (width) {
    40003a40:	54000280 	b.eq	40003a90 <cmd_devmem+0x100>  // b.none
    40003a44:	7100827f 	cmp	w19, #0x20
    40003a48:	540002a0 	b.eq	40003a9c <cmd_devmem+0x10c>  // b.none
    40003a4c:	7100227f 	cmp	w19, #0x8
    40003a50:	540002a1 	b.ne	40003aa4 <cmd_devmem+0x114>  // b.any
 */
static ALWAYS_INLINE uint8_t sys_read8(mem_addr_t addr)
{
	uint8_t val;

	__asm__ volatile("ldrb %w0, [%1]" : "=r" (val) : "r" (addr));
    40003a54:	39400063 	ldrb	w3, [x3]
    40003a58:	12001c63 	and	w3, w3, #0xff
{
	uint32_t val;

	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));

	__DMB();
    40003a5c:	d5033fbf 	dmb	sy
		shell_fprintf(sh, SHELL_NORMAL, "Read value 0x%x\n", value);
    40003a60:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003a64:	91399c42 	add	x2, x2, #0xe67
    40003a68:	aa1403e0 	mov	x0, x20
    40003a6c:	52800101 	mov	w1, #0x8                   	// #8
    40003a70:	94000738 	bl	40005750 <shell_fprintf>
	int err = 0;
    40003a74:	52800000 	mov	w0, #0x0                   	// #0
	value = strtoul(argv[3], NULL, 16);

	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);

	return memory_write(sh, addr, width, value);
}
    40003a78:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003a7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003a80:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40003a84:	d65f03c0 	ret
		width = 32;
    40003a88:	52800413 	mov	w19, #0x20                  	// #32
    40003a8c:	17ffffe3 	b	40003a18 <cmd_devmem+0x88>
	__asm__ volatile("ldrh %w0, [%1]" : "=r" (val) : "r" (addr));
    40003a90:	79400063 	ldrh	w3, [x3]
    40003a94:	12003c63 	and	w3, w3, #0xffff
	__DMB();
    40003a98:	17fffff1 	b	40003a5c <cmd_devmem+0xcc>
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    40003a9c:	b9400063 	ldr	w3, [x3]
    40003aa0:	17ffffef 	b	40003a5c <cmd_devmem+0xcc>
		shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
    40003aa4:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003aa8:	91394442 	add	x2, x2, #0xe51
    40003aac:	aa1403e0 	mov	x0, x20
    40003ab0:	52800101 	mov	w1, #0x8                   	// #8
    40003ab4:	94000727 	bl	40005750 <shell_fprintf>
		return -EINVAL;
    40003ab8:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40003abc:	17ffffef 	b	40003a78 <cmd_devmem+0xe8>
	value = strtoul(argv[3], NULL, 16);
    40003ac0:	f9400ea0 	ldr	x0, [x21, #24]
    40003ac4:	52800202 	mov	w2, #0x10                  	// #16
    40003ac8:	d2800001 	mov	x1, #0x0                   	// #0
    40003acc:	940013bf 	bl	400089c8 <strtoul>
    40003ad0:	aa0003f5 	mov	x21, x0
	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);
    40003ad4:	2a0003e3 	mov	w3, w0
    40003ad8:	52800101 	mov	w1, #0x8                   	// #8
    40003adc:	aa1403e0 	mov	x0, x20
    40003ae0:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003ae4:	9139e042 	add	x2, x2, #0xe78
    40003ae8:	9400071a 	bl	40005750 <shell_fprintf>
	return memory_write(sh, addr, width, value);
    40003aec:	92407ea1 	and	x1, x21, #0xffffffff
	switch (width) {
    40003af0:	7100427f 	cmp	w19, #0x10
	return memory_write(sh, addr, width, value);
    40003af4:	f9401fe0 	ldr	x0, [sp, #56]
	switch (width) {
    40003af8:	54000100 	b.eq	40003b18 <cmd_devmem+0x188>  // b.none
    40003afc:	7100827f 	cmp	w19, #0x20
    40003b00:	54000120 	b.eq	40003b24 <cmd_devmem+0x194>  // b.none
    40003b04:	7100227f 	cmp	w19, #0x8
    40003b08:	54fffce1 	b.ne	40003aa4 <cmd_devmem+0x114>  // b.any
	__DMB();
    40003b0c:	d5033fbf 	dmb	sy
	__asm__ volatile("strb %w0, [%1]" : : "r" (data), "r" (addr));
    40003b10:	39000001 	strb	w1, [x0]
    40003b14:	17ffffd8 	b	40003a74 <cmd_devmem+0xe4>
	__DMB();
    40003b18:	d5033fbf 	dmb	sy
	__asm__ volatile("strh %w0, [%1]" : : "r" (data), "r" (addr));
    40003b1c:	79000001 	strh	w1, [x0]
    40003b20:	17ffffd5 	b	40003a74 <cmd_devmem+0xe4>
	return val;
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	__DMB();
    40003b24:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40003b28:	b9000015 	str	w21, [x0]
    40003b2c:	17ffffd2 	b	40003a74 <cmd_devmem+0xe4>

0000000040003b30 <set_bypass.isra.0>:
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
    40003b30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40003b34:	910003fd 	mov	x29, sp
    40003b38:	a90153f3 	stp	x19, x20, [sp, #16]
	if (bypass && in_use) {
    40003b3c:	f00000b3 	adrp	x19, 4001a000 <shell_uart_ctx+0x1c8>
    40003b40:	394ffa62 	ldrb	w2, [x19, #1022]
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
    40003b44:	f90013f5 	str	x21, [sp, #32]
    40003b48:	aa0003f4 	mov	x20, x0
    40003b4c:	aa0103f5 	mov	x21, x1
	if (bypass && in_use) {
    40003b50:	b4000121 	cbz	x1, 40003b74 <set_bypass.isra.0+0x44>
    40003b54:	34000102 	cbz	w2, 40003b74 <set_bypass.isra.0+0x44>
}
    40003b58:	a94153f3 	ldp	x19, x20, [sp, #16]
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
    40003b5c:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003b60:	913a3042 	add	x2, x2, #0xe8c
    40003b64:	52800021 	mov	w1, #0x1                   	// #1
}
    40003b68:	f94013f5 	ldr	x21, [sp, #32]
    40003b6c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
    40003b70:	140006f8 	b	40005750 <shell_fprintf>
	in_use = !in_use;
    40003b74:	52000042 	eor	w2, w2, #0x1
    40003b78:	390ffa62 	strb	w2, [x19, #1022]
	if (in_use) {
    40003b7c:	34000102 	cbz	w2, 40003b9c <set_bypass.isra.0+0x6c>
		shell_print(sh, "Loading...\npress ctrl-x ctrl-q to escape");
    40003b80:	aa1403e0 	mov	x0, x20
    40003b84:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003b88:	913b1c42 	add	x2, x2, #0xec7
    40003b8c:	52800101 	mov	w1, #0x8                   	// #8
    40003b90:	940006f0 	bl	40005750 <shell_fprintf>
		in_use = true;
    40003b94:	52800020 	mov	w0, #0x1                   	// #1
    40003b98:	390ffa60 	strb	w0, [x19, #1022]
	shell_set_bypass(sh, bypass);
    40003b9c:	aa1503e1 	mov	x1, x21
    40003ba0:	aa1403e0 	mov	x0, x20
}
    40003ba4:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003ba8:	f94013f5 	ldr	x21, [sp, #32]
    40003bac:	a8c37bfd 	ldp	x29, x30, [sp], #48
	shell_set_bypass(sh, bypass);
    40003bb0:	14000725 	b	40005844 <shell_set_bypass>

0000000040003bb4 <bypass_cb>:
{
    40003bb4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003bb8:	910003fd 	mov	x29, sp
    40003bbc:	a90153f3 	stp	x19, x20, [sp, #16]
    40003bc0:	aa0003f4 	mov	x20, x0
	if (tail == CHAR_CAN && recv[0] == CHAR_DC1) {
    40003bc4:	f00000a3 	adrp	x3, 4001a000 <shell_uart_ctx+0x1c8>
    40003bc8:	39500060 	ldrb	w0, [x3, #1024]
    40003bcc:	aa0303e4 	mov	x4, x3
    40003bd0:	7100601f 	cmp	w0, #0x18
    40003bd4:	54000081 	b.ne	40003be4 <bypass_cb+0x30>  // b.any
    40003bd8:	39400020 	ldrb	w0, [x1]
    40003bdc:	7100441f 	cmp	w0, #0x11
    40003be0:	54000640 	b.eq	40003ca8 <bypass_cb+0xf4>  // b.none
		for (int i = 0; i < (len - 1); i++) {
    40003be4:	d1000442 	sub	x2, x2, #0x1
    40003be8:	52800003 	mov	w3, #0x0                   	// #0
    40003bec:	93407c60 	sxtw	x0, w3
    40003bf0:	eb23c05f 	cmp	x2, w3, sxtw
    40003bf4:	540004c8 	b.hi	40003c8c <bypass_cb+0xd8>  // b.pmore
	tail = recv[len - 1];
    40003bf8:	38626820 	ldrb	w0, [x1, x2]
    40003bfc:	f00000b3 	adrp	x19, 4001a000 <shell_uart_ctx+0x1c8>
	if (is_ascii(*recv)) {
    40003c00:	39400021 	ldrb	w1, [x1]
	tail = recv[len - 1];
    40003c04:	39100080 	strb	w0, [x4, #1024]
	return (data >= 0x30 && data <= 0x39) || (data >= 0x61 && data <= 0x66) ||
    40003c08:	5100c020 	sub	w0, w1, #0x30
    40003c0c:	12001c00 	and	w0, w0, #0xff
    40003c10:	7100241f 	cmp	w0, #0x9
    40003c14:	540000c9 	b.ls	40003c2c <bypass_cb+0x78>  // b.plast
	if (is_ascii(*recv)) {
    40003c18:	121a7820 	and	w0, w1, #0xffffffdf
    40003c1c:	51010400 	sub	w0, w0, #0x41
    40003c20:	12001c00 	and	w0, w0, #0xff
    40003c24:	7100141f 	cmp	w0, #0x5
    40003c28:	540000e8 	b.hi	40003c44 <bypass_cb+0x90>  // b.pmore
		chunk[chunk_element] = *recv;
    40003c2c:	b942da60 	ldr	w0, [x19, #728]
    40003c30:	f00000a2 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    40003c34:	910ff042 	add	x2, x2, #0x3fc
    40003c38:	3820c841 	strb	w1, [x2, w0, sxtw]
		chunk_element++;
    40003c3c:	11000400 	add	w0, w0, #0x1
    40003c40:	b902da60 	str	w0, [x19, #728]
	if (chunk_element == 2) {
    40003c44:	b942da60 	ldr	w0, [x19, #728]
    40003c48:	7100081f 	cmp	w0, #0x2
    40003c4c:	54000641 	b.ne	40003d14 <bypass_cb+0x160>  // b.any
		byte = (uint8_t)strtoul(chunk, NULL, 16);
    40003c50:	52800202 	mov	w2, #0x10                  	// #16
    40003c54:	d2800001 	mov	x1, #0x0                   	// #0
    40003c58:	f00000a0 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    40003c5c:	910ff000 	add	x0, x0, #0x3fc
    40003c60:	9400135a 	bl	400089c8 <strtoul>
		chunk_element = 0;
    40003c64:	b902da7f 	str	wzr, [x19, #728]
		*bytes = byte;
    40003c68:	d00000a2 	adrp	x2, 40019000 <shell_uart_thread>
		byte = (uint8_t)strtoul(chunk, NULL, 16);
    40003c6c:	f9470041 	ldr	x1, [x2, #3584]
    40003c70:	38001420 	strb	w0, [x1], #1
		bytes++;
    40003c74:	f9070041 	str	x1, [x2, #3584]
		sum++;
    40003c78:	f00000a1 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    40003c7c:	b942dc20 	ldr	w0, [x1, #732]
    40003c80:	11000400 	add	w0, w0, #0x1
    40003c84:	b902dc20 	str	w0, [x1, #732]
		chunk_element = 0;
    40003c88:	14000023 	b	40003d14 <bypass_cb+0x160>
			if (recv[i] == CHAR_CAN && recv[i + 1] == CHAR_DC1) {
    40003c8c:	38606820 	ldrb	w0, [x1, x0]
    40003c90:	11000463 	add	w3, w3, #0x1
    40003c94:	7100601f 	cmp	w0, #0x18
    40003c98:	54fffaa1 	b.ne	40003bec <bypass_cb+0x38>  // b.any
    40003c9c:	3863c820 	ldrb	w0, [x1, w3, sxtw]
    40003ca0:	7100441f 	cmp	w0, #0x11
    40003ca4:	54fffa41 	b.ne	40003bec <bypass_cb+0x38>  // b.any
		shell_print(sh, "Number of bytes read: %d", sum);
    40003ca8:	f00000b3 	adrp	x19, 4001a000 <shell_uart_ctx+0x1c8>
    40003cac:	b942de63 	ldr	w3, [x19, #732]
    40003cb0:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003cb4:	913bc442 	add	x2, x2, #0xef1
    40003cb8:	aa1403e0 	mov	x0, x20
    40003cbc:	52800101 	mov	w1, #0x8                   	// #8
    40003cc0:	940006a4 	bl	40005750 <shell_fprintf>
		set_bypass(sh, NULL);
    40003cc4:	aa1403e0 	mov	x0, x20
    40003cc8:	d2800001 	mov	x1, #0x0                   	// #0
    40003ccc:	97ffff99 	bl	40003b30 <set_bypass.isra.0>
		if (!littleendian) {
    40003cd0:	f00000a0 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    40003cd4:	394ffc03 	ldrb	w3, [x0, #1023]
    40003cd8:	350001e3 	cbnz	w3, 40003d14 <bypass_cb+0x160>
    40003cdc:	d00000a1 	adrp	x1, 40019000 <shell_uart_thread>
    40003ce0:	f9470422 	ldr	x2, [x1, #3592]
    40003ce4:	b942de60 	ldr	w0, [x19, #732]
			while (sum > 4) {
    40003ce8:	7100101f 	cmp	w0, #0x4
    40003cec:	540001ac 	b.gt	40003d20 <bypass_cb+0x16c>
    40003cf0:	34000063 	cbz	w3, 40003cfc <bypass_cb+0x148>
    40003cf4:	f9070422 	str	x2, [x1, #3592]
    40003cf8:	b902de60 	str	w0, [x19, #732]
			if (sum % 4 == 0) {
    40003cfc:	72000402 	ands	w2, w0, #0x3
    40003d00:	540001c1 	b.ne	40003d38 <bypass_cb+0x184>  // b.any
				*data = __bswap_32(*data);
    40003d04:	f9470421 	ldr	x1, [x1, #3592]
    40003d08:	b9400020 	ldr	w0, [x1]
    40003d0c:	5ac00800 	rev	w0, w0
				*data = __bswap_16(*data);
    40003d10:	b9000020 	str	w0, [x1]
}
    40003d14:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003d18:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003d1c:	d65f03c0 	ret
				*data = __bswap_32(*data);
    40003d20:	b9400043 	ldr	w3, [x2]
				sum = sum - 4;
    40003d24:	51001000 	sub	w0, w0, #0x4
    40003d28:	5ac00863 	rev	w3, w3
				*data = __bswap_32(*data);
    40003d2c:	b8004443 	str	w3, [x2], #4
				sum = sum - 4;
    40003d30:	52800023 	mov	w3, #0x1                   	// #1
    40003d34:	17ffffed 	b	40003ce8 <bypass_cb+0x134>
			} else if (sum % 4 == 2) {
    40003d38:	6b0003e0 	negs	w0, w0
    40003d3c:	12000400 	and	w0, w0, #0x3
    40003d40:	5a804440 	csneg	w0, w2, w0, mi  // mi = first
    40003d44:	7100081f 	cmp	w0, #0x2
    40003d48:	540000c1 	b.ne	40003d60 <bypass_cb+0x1ac>  // b.any
				*data = __bswap_16(*data);
    40003d4c:	f9470421 	ldr	x1, [x1, #3592]
    40003d50:	79400020 	ldrh	w0, [x1]
    40003d54:	5ac00400 	rev16	w0, w0
    40003d58:	12003c00 	and	w0, w0, #0xffff
    40003d5c:	17ffffed 	b	40003d10 <bypass_cb+0x15c>
			} else if (sum % 4 == 3) {
    40003d60:	71000c1f 	cmp	w0, #0x3
    40003d64:	54fffd81 	b.ne	40003d14 <bypass_cb+0x160>  // b.any
				*data = __bswap_24(*data);
    40003d68:	f9470422 	ldr	x2, [x1, #3592]
    40003d6c:	b9400041 	ldr	w1, [x2]
    40003d70:	d3505c20 	ubfx	x0, x1, #16, #8
    40003d74:	53101c23 	ubfiz	w3, w1, #16, #8
    40003d78:	2a030000 	orr	w0, w0, w3
    40003d7c:	12181c21 	and	w1, w1, #0xff00
    40003d80:	2a010000 	orr	w0, w0, w1
    40003d84:	b9000040 	str	w0, [x2]
    40003d88:	17ffffe3 	b	40003d14 <bypass_cb+0x160>

0000000040003d8c <cmd_load>:
{
    40003d8c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40003d90:	910003fd 	mov	x29, sp
    40003d94:	a9025bf5 	stp	x21, x22, [sp, #32]
    40003d98:	aa0103f5 	mov	x21, x1
	chunk_element = 0;
    40003d9c:	f00000a1 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
{
    40003da0:	aa0003f6 	mov	x22, x0
	littleendian = false;
    40003da4:	f00000a0 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
	chunk_element = 0;
    40003da8:	b902d83f 	str	wzr, [x1, #728]
	sum = 0;
    40003dac:	f00000a1 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
{
    40003db0:	a90153f3 	stp	x19, x20, [sp, #16]
    40003db4:	aa0203f3 	mov	x19, x2
    40003db8:	a90363f7 	stp	x23, x24, [sp, #48]
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    40003dbc:	f0000057 	adrp	x23, 4000e000 <mmu_regions+0x38>
    40003dc0:	913c2ef7 	add	x23, x23, #0xf0b
{
    40003dc4:	a9046bf9 	stp	x25, x26, [sp, #64]
		if (!strncmp(arg, "-e", 2)) {
    40003dc8:	f0000059 	adrp	x25, 4000e000 <mmu_regions+0x38>
    40003dcc:	913c3b39 	add	x25, x25, #0xf0e
    40003dd0:	aa0003fa 	mov	x26, x0
	littleendian = false;
    40003dd4:	390ffc1f 	strb	wzr, [x0, #1023]
	sum = 0;
    40003dd8:	b902dc3f 	str	wzr, [x1, #732]
{
    40003ddc:	f9002bfb 	str	x27, [sp, #80]
	while (argc >= 2) {
    40003de0:	f10006bf 	cmp	x21, #0x1
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    40003de4:	f9400678 	ldr	x24, [x19, #8]
	while (argc >= 2) {
    40003de8:	540003a9 	b.ls	40003e5c <cmd_load+0xd0>  // b.plast
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    40003dec:	aa1703e1 	mov	x1, x23
    40003df0:	aa1803e0 	mov	x0, x24
    40003df4:	d2800042 	mov	x2, #0x2                   	// #2
    40003df8:	940013b0 	bl	40008cb8 <strncmp>
    40003dfc:	35000220 	cbnz	w0, 40003e40 <cmd_load+0xb4>
    40003e00:	f9400660 	ldr	x0, [x19, #8]
    40003e04:	39400800 	ldrb	w0, [x0, #2]
    40003e08:	7100001f 	cmp	w0, #0x0
    40003e0c:	1a9f07f4 	cset	w20, ne  // ne = any
    40003e10:	93407e9b 	sxtw	x27, w20
    40003e14:	8b34c314 	add	x20, x24, w20, sxtw
		if (!strncmp(arg, "-e", 2)) {
    40003e18:	aa1903e1 	mov	x1, x25
    40003e1c:	aa1403e0 	mov	x0, x20
    40003e20:	d2800042 	mov	x2, #0x2                   	// #2
    40003e24:	940013a5 	bl	40008cb8 <strncmp>
    40003e28:	35000100 	cbnz	w0, 40003e48 <cmd_load+0xbc>
			littleendian = true;
    40003e2c:	52800020 	mov	w0, #0x1                   	// #1
    40003e30:	390fff40 	strb	w0, [x26, #1023]
		argv++;
    40003e34:	91002273 	add	x19, x19, #0x8
		argc--;
    40003e38:	d10006b5 	sub	x21, x21, #0x1
    40003e3c:	17ffffe9 	b	40003de0 <cmd_load+0x54>
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    40003e40:	52800014 	mov	w20, #0x0                   	// #0
    40003e44:	17fffff3 	b	40003e10 <cmd_load+0x84>
		} else if (!strcmp(arg, "--")) {
    40003e48:	aa1703e1 	mov	x1, x23
    40003e4c:	aa1403e0 	mov	x0, x20
    40003e50:	94001391 	bl	40008c94 <strcmp>
    40003e54:	35000340 	cbnz	w0, 40003ebc <cmd_load+0x130>
			argv++;
    40003e58:	91002273 	add	x19, x19, #0x8
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
    40003e5c:	f9400660 	ldr	x0, [x19, #8]
    40003e60:	52800002 	mov	w2, #0x0                   	// #0
    40003e64:	d2800001 	mov	x1, #0x0                   	// #0
    40003e68:	94001276 	bl	40008840 <strtol>
    40003e6c:	d00000a1 	adrp	x1, 40019000 <shell_uart_thread>
	data = (uint32_t *)strtol(argv[1], NULL, 0);
    40003e70:	52800002 	mov	w2, #0x0                   	// #0
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
    40003e74:	f9070020 	str	x0, [x1, #3584]
	data = (uint32_t *)strtol(argv[1], NULL, 0);
    40003e78:	d2800001 	mov	x1, #0x0                   	// #0
    40003e7c:	f9400660 	ldr	x0, [x19, #8]
    40003e80:	94001270 	bl	40008840 <strtol>
    40003e84:	d00000a1 	adrp	x1, 40019000 <shell_uart_thread>
    40003e88:	f9070420 	str	x0, [x1, #3592]
	set_bypass(sh, bypass_cb);
    40003e8c:	aa1603e0 	mov	x0, x22
    40003e90:	90000001 	adrp	x1, 40003000 <fnmatchx+0xa8>
    40003e94:	912ed021 	add	x1, x1, #0xbb4
    40003e98:	97ffff26 	bl	40003b30 <set_bypass.isra.0>
}
    40003e9c:	52800000 	mov	w0, #0x0                   	// #0
    40003ea0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003ea4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003ea8:	a94363f7 	ldp	x23, x24, [sp, #48]
    40003eac:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40003eb0:	f9402bfb 	ldr	x27, [sp, #80]
    40003eb4:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40003eb8:	d65f03c0 	ret
		} else if (arg[0] == '-' && arg[1]) {
    40003ebc:	387b6b00 	ldrb	w0, [x24, x27]
    40003ec0:	7100b41f 	cmp	w0, #0x2d
    40003ec4:	54fffcc1 	b.ne	40003e5c <cmd_load+0xd0>  // b.any
    40003ec8:	39400680 	ldrb	w0, [x20, #1]
    40003ecc:	34fffc80 	cbz	w0, 40003e5c <cmd_load+0xd0>
			shell_print(sh, "Unknown option \"%s\"", arg);
    40003ed0:	aa1403e3 	mov	x3, x20
    40003ed4:	aa1603e0 	mov	x0, x22
    40003ed8:	f0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40003edc:	913c4442 	add	x2, x2, #0xf11
    40003ee0:	52800101 	mov	w1, #0x8                   	// #8
    40003ee4:	9400061b 	bl	40005750 <shell_fprintf>
    40003ee8:	17ffffd3 	b	40003e34 <cmd_load+0xa8>

0000000040003eec <uart_irq_tx_disable>:
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	if (api->irq_tx_disable != NULL) {
    40003eec:	f9400801 	ldr	x1, [x0, #16]
    40003ef0:	f9402021 	ldr	x1, [x1, #64]
    40003ef4:	b4000061 	cbz	x1, 40003f00 <uart_irq_tx_disable+0x14>
		api->irq_tx_disable(dev);
    40003ef8:	aa0103f0 	mov	x16, x1
    40003efc:	d61f0200 	br	x16
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_disable(dev);
}
    40003f00:	d65f03c0 	ret

0000000040003f04 <uninit>:

	return 0;
}

static int uninit(const struct shell_transport *transport)
{
    40003f04:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003f08:	910003fd 	mov	x29, sp
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN)) {
		const struct device *dev = sh_uart->ctrl_blk->dev;
    40003f0c:	f9400400 	ldr	x0, [x0, #8]
    40003f10:	f9400000 	ldr	x0, [x0]
{
    40003f14:	f9000bf3 	str	x19, [sp, #16]
		const struct device *dev = sh_uart->ctrl_blk->dev;
    40003f18:	f9400013 	ldr	x19, [x0]

		uart_irq_tx_disable(dev);
    40003f1c:	aa1303e0 	mov	x0, x19
    40003f20:	97fffff3 	bl	40003eec <uart_irq_tx_disable>
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	if (api->irq_rx_disable != NULL) {
    40003f24:	f9400a60 	ldr	x0, [x19, #16]
    40003f28:	f9402c01 	ldr	x1, [x0, #88]
    40003f2c:	b4000061 	cbz	x1, 40003f38 <uninit+0x34>
		api->irq_rx_disable(dev);
    40003f30:	aa1303e0 	mov	x0, x19
    40003f34:	d63f0020 	blr	x1
	} else {
		k_timer_stop(sh_uart->timer);
	}

	return 0;
}
    40003f38:	52800000 	mov	w0, #0x0                   	// #0
    40003f3c:	f9400bf3 	ldr	x19, [sp, #16]
    40003f40:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003f44:	d65f03c0 	ret

0000000040003f48 <enable>:

static int enable(const struct shell_transport *transport, bool blocking_tx)
{
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
    40003f48:	f9400400 	ldr	x0, [x0, #8]
{
    40003f4c:	12001c21 	and	w1, w1, #0xff
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
    40003f50:	f9400000 	ldr	x0, [x0]
    40003f54:	39008001 	strb	w1, [x0, #32]

	if (blocking_tx) {
    40003f58:	34000101 	cbz	w1, 40003f78 <enable+0x30>
{
    40003f5c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40003f60:	910003fd 	mov	x29, sp
#ifdef CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
    40003f64:	f9400000 	ldr	x0, [x0]
    40003f68:	97ffffe1 	bl	40003eec <uart_irq_tx_disable>
#endif
	}

	return 0;
}
    40003f6c:	52800000 	mov	w0, #0x0                   	// #0
    40003f70:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40003f74:	d65f03c0 	ret
    40003f78:	52800000 	mov	w0, #0x0                   	// #0
    40003f7c:	d65f03c0 	ret

0000000040003f80 <read>:
	return 0;
}

static int read(const struct shell_transport *transport,
		void *data, size_t length, size_t *cnt)
{
    40003f80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003f84:	910003fd 	mov	x29, sp
	struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
    40003f88:	f9400400 	ldr	x0, [x0, #8]
    40003f8c:	f9400c00 	ldr	x0, [x0, #24]
{
    40003f90:	f9000bf3 	str	x19, [sp, #16]
    40003f94:	aa0303f3 	mov	x19, x3
	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
    40003f98:	97fffbc8 	bl	40002eb8 <ring_buf_get>
    40003f9c:	2a0003e0 	mov	w0, w0
    40003fa0:	f9000260 	str	x0, [x19]

	return 0;
}
    40003fa4:	52800000 	mov	w0, #0x0                   	// #0
    40003fa8:	f9400bf3 	ldr	x19, [sp, #16]
    40003fac:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003fb0:	d65f03c0 	ret

0000000040003fb4 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_SMP_SHELL */
};

static int enable_shell_uart(const struct device *arg)
{
    40003fb4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003fb8:	910003fd 	mov	x29, sp
    40003fbc:	f9000bf3 	str	x19, [sp, #16]
    40003fc0:	d0000053 	adrp	x19, 4000d000 <__rodata_region_start>
    40003fc4:	91018273 	add	x19, x19, #0x60
    40003fc8:	aa1303e0 	mov	x0, x19
    40003fcc:	94001683 	bl	400099d8 <z_device_ready>
    40003fd0:	72001c1f 	tst	w0, #0xff
    40003fd4:	540001a0 	b.eq	40004008 <enable_shell_uart+0x54>  // b.none

	if (IS_ENABLED(CONFIG_MCUMGR_SMP_SHELL)) {
		smp_shell_init();
	}

	shell_init(&shell_uart, dev, cfg_flags, log_backend, level);
    40003fd8:	f0000040 	adrp	x0, 4000e000 <mmu_regions+0x38>
    40003fdc:	b94a5402 	ldr	w2, [x0, #2644]
    40003fe0:	aa1303e1 	mov	x1, x19
    40003fe4:	52800004 	mov	w4, #0x0                   	// #0
    40003fe8:	52800023 	mov	w3, #0x1                   	// #1
    40003fec:	d0000040 	adrp	x0, 4000d000 <__rodata_region_start>
    40003ff0:	913a0000 	add	x0, x0, #0xe80
    40003ff4:	940004e9 	bl	40005398 <shell_init>

	return 0;
    40003ff8:	52800000 	mov	w0, #0x0                   	// #0
}
    40003ffc:	f9400bf3 	ldr	x19, [sp, #16]
    40004000:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004004:	d65f03c0 	ret
		return -ENODEV;
    40004008:	12800240 	mov	w0, #0xffffffed            	// #-19
    4000400c:	17fffffc 	b	40003ffc <enable_shell_uart+0x48>

0000000040004010 <write>:
{
    40004010:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40004014:	910003fd 	mov	x29, sp
    40004018:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000401c:	aa0303f6 	mov	x22, x3
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
    40004020:	f9400415 	ldr	x21, [x0, #8]
{
    40004024:	a90153f3 	stp	x19, x20, [sp, #16]
    40004028:	aa0203f4 	mov	x20, x2
		!sh_uart->ctrl_blk->blocking_tx) {
    4000402c:	f94002a0 	ldr	x0, [x21]
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
    40004030:	39408000 	ldrb	w0, [x0, #32]
{
    40004034:	f9001bf7 	str	x23, [sp, #48]
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
    40004038:	34000160 	cbz	w0, 40004064 <write+0x54>
    4000403c:	aa0103f3 	mov	x19, x1
    40004040:	8b020037 	add	x23, x1, x2
		for (size_t i = 0; i < length; i++) {
    40004044:	eb17027f 	cmp	x19, x23
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
    40004048:	f94002a0 	ldr	x0, [x21]
		for (size_t i = 0; i < length; i++) {
    4000404c:	54000361 	b.ne	400040b8 <write+0xa8>  // b.any
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    40004050:	a9408402 	ldp	x2, x1, [x0, #8]
		*cnt = length;
    40004054:	f90002d4 	str	x20, [x22]
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    40004058:	52800020 	mov	w0, #0x1                   	// #1
    4000405c:	d63f0040 	blr	x2
    40004060:	14000010 	b	400040a0 <write+0x90>
	*cnt = ring_buf_put(sh_uart->tx_ringbuf, data, length);
    40004064:	f9400aa0 	ldr	x0, [x21, #16]
    40004068:	97fffb2e 	bl	40002d20 <ring_buf_put>
    4000406c:	2a0003e0 	mov	w0, w0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    40004070:	f94002a1 	ldr	x1, [x21]
    40004074:	f90002c0 	str	x0, [x22]
    40004078:	d2800020 	mov	x0, #0x1                   	// #1
    4000407c:	91006021 	add	x1, x1, #0x18
    40004080:	97fff3c4 	bl	40000f90 <__aarch64_swp8_acq_rel>
	if (atomic_set(&sh_uart->ctrl_blk->tx_busy, 1) == 0) {
    40004084:	b50000e0 	cbnz	x0, 400040a0 <write+0x90>
		uart_irq_tx_enable(sh_uart->ctrl_blk->dev);
    40004088:	f94002a0 	ldr	x0, [x21]
    4000408c:	f9400000 	ldr	x0, [x0]
	if (api->irq_tx_enable != NULL) {
    40004090:	f9400801 	ldr	x1, [x0, #16]
    40004094:	f9401c21 	ldr	x1, [x1, #56]
    40004098:	b4000041 	cbz	x1, 400040a0 <write+0x90>
		api->irq_tx_enable(dev);
    4000409c:	d63f0020 	blr	x1
}
    400040a0:	52800000 	mov	w0, #0x0                   	// #0
    400040a4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400040a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400040ac:	f9401bf7 	ldr	x23, [sp, #48]
    400040b0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400040b4:	d65f03c0 	ret
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
    400040b8:	38401661 	ldrb	w1, [x19], #1
    400040bc:	f9400000 	ldr	x0, [x0]
	api->poll_out(dev, out_char);
    400040c0:	f9400802 	ldr	x2, [x0, #16]
    400040c4:	f9400442 	ldr	x2, [x2, #8]
    400040c8:	d63f0040 	blr	x2
		for (size_t i = 0; i < length; i++) {
    400040cc:	17ffffde 	b	40004044 <write+0x34>

00000000400040d0 <init>:
{
    400040d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400040d4:	910003fd 	mov	x29, sp
    400040d8:	a90153f3 	stp	x19, x20, [sp, #16]
    400040dc:	aa0103f3 	mov	x19, x1
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
    400040e0:	f9400414 	ldr	x20, [x0, #8]
	sh_uart->ctrl_blk->dev = (const struct device *)config;
    400040e4:	f9400280 	ldr	x0, [x20]
	sh_uart->ctrl_blk->handler = evt_handler;
    400040e8:	a9000801 	stp	x1, x2, [x0]
 */
static inline void ring_buf_reset(struct ring_buf *buf)
{
	buf->head = 0;
	buf->tail = 0;
	memset(&buf->misc, 0, sizeof(buf->misc));
    400040ec:	d2800102 	mov	x2, #0x8                   	// #8
    400040f0:	52800001 	mov	w1, #0x0                   	// #0
	sh_uart->ctrl_blk->context = context;
    400040f4:	f9000803 	str	x3, [x0, #16]
	buf->head = 0;
    400040f8:	f9400a80 	ldr	x0, [x20, #16]
    400040fc:	f800841f 	str	xzr, [x0], #8
	memset(&buf->misc, 0, sizeof(buf->misc));
    40004100:	94001320 	bl	40008d80 <memset>
	buf->head = 0;
    40004104:	f9400e80 	ldr	x0, [x20, #24]
	memset(&buf->misc, 0, sizeof(buf->misc));
    40004108:	d2800102 	mov	x2, #0x8                   	// #8
    4000410c:	52800001 	mov	w1, #0x0                   	// #0
	buf->head = 0;
    40004110:	f800841f 	str	xzr, [x0], #8
	memset(&buf->misc, 0, sizeof(buf->misc));
    40004114:	9400131b 	bl	40008d80 <memset>
	sh_uart->ctrl_blk->tx_busy = 0;
    40004118:	f9400280 	ldr	x0, [x20]
    4000411c:	f9000c1f 	str	xzr, [x0, #24]
static inline void uart_irq_callback_user_data_set(const struct device *dev,
						   uart_irq_callback_user_data_t cb,
						   void *user_data)
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    40004120:	f9400a60 	ldr	x0, [x19, #16]
		(const struct uart_driver_api *)dev->api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    40004124:	b4000100 	cbz	x0, 40004144 <init+0x74>
    40004128:	f9404803 	ldr	x3, [x0, #144]
    4000412c:	b40000c3 	cbz	x3, 40004144 <init+0x74>
		api->irq_callback_set(dev, cb, user_data);
    40004130:	90000001 	adrp	x1, 40004000 <enable_shell_uart+0x4c>
    40004134:	9105a021 	add	x1, x1, #0x168
    40004138:	aa1403e2 	mov	x2, x20
    4000413c:	aa1303e0 	mov	x0, x19
    40004140:	d63f0060 	blr	x3
	if (api->irq_rx_enable != NULL) {
    40004144:	f9400a60 	ldr	x0, [x19, #16]
    40004148:	f9402801 	ldr	x1, [x0, #80]
    4000414c:	b4000061 	cbz	x1, 40004158 <init+0x88>
		api->irq_rx_enable(dev);
    40004150:	aa1303e0 	mov	x0, x19
    40004154:	d63f0020 	blr	x1
}
    40004158:	52800000 	mov	w0, #0x0                   	// #0
    4000415c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004160:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004164:	d65f03c0 	ret

0000000040004168 <uart_callback>:
{
    40004168:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000416c:	910003fd 	mov	x29, sp
    40004170:	a90153f3 	stp	x19, x20, [sp, #16]
    40004174:	aa0003f4 	mov	x20, x0
    40004178:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000417c:	aa0103f5 	mov	x21, x1
    40004180:	a90363f7 	stp	x23, x24, [sp, #48]
	if (api->irq_update == NULL) {
    40004184:	f9400801 	ldr	x1, [x0, #16]
    40004188:	f9404421 	ldr	x1, [x1, #136]
    4000418c:	b4000041 	cbz	x1, 40004194 <uart_callback+0x2c>
	return api->irq_update(dev);
    40004190:	d63f0020 	blr	x1
	if (api->irq_rx_ready == NULL) {
    40004194:	f9400a80 	ldr	x0, [x20, #16]
    40004198:	f9403401 	ldr	x1, [x0, #104]
    4000419c:	b50003e1 	cbnz	x1, 40004218 <uart_callback+0xb0>
    400041a0:	52800017 	mov	w23, #0x0                   	// #0
	return api->fifo_read(dev, rx_data, size);
    400041a4:	52800038 	mov	w24, #0x1                   	// #1
		len = ring_buf_put_claim(sh_uart->rx_ringbuf, &data,
    400041a8:	f9400ea0 	ldr	x0, [x21, #24]
    400041ac:	910123e1 	add	x1, sp, #0x48
    400041b0:	b9401002 	ldr	w2, [x0, #16]
    400041b4:	97fffaaa 	bl	40002c5c <ring_buf_put_claim>
    400041b8:	2a0003f6 	mov	w22, w0
		if (len > 0) {
    400041bc:	f9400a80 	ldr	x0, [x20, #16]
    400041c0:	34000536 	cbz	w22, 40004264 <uart_callback+0xfc>
	if (api->fifo_read == NULL) {
    400041c4:	f9401803 	ldr	x3, [x0, #48]
			rd_len = uart_fifo_read(dev, data, len);
    400041c8:	f94027e1 	ldr	x1, [sp, #72]
    400041cc:	b4000483 	cbz	x3, 4000425c <uart_callback+0xf4>
	return api->fifo_read(dev, rx_data, size);
    400041d0:	2a1603e2 	mov	w2, w22
    400041d4:	aa1403e0 	mov	x0, x20
    400041d8:	d63f0060 	blr	x3
    400041dc:	2a0003f3 	mov	w19, w0
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
    400041e0:	f9400ea0 	ldr	x0, [x21, #24]
				new_data = true;
    400041e4:	7100027f 	cmp	w19, #0x0
    400041e8:	1a9802f7 	csel	w23, w23, w24, eq  // eq = none
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
    400041ec:	2a1303e1 	mov	w1, w19
    400041f0:	97fffab2 	bl	40002cb8 <ring_buf_put_finish>
	} while (rd_len && (rd_len == len));
    400041f4:	7100027f 	cmp	w19, #0x0
    400041f8:	7a5312c0 	ccmp	w22, w19, #0x0, ne  // ne = any
    400041fc:	54fffd60 	b.eq	400041a8 <uart_callback+0x40>  // b.none
	if (new_data) {
    40004200:	34000137 	cbz	w23, 40004224 <uart_callback+0xbc>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
    40004204:	f94002a0 	ldr	x0, [x21]
    40004208:	a9408402 	ldp	x2, x1, [x0, #8]
    4000420c:	52800000 	mov	w0, #0x0                   	// #0
    40004210:	d63f0040 	blr	x2
}
    40004214:	14000004 	b	40004224 <uart_callback+0xbc>
	return api->irq_rx_ready(dev);
    40004218:	aa1403e0 	mov	x0, x20
    4000421c:	d63f0020 	blr	x1
	if (uart_irq_rx_ready(dev)) {
    40004220:	35fffc00 	cbnz	w0, 400041a0 <uart_callback+0x38>
	if (api->irq_tx_ready == NULL) {
    40004224:	f9400a80 	ldr	x0, [x20, #16]
    40004228:	f9402401 	ldr	x1, [x0, #72]
    4000422c:	b5000301 	cbnz	x1, 4000428c <uart_callback+0x124>
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (uint8_t **)&data,
    40004230:	f9400aa0 	ldr	x0, [x21, #16]
    40004234:	910123e1 	add	x1, sp, #0x48
    40004238:	b9401002 	ldr	w2, [x0, #16]
    4000423c:	97fffad9 	bl	40002da0 <ring_buf_get_claim>
    40004240:	2a0003e2 	mov	w2, w0
	if (len) {
    40004244:	35000340 	cbnz	w0, 400042ac <uart_callback+0x144>
		uart_irq_tx_disable(dev);
    40004248:	aa1403e0 	mov	x0, x20
    4000424c:	97ffff28 	bl	40003eec <uart_irq_tx_disable>
		sh_uart->ctrl_blk->tx_busy = 0;
    40004250:	f94002a0 	ldr	x0, [x21]
    40004254:	f9000c1f 	str	xzr, [x0, #24]
    40004258:	1400001e 	b	400042d0 <uart_callback+0x168>
		return -ENOSYS;
    4000425c:	12800af3 	mov	w19, #0xffffffa8            	// #-88
    40004260:	17ffffe0 	b	400041e0 <uart_callback+0x78>
	if (api->fifo_read == NULL) {
    40004264:	f9401803 	ldr	x3, [x0, #48]
    40004268:	b40000e3 	cbz	x3, 40004284 <uart_callback+0x11c>
	return api->fifo_read(dev, rx_data, size);
    4000426c:	91011fe1 	add	x1, sp, #0x47
    40004270:	aa1403e0 	mov	x0, x20
    40004274:	52800022 	mov	w2, #0x1                   	// #1
    40004278:	d63f0060 	blr	x3
    4000427c:	2a0003f3 	mov	w19, w0
    40004280:	17ffffdd 	b	400041f4 <uart_callback+0x8c>
		return -ENOSYS;
    40004284:	12800af3 	mov	w19, #0xffffffa8            	// #-88
    40004288:	17ffffdb 	b	400041f4 <uart_callback+0x8c>
	return api->irq_tx_ready(dev);
    4000428c:	aa1403e0 	mov	x0, x20
    40004290:	d63f0020 	blr	x1
	if (uart_irq_tx_ready(dev)) {
    40004294:	35fffce0 	cbnz	w0, 40004230 <uart_callback+0xc8>
}
    40004298:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000429c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400042a0:	a94363f7 	ldp	x23, x24, [sp, #48]
    400042a4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    400042a8:	d65f03c0 	ret
	if (api->fifo_fill == NULL) {
    400042ac:	f9400a80 	ldr	x0, [x20, #16]
		len = uart_fifo_fill(dev, data, len);
    400042b0:	f94027e1 	ldr	x1, [sp, #72]
    400042b4:	f9401403 	ldr	x3, [x0, #40]
    400042b8:	b4000163 	cbz	x3, 400042e4 <uart_callback+0x17c>
	return api->fifo_fill(dev, tx_data, size);
    400042bc:	aa1403e0 	mov	x0, x20
    400042c0:	d63f0060 	blr	x3
    400042c4:	2a0003e1 	mov	w1, w0
		err = ring_buf_get_finish(sh_uart->tx_ringbuf, len);
    400042c8:	f9400aa0 	ldr	x0, [x21, #16]
    400042cc:	97fffadc 	bl	40002e3c <ring_buf_get_finish>
	sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    400042d0:	f94002a0 	ldr	x0, [x21]
    400042d4:	a9408402 	ldp	x2, x1, [x0, #8]
    400042d8:	52800020 	mov	w0, #0x1                   	// #1
    400042dc:	d63f0040 	blr	x2
}
    400042e0:	17ffffee 	b	40004298 <uart_callback+0x130>
		return -ENOSYS;
    400042e4:	12800ae1 	mov	w1, #0xffffffa8            	// #-88
    400042e8:	17fffff8 	b	400042c8 <uart_callback+0x160>

00000000400042ec <atomic_or>:
 * @param value Value to OR.
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
    400042ec:	aa0003e2 	mov	x2, x0
    400042f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400042f4:	aa0103e0 	mov	x0, x1
    400042f8:	910003fd 	mov	x29, sp
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    400042fc:	aa0203e1 	mov	x1, x2
    40004300:	97fff33c 	bl	40000ff0 <__aarch64_ldset8_acq_rel>
}
    40004304:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004308:	d65f03c0 	ret

000000004000430c <atomic_and>:
 * @param value Value to AND.
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
    4000430c:	aa0103e2 	mov	x2, x1
    40004310:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    40004314:	aa0003e1 	mov	x1, x0
{
    40004318:	910003fd 	mov	x29, sp
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4000431c:	aa2203e0 	mvn	x0, x2
    40004320:	97fff328 	bl	40000fc0 <__aarch64_ldclr8_acq_rel>
}
    40004324:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004328:	d65f03c0 	ret

000000004000432c <shell_signal_handle>:
typedef void (*shell_signal_handler_t)(const struct shell *shell);

static void shell_signal_handle(const struct shell *shell,
				enum shell_signal sig_idx,
				shell_signal_handler_t handler)
{
    4000432c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    40004330:	2a0103e1 	mov	w1, w1
{
    40004334:	910003fd 	mov	x29, sp
    40004338:	a90153f3 	stp	x19, x20, [sp, #16]
    4000433c:	aa0003f3 	mov	x19, x0
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    40004340:	d2800300 	mov	x0, #0x18                  	// #24
    40004344:	9b007c21 	mul	x1, x1, x0
    40004348:	f9400a74 	ldr	x20, [x19, #16]
    4000434c:	910b2021 	add	x1, x1, #0x2c8
{
    40004350:	f90013f5 	str	x21, [sp, #32]
    40004354:	aa0203f5 	mov	x21, x2
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    40004358:	8b010294 	add	x20, x20, x1
		arch_syscall_invoke3(*(uintptr_t *)&sig, *(uintptr_t *)&signaled, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_CHECK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_check(sig, signaled, result);
    4000435c:	aa1403e0 	mov	x0, x20
    40004360:	9100f3e2 	add	x2, sp, #0x3c
    40004364:	9100e3e1 	add	x1, sp, #0x38
    40004368:	94001e2b 	bl	4000bc14 <z_impl_k_poll_signal_check>
	int set;
	int res;

	k_poll_signal_check(signal, &set, &res);

	if (set) {
    4000436c:	b9403be0 	ldr	w0, [sp, #56]
    40004370:	340000a0 	cbz	w0, 40004384 <shell_signal_handle+0x58>
	z_impl_k_poll_signal_reset(sig);
    40004374:	aa1403e0 	mov	x0, x20
    40004378:	94001e25 	bl	4000bc0c <z_impl_k_poll_signal_reset>
		k_poll_signal_reset(signal);
		handler(shell);
    4000437c:	aa1303e0 	mov	x0, x19
    40004380:	d63f02a0 	blr	x21
	}
}
    40004384:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004388:	f94013f5 	ldr	x21, [sp, #32]
    4000438c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40004390:	d65f03c0 	ret

0000000040004394 <z_shell_strlen>:
void z_shell_multiline_data_calc(struct shell_multiline_cons *cons,
				 uint16_t buff_pos, uint16_t buff_len);

static inline uint16_t z_shell_strlen(const char *str)
{
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40004394:	b40000e0 	cbz	x0, 400043b0 <z_shell_strlen+0x1c>
{
    40004398:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000439c:	910003fd 	mov	x29, sp
	return str == NULL ? 0U : (uint16_t)strlen(str);
    400043a0:	9400122d 	bl	40008c54 <strlen>
    400043a4:	12003c00 	and	w0, w0, #0xffff
}
    400043a8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400043ac:	d65f03c0 	ret
	return str == NULL ? 0U : (uint16_t)strlen(str);
    400043b0:	52800000 	mov	w0, #0x0                   	// #0
}
    400043b4:	d65f03c0 	ret

00000000400043b8 <z_shell_raw_fprintf>:
extern "C" {
#endif

static inline void z_shell_raw_fprintf(const struct shell_fprintf *const ctx,
				       const char *fmt, ...)
{
    400043b8:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    400043bc:	910003fd 	mov	x29, sp
    400043c0:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_list args;

	va_start(args, fmt);
    400043c4:	910403e2 	add	x2, sp, #0x100
    400043c8:	a9030be2 	stp	x2, x2, [sp, #48]
    400043cc:	910343e2 	add	x2, sp, #0xd0
    400043d0:	f90023e2 	str	x2, [sp, #64]
    400043d4:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    400043d8:	b9004be2 	str	w2, [sp, #72]
    400043dc:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    400043e0:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    400043e4:	a9430fe2 	ldp	x2, x3, [sp, #48]
    400043e8:	a9010fe2 	stp	x2, x3, [sp, #16]
    400043ec:	a9440fe2 	ldp	x2, x3, [sp, #64]
    400043f0:	a9020fe2 	stp	x2, x3, [sp, #32]
    400043f4:	910043e2 	add	x2, sp, #0x10
{
    400043f8:	3d8017e0 	str	q0, [sp, #80]
    400043fc:	3d801be1 	str	q1, [sp, #96]
    40004400:	3d801fe2 	str	q2, [sp, #112]
    40004404:	3d8023e3 	str	q3, [sp, #128]
    40004408:	3d8027e4 	str	q4, [sp, #144]
    4000440c:	3d802be5 	str	q5, [sp, #160]
    40004410:	3d802fe6 	str	q6, [sp, #176]
    40004414:	3d8033e7 	str	q7, [sp, #192]
    40004418:	a90e17e4 	stp	x4, x5, [sp, #224]
    4000441c:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40004420:	9400051b 	bl	4000588c <z_shell_fprintf_fmt>
	va_end(args);
}
    40004424:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40004428:	d65f03c0 	ret

000000004000442c <shell_internal_help_print>:
{
    4000442c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40004430:	910003fd 	mov	x29, sp
	z_shell_help_cmd_print(shell, &shell->ctx->active_cmd);
    40004434:	f9400801 	ldr	x1, [x0, #16]
{
    40004438:	f9000bf3 	str	x19, [sp, #16]
    4000443c:	aa0003f3 	mov	x19, x0
	z_shell_help_cmd_print(shell, &shell->ctx->active_cmd);
    40004440:	91004021 	add	x1, x1, #0x10
    40004444:	94000af7 	bl	40007020 <z_shell_help_cmd_print>
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
    40004448:	aa1303e0 	mov	x0, x19
    4000444c:	d0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40004450:	913f1c42 	add	x2, x2, #0xfc7
    40004454:	f9400a61 	ldr	x1, [x19, #16]
}
    40004458:	f9400bf3 	ldr	x19, [sp, #16]
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
    4000445c:	91004021 	add	x1, x1, #0x10
}
    40004460:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
    40004464:	14000aa1 	b	40006ee8 <z_shell_help_subcmd_print>

0000000040004468 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
    40004468:	14001740 	b	4000a168 <z_impl_k_mutex_lock>

000000004000446c <transport_evt_handler>:
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
    4000446c:	f9400821 	ldr	x1, [x1, #16]
    40004470:	7100001f 	cmp	w0, #0x0
    40004474:	910b2022 	add	x2, x1, #0x2c8
    40004478:	910c4021 	add	x1, x1, #0x310
    4000447c:	9a821020 	csel	x0, x1, x2, ne  // ne = any
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sig, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
    40004480:	52800001 	mov	w1, #0x0                   	// #0
    40004484:	14001de9 	b	4000bc28 <z_impl_k_poll_signal_raise>

0000000040004488 <kill_handler>:

static void kill_handler(const struct shell *shell)
{
    40004488:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000448c:	910003fd 	mov	x29, sp
    40004490:	a90153f3 	stp	x19, x20, [sp, #16]
    40004494:	aa0003f3 	mov	x19, x0
	return ret;
}

static inline bool z_flag_processing_get(const struct shell *sh)
{
	return sh->ctx->ctx.flags.processing == 1;
    40004498:	f9400800 	ldr	x0, [x0, #16]
    4000449c:	b942c000 	ldr	w0, [x0, #704]
	if (z_flag_processing_get(shell)) {
    400044a0:	370002e0 	tbnz	w0, #0, 400044fc <kill_handler+0x74>
	err = shell->iface->api->uninit(shell->iface);
    400044a4:	f9400660 	ldr	x0, [x19, #8]
    400044a8:	f9400001 	ldr	x1, [x0]
    400044ac:	f9400421 	ldr	x1, [x1, #8]
    400044b0:	d63f0020 	blr	x1
    400044b4:	2a0003f4 	mov	w20, w0
	if (err != 0) {
    400044b8:	350000a0 	cbnz	w0, 400044cc <kill_handler+0x44>
	z_shell_history_purge(shell->history);
    400044bc:	f9400e60 	ldr	x0, [x19, #24]
    400044c0:	94000c92 	bl	40007708 <z_shell_history_purge>
	shell->ctx->state = state;
    400044c4:	f9400a60 	ldr	x0, [x19, #16]
    400044c8:	b900081f 	str	wzr, [x0, #8]
	int err = instance_uninit(shell);

	if (shell->ctx->uninit_cb) {
    400044cc:	f9400a60 	ldr	x0, [x19, #16]
    400044d0:	f9403002 	ldr	x2, [x0, #96]
    400044d4:	b4000082 	cbz	x2, 400044e4 <kill_handler+0x5c>
		shell->ctx->uninit_cb(shell, err);
    400044d8:	2a1403e1 	mov	w1, w20
    400044dc:	aa1303e0 	mov	x0, x19
    400044e0:	d63f0040 	blr	x2
	}

	shell->ctx->tid = NULL;
    400044e4:	f9400a60 	ldr	x0, [x19, #16]
    400044e8:	f901f41f 	str	xzr, [x0, #1000]
	return z_impl_z_current_get();
    400044ec:	94001a4e 	bl	4000ae24 <z_impl_z_current_get>
	k_thread_abort(k_current_get());
}
    400044f0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400044f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_impl_k_thread_abort(thread);
    400044f8:	14001a97 	b	4000af54 <z_impl_k_thread_abort>
		return -EBUSY;
    400044fc:	128001f4 	mov	w20, #0xfffffff0            	// #-16
    40004500:	17fffff3 	b	400044cc <kill_handler+0x44>

0000000040004504 <z_cursor_next_line_move.isra.0>:
/* Function forcing new line - cannot be replaced with function
 * cursor_down_move.
 */
static inline void z_cursor_next_line_move(const struct shell *sh)
{
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
    40004504:	d0000041 	adrp	x1, 4000e000 <mmu_regions+0x38>
    40004508:	91317421 	add	x1, x1, #0xc5d
    4000450c:	17ffffab 	b	400043b8 <z_shell_raw_fprintf>

0000000040004510 <z_flag_history_exit_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, history_exit, val, ret);
    40004510:	910b0000 	add	x0, x0, #0x2c0
    40004514:	72001c3f 	tst	w1, #0xff
    40004518:	54000060 	b.eq	40004524 <z_flag_history_exit_set.isra.0+0x14>  // b.none
    4000451c:	d2800081 	mov	x1, #0x4                   	// #4
    40004520:	17ffff73 	b	400042ec <atomic_or>
    40004524:	12800081 	mov	w1, #0xfffffffb            	// #-5
    40004528:	17ffff79 	b	4000430c <atomic_and>

000000004000452c <history_handle>:
{
    4000452c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40004530:	910003fd 	mov	x29, sp
    40004534:	a90153f3 	stp	x19, x20, [sp, #16]
    40004538:	aa0003f3 	mov	x19, x0
    4000453c:	12001c34 	and	w20, w1, #0xff
	return sh->ctx->ctx.flags.history_exit == 1;
    40004540:	f9400800 	ldr	x0, [x0, #16]
    40004544:	b942c001 	ldr	w1, [x0, #704]
	if (z_flag_history_exit_get(shell)) {
    40004548:	361000a1 	tbz	w1, #2, 4000455c <history_handle+0x30>
		z_flag_history_exit_set(shell, false);
    4000454c:	52800001 	mov	w1, #0x0                   	// #0
    40004550:	97fffff0 	bl	40004510 <z_flag_history_exit_set.isra.0>
		z_shell_history_mode_exit(shell->history);
    40004554:	f9400e60 	ldr	x0, [x19, #24]
    40004558:	94000c3f 	bl	40007654 <z_shell_history_mode_exit>
 *
 * @return True if in browsing mode.
 */
static inline bool z_shell_history_active(struct shell_history *history)
{
	return (history->current) ? true : false;
    4000455c:	f9400e60 	ldr	x0, [x19, #24]
	if (!z_shell_history_active(shell->history)) {
    40004560:	f9400c00 	ldr	x0, [x0, #24]
    40004564:	b5000160 	cbnz	x0, 40004590 <history_handle+0x64>
		if (up) {
    40004568:	34000554 	cbz	w20, 40004610 <history_handle+0xe4>
			uint16_t cmd_len = z_shell_strlen(shell->ctx->cmd_buff);
    4000456c:	f9400a60 	ldr	x0, [x19, #16]
    40004570:	91025800 	add	x0, x0, #0x96
    40004574:	97ffff88 	bl	40004394 <z_shell_strlen>
			if (cmd_len) {
    40004578:	72003c1f 	tst	w0, #0xffff
    4000457c:	f9400a60 	ldr	x0, [x19, #16]
    40004580:	540004e0 	b.eq	4000461c <history_handle+0xf0>  // b.none
				strcpy(shell->ctx->temp_buff,
    40004584:	91025801 	add	x1, x0, #0x96
    40004588:	91065800 	add	x0, x0, #0x196
    4000458c:	9400118f 	bl	40008bc8 <strcpy>
	history_mode = z_shell_history_get(shell->history, up,
    40004590:	a9410262 	ldp	x2, x0, [x19, #16]
    40004594:	9100bbe3 	add	x3, sp, #0x2e
    40004598:	2a1403e1 	mov	w1, w20
    4000459c:	91025842 	add	x2, x2, #0x96
    400045a0:	94000c2f 	bl	4000765c <z_shell_history_get>
	if (!history_mode) {
    400045a4:	72001c1f 	tst	w0, #0xff
    400045a8:	54000121 	b.ne	400045cc <history_handle+0xa0>  // b.any
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
    400045ac:	f9400a60 	ldr	x0, [x19, #16]
    400045b0:	91065801 	add	x1, x0, #0x196
    400045b4:	91025800 	add	x0, x0, #0x96
    400045b8:	94001184 	bl	40008bc8 <strcpy>
		len = z_shell_strlen(shell->ctx->cmd_buff);
    400045bc:	f9400a60 	ldr	x0, [x19, #16]
    400045c0:	91025800 	add	x0, x0, #0x96
    400045c4:	97ffff74 	bl	40004394 <z_shell_strlen>
    400045c8:	79005fe0 	strh	w0, [sp, #46]
	z_shell_op_cursor_home_move(shell);
    400045cc:	aa1303e0 	mov	x0, x19
    400045d0:	940007b6 	bl	400064a8 <z_shell_op_cursor_home_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    400045d4:	f9400a60 	ldr	x0, [x19, #16]
    400045d8:	b942b800 	ldr	w0, [x0, #696]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
    400045dc:	362800a0 	tbz	w0, #5, 400045f0 <history_handle+0xc4>
    400045e0:	f9401660 	ldr	x0, [x19, #40]
    400045e4:	b0000041 	adrp	x1, 4000d000 <__rodata_region_start>
    400045e8:	913de021 	add	x1, x1, #0xf78
    400045ec:	97ffff73 	bl	400043b8 <z_shell_raw_fprintf>
	z_shell_print_cmd(shell);
    400045f0:	aa1303e0 	mov	x0, x19
    400045f4:	940007e2 	bl	4000657c <z_shell_print_cmd>
	shell->ctx->cmd_buff_pos = len;
    400045f8:	f9400a60 	ldr	x0, [x19, #16]
    400045fc:	79405fe1 	ldrh	w1, [sp, #46]
	shell->ctx->cmd_buff_len = len;
    40004600:	79012001 	strh	w1, [x0, #144]
	shell->ctx->cmd_buff_pos = len;
    40004604:	79012401 	strh	w1, [x0, #146]
	z_shell_op_cond_next_line(shell);
    40004608:	aa1303e0 	mov	x0, x19
    4000460c:	94000717 	bl	40006268 <z_shell_op_cond_next_line>
}
    40004610:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004614:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40004618:	d65f03c0 	ret
				shell->ctx->temp_buff[0] = '\0';
    4000461c:	3906581f 	strb	wzr, [x0, #406]
    40004620:	17ffffdc 	b	40004590 <history_handle+0x64>

0000000040004624 <z_flag_insert_mode_set.isra.0>:
static inline bool z_flag_insert_mode_set(const struct shell *sh, bool val)
    40004624:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
    40004628:	910ae000 	add	x0, x0, #0x2b8
    4000462c:	72001c3f 	tst	w1, #0xff
static inline bool z_flag_insert_mode_set(const struct shell *sh, bool val)
    40004630:	910003fd 	mov	x29, sp
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
    40004634:	540000c0 	b.eq	4000464c <z_flag_insert_mode_set.isra.0+0x28>  // b.none
    40004638:	d2800021 	mov	x1, #0x1                   	// #1
    4000463c:	97ffff2c 	bl	400042ec <atomic_or>
}
    40004640:	12000000 	and	w0, w0, #0x1
    40004644:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004648:	d65f03c0 	ret
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
    4000464c:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    40004650:	97ffff2f 	bl	4000430c <atomic_and>
    40004654:	17fffffb 	b	40004640 <z_flag_insert_mode_set.isra.0+0x1c>

0000000040004658 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
    40004658:	14001719 	b	4000a2bc <z_impl_k_mutex_unlock>

000000004000465c <execute>:
{
    4000465c:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
    40004660:	910003fd 	mov	x29, sp
	char *cmd_buf = shell->ctx->cmd_buff;
    40004664:	f9400801 	ldr	x1, [x0, #16]
{
    40004668:	a90153f3 	stp	x19, x20, [sp, #16]
	char *cmd_buf = shell->ctx->cmd_buff;
    4000466c:	91025821 	add	x1, x1, #0x96
{
    40004670:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004674:	a90363f7 	stp	x23, x24, [sp, #48]
    40004678:	aa0003f7 	mov	x23, x0
    4000467c:	a9046bf9 	stp	x25, x26, [sp, #64]
    40004680:	a90573fb 	stp	x27, x28, [sp, #80]
	char *cmd_buf = shell->ctx->cmd_buff;
    40004684:	f9003be1 	str	x1, [sp, #112]
	size_t argc = 0, args_left = SIZE_MAX;
    40004688:	a908ffff 	stp	xzr, xzr, [sp, #136]
	z_shell_op_cursor_end_move(shell);
    4000468c:	9400078b 	bl	400064b8 <z_shell_op_cursor_end_move>
	if (!z_shell_cursor_in_empty_line(shell)) {
    40004690:	aa1703e0 	mov	x0, x23
    40004694:	940006df 	bl	40006210 <z_shell_cursor_in_empty_line>
    40004698:	72001c1f 	tst	w0, #0xff
    4000469c:	54000061 	b.ne	400046a8 <execute+0x4c>  // b.any
		z_cursor_next_line_move(shell);
    400046a0:	f94016e0 	ldr	x0, [x23, #40]
    400046a4:	97ffff98 	bl	40004504 <z_cursor_next_line_move.isra.0>
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
    400046a8:	f9400ae0 	ldr	x0, [x23, #16]
    400046ac:	d2800502 	mov	x2, #0x28                  	// #40
    400046b0:	52800001 	mov	w1, #0x0                   	// #0
		z_shell_wildcard_prepare(shell);
    400046b4:	9103a3f4 	add	x20, sp, #0xe8
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
    400046b8:	91004000 	add	x0, x0, #0x10
    400046bc:	940011b1 	bl	40008d80 <memset>
		z_shell_cmd_trim(shell);
    400046c0:	aa1703e0 	mov	x0, x23
    400046c4:	94000642 	bl	40005fcc <z_shell_cmd_trim>
	z_shell_history_put(shell->history, line, length);
    400046c8:	a94102e1 	ldp	x1, x0, [x23, #16]
				z_shell_fprintf(shell, SHELL_ERROR,
    400046cc:	f000005c 	adrp	x28, 4000f000 <cfg_flags.0+0x5ac>
    400046d0:	910c339c 	add	x28, x28, #0x30c
    400046d4:	aa1403f9 	mov	x25, x20
		help_entry.help = NULL;
    400046d8:	d2800015 	mov	x21, #0x0                   	// #0
	size_t argc = 0, args_left = SIZE_MAX;
    400046dc:	92800013 	mov	x19, #0xffffffffffffffff    	// #-1
	size_t cmd_with_handler_lvl = 0;
    400046e0:	d2800016 	mov	x22, #0x0                   	// #0
		z_shell_wildcard_prepare(shell);
    400046e4:	52800018 	mov	w24, #0x0                   	// #0
    400046e8:	d280001a 	mov	x26, #0x0                   	// #0
    400046ec:	d280001b 	mov	x27, #0x0                   	// #0
	z_shell_history_put(shell->history, line, length);
    400046f0:	79412022 	ldrh	w2, [x1, #144]
    400046f4:	91025821 	add	x1, x1, #0x96
    400046f8:	94000c13 	bl	40007744 <z_shell_history_put>
		z_shell_wildcard_prepare(shell);
    400046fc:	aa1703e0 	mov	x0, x23
    40004700:	94000c88 	bl	40007920 <z_shell_wildcard_prepare>
				z_shell_fprintf(shell, SHELL_ERROR,
    40004704:	f0000040 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    40004708:	9100d800 	add	x0, x0, #0x36
		z_shell_wildcard_prepare(shell);
    4000470c:	b9006fff 	str	wzr, [sp, #108]
				z_shell_fprintf(shell, SHELL_ERROR,
    40004710:	f9003fe0 	str	x0, [sp, #120]
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
    40004714:	a94887e0 	ldp	x0, x1, [sp, #136]
    40004718:	f100043f 	cmp	x1, #0x1
    4000471c:	54001720 	b.eq	40004a00 <execute+0x3a4>  // b.none
    40004720:	f1002c1f 	cmp	x0, #0xb
    40004724:	54001349 	b.ls	4000498c <execute+0x330>  // b.plast
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
    40004728:	f9404be0 	ldr	x0, [sp, #144]
    4000472c:	f100081f 	cmp	x0, #0x2
    40004730:	54001301 	b.ne	40004990 <execute+0x334>  // b.any
		z_shell_fprintf(shell, SHELL_ERROR, "%s\n",
    40004734:	aa1703e0 	mov	x0, x23
    40004738:	f0000043 	adrp	x3, 4000f000 <cfg_flags.0+0x5ac>
    4000473c:	91012863 	add	x3, x3, #0x4a
    40004740:	d0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40004744:	91362042 	add	x2, x2, #0xd88
    40004748:	52800021 	mov	w1, #0x1                   	// #1
    4000474c:	94000826 	bl	400067e4 <z_shell_fprintf>
		return -ENOEXEC;
    40004750:	1400000b 	b	4000477c <execute+0x120>
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
    40004754:	f9403be2 	ldr	x2, [sp, #112]
    40004758:	aa1403e1 	mov	x1, x20
    4000475c:	52800043 	mov	w3, #0x2                   	// #2
    40004760:	910243e0 	add	x0, sp, #0x90
    40004764:	940004ac 	bl	40005a14 <z_shell_make_argv>
    40004768:	12001c03 	and	w3, w0, #0xff
		if (argc == 0) {
    4000476c:	f9404be1 	ldr	x1, [sp, #144]
		cmd_buf = (char *)argvp[1];
    40004770:	f9400680 	ldr	x0, [x20, #8]
    40004774:	f9003be0 	str	x0, [sp, #112]
		if (argc == 0) {
    40004778:	b5000141 	cbnz	x1, 400047a0 <execute+0x144>
			return -ENOEXEC;
    4000477c:	128000f3 	mov	w19, #0xfffffff8            	// #-8
}
    40004780:	2a1303e0 	mov	w0, w19
    40004784:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004788:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000478c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40004790:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40004794:	a94573fb 	ldp	x27, x28, [sp, #80]
    40004798:	a8d57bfd 	ldp	x29, x30, [sp], #336
    4000479c:	d65f03c0 	ret
		} else if ((argc == 1) && (quote != 0)) {
    400047a0:	f100043f 	cmp	x1, #0x1
    400047a4:	540000e1 	b.ne	400047c0 <execute+0x164>  // b.any
    400047a8:	340000c3 	cbz	w3, 400047c0 <execute+0x164>
			z_shell_fprintf(shell, SHELL_ERROR,
    400047ac:	aa1703e0 	mov	x0, x23
    400047b0:	d0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400047b4:	913f5442 	add	x2, x2, #0xfd5
    400047b8:	9400080b 	bl	400067e4 <z_shell_fprintf>
    400047bc:	17fffff0 	b	4000477c <execute+0x120>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
    400047c0:	f94047e0 	ldr	x0, [sp, #136]
    400047c4:	b4000520 	cbz	x0, 40004868 <execute+0x20c>
		    z_shell_help_request(argvp[0])) {
    400047c8:	f9400280 	ldr	x0, [x20]
    400047cc:	94000a35 	bl	400070a0 <z_shell_help_request>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
    400047d0:	72001c1f 	tst	w0, #0xff
    400047d4:	540002a0 	b.eq	40004828 <execute+0x1cc>  // b.none
			if (help_entry.help) {
    400047d8:	b40001d5 	cbz	x21, 40004810 <execute+0x1b4>
				shell->ctx->active_cmd = help_entry;
    400047dc:	f9400ae1 	ldr	x1, [x23, #16]
    400047e0:	f90067f5 	str	x21, [sp, #200]
    400047e4:	91004020 	add	x0, x1, #0x10
    400047e8:	a94c0fe2 	ldp	x2, x3, [sp, #192]
    400047ec:	a9010c22 	stp	x2, x3, [x1, #16]
    400047f0:	a94d0fe2 	ldp	x2, x3, [sp, #208]
    400047f4:	a9020c22 	stp	x2, x3, [x1, #32]
    400047f8:	f94073e1 	ldr	x1, [sp, #224]
    400047fc:	f9001001 	str	x1, [x0, #32]
			shell_internal_help_print(shell);
    40004800:	aa1703e0 	mov	x0, x23
			return SHELL_CMD_HELP_PRINTED;
    40004804:	52800033 	mov	w19, #0x1                   	// #1
			shell_internal_help_print(shell);
    40004808:	97ffff09 	bl	4000442c <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
    4000480c:	17ffffdd 	b	40004780 <execute+0x124>
			z_shell_fprintf(shell, SHELL_ERROR,
    40004810:	d0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40004814:	913fa442 	add	x2, x2, #0xfe9
		z_shell_fprintf(shell, SHELL_ERROR,
    40004818:	aa1703e0 	mov	x0, x23
    4000481c:	52800021 	mov	w1, #0x1                   	// #1
    40004820:	940007f1 	bl	400067e4 <z_shell_fprintf>
		return false;
    40004824:	17ffffd6 	b	4000477c <execute+0x120>
		if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {
    40004828:	f94047e0 	ldr	x0, [sp, #136]
    4000482c:	b40001e0 	cbz	x0, 40004868 <execute+0x20c>
			status = z_shell_wildcard_process(shell, entry,
    40004830:	f9400282 	ldr	x2, [x20]
    40004834:	aa1a03e1 	mov	x1, x26
    40004838:	aa1703e0 	mov	x0, x23
    4000483c:	94000c57 	bl	40007998 <z_shell_wildcard_process>
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
    40004840:	7100081f 	cmp	w0, #0x2
    40004844:	54000de0 	b.eq	40004a00 <execute+0x3a4>  // b.none
			if (status != SHELL_WILDCARD_NOT_FOUND) {
    40004848:	71000c1f 	cmp	w0, #0x3
    4000484c:	540000e0 	b.eq	40004868 <execute+0x20c>  // b.none
				++cmd_lvl;
    40004850:	f94047e0 	ldr	x0, [sp, #136]
    40004854:	91000400 	add	x0, x0, #0x1
    40004858:	f90047e0 	str	x0, [sp, #136]
				wildcard_found = true;
    4000485c:	52800020 	mov	w0, #0x1                   	// #1
    40004860:	b9006fe0 	str	w0, [sp, #108]
				continue;
    40004864:	17ffffac 	b	40004714 <execute+0xb8>
		if (has_last_handler == false) {
    40004868:	350000d8 	cbnz	w24, 40004880 <execute+0x224>
			entry = z_shell_find_cmd(parent, argvp[0], &dloc);
    4000486c:	f9400281 	ldr	x1, [x20]
    40004870:	910263e2 	add	x2, sp, #0x98
    40004874:	aa1b03e0 	mov	x0, x27
    40004878:	94000559 	bl	40005ddc <z_shell_find_cmd>
    4000487c:	aa0003fa 	mov	x26, x0
		argvp++;
    40004880:	91002294 	add	x20, x20, #0x8
		args_left--;
    40004884:	d1000673 	sub	x19, x19, #0x1
		if (entry) {
    40004888:	b400065a 	cbz	x26, 40004950 <execute+0x2f4>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && found && entry->handler) {
    4000488c:	b9406fe1 	ldr	w1, [sp, #108]
    40004890:	f9400f40 	ldr	x0, [x26, #24]
    40004894:	34000121 	cbz	w1, 400048b8 <execute+0x25c>
    40004898:	b4000380 	cbz	x0, 40004908 <execute+0x2ac>
		z_shell_op_cursor_end_move(shell);
    4000489c:	aa1703e0 	mov	x0, x23
    400048a0:	94000706 	bl	400064b8 <z_shell_op_cursor_end_move>
		z_shell_op_cond_next_line(shell);
    400048a4:	aa1703e0 	mov	x0, x23
    400048a8:	94000670 	bl	40006268 <z_shell_op_cond_next_line>
		z_shell_fprintf(shell, SHELL_ERROR,
    400048ac:	f0000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    400048b0:	91001c42 	add	x2, x2, #0x7
    400048b4:	17ffffd9 	b	40004818 <execute+0x1bc>
	if (entry->handler) {
    400048b8:	b4000280 	cbz	x0, 40004908 <execute+0x2ac>
		*active_cmd = *entry;
    400048bc:	f9400ae1 	ldr	x1, [x23, #16]
    400048c0:	a9400f42 	ldp	x2, x3, [x26]
    400048c4:	91004020 	add	x0, x1, #0x10
    400048c8:	a9010c22 	stp	x2, x3, [x1, #16]
    400048cc:	a9410f42 	ldp	x2, x3, [x26, #16]
    400048d0:	a9020c22 	stp	x2, x3, [x1, #32]
    400048d4:	f9401341 	ldr	x1, [x26, #32]
    400048d8:	f9001001 	str	x1, [x0, #32]
		if ((entry->subcmd == NULL)
    400048dc:	f9400b40 	ldr	x0, [x26, #16]
		*handler_lvl = *lvl;
    400048e0:	f94047f6 	ldr	x22, [sp, #136]
		if ((entry->subcmd == NULL)
    400048e4:	b5000120 	cbnz	x0, 40004908 <execute+0x2ac>
		    && entry->args.optional == SHELL_OPT_ARG_RAW) {
    400048e8:	39408740 	ldrb	w0, [x26, #33]
    400048ec:	7103f81f 	cmp	w0, #0xfe
    400048f0:	540000c1 	b.ne	40004908 <execute+0x2ac>  // b.any
			*args_left = entry->args.mandatory - 1;
    400048f4:	39408353 	ldrb	w19, [x26, #32]
			*lvl = *lvl + 1;
    400048f8:	910006c0 	add	x0, x22, #0x1
    400048fc:	f90047e0 	str	x0, [sp, #136]
			*args_left = entry->args.mandatory - 1;
    40004900:	51000673 	sub	w19, w19, #0x1
    40004904:	93407e73 	sxtw	x19, w19
	if (entry->help) {
    40004908:	f9400740 	ldr	x0, [x26, #8]
    4000490c:	b4000100 	cbz	x0, 4000492c <execute+0x2d0>
		*help_entry = *entry;
    40004910:	a9400f42 	ldp	x2, x3, [x26]
    40004914:	aa0003f5 	mov	x21, x0
    40004918:	a90c0fe2 	stp	x2, x3, [sp, #192]
    4000491c:	a9410f42 	ldp	x2, x3, [x26, #16]
    40004920:	a90d0fe2 	stp	x2, x3, [sp, #208]
    40004924:	f9401341 	ldr	x1, [x26, #32]
    40004928:	f90073e1 	str	x1, [sp, #224]
    4000492c:	aa1a03fb 	mov	x27, x26
		if (args_left || (argc == 2)) {
    40004930:	b5000093 	cbnz	x19, 40004940 <execute+0x2e4>
    40004934:	f9404be0 	ldr	x0, [sp, #144]
    40004938:	f100081f 	cmp	x0, #0x2
    4000493c:	54ffeec1 	b.ne	40004714 <execute+0xb8>  // b.any
			cmd_lvl++;
    40004940:	f94047e0 	ldr	x0, [sp, #136]
    40004944:	91000400 	add	x0, x0, #0x1
    40004948:	f90047e0 	str	x0, [sp, #136]
    4000494c:	17ffff72 	b	40004714 <execute+0xb8>
			if (cmd_lvl == 0 &&
    40004950:	f94047e0 	ldr	x0, [sp, #136]
    40004954:	b5000180 	cbnz	x0, 40004984 <execute+0x328>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
}

static inline bool z_shell_in_select_mode(const struct shell *shell)
{
	return shell->ctx->selected_cmd == NULL ? false : true;
    40004958:	f9400ae0 	ldr	x0, [x23, #16]
    4000495c:	f9401c00 	ldr	x0, [x0, #56]
    40004960:	b4000060 	cbz	x0, 4000496c <execute+0x310>
				(!z_shell_in_select_mode(shell) ||
    40004964:	f9400c00 	ldr	x0, [x0, #24]
    40004968:	b50000e0 	cbnz	x0, 40004984 <execute+0x328>
				z_shell_fprintf(shell, SHELL_ERROR,
    4000496c:	f9403fe4 	ldr	x4, [sp, #120]
    40004970:	aa1c03e2 	mov	x2, x28
    40004974:	f94077e3 	ldr	x3, [sp, #232]
    40004978:	aa1703e0 	mov	x0, x23
    4000497c:	52800021 	mov	w1, #0x1                   	// #1
    40004980:	94000799 	bl	400067e4 <z_shell_fprintf>
			has_last_handler = true;
    40004984:	52800038 	mov	w24, #0x1                   	// #1
    40004988:	17ffffea 	b	40004930 <execute+0x2d4>
		&& args_left > 0) {
    4000498c:	b5ffee53 	cbnz	x19, 40004754 <execute+0xf8>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
    40004990:	b9406fe0 	ldr	w0, [sp, #108]
    40004994:	34000120 	cbz	w0, 400049b8 <execute+0x35c>
		z_shell_wildcard_finalize(shell);
    40004998:	aa1703e0 	mov	x0, x23
    4000499c:	94000c5e 	bl	40007b14 <z_shell_wildcard_finalize>
					shell->ctx->cmd_buff,
    400049a0:	f9400ae2 	ldr	x2, [x23, #16]
		(void)z_shell_make_argv(&cmd_lvl,
    400049a4:	aa1903e1 	mov	x1, x25
    400049a8:	910223e0 	add	x0, sp, #0x88
    400049ac:	52800183 	mov	w3, #0xc                   	// #12
    400049b0:	91025842 	add	x2, x2, #0x96
    400049b4:	94000418 	bl	40005a14 <z_shell_make_argv>
	if (shell->ctx->active_cmd.handler == NULL) {
    400049b8:	f9400ae0 	ldr	x0, [x23, #16]
	argv[cmd_lvl] = NULL;
    400049bc:	f94047f3 	ldr	x19, [sp, #136]
	if (shell->ctx->active_cmd.handler == NULL) {
    400049c0:	f9401401 	ldr	x1, [x0, #40]
	argv[cmd_lvl] = NULL;
    400049c4:	f8337b3f 	str	xzr, [x25, x19, lsl #3]
	if (shell->ctx->active_cmd.handler == NULL) {
    400049c8:	b5000241 	cbnz	x1, 40004a10 <execute+0x3b4>
			if (help_entry->help == NULL) {
    400049cc:	b4ffed95 	cbz	x21, 4000477c <execute+0x120>
			if (help_entry->help != shell->ctx->active_cmd.help) {
    400049d0:	f9400c01 	ldr	x1, [x0, #24]
    400049d4:	eb15003f 	cmp	x1, x21
    400049d8:	54fff140 	b.eq	40004800 <execute+0x1a4>  // b.none
				shell->ctx->active_cmd = *help_entry;
    400049dc:	f90067f5 	str	x21, [sp, #200]
    400049e0:	91004001 	add	x1, x0, #0x10
    400049e4:	a94c0fe2 	ldp	x2, x3, [sp, #192]
    400049e8:	a9010c02 	stp	x2, x3, [x0, #16]
    400049ec:	a94d0fe2 	ldp	x2, x3, [sp, #208]
    400049f0:	a9020c02 	stp	x2, x3, [x0, #32]
    400049f4:	f94073e0 	ldr	x0, [sp, #224]
    400049f8:	f9001020 	str	x0, [x1, #32]
    400049fc:	17ffff81 	b	40004800 <execute+0x1a4>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
    40004a00:	f94047e0 	ldr	x0, [sp, #136]
    40004a04:	f1002c1f 	cmp	x0, #0xb
    40004a08:	54fffc49 	b.ls	40004990 <execute+0x334>  // b.plast
    40004a0c:	17ffff47 	b	40004728 <execute+0xcc>
	if (shell->ctx->active_cmd.args.mandatory) {
    40004a10:	3940c002 	ldrb	w2, [x0, #48]
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
    40004a14:	cb160273 	sub	x19, x19, x22
	if (shell->ctx->active_cmd.args.mandatory) {
    40004a18:	34000282 	cbz	w2, 40004a68 <execute+0x40c>
		uint8_t opt8 = shell->ctx->active_cmd.args.optional;
    40004a1c:	3940c401 	ldrb	w1, [x0, #49]
				UINT16_MAX : opt8;
    40004a20:	529fffe3 	mov	w3, #0xffff                	// #65535
    40004a24:	7103fc3f 	cmp	w1, #0xff
    40004a28:	1a831021 	csel	w1, w1, w3, ne  // ne = any
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
    40004a2c:	eb22027f 	cmp	x19, w2, uxtb
    40004a30:	54000083 	b.cc	40004a40 <execute+0x3e4>  // b.lo, b.ul, b.last
    40004a34:	0b010042 	add	w2, w2, w1
	if (!arg_cnt_ok) {
    40004a38:	eb02027f 	cmp	x19, x2
    40004a3c:	54000169 	b.ls	40004a68 <execute+0x40c>  // b.plast
		z_shell_fprintf(shell, SHELL_ERROR,
    40004a40:	f9400803 	ldr	x3, [x0, #16]
    40004a44:	f0000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40004a48:	9101b842 	add	x2, x2, #0x6e
    40004a4c:	52800021 	mov	w1, #0x1                   	// #1
    40004a50:	aa1703e0 	mov	x0, x23
		return -EINVAL;
    40004a54:	128002b3 	mov	w19, #0xffffffea            	// #-22
		z_shell_fprintf(shell, SHELL_ERROR,
    40004a58:	94000763 	bl	400067e4 <z_shell_fprintf>
			shell_internal_help_print(shell);
    40004a5c:	aa1703e0 	mov	x0, x23
    40004a60:	97fffe73 	bl	4000442c <shell_internal_help_print>
	if (!ret_val) {
    40004a64:	17ffff47 	b	40004780 <execute+0x124>
		z_shell_getopt_init(&shell->ctx->getopt_state);
    40004a68:	9101c000 	add	x0, x0, #0x70
    40004a6c:	9400098f 	bl	400070a8 <z_shell_getopt_init>
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, cmd_ctx, val, ret);
    40004a70:	f9400ae0 	ldr	x0, [x23, #16]
    40004a74:	d2810001 	mov	x1, #0x800                 	// #2048
    40004a78:	910b0000 	add	x0, x0, #0x2c0
    40004a7c:	97fffe1c 	bl	400042ec <atomic_or>
		k_mutex_unlock(&shell->ctx->wr_mtx);
    40004a80:	f9400ae0 	ldr	x0, [x23, #16]
    40004a84:	910f2000 	add	x0, x0, #0x3c8
    40004a88:	97fffef4 	bl	40004658 <k_mutex_unlock.isra.0>
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
    40004a8c:	f9400ae0 	ldr	x0, [x23, #16]
    40004a90:	8b160f22 	add	x2, x25, x22, lsl #3
    40004a94:	aa1303e1 	mov	x1, x19
    40004a98:	f9401403 	ldr	x3, [x0, #40]
    40004a9c:	aa1703e0 	mov	x0, x23
    40004aa0:	d63f0060 	blr	x3
    40004aa4:	2a0003f3 	mov	w19, w0
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40004aa8:	f9400ae0 	ldr	x0, [x23, #16]
    40004aac:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40004ab0:	910f2000 	add	x0, x0, #0x3c8
    40004ab4:	97fffe6d 	bl	40004468 <k_mutex_lock.constprop.0.isra.0>
    40004ab8:	f9400ae0 	ldr	x0, [x23, #16]
    40004abc:	12810001 	mov	w1, #0xfffff7ff            	// #-2049
    40004ac0:	910b0000 	add	x0, x0, #0x2c0
    40004ac4:	97fffe12 	bl	4000430c <atomic_and>
	return ret;
    40004ac8:	17ffff2e 	b	40004780 <execute+0x124>

0000000040004acc <state_set.constprop.0>:
	shell->ctx->state = state;
    40004acc:	f9400801 	ldr	x1, [x0, #16]
    40004ad0:	52800042 	mov	w2, #0x2                   	// #2
    40004ad4:	b9000822 	str	w2, [x1, #8]
	if (state == SHELL_STATE_ACTIVE && !shell->ctx->bypass) {
    40004ad8:	f9403422 	ldr	x2, [x1, #104]
    40004adc:	b50002e2 	cbnz	x2, 40004b38 <state_set.constprop.0+0x6c>
static inline void state_set(const struct shell *shell, enum shell_state state)
    40004ae0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40004ae4:	910003fd 	mov	x29, sp
    40004ae8:	f9000bf3 	str	x19, [sp, #16]
    40004aec:	aa0003f3 	mov	x19, x0
	shell->ctx->cmd_buff_len = 0;
    40004af0:	b900903f 	str	wzr, [x1, #144]
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
    40004af4:	3902583f 	strb	wzr, [x1, #150]
	return sh->ctx->ctx.flags.print_noinit == 1;
    40004af8:	b942c021 	ldr	w1, [x1, #704]
		if (z_flag_print_noinit_get(shell)) {
    40004afc:	36600161 	tbz	w1, #12, 40004b28 <state_set.constprop.0+0x5c>
			z_shell_fprintf(shell, SHELL_WARNING, "%s",
    40004b00:	52800061 	mov	w1, #0x3                   	// #3
    40004b04:	f0000043 	adrp	x3, 4000f000 <cfg_flags.0+0x5ac>
    40004b08:	91022463 	add	x3, x3, #0x89
    40004b0c:	d0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40004b10:	9135f042 	add	x2, x2, #0xd7c
    40004b14:	94000734 	bl	400067e4 <z_shell_fprintf>
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
    40004b18:	f9400a60 	ldr	x0, [x19, #16]
    40004b1c:	12820001 	mov	w1, #0xffffefff            	// #-4097
    40004b20:	910b0000 	add	x0, x0, #0x2c0
    40004b24:	97fffdfa 	bl	4000430c <atomic_and>
		z_shell_print_prompt_and_cmd(shell);
    40004b28:	aa1303e0 	mov	x0, x19
}
    40004b2c:	f9400bf3 	ldr	x19, [sp, #16]
    40004b30:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_shell_print_prompt_and_cmd(shell);
    40004b34:	1400085a 	b	40006c9c <z_shell_print_prompt_and_cmd>
    40004b38:	d65f03c0 	ret

0000000040004b3c <shell_process>:

	return 0;
}

void shell_process(const struct shell *shell)
{
    40004b3c:	a9a67bfd 	stp	x29, x30, [sp, #-416]!
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, processing, val, ret);
    40004b40:	d2800021 	mov	x1, #0x1                   	// #1
    40004b44:	910003fd 	mov	x29, sp
    40004b48:	a90153f3 	stp	x19, x20, [sp, #16]
    40004b4c:	aa0003f3 	mov	x19, x0
    40004b50:	f9400800 	ldr	x0, [x0, #16]
    40004b54:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004b58:	910b0000 	add	x0, x0, #0x2c0
    40004b5c:	a90363f7 	stp	x23, x24, [sp, #48]
    40004b60:	a9046bf9 	stp	x25, x26, [sp, #64]
    40004b64:	a90573fb 	stp	x27, x28, [sp, #80]
    40004b68:	97fffde1 	bl	400042ec <atomic_or>
	__ASSERT_NO_MSG(shell->ctx);

	/* atomically set the processing flag */
	z_flag_processing_set(shell, true);

	switch (shell->ctx->state) {
    40004b6c:	f9400a60 	ldr	x0, [x19, #16]
    40004b70:	b9400800 	ldr	w0, [x0, #8]
    40004b74:	7100081f 	cmp	w0, #0x2
    40004b78:	54000321 	b.ne	40004bdc <shell_process+0xa0>  // b.any
		switch (shell->ctx->receive_state) {
    40004b7c:	d0000040 	adrp	x0, 4000e000 <mmu_regions+0x38>
    40004b80:	91296000 	add	x0, x0, #0xa58
    40004b84:	f90043e0 	str	x0, [sp, #128]
	size_t count = 0;
    40004b88:	f90057ff 	str	xzr, [sp, #168]
		shell_bypass_cb_t bypass = shell->ctx->bypass;
    40004b8c:	f9400a60 	ldr	x0, [x19, #16]
			(void)shell->iface->api->read(shell->iface, buf,
    40004b90:	9102a3e3 	add	x3, sp, #0xa8
		shell_bypass_cb_t bypass = shell->ctx->bypass;
    40004b94:	f9403414 	ldr	x20, [x0, #104]
			(void)shell->iface->api->read(shell->iface, buf,
    40004b98:	f9400660 	ldr	x0, [x19, #8]
    40004b9c:	f9400001 	ldr	x1, [x0]
    40004ba0:	f9401024 	ldr	x4, [x1, #32]
		if (bypass) {
    40004ba4:	b4000314 	cbz	x20, 40004c04 <shell_process+0xc8>
			(void)shell->iface->api->read(shell->iface, buf,
    40004ba8:	d2800202 	mov	x2, #0x10                  	// #16
    40004bac:	9104e3e1 	add	x1, sp, #0x138
    40004bb0:	d63f0080 	blr	x4
			if (count) {
    40004bb4:	f94057e2 	ldr	x2, [sp, #168]
    40004bb8:	b4000122 	cbz	x2, 40004bdc <shell_process+0xa0>
				bypass(shell, buf, count);
    40004bbc:	aa1303e0 	mov	x0, x19
    40004bc0:	9104e3e1 	add	x1, sp, #0x138
    40004bc4:	d63f0280 	blr	x20
				if (!(volatile shell_bypass_cb_t *)shell->ctx->bypass) {
    40004bc8:	f9400a60 	ldr	x0, [x19, #16]
    40004bcc:	f9403400 	ldr	x0, [x0, #104]
    40004bd0:	b5fffde0 	cbnz	x0, 40004b8c <shell_process+0x50>
					state_set(shell, SHELL_STATE_ACTIVE);
    40004bd4:	aa1303e0 	mov	x0, x19
    40004bd8:	97ffffbd 	bl	40004acc <state_set.constprop.0>
    40004bdc:	f9400a60 	ldr	x0, [x19, #16]
    40004be0:	b27f7be1 	mov	x1, #0xfffffffe            	// #4294967294
		break;
	}

	/* atomically clear the processing flag */
	z_flag_processing_set(shell, false);
}
    40004be4:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004be8:	910b0000 	add	x0, x0, #0x2c0
    40004bec:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004bf0:	a94363f7 	ldp	x23, x24, [sp, #48]
    40004bf4:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40004bf8:	a94573fb 	ldp	x27, x28, [sp, #80]
    40004bfc:	a8da7bfd 	ldp	x29, x30, [sp], #416
    40004c00:	17fffdc3 	b	4000430c <atomic_and>
		(void)shell->iface->api->read(shell->iface, &data,
    40004c04:	91029fe1 	add	x1, sp, #0xa7
    40004c08:	d2800022 	mov	x2, #0x1                   	// #1
    40004c0c:	d63f0080 	blr	x4
		if (count == 0) {
    40004c10:	f94057e0 	ldr	x0, [sp, #168]
    40004c14:	b4fffe40 	cbz	x0, 40004bdc <shell_process+0xa0>
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
    40004c18:	39c29fe2 	ldrsb	w2, [sp, #167]
		if (ascii_filter(data) != 0) {
    40004c1c:	39429fe1 	ldrb	w1, [sp, #167]
		switch (shell->ctx->receive_state) {
    40004c20:	f9400a60 	ldr	x0, [x19, #16]
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
    40004c24:	37fffb42 	tbnz	w2, #31, 40004b8c <shell_process+0x50>
		switch (shell->ctx->receive_state) {
    40004c28:	b9400c02 	ldr	w2, [x0, #12]
    40004c2c:	71000c5f 	cmp	w2, #0x3
    40004c30:	54003668 	b.hi	400052fc <shell_process+0x7c0>  // b.pmore
    40004c34:	f94043e3 	ldr	x3, [sp, #128]
    40004c38:	78625862 	ldrh	w2, [x3, w2, uxtw #1]
    40004c3c:	10000063 	adr	x3, 40004c48 <shell_process+0x10c>
    40004c40:	8b22a862 	add	x2, x3, w2, sxth #2
    40004c44:	d61f0040 	br	x2
	if ((data != '\r') && (data != '\n')) {
    40004c48:	7100343f 	cmp	w1, #0xd
    40004c4c:	7a4a1824 	ccmp	w1, #0xa, #0x4, ne  // ne = any
    40004c50:	54000220 	b.eq	40004c94 <shell_process+0x158>  // b.none
	sh->ctx->ctx.flags.last_nl = val;
    40004c54:	79458002 	ldrh	w2, [x0, #704]
    40004c58:	12155c42 	and	w2, w2, #0xfffff807
    40004c5c:	79058002 	strh	w2, [x0, #704]
			switch (data) {
    40004c60:	7100243f 	cmp	w1, #0x9
    40004c64:	54000680 	b.eq	40004d34 <shell_process+0x1f8>  // b.none
    40004c68:	54000448 	b.hi	40004cf0 <shell_process+0x1b4>  // b.pmore
    40004c6c:	34fff901 	cbz	w1, 40004b8c <shell_process+0x50>
    40004c70:	7100203f 	cmp	w1, #0x8
    40004c74:	54002840 	b.eq	4000517c <shell_process+0x640>  // b.none
	return (int)((((unsigned)c) >= ' ') &&
    40004c78:	51008022 	sub	w2, w1, #0x20
				if (isprint((int) data)) {
    40004c7c:	7101785f 	cmp	w2, #0x5e
    40004c80:	540028c8 	b.hi	40005198 <shell_process+0x65c>  // b.pmore
					z_flag_history_exit_set(shell, true);
    40004c84:	52800021 	mov	w1, #0x1                   	// #1
    40004c88:	97fffe22 	bl	40004510 <z_flag_history_exit_set.isra.0>
					z_shell_op_char_insert(shell, data);
    40004c8c:	39429fe1 	ldrb	w1, [sp, #167]
    40004c90:	140000a4 	b	40004f20 <shell_process+0x3e4>
	return sh->ctx->ctx.flags.last_nl;
    40004c94:	b942c002 	ldr	w2, [x0, #704]
	if ((z_flag_last_nl_get(shell) == 0U) ||
    40004c98:	f27d1c5f 	tst	x2, #0x7f8
    40004c9c:	540000a0 	b.eq	40004cb0 <shell_process+0x174>  // b.none
    40004ca0:	b942c002 	ldr	w2, [x0, #704]
    40004ca4:	d3432842 	ubfx	x2, x2, #3, #8
    40004ca8:	6b02003f 	cmp	w1, w2
    40004cac:	54fffda1 	b.ne	40004c60 <shell_process+0x124>  // b.any
	sh->ctx->ctx.flags.last_nl = val;
    40004cb0:	79458002 	ldrh	w2, [x0, #704]
    40004cb4:	331d1c22 	bfi	w2, w1, #3, #8
				if (!shell->ctx->cmd_buff_len) {
    40004cb8:	79412001 	ldrh	w1, [x0, #144]
    40004cbc:	79058002 	strh	w2, [x0, #704]
    40004cc0:	35000121 	cbnz	w1, 40004ce4 <shell_process+0x1a8>
	z_flag_history_exit_set(shell, false);
    40004cc4:	97fffe13 	bl	40004510 <z_flag_history_exit_set.isra.0>
	z_shell_history_mode_exit(shell->history);
    40004cc8:	f9400e60 	ldr	x0, [x19, #24]
    40004ccc:	94000a62 	bl	40007654 <z_shell_history_mode_exit>
					z_cursor_next_line_move(shell);
    40004cd0:	f9401660 	ldr	x0, [x19, #40]
    40004cd4:	97fffe0c 	bl	40004504 <z_cursor_next_line_move.isra.0>
		state_set(shell, SHELL_STATE_ACTIVE);
    40004cd8:	aa1303e0 	mov	x0, x19
    40004cdc:	97ffff7c 	bl	40004acc <state_set.constprop.0>
		break;
    40004ce0:	17ffffab 	b	40004b8c <shell_process+0x50>
					(void)execute(shell);
    40004ce4:	aa1303e0 	mov	x0, x19
    40004ce8:	97fffe5d 	bl	4000465c <execute>
				state_set(shell, SHELL_STATE_ACTIVE);
    40004cec:	17fffffb 	b	40004cd8 <shell_process+0x19c>
    40004cf0:	71006c3f 	cmp	w1, #0x1b
    40004cf4:	540001a0 	b.eq	40004d28 <shell_process+0x1ec>  // b.none
    40004cf8:	7101fc3f 	cmp	w1, #0x7f
    40004cfc:	54fffbe1 	b.ne	40004c78 <shell_process+0x13c>  // b.any
	return sh->ctx->cfg.flags.echo == 1;
    40004d00:	b942b801 	ldr	w1, [x0, #696]
				if (z_flag_echo_get(shell)) {
    40004d04:	360ff441 	tbz	w1, #1, 40004b8c <shell_process+0x50>
					z_flag_history_exit_set(shell, true);
    40004d08:	52800021 	mov	w1, #0x1                   	// #1
    40004d0c:	97fffe01 	bl	40004510 <z_flag_history_exit_set.isra.0>
	return sh->ctx->cfg.flags.mode_delete == 1;
    40004d10:	f9400a60 	ldr	x0, [x19, #16]
    40004d14:	b942b800 	ldr	w0, [x0, #696]
					if (z_flag_mode_delete_get(shell)) {
    40004d18:	371823a0 	tbnz	w0, #3, 4000518c <shell_process+0x650>
		z_shell_op_char_delete(shell);
    40004d1c:	aa1303e0 	mov	x0, x19
    40004d20:	940007b2 	bl	40006be8 <z_shell_op_char_delete>
		break;
    40004d24:	17ffff9a 	b	40004b8c <shell_process+0x50>
	shell->ctx->receive_state = state;
    40004d28:	52800021 	mov	w1, #0x1                   	// #1
    40004d2c:	b9000c01 	str	w1, [x0, #12]
}
    40004d30:	17ffff97 	b	40004b8c <shell_process+0x50>
	return sh->ctx->cfg.flags.echo == 1;
    40004d34:	b942b801 	ldr	w1, [x0, #696]
				if (z_flag_echo_get(shell) &&
    40004d38:	360ff2a1 	tbz	w1, #1, 40004b8c <shell_process+0x50>
					z_flag_history_exit_set(shell, true);
    40004d3c:	52800021 	mov	w1, #0x1                   	// #1
    40004d40:	97fffdf4 	bl	40004510 <z_flag_history_exit_set.isra.0>
			shell->ctx->cmd_buff_len;
    40004d44:	f9400a60 	ldr	x0, [x19, #16]
	if (compl_space == 0U) {
    40004d48:	79412001 	ldrh	w1, [x0, #144]
    40004d4c:	7103fc3f 	cmp	w1, #0xff
    40004d50:	54fff1e0 	b.eq	40004b8c <shell_process+0x50>  // b.none
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
    40004d54:	79412402 	ldrh	w2, [x0, #146]
    40004d58:	91025801 	add	x1, x0, #0x96
    40004d5c:	91065800 	add	x0, x0, #0x196
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    40004d60:	9104e3f6 	add	x22, sp, #0x138
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
    40004d64:	94000fff 	bl	40008d60 <memcpy>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    40004d68:	f9400a62 	ldr	x2, [x19, #16]
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    40004d6c:	aa1603e1 	mov	x1, x22
    40004d70:	52800183 	mov	w3, #0xc                   	// #12
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    40004d74:	79412440 	ldrh	w0, [x2, #146]
    40004d78:	8b000040 	add	x0, x2, x0
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    40004d7c:	91065842 	add	x2, x2, #0x196
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    40004d80:	3906581f 	strb	wzr, [x0, #406]
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    40004d84:	9102e3e0 	add	x0, sp, #0xb8
    40004d88:	94000323 	bl	40005a14 <z_shell_make_argv>
	if (*argc > CONFIG_SHELL_ARGC_MAX) {
    40004d8c:	f9405fe1 	ldr	x1, [sp, #184]
    40004d90:	f100303f 	cmp	x1, #0xc
    40004d94:	54ffefc8 	b.hi	40004b8c <shell_process+0x50>  // b.pmore
	(*argv)[*argc] = NULL;
    40004d98:	f8217adf 	str	xzr, [x22, x1, lsl #3]
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
    40004d9c:	b4000181 	cbz	x1, 40004dcc <shell_process+0x290>
	int space = isspace((int)shell->ctx->cmd_buff[
    40004da0:	f9400a62 	ldr	x2, [x19, #16]
						shell->ctx->cmd_buff_pos - 1]);
    40004da4:	79412440 	ldrh	w0, [x2, #146]
    40004da8:	51000400 	sub	w0, w0, #0x1
	int space = isspace((int)shell->ctx->cmd_buff[
    40004dac:	8b20c040 	add	x0, x2, w0, sxtw
    40004db0:	39425800 	ldrb	w0, [x0, #150]
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    40004db4:	51002402 	sub	w2, w0, #0x9
    40004db8:	7100801f 	cmp	w0, #0x20
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
    40004dbc:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    40004dc0:	540007c9 	b.ls	40004eb8 <shell_process+0x37c>  // b.plast
    40004dc4:	f100043f 	cmp	x1, #0x1
    40004dc8:	54000761 	b.ne	40004eb4 <shell_process+0x378>  // b.any
		*cmd = selected_cmd_get(shell);
    40004dcc:	d2800014 	mov	x20, #0x0                   	// #0
		*complete_arg_idx = Z_SHELL_CMD_ROOT_LVL;
    40004dd0:	f9005bff 	str	xzr, [sp, #176]
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
    40004dd4:	f9405be0 	ldr	x0, [sp, #176]
	*cnt = 0;
    40004dd8:	d2800015 	mov	x21, #0x0                   	// #0
	*longest = 0U;
    40004ddc:	5280001a 	mov	w26, #0x0                   	// #0
	size_t first = 0;
    40004de0:	d2800017 	mov	x23, #0x0                   	// #0
	size_t idx = 0;
    40004de4:	d2800018 	mov	x24, #0x0                   	// #0
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
    40004de8:	f8607adb 	ldr	x27, [x22, x0, lsl #3]
	incompl_cmd_len = z_shell_strlen(incompl_cmd);
    40004dec:	aa1b03e0 	mov	x0, x27
    40004df0:	97fffd69 	bl	40004394 <z_shell_strlen>
    40004df4:	92403c19 	and	x25, x0, #0xffff
	while ((candidate = z_shell_cmd_get(cmd, idx, &dloc)) != NULL) {
    40004df8:	910443e2 	add	x2, sp, #0x110
    40004dfc:	aa1803e1 	mov	x1, x24
    40004e00:	aa1403e0 	mov	x0, x20
    40004e04:	940003d0 	bl	40005d44 <z_shell_cmd_get>
    40004e08:	aa0003fc 	mov	x28, x0
    40004e0c:	b5000680 	cbnz	x0, 40004edc <shell_process+0x3a0>
	if (cnt == 1) {
    40004e10:	f10006bf 	cmp	x21, #0x1
    40004e14:	54000941 	b.ne	40004f3c <shell_process+0x400>  // b.any
	uint16_t arg_len = z_shell_strlen(arg);
    40004e18:	f9405be0 	ldr	x0, [sp, #176]
    40004e1c:	f8607ac0 	ldr	x0, [x22, x0, lsl #3]
    40004e20:	97fffd5d 	bl	40004394 <z_shell_strlen>
    40004e24:	12003c16 	and	w22, w0, #0xffff
	match = z_shell_cmd_get(cmd, subcmd_idx, &shell->ctx->active_cmd);
    40004e28:	f9400a62 	ldr	x2, [x19, #16]
    40004e2c:	aa1703e1 	mov	x1, x23
    40004e30:	aa1403e0 	mov	x0, x20
    40004e34:	91004042 	add	x2, x2, #0x10
    40004e38:	940003c3 	bl	40005d44 <z_shell_cmd_get>
    40004e3c:	aa0003f4 	mov	x20, x0
	cmd_len = z_shell_strlen(match->syntax);
    40004e40:	f9400000 	ldr	x0, [x0]
    40004e44:	97fffd54 	bl	40004394 <z_shell_strlen>
    40004e48:	12003c02 	and	w2, w0, #0xffff
	if (cmd_len != arg_len) {
    40004e4c:	6b2022df 	cmp	w22, w0, uxth
    40004e50:	540000c0 	b.eq	40004e68 <shell_process+0x32c>  // b.none
		z_shell_op_completion_insert(shell,
    40004e54:	f9400281 	ldr	x1, [x20]
    40004e58:	4b160042 	sub	w2, w2, w22
    40004e5c:	aa1303e0 	mov	x0, x19
    40004e60:	8b362021 	add	x1, x1, w22, uxth
    40004e64:	94000760 	bl	40006be4 <z_shell_op_completion_insert>
	if (!isspace((int) shell->ctx->cmd_buff[
    40004e68:	f9400a60 	ldr	x0, [x19, #16]
    40004e6c:	79412401 	ldrh	w1, [x0, #146]
    40004e70:	8b010001 	add	x1, x0, x1
    40004e74:	39425821 	ldrb	w1, [x1, #150]
    40004e78:	51002422 	sub	w2, w1, #0x9
    40004e7c:	7100803f 	cmp	w1, #0x20
    40004e80:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    40004e84:	54000549 	b.ls	40004f2c <shell_process+0x3f0>  // b.plast
	return sh->ctx->cfg.flags.insert_mode == 1;
    40004e88:	b942b801 	ldr	w1, [x0, #696]
		if (z_flag_insert_mode_get(shell)) {
    40004e8c:	36000481 	tbz	w1, #0, 40004f1c <shell_process+0x3e0>
			z_flag_insert_mode_set(shell, false);
    40004e90:	52800001 	mov	w1, #0x0                   	// #0
    40004e94:	97fffde4 	bl	40004624 <z_flag_insert_mode_set.isra.0>
			z_shell_op_char_insert(shell, ' ');
    40004e98:	aa1303e0 	mov	x0, x19
    40004e9c:	52800401 	mov	w1, #0x20                  	// #32
    40004ea0:	94000728 	bl	40006b40 <z_shell_op_char_insert>
			z_flag_insert_mode_set(shell, true);
    40004ea4:	f9400a60 	ldr	x0, [x19, #16]
    40004ea8:	52800021 	mov	w1, #0x1                   	// #1
				z_flag_insert_mode_set(shell, !status);
    40004eac:	97fffdde 	bl	40004624 <z_flag_insert_mode_set.isra.0>
				break;
    40004eb0:	17ffff37 	b	40004b8c <shell_process+0x50>
	search_argc = space ? *argc : *argc - 1;
    40004eb4:	d1000421 	sub	x1, x1, #0x1
	*cmd = z_shell_get_last_command(selected_cmd_get(shell), search_argc,
    40004eb8:	910303e4 	add	x4, sp, #0xc0
    40004ebc:	9102c3e3 	add	x3, sp, #0xb0
    40004ec0:	aa1603e2 	mov	x2, x22
    40004ec4:	52800005 	mov	w5, #0x0                   	// #0
    40004ec8:	d2800000 	mov	x0, #0x0                   	// #0
    40004ecc:	940003e4 	bl	40005e5c <z_shell_get_last_command>
    40004ed0:	aa0003f4 	mov	x20, x0
	if ((*cmd == NULL) && (search_argc != 0)) {
    40004ed4:	b5fff800 	cbnz	x0, 40004dd4 <shell_process+0x298>
    40004ed8:	17ffff2d 	b	40004b8c <shell_process+0x50>
	return (strncmp(candidate, str, len) == 0) ? true : false;
    40004edc:	f9400380 	ldr	x0, [x28]
    40004ee0:	aa1903e2 	mov	x2, x25
    40004ee4:	aa1b03e1 	mov	x1, x27
    40004ee8:	94000f74 	bl	40008cb8 <strncmp>
		if (is_candidate) {
    40004eec:	35000140 	cbnz	w0, 40004f14 <shell_process+0x3d8>
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
    40004ef0:	f9400380 	ldr	x0, [x28]
    40004ef4:	94000f58 	bl	40008c54 <strlen>
    40004ef8:	eb3a201f 	cmp	x0, w26, uxth
    40004efc:	92403f41 	and	x1, x26, #0xffff
    40004f00:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
				*first_idx = idx;
    40004f04:	f10002bf 	cmp	x21, #0x0
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
    40004f08:	12003c1a 	and	w26, w0, #0xffff
				*first_idx = idx;
    40004f0c:	9a9812f7 	csel	x23, x23, x24, ne  // ne = any
			(*cnt)++;
    40004f10:	910006b5 	add	x21, x21, #0x1
		idx++;
    40004f14:	91000718 	add	x24, x24, #0x1
    40004f18:	17ffffb8 	b	40004df8 <shell_process+0x2bc>
			z_shell_op_char_insert(shell, ' ');
    40004f1c:	52800401 	mov	w1, #0x20                  	// #32
					z_shell_op_char_insert(shell, data);
    40004f20:	aa1303e0 	mov	x0, x19
    40004f24:	94000707 	bl	40006b40 <z_shell_op_char_insert>
    40004f28:	17ffff19 	b	40004b8c <shell_process+0x50>
		z_shell_op_cursor_move(shell, 1);
    40004f2c:	aa1303e0 	mov	x0, x19
    40004f30:	52800021 	mov	w1, #0x1                   	// #1
    40004f34:	94000504 	bl	40006344 <z_shell_op_cursor_move>
    40004f38:	17ffff15 	b	40004b8c <shell_process+0x50>
	} else if (cnt > 1) {
    40004f3c:	54ffe289 	b.ls	40004b8c <shell_process+0x50>  // b.plast
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
    40004f40:	f9405be0 	ldr	x0, [sp, #176]
	longest_option += z_shell_strlen(tab);
    40004f44:	f0000058 	adrp	x24, 4000f000 <cfg_flags.0+0x5ac>
    40004f48:	91033718 	add	x24, x24, #0xcd
		shell->ctx->vt100_ctx.printed_cmd = 0;
    40004f4c:	aa1703fb 	mov	x27, x23
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
    40004f50:	f8607adc 	ldr	x28, [x22, x0, lsl #3]
	size_t str_len = z_shell_strlen(str);
    40004f54:	aa1c03e0 	mov	x0, x28
    40004f58:	97fffd0f 	bl	40004394 <z_shell_strlen>
    40004f5c:	92403c00 	and	x0, x0, #0xffff
    40004f60:	a90683f5 	stp	x21, x0, [sp, #104]
		shell->ctx->vt100_ctx.printed_cmd = 0;
    40004f64:	f9400a60 	ldr	x0, [x19, #16]
    40004f68:	7900b01f 	strh	wzr, [x0, #88]
		z_shell_fprintf(shell, SHELL_OPTION, "%s", option);
    40004f6c:	d0000040 	adrp	x0, 4000e000 <mmu_regions+0x38>
    40004f70:	9135f000 	add	x0, x0, #0xd7c
    40004f74:	f9003fe0 	str	x0, [sp, #120]
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
    40004f78:	f9400a62 	ldr	x2, [x19, #16]
    40004f7c:	aa1b03e1 	mov	x1, x27
    40004f80:	aa1403e0 	mov	x0, x20
		idx++;
    40004f84:	9100077b 	add	x27, x27, #0x1
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
    40004f88:	91004042 	add	x2, x2, #0x10
    40004f8c:	9400036e 	bl	40005d44 <z_shell_cmd_get>
    40004f90:	aa0003f9 	mov	x25, x0
		if (str && match->syntax &&
    40004f94:	b50007dc 	cbnz	x28, 4000508c <shell_process+0x550>
		tab_item_print(shell, match->syntax, longest);
    40004f98:	f9400323 	ldr	x3, [x25]
	if (option == NULL) {
    40004f9c:	b5000863 	cbnz	x3, 400050a8 <shell_process+0x56c>
		shell->ctx->vt100_ctx.printed_cmd = 0;
    40004fa0:	f9400a60 	ldr	x0, [x19, #16]
    40004fa4:	7900b01f 	strh	wzr, [x0, #88]
	while (cnt) {
    40004fa8:	f94037e0 	ldr	x0, [sp, #104]
    40004fac:	f1000400 	subs	x0, x0, #0x1
    40004fb0:	f90037e0 	str	x0, [sp, #104]
    40004fb4:	54fffe21 	b.ne	40004f78 <shell_process+0x43c>  // b.any
	z_cursor_next_line_move(shell);
    40004fb8:	f9401660 	ldr	x0, [x19, #40]
	size_t idx = first + 1;
    40004fbc:	910006fa 	add	x26, x23, #0x1
	z_cursor_next_line_move(shell);
    40004fc0:	97fffd51 	bl	40004504 <z_cursor_next_line_move.isra.0>
	z_shell_print_prompt_and_cmd(shell);
    40004fc4:	aa1303e0 	mov	x0, x19
    40004fc8:	94000735 	bl	40006c9c <z_shell_print_prompt_and_cmd>
	uint16_t arg_len = z_shell_strlen(arg);
    40004fcc:	f9405be0 	ldr	x0, [sp, #176]
    40004fd0:	f8607ac0 	ldr	x0, [x22, x0, lsl #3]
	uint16_t common = UINT16_MAX;
    40004fd4:	529ffff6 	mov	w22, #0xffff                	// #65535
	uint16_t arg_len = z_shell_strlen(arg);
    40004fd8:	97fffcef 	bl	40004394 <z_shell_strlen>
    40004fdc:	12003c19 	and	w25, w0, #0xffff
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
    40004fe0:	aa1703e1 	mov	x1, x23
    40004fe4:	9103a3e2 	add	x2, sp, #0xe8
    40004fe8:	aa1403e0 	mov	x0, x20
    40004fec:	94000356 	bl	40005d44 <z_shell_cmd_get>
    40004ff0:	aa0003f7 	mov	x23, x0
	strncpy(shell->ctx->temp_buff, match->syntax,
    40004ff4:	d2801fe2 	mov	x2, #0xff                  	// #255
    40004ff8:	f9400a60 	ldr	x0, [x19, #16]
	uint16_t arg_len = z_shell_strlen(arg);
    40004ffc:	2a1903f8 	mov	w24, w25
	strncpy(shell->ctx->temp_buff, match->syntax,
    40005000:	f94002e1 	ldr	x1, [x23]
    40005004:	91065800 	add	x0, x0, #0x196
    40005008:	94000ef9 	bl	40008bec <strncpy>
	*str = match->syntax;
    4000500c:	f94002f7 	ldr	x23, [x23]
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
    40005010:	9100075b 	add	x27, x26, #0x1
    40005014:	910443e2 	add	x2, sp, #0x110
    40005018:	aa1a03e1 	mov	x1, x26
    4000501c:	aa1403e0 	mov	x0, x20
    40005020:	94000349 	bl	40005d44 <z_shell_cmd_get>
		if (match2 == NULL) {
    40005024:	b4000a00 	cbz	x0, 40005164 <shell_process+0x628>
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
    40005028:	f9400a61 	ldr	x1, [x19, #16]
    4000502c:	f9400003 	ldr	x3, [x0]
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    40005030:	91065821 	add	x1, x1, #0x196
	size_t common = 0;
    40005034:	d2800000 	mov	x0, #0x0                   	// #0
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    40005038:	38606824 	ldrb	w4, [x1, x0]
    4000503c:	38606862 	ldrb	w2, [x3, x0]
    40005040:	6b04005f 	cmp	w2, w4
    40005044:	540000c1 	b.ne	4000505c <shell_process+0x520>  // b.any
    40005048:	340000a2 	cbz	w2, 4000505c <shell_process+0x520>
		common++;
    4000504c:	91000400 	add	x0, x0, #0x1
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    40005050:	d29fffe2 	mov	x2, #0xffff                	// #65535
    40005054:	eb02001f 	cmp	x0, x2
    40005058:	54ffff01 	b.ne	40005038 <shell_process+0x4fc>  // b.any
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
    4000505c:	2a0003e2 	mov	w2, w0
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
    40005060:	34000079 	cbz	w25, 4000506c <shell_process+0x530>
    40005064:	6b19001f 	cmp	w0, w25
    40005068:	540000eb 	b.lt	40005084 <shell_process+0x548>  // b.tstop
			common = (curr_common < common) ? curr_common : common;
    4000506c:	6b0202df 	cmp	w22, w2
			--cnt;
    40005070:	d10006b5 	sub	x21, x21, #0x1
			common = (curr_common < common) ? curr_common : common;
    40005074:	1a82d2d6 	csel	w22, w22, w2, le
	while (cnt > 1) {
    40005078:	f10006bf 	cmp	x21, #0x1
			common = (curr_common < common) ? curr_common : common;
    4000507c:	12003ed6 	and	w22, w22, #0xffff
	while (cnt > 1) {
    40005080:	54000720 	b.eq	40005164 <shell_process+0x628>  // b.none
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
    40005084:	aa1b03fa 	mov	x26, x27
    40005088:	17ffffe2 	b	40005010 <shell_process+0x4d4>
		if (str && match->syntax &&
    4000508c:	f9400000 	ldr	x0, [x0]
    40005090:	b4fff840 	cbz	x0, 40004f98 <shell_process+0x45c>
	return (strncmp(candidate, str, len) == 0) ? true : false;
    40005094:	f9403be2 	ldr	x2, [sp, #112]
    40005098:	aa1c03e1 	mov	x1, x28
    4000509c:	94000f07 	bl	40008cb8 <strncmp>
		if (str && match->syntax &&
    400050a0:	34fff7c0 	cbz	w0, 40004f98 <shell_process+0x45c>
    400050a4:	17ffffb5 	b	40004f78 <shell_process+0x43c>
	longest_option += z_shell_strlen(tab);
    400050a8:	aa1803e0 	mov	x0, x24
    400050ac:	f90047e3 	str	x3, [sp, #136]
    400050b0:	97fffcb9 	bl	40004394 <z_shell_strlen>
    400050b4:	0b202340 	add	w0, w26, w0, uxth
    400050b8:	12003c02 	and	w2, w0, #0xffff
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
    400050bc:	f9400a60 	ldr	x0, [x19, #16]
    400050c0:	79409401 	ldrh	w1, [x0, #74]
			- z_shell_strlen(tab)) / longest_option;
    400050c4:	aa1803e0 	mov	x0, x24
	longest_option += z_shell_strlen(tab);
    400050c8:	29130be1 	stp	w1, w2, [sp, #152]
			- z_shell_strlen(tab)) / longest_option;
    400050cc:	97fffcb2 	bl	40004394 <z_shell_strlen>
    400050d0:	12003c05 	and	w5, w0, #0xffff
	diff = longest_option - z_shell_strlen(option);
    400050d4:	f94047e3 	ldr	x3, [sp, #136]
			- z_shell_strlen(tab)) / longest_option;
    400050d8:	b90097e5 	str	w5, [sp, #148]
	diff = longest_option - z_shell_strlen(option);
    400050dc:	aa0303e0 	mov	x0, x3
    400050e0:	97fffcad 	bl	40004394 <z_shell_strlen>
    400050e4:	b9409fe2 	ldr	w2, [sp, #156]
			- z_shell_strlen(tab)) / longest_option;
    400050e8:	295287e5 	ldp	w5, w1, [sp, #148]
	diff = longest_option - z_shell_strlen(option);
    400050ec:	4b202059 	sub	w25, w2, w0, uxth
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
    400050f0:	f9400a60 	ldr	x0, [x19, #16]
	diff = longest_option - z_shell_strlen(option);
    400050f4:	12003f39 	and	w25, w25, #0xffff
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
    400050f8:	f94047e3 	ldr	x3, [sp, #136]
    400050fc:	7940b004 	ldrh	w4, [x0, #88]
    40005100:	11000486 	add	w6, w4, #0x1
    40005104:	7900b006 	strh	w6, [x0, #88]
			- z_shell_strlen(tab)) / longest_option;
    40005108:	4b050020 	sub	w0, w1, w5
    4000510c:	1ac20c00 	sdiv	w0, w0, w2
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
    40005110:	12003c00 	and	w0, w0, #0xffff
    40005114:	1ac00881 	udiv	w1, w4, w0
    40005118:	1b009020 	msub	w0, w1, w0, w4
    4000511c:	72003c1f 	tst	w0, #0xffff
    40005120:	54000181 	b.ne	40005150 <shell_process+0x614>  // b.any
		z_shell_fprintf(shell, SHELL_OPTION, "\n%s%s", tab, option);
    40005124:	aa0303e4 	mov	x4, x3
    40005128:	d0000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    4000512c:	91034042 	add	x2, x2, #0xd0
    40005130:	aa1803e3 	mov	x3, x24
    40005134:	aa1303e0 	mov	x0, x19
    40005138:	528000c1 	mov	w1, #0x6                   	// #6
    4000513c:	940005aa 	bl	400067e4 <z_shell_fprintf>
	z_shell_op_cursor_horiz_move(shell, diff);
    40005140:	2a1903e1 	mov	w1, w25
    40005144:	aa1303e0 	mov	x0, x19
    40005148:	94000422 	bl	400061d0 <z_shell_op_cursor_horiz_move>
    4000514c:	17ffff97 	b	40004fa8 <shell_process+0x46c>
		z_shell_fprintf(shell, SHELL_OPTION, "%s", option);
    40005150:	f9403fe2 	ldr	x2, [sp, #120]
    40005154:	aa1303e0 	mov	x0, x19
    40005158:	528000c1 	mov	w1, #0x6                   	// #6
    4000515c:	940005a2 	bl	400067e4 <z_shell_fprintf>
    40005160:	17fffff8 	b	40005140 <shell_process+0x604>
	if (common) {
    40005164:	34ffd156 	cbz	w22, 40004b8c <shell_process+0x50>
		z_shell_op_completion_insert(shell, &completion[arg_len],
    40005168:	4b1902c2 	sub	w2, w22, w25
    4000516c:	8b3822e1 	add	x1, x23, w24, uxth
    40005170:	aa1303e0 	mov	x0, x19
    40005174:	9400069c 	bl	40006be4 <z_shell_op_completion_insert>
    40005178:	17fffe85 	b	40004b8c <shell_process+0x50>
	return sh->ctx->cfg.flags.echo == 1;
    4000517c:	b942b801 	ldr	w1, [x0, #696]
				if (z_flag_echo_get(shell)) {
    40005180:	360fd061 	tbz	w1, #1, 40004b8c <shell_process+0x50>
					z_flag_history_exit_set(shell, true);
    40005184:	52800021 	mov	w1, #0x1                   	// #1
    40005188:	97fffce2 	bl	40004510 <z_flag_history_exit_set.isra.0>
						z_shell_op_char_backspace(shell);
    4000518c:	aa1303e0 	mov	x0, x19
    40005190:	940006b3 	bl	40006c5c <z_shell_op_char_backspace>
    40005194:	17fffe7e 	b	40004b8c <shell_process+0x50>
    40005198:	b942b802 	ldr	w2, [x0, #696]
				} else if (z_flag_echo_get(shell)) {
    4000519c:	360fcf82 	tbz	w2, #1, 40004b8c <shell_process+0x50>
	switch (data) {
    400051a0:	51000421 	sub	w1, w1, #0x1
    400051a4:	7100583f 	cmp	w1, #0x16
    400051a8:	54ffcf28 	b.hi	40004b8c <shell_process+0x50>  // b.pmore
    400051ac:	b0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    400051b0:	91298042 	add	x2, x2, #0xa60
    400051b4:	78615841 	ldrh	w1, [x2, w1, uxtw #1]
    400051b8:	10000062 	adr	x2, 400051c4 <shell_process+0x688>
    400051bc:	8b21a841 	add	x1, x2, w1, sxth #2
    400051c0:	d61f0020 	br	x1
		z_shell_op_left_arrow(shell);
    400051c4:	aa1303e0 	mov	x0, x19
    400051c8:	940004c1 	bl	400064cc <z_shell_op_left_arrow>
		break;
    400051cc:	17fffe70 	b	40004b8c <shell_process+0x50>
		z_shell_op_cursor_end_move(shell);
    400051d0:	aa1303e0 	mov	x0, x19
    400051d4:	940004b9 	bl	400064b8 <z_shell_op_cursor_end_move>
		if (!z_shell_cursor_in_empty_line(shell)) {
    400051d8:	aa1303e0 	mov	x0, x19
    400051dc:	9400040d 	bl	40006210 <z_shell_cursor_in_empty_line>
    400051e0:	72001c1f 	tst	w0, #0xff
    400051e4:	54000061 	b.ne	400051f0 <shell_process+0x6b4>  // b.any
			z_cursor_next_line_move(shell);
    400051e8:	f9401660 	ldr	x0, [x19, #40]
    400051ec:	97fffcc6 	bl	40004504 <z_cursor_next_line_move.isra.0>
		z_flag_history_exit_set(shell, true);
    400051f0:	f9400a60 	ldr	x0, [x19, #16]
    400051f4:	52800021 	mov	w1, #0x1                   	// #1
    400051f8:	97fffcc6 	bl	40004510 <z_flag_history_exit_set.isra.0>
    400051fc:	17fffeb7 	b	40004cd8 <shell_process+0x19c>
		z_shell_op_right_arrow(shell);
    40005200:	aa1303e0 	mov	x0, x19
    40005204:	940004b8 	bl	400064e4 <z_shell_op_right_arrow>
		break;
    40005208:	17fffe61 	b	40004b8c <shell_process+0x50>
		z_shell_op_delete_from_cursor(shell);
    4000520c:	aa1303e0 	mov	x0, x19
    40005210:	940004bd 	bl	40006504 <z_shell_op_delete_from_cursor>
		break;
    40005214:	17fffe5e 	b	40004b8c <shell_process+0x50>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40005218:	b942b800 	ldr	w0, [x0, #696]
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
    4000521c:	362800c0 	tbz	w0, #5, 40005234 <shell_process+0x6f8>
    40005220:	f9401660 	ldr	x0, [x19, #40]
    40005224:	90000041 	adrp	x1, 4000d000 <__rodata_region_start>
    40005228:	913de021 	add	x1, x1, #0xf78
    4000522c:	91001421 	add	x1, x1, #0x5
    40005230:	97fffc62 	bl	400043b8 <z_shell_raw_fprintf>
    40005234:	f9400a60 	ldr	x0, [x19, #16]
    40005238:	b942b800 	ldr	w0, [x0, #696]
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
    4000523c:	362800c0 	tbz	w0, #5, 40005254 <shell_process+0x718>
    40005240:	f9401660 	ldr	x0, [x19, #40]
    40005244:	90000041 	adrp	x1, 4000d000 <__rodata_region_start>
    40005248:	913de021 	add	x1, x1, #0xf78
    4000524c:	91002821 	add	x1, x1, #0xa
    40005250:	97fffc5a 	bl	400043b8 <z_shell_raw_fprintf>
		z_shell_print_prompt_and_cmd(shell);
    40005254:	aa1303e0 	mov	x0, x19
    40005258:	94000691 	bl	40006c9c <z_shell_print_prompt_and_cmd>
		break;
    4000525c:	17fffe4c 	b	40004b8c <shell_process+0x50>
		history_handle(shell, false);
    40005260:	52800001 	mov	w1, #0x0                   	// #0
		history_handle(shell, true);
    40005264:	aa1303e0 	mov	x0, x19
    40005268:	97fffcb1 	bl	4000452c <history_handle>
		break;
    4000526c:	17fffe48 	b	40004b8c <shell_process+0x50>
		history_handle(shell, true);
    40005270:	52800021 	mov	w1, #0x1                   	// #1
    40005274:	17fffffc 	b	40005264 <shell_process+0x728>
		z_shell_op_cursor_home_move(shell);
    40005278:	aa1303e0 	mov	x0, x19
    4000527c:	9400048b 	bl	400064a8 <z_shell_op_cursor_home_move>
		cmd_buffer_clear(shell);
    40005280:	f9400a60 	ldr	x0, [x19, #16]
		z_flag_history_exit_set(shell, true);
    40005284:	52800021 	mov	w1, #0x1                   	// #1
	shell->ctx->cmd_buff_len = 0;
    40005288:	b900901f 	str	wzr, [x0, #144]
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
    4000528c:	3902581f 	strb	wzr, [x0, #150]
		z_flag_history_exit_set(shell, true);
    40005290:	97fffca0 	bl	40004510 <z_flag_history_exit_set.isra.0>
    40005294:	f9400a60 	ldr	x0, [x19, #16]
    40005298:	b942b800 	ldr	w0, [x0, #696]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
    4000529c:	362fc780 	tbz	w0, #5, 40004b8c <shell_process+0x50>
    400052a0:	f9401660 	ldr	x0, [x19, #40]
    400052a4:	90000041 	adrp	x1, 4000d000 <__rodata_region_start>
    400052a8:	913de021 	add	x1, x1, #0xf78
    400052ac:	97fffc43 	bl	400043b8 <z_shell_raw_fprintf>
    400052b0:	17fffe37 	b	40004b8c <shell_process+0x50>
		z_shell_op_word_remove(shell);
    400052b4:	aa1303e0 	mov	x0, x19
    400052b8:	94000568 	bl	40006858 <z_shell_op_word_remove>
		z_flag_history_exit_set(shell, true);
    400052bc:	f9400a60 	ldr	x0, [x19, #16]
    400052c0:	52800021 	mov	w1, #0x1                   	// #1
    400052c4:	97fffc93 	bl	40004510 <z_flag_history_exit_set.isra.0>
		break;
    400052c8:	17fffe31 	b	40004b8c <shell_process+0x50>
			if (data == '[') {
    400052cc:	71016c3f 	cmp	w1, #0x5b
    400052d0:	54000061 	b.ne	400052dc <shell_process+0x7a0>  // b.any
	shell->ctx->receive_state = state;
    400052d4:	52800041 	mov	w1, #0x2                   	// #2
    400052d8:	17fffe95 	b	40004d2c <shell_process+0x1f0>
	return sh->ctx->cfg.flags.echo == 1;
    400052dc:	b942b800 	ldr	w0, [x0, #696]
			} else if (z_flag_echo_get(shell)) {
    400052e0:	360800c0 	tbz	w0, #1, 400052f8 <shell_process+0x7bc>
	if (data == SHELL_VT100_ASCII_ALT_B) {
    400052e4:	7101883f 	cmp	w1, #0x62
    400052e8:	540000e1 	b.ne	40005304 <shell_process+0x7c8>  // b.any
		z_shell_op_cursor_word_move(shell, -1);
    400052ec:	12800001 	mov	w1, #0xffffffff            	// #-1
		z_shell_op_cursor_word_move(shell, 1);
    400052f0:	aa1303e0 	mov	x0, x19
    400052f4:	94000439 	bl	400063d8 <z_shell_op_cursor_word_move>
	shell->ctx->receive_state = state;
    400052f8:	f9400a60 	ldr	x0, [x19, #16]
    400052fc:	b9000c1f 	str	wzr, [x0, #12]
}
    40005300:	17fffe23 	b	40004b8c <shell_process+0x50>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
    40005304:	7101983f 	cmp	w1, #0x66
    40005308:	54ffff81 	b.ne	400052f8 <shell_process+0x7bc>  // b.any
		z_shell_op_cursor_word_move(shell, 1);
    4000530c:	52800021 	mov	w1, #0x1                   	// #1
    40005310:	17fffff8 	b	400052f0 <shell_process+0x7b4>
    40005314:	b942b802 	ldr	w2, [x0, #696]
	shell->ctx->receive_state = state;
    40005318:	b9000c1f 	str	wzr, [x0, #12]
			if (!z_flag_echo_get(shell)) {
    4000531c:	360fc382 	tbz	w2, #1, 40004b8c <shell_process+0x50>
			switch (data) {
    40005320:	5100c421 	sub	w1, w1, #0x31
    40005324:	71006c3f 	cmp	w1, #0x1b
    40005328:	54ffc328 	b.hi	40004b8c <shell_process+0x50>  // b.pmore
    4000532c:	b0000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40005330:	912a4042 	add	x2, x2, #0xa90
    40005334:	78615841 	ldrh	w1, [x2, w1, uxtw #1]
    40005338:	10000062 	adr	x2, 40005344 <shell_process+0x808>
    4000533c:	8b21a841 	add	x1, x2, w1, sxth #2
    40005340:	d61f0020 	br	x1
	shell->ctx->receive_state = state;
    40005344:	52800061 	mov	w1, #0x3                   	// #3
    40005348:	b9000c01 	str	w1, [x0, #12]
		z_shell_op_cursor_end_move(shell);
    4000534c:	aa1303e0 	mov	x0, x19
    40005350:	9400045a 	bl	400064b8 <z_shell_op_cursor_end_move>
		break;
    40005354:	17fffe0e 	b	40004b8c <shell_process+0x50>
	shell->ctx->receive_state = state;
    40005358:	52800061 	mov	w1, #0x3                   	// #3
    4000535c:	b9000c01 	str	w1, [x0, #12]
		z_shell_op_cursor_home_move(shell);
    40005360:	aa1303e0 	mov	x0, x19
    40005364:	94000451 	bl	400064a8 <z_shell_op_cursor_home_move>
		break;
    40005368:	17fffe09 	b	40004b8c <shell_process+0x50>
	shell->ctx->receive_state = state;
    4000536c:	52800061 	mov	w1, #0x3                   	// #3
    40005370:	b9000c01 	str	w1, [x0, #12]
	return sh->ctx->cfg.flags.insert_mode == 1;
    40005374:	b942b801 	ldr	w1, [x0, #696]
    40005378:	12000021 	and	w1, w1, #0x1
				z_flag_insert_mode_set(shell, !status);
    4000537c:	52000021 	eor	w1, w1, #0x1
    40005380:	17fffecb 	b	40004eac <shell_process+0x370>
	shell->ctx->receive_state = state;
    40005384:	52800061 	mov	w1, #0x3                   	// #3
    40005388:	b9000c01 	str	w1, [x0, #12]
	return sh->ctx->cfg.flags.echo == 1;
    4000538c:	b942b800 	ldr	w0, [x0, #696]
				if (z_flag_echo_get(shell)) {
    40005390:	360fbfe0 	tbz	w0, #1, 40004b8c <shell_process+0x50>
    40005394:	17fffe62 	b	40004d1c <shell_process+0x1e0>

0000000040005398 <shell_init>:
{
    40005398:	d10183ff 	sub	sp, sp, #0x60
    4000539c:	a9017bfd 	stp	x29, x30, [sp, #16]
    400053a0:	910043fd 	add	x29, sp, #0x10
    400053a4:	a90253f3 	stp	x19, x20, [sp, #32]
    400053a8:	aa0003f3 	mov	x19, x0
	if (shell->ctx->tid) {
    400053ac:	f9400800 	ldr	x0, [x0, #16]
{
    400053b0:	a90463f7 	stp	x23, x24, [sp, #64]
    400053b4:	aa0103f7 	mov	x23, x1
    400053b8:	a9035bf5 	stp	x21, x22, [sp, #48]
	if (shell->ctx->tid) {
    400053bc:	f941f401 	ldr	x1, [x0, #1000]
{
    400053c0:	f9002bf9 	str	x25, [sp, #80]
	if (shell->ctx->tid) {
    400053c4:	b5000a21 	cbnz	x1, 40005508 <shell_init+0x170>
    400053c8:	12001c79 	and	w25, w3, #0xff
    400053cc:	2a0403f6 	mov	w22, w4
static int instance_init(const struct shell *sh,
    400053d0:	2a0203f4 	mov	w20, w2
	memset(sh->ctx, 0, sizeof(*sh->ctx));
    400053d4:	d2807e02 	mov	x2, #0x3f0                 	// #1008
    400053d8:	94000e6a 	bl	40008d80 <memset>
	sh->ctx->prompt = sh->default_prompt;
    400053dc:	f9400a60 	ldr	x0, [x19, #16]
    400053e0:	f9400261 	ldr	x1, [x19]
    400053e4:	f9000001 	str	x1, [x0]
	z_shell_history_init(shell->history);
    400053e8:	f9400e60 	ldr	x0, [x19, #24]
    400053ec:	94000930 	bl	400078ac <z_shell_history_init>
	k_mutex_init(&sh->ctx->wr_mtx);
    400053f0:	f9400a60 	ldr	x0, [x19, #16]
    400053f4:	910f2000 	add	x0, x0, #0x3c8
	return z_impl_k_mutex_init(mutex);
    400053f8:	d2806518 	mov	x24, #0x328                 	// #808
    400053fc:	d2805915 	mov	x21, #0x2c8                 	// #712
    40005400:	94001355 	bl	4000a154 <z_impl_k_mutex_init>
		k_poll_signal_init(&sh->ctx->signals[i]);
    40005404:	f9400a60 	ldr	x0, [x19, #16]
    40005408:	8b150000 	add	x0, x0, x21
	z_impl_k_poll_signal_init(sig);
    4000540c:	940019fd 	bl	4000bc00 <z_impl_k_poll_signal_init>
		k_poll_event_init(&sh->ctx->events[i],
    40005410:	f9400a60 	ldr	x0, [x19, #16]
    40005414:	52800002 	mov	w2, #0x0                   	// #0
    40005418:	52800021 	mov	w1, #0x1                   	// #1
    4000541c:	8b150003 	add	x3, x0, x21
    40005420:	8b180000 	add	x0, x0, x24
	for (int i = 0; i < SHELL_SIGNALS; i++) {
    40005424:	910062b5 	add	x21, x21, #0x18
		k_poll_event_init(&sh->ctx->events[i],
    40005428:	940019ad 	bl	4000badc <k_poll_event_init>
	for (int i = 0; i < SHELL_SIGNALS; i++) {
    4000542c:	9100a318 	add	x24, x24, #0x28
    40005430:	f10ca2bf 	cmp	x21, #0x328
    40005434:	54fffe81 	b.ne	40005404 <shell_init+0x6c>  // b.any
		sh->stats->log_lost_cnt = 0;
    40005438:	f9401a60 	ldr	x0, [x19, #48]
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, tx_rdy, val, ret);
    4000543c:	d2800041 	mov	x1, #0x2                   	// #2
	sh->ctx->cfg.flags = cfg_flags;
    40005440:	121d7a94 	and	w20, w20, #0xfffffffb
		sh->stats->log_lost_cnt = 0;
    40005444:	f900001f 	str	xzr, [x0]
    40005448:	f9400a60 	ldr	x0, [x19, #16]
    4000544c:	910b0000 	add	x0, x0, #0x2c0
    40005450:	97fffba7 	bl	400042ec <atomic_or>
	sh->ctx->vt100_ctx.cons.terminal_wid =
    40005454:	f9400a60 	ldr	x0, [x19, #16]
	sh->ctx->vt100_ctx.cons.terminal_hei =
    40005458:	52800301 	mov	w1, #0x18                  	// #24
    4000545c:	72a00a01 	movk	w1, #0x50, lsl #16
    40005460:	b9004801 	str	w1, [x0, #72]
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
    40005464:	f9400000 	ldr	x0, [x0]
    40005468:	97fffbcb 	bl	40004394 <z_shell_strlen>
    4000546c:	f9400a61 	ldr	x1, [x19, #16]
	int ret = sh->iface->api->init(sh->iface, transport_config,
    40005470:	aa1303e3 	mov	x3, x19
    40005474:	f0ffffe2 	adrp	x2, 40004000 <enable_shell_uart+0x4c>
    40005478:	9111b042 	add	x2, x2, #0x46c
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
    4000547c:	39013020 	strb	w0, [x1, #76]
	int ret = sh->iface->api->init(sh->iface, transport_config,
    40005480:	f9400660 	ldr	x0, [x19, #8]
	sh->ctx->cfg.flags = cfg_flags;
    40005484:	b902b834 	str	w20, [x1, #696]
	int ret = sh->iface->api->init(sh->iface, transport_config,
    40005488:	f9400001 	ldr	x1, [x0]
    4000548c:	f9400024 	ldr	x4, [x1]
    40005490:	aa1703e1 	mov	x1, x23
    40005494:	d63f0080 	blr	x4
    40005498:	2a0003f4 	mov	w20, w0
	if (ret == 0) {
    4000549c:	35000260 	cbnz	w0, 400054e8 <shell_init+0x150>
	shell->ctx->state = state;
    400054a0:	f9400a60 	ldr	x0, [x19, #16]
    400054a4:	52800021 	mov	w1, #0x1                   	// #1
    400054a8:	b9000801 	str	w1, [x0, #8]
	k_tid_t tid = k_thread_create(shell->thread,
    400054ac:	a9448660 	ldp	x0, x1, [x19, #72]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    400054b0:	b90003ff 	str	wzr, [sp]
    400054b4:	2a1603e6 	mov	w6, w22
    400054b8:	f90007ff 	str	xzr, [sp, #8]
    400054bc:	92401f25 	and	x5, x25, #0xff
    400054c0:	aa1303e4 	mov	x4, x19
    400054c4:	528001c7 	mov	w7, #0xe                   	// #14
    400054c8:	d2810002 	mov	x2, #0x800                 	// #2048
    400054cc:	90000003 	adrp	x3, 40005000 <shell_process+0x4c4>
    400054d0:	91161063 	add	x3, x3, #0x584
    400054d4:	940012b4 	bl	40009fa4 <z_impl_k_thread_create>
	shell->ctx->tid = tid;
    400054d8:	f9400a61 	ldr	x1, [x19, #16]
    400054dc:	f901f420 	str	x0, [x1, #1000]
	k_thread_name_set(tid, shell->thread_name);
    400054e0:	f9402261 	ldr	x1, [x19, #64]
	return z_impl_k_thread_name_set(thread, str);
    400054e4:	9400122b 	bl	40009d90 <z_impl_k_thread_name_set>
}
    400054e8:	2a1403e0 	mov	w0, w20
    400054ec:	a9417bfd 	ldp	x29, x30, [sp, #16]
    400054f0:	a94253f3 	ldp	x19, x20, [sp, #32]
    400054f4:	a9435bf5 	ldp	x21, x22, [sp, #48]
    400054f8:	a94463f7 	ldp	x23, x24, [sp, #64]
    400054fc:	f9402bf9 	ldr	x25, [sp, #80]
    40005500:	910183ff 	add	sp, sp, #0x60
    40005504:	d65f03c0 	ret
		return -EALREADY;
    40005508:	12800ef4 	mov	w20, #0xffffff88            	// #-120
    4000550c:	17fffff7 	b	400054e8 <shell_init+0x150>

0000000040005510 <shell_start>:
{
    40005510:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005514:	910003fd 	mov	x29, sp
    40005518:	f9000bf3 	str	x19, [sp, #16]
    4000551c:	aa0003f3 	mov	x19, x0
	return shell->ctx->state;
    40005520:	f9400800 	ldr	x0, [x0, #16]
	if (state_get(shell) != SHELL_STATE_INITIALIZED) {
    40005524:	b9400801 	ldr	w1, [x0, #8]
    40005528:	7100043f 	cmp	w1, #0x1
    4000552c:	54000281 	b.ne	4000557c <shell_start+0x6c>  // b.any
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40005530:	910f2000 	add	x0, x0, #0x3c8
    40005534:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40005538:	97fffbcc 	bl	40004468 <k_mutex_lock.constprop.0.isra.0>
		z_shell_vt100_color_set(shell, SHELL_NORMAL);
    4000553c:	aa1303e0 	mov	x0, x19
    40005540:	52800101 	mov	w1, #0x8                   	// #8
    40005544:	9400044a 	bl	4000666c <z_shell_vt100_color_set>
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n\n");
    40005548:	f9401660 	ldr	x0, [x19, #40]
    4000554c:	b0000041 	adrp	x1, 4000e000 <mmu_regions+0x38>
    40005550:	91317021 	add	x1, x1, #0xc5c
    40005554:	97fffb99 	bl	400043b8 <z_shell_raw_fprintf>
	state_set(shell, SHELL_STATE_ACTIVE);
    40005558:	aa1303e0 	mov	x0, x19
    4000555c:	97fffd5c 	bl	40004acc <state_set.constprop.0>
	k_mutex_unlock(&shell->ctx->wr_mtx);
    40005560:	f9400a60 	ldr	x0, [x19, #16]
    40005564:	910f2000 	add	x0, x0, #0x3c8
    40005568:	97fffc3c 	bl	40004658 <k_mutex_unlock.isra.0>
	return 0;
    4000556c:	52800000 	mov	w0, #0x0                   	// #0
}
    40005570:	f9400bf3 	ldr	x19, [sp, #16]
    40005574:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005578:	d65f03c0 	ret
		return -ENOTSUP;
    4000557c:	128010a0 	mov	w0, #0xffffff7a            	// #-134
    40005580:	17fffffc 	b	40005570 <shell_start+0x60>

0000000040005584 <shell_thread>:
{
    40005584:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40005588:	910003fd 	mov	x29, sp
    4000558c:	a90153f3 	stp	x19, x20, [sp, #16]
    40005590:	aa0003f3 	mov	x19, x0
	err = shell->iface->api->enable(shell->iface, false);
    40005594:	f9400400 	ldr	x0, [x0, #8]
{
    40005598:	a9025bf5 	stp	x21, x22, [sp, #32]
	err = shell->iface->api->enable(shell->iface, false);
    4000559c:	f9400001 	ldr	x1, [x0]
    400055a0:	f9400822 	ldr	x2, [x1, #16]
    400055a4:	52800001 	mov	w1, #0x0                   	// #0
    400055a8:	d63f0040 	blr	x2
	if (err != 0) {
    400055ac:	35000620 	cbnz	w0, 40005670 <shell_thread+0xec>
	err = shell_start(shell);
    400055b0:	aa1303e0 	mov	x0, x19
    400055b4:	97ffffd7 	bl	40005510 <shell_start>
	if (err != 0) {
    400055b8:	350005c0 	cbnz	w0, 40005670 <shell_thread+0xec>
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
    400055bc:	f0fffff6 	adrp	x22, 40004000 <enable_shell_uart+0x4c>
    400055c0:	911222d6 	add	x22, x22, #0x488
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
    400055c4:	f0fffff5 	adrp	x21, 40004000 <enable_shell_uart+0x4c>
    400055c8:	912cf2b5 	add	x21, x21, #0xb3c
		err = k_poll(shell->ctx->events, SHELL_SIGNAL_TXDONE,
    400055cc:	f9400a60 	ldr	x0, [x19, #16]
    400055d0:	910ca000 	add	x0, x0, #0x328
	return z_impl_k_poll(events, num_events, timeout);
    400055d4:	52800061 	mov	w1, #0x3                   	// #3
    400055d8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    400055dc:	94001949 	bl	4000bb00 <z_impl_k_poll>
    400055e0:	2a0003f4 	mov	w20, w0
		if (err != 0) {
    400055e4:	f9400a60 	ldr	x0, [x19, #16]
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    400055e8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    400055ec:	910f2000 	add	x0, x0, #0x3c8
		if (err != 0) {
    400055f0:	340001d4 	cbz	w20, 40005628 <shell_thread+0xa4>
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    400055f4:	97fffb9d 	bl	40004468 <k_mutex_lock.constprop.0.isra.0>
			z_shell_fprintf(shell, SHELL_ERROR,
    400055f8:	2a1403e3 	mov	w3, w20
    400055fc:	aa1303e0 	mov	x0, x19
    40005600:	52800021 	mov	w1, #0x1                   	// #1
    40005604:	d0000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40005608:	91035842 	add	x2, x2, #0xd6
    4000560c:	94000476 	bl	400067e4 <z_shell_fprintf>
			k_mutex_unlock(&shell->ctx->wr_mtx);
    40005610:	f9400a60 	ldr	x0, [x19, #16]
}
    40005614:	a94153f3 	ldp	x19, x20, [sp, #16]
			k_mutex_unlock(&shell->ctx->wr_mtx);
    40005618:	910f2000 	add	x0, x0, #0x3c8
}
    4000561c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005620:	a8c37bfd 	ldp	x29, x30, [sp], #48
			k_mutex_unlock(&shell->ctx->wr_mtx);
    40005624:	17fffc0d 	b	40004658 <k_mutex_unlock.isra.0>
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40005628:	97fffb90 	bl	40004468 <k_mutex_lock.constprop.0.isra.0>
		if (shell->iface->api->update) {
    4000562c:	f9400660 	ldr	x0, [x19, #8]
    40005630:	f9400001 	ldr	x1, [x0]
    40005634:	f9401421 	ldr	x1, [x1, #40]
    40005638:	b4000041 	cbz	x1, 40005640 <shell_thread+0xbc>
			shell->iface->api->update(shell->iface);
    4000563c:	d63f0020 	blr	x1
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
    40005640:	aa1603e2 	mov	x2, x22
    40005644:	aa1303e0 	mov	x0, x19
    40005648:	52800041 	mov	w1, #0x2                   	// #2
    4000564c:	97fffb38 	bl	4000432c <shell_signal_handle>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
    40005650:	aa1303e0 	mov	x0, x19
    40005654:	aa1503e2 	mov	x2, x21
    40005658:	52800001 	mov	w1, #0x0                   	// #0
    4000565c:	97fffb34 	bl	4000432c <shell_signal_handle>
		k_mutex_unlock(&shell->ctx->wr_mtx);
    40005660:	f9400a60 	ldr	x0, [x19, #16]
    40005664:	910f2000 	add	x0, x0, #0x3c8
    40005668:	97fffbfc 	bl	40004658 <k_mutex_unlock.isra.0>
    4000566c:	17ffffd8 	b	400055cc <shell_thread+0x48>
}
    40005670:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005674:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005678:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000567c:	d65f03c0 	ret

0000000040005680 <shell_vfprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_vfprintf(const struct shell *sh, enum shell_vt100_color color,
		   const char *fmt, va_list args)
{
    40005680:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40005684:	910003fd 	mov	x29, sp
    40005688:	a90153f3 	stp	x19, x20, [sp, #16]
    4000568c:	aa0003f3 	mov	x19, x0
	return shell->ctx->state;
    40005690:	f9400800 	ldr	x0, [x0, #16]
{
    40005694:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005698:	2a0103f5 	mov	w21, w1
			(k_current_get() != sh->ctx->tid));
	__ASSERT_NO_MSG(sh->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	/* Sending a message to a non-active shell leads to a dead lock. */
	if (state_get(sh) != SHELL_STATE_ACTIVE) {
    4000569c:	b9400801 	ldr	w1, [x0, #8]
    400056a0:	7100083f 	cmp	w1, #0x2
    400056a4:	540000e0 	b.eq	400056c0 <shell_vfprintf+0x40>  // b.none
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
		z_shell_print_prompt_and_cmd(sh);
	}
	z_transport_buffer_flush(sh);
	k_mutex_unlock(&sh->ctx->wr_mtx);
}
    400056a8:	a94153f3 	ldp	x19, x20, [sp, #16]
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
    400056ac:	910b0000 	add	x0, x0, #0x2c0
    400056b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400056b4:	d2820001 	mov	x1, #0x1000                	// #4096
    400056b8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    400056bc:	17fffb0c 	b	400042ec <atomic_or>
	k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
    400056c0:	910f2000 	add	x0, x0, #0x3c8
    400056c4:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    400056c8:	aa0203f6 	mov	x22, x2
    400056cc:	aa0303f4 	mov	x20, x3
    400056d0:	97fffb66 	bl	40004468 <k_mutex_lock.constprop.0.isra.0>
	return sh->ctx->ctx.flags.cmd_ctx == 1;
    400056d4:	f9400a60 	ldr	x0, [x19, #16]
    400056d8:	b942c001 	ldr	w1, [x0, #704]
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
    400056dc:	375800a1 	tbnz	w1, #11, 400056f0 <shell_vfprintf+0x70>
    400056e0:	f9403400 	ldr	x0, [x0, #104]
    400056e4:	b5000060 	cbnz	x0, 400056f0 <shell_vfprintf+0x70>
		z_shell_cmd_line_erase(sh);
    400056e8:	aa1303e0 	mov	x0, x19
    400056ec:	9400038c 	bl	4000651c <z_shell_cmd_line_erase>
	z_shell_vfprintf(sh, color, fmt, args);
    400056f0:	a9400680 	ldp	x0, x1, [x20]
    400056f4:	a90307e0 	stp	x0, x1, [sp, #48]
    400056f8:	9100c3e3 	add	x3, sp, #0x30
    400056fc:	a9410680 	ldp	x0, x1, [x20, #16]
    40005700:	aa1603e2 	mov	x2, x22
    40005704:	a90407e0 	stp	x0, x1, [sp, #64]
    40005708:	2a1503e1 	mov	w1, w21
    4000570c:	aa1303e0 	mov	x0, x19
    40005710:	94000408 	bl	40006730 <z_shell_vfprintf>
    40005714:	f9400a60 	ldr	x0, [x19, #16]
    40005718:	b942c001 	ldr	w1, [x0, #704]
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
    4000571c:	375800a1 	tbnz	w1, #11, 40005730 <shell_vfprintf+0xb0>
    40005720:	f9403400 	ldr	x0, [x0, #104]
    40005724:	b5000060 	cbnz	x0, 40005730 <shell_vfprintf+0xb0>
		z_shell_print_prompt_and_cmd(sh);
    40005728:	aa1303e0 	mov	x0, x19
    4000572c:	9400055c 	bl	40006c9c <z_shell_print_prompt_and_cmd>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
    40005730:	f9401660 	ldr	x0, [x19, #40]
    40005734:	94000047 	bl	40005850 <z_shell_fprintf_buffer_flush>
	k_mutex_unlock(&sh->ctx->wr_mtx);
    40005738:	f9400a60 	ldr	x0, [x19, #16]
}
    4000573c:	a94153f3 	ldp	x19, x20, [sp, #16]
	k_mutex_unlock(&sh->ctx->wr_mtx);
    40005740:	910f2000 	add	x0, x0, #0x3c8
}
    40005744:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005748:	a8c57bfd 	ldp	x29, x30, [sp], #80
	k_mutex_unlock(&sh->ctx->wr_mtx);
    4000574c:	17fffbc3 	b	40004658 <k_mutex_unlock.isra.0>

0000000040005750 <shell_fprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_fprintf(const struct shell *shell, enum shell_vt100_color color,
		   const char *fmt, ...)
{
    40005750:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40005754:	910003fd 	mov	x29, sp
    40005758:	a90d93e3 	stp	x3, x4, [sp, #216]
	va_list args;

	va_start(args, fmt);
    4000575c:	910403e3 	add	x3, sp, #0x100
    40005760:	a9030fe3 	stp	x3, x3, [sp, #48]
    40005764:	910343e3 	add	x3, sp, #0xd0
    40005768:	f90023e3 	str	x3, [sp, #64]
    4000576c:	128004e3 	mov	w3, #0xffffffd8            	// #-40
    40005770:	b9004be3 	str	w3, [sp, #72]
    40005774:	12800fe3 	mov	w3, #0xffffff80            	// #-128
    40005778:	b9004fe3 	str	w3, [sp, #76]
	shell_vfprintf(shell, color, fmt, args);
    4000577c:	910043e3 	add	x3, sp, #0x10
{
    40005780:	a90e9be5 	stp	x5, x6, [sp, #232]
	shell_vfprintf(shell, color, fmt, args);
    40005784:	a94317e4 	ldp	x4, x5, [sp, #48]
    40005788:	a90117e4 	stp	x4, x5, [sp, #16]
    4000578c:	a94417e4 	ldp	x4, x5, [sp, #64]
    40005790:	a90217e4 	stp	x4, x5, [sp, #32]
{
    40005794:	3d8017e0 	str	q0, [sp, #80]
    40005798:	3d801be1 	str	q1, [sp, #96]
    4000579c:	3d801fe2 	str	q2, [sp, #112]
    400057a0:	3d8023e3 	str	q3, [sp, #128]
    400057a4:	3d8027e4 	str	q4, [sp, #144]
    400057a8:	3d802be5 	str	q5, [sp, #160]
    400057ac:	3d802fe6 	str	q6, [sp, #176]
    400057b0:	3d8033e7 	str	q7, [sp, #192]
    400057b4:	f9007fe7 	str	x7, [sp, #248]
	shell_vfprintf(shell, color, fmt, args);
    400057b8:	97ffffb2 	bl	40005680 <shell_vfprintf>
	va_end(args);
}
    400057bc:	a8d07bfd 	ldp	x29, x30, [sp], #256
    400057c0:	d65f03c0 	ret

00000000400057c4 <cmd_help>:
{
	sh->ctx->bypass = bypass;
}

static int cmd_help(const struct shell *shell, size_t argc, char **argv)
{
    400057c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

#if defined(CONFIG_SHELL_TAB)
	shell_print(shell, "Please press the <Tab> button to see all available "
    400057c8:	52800101 	mov	w1, #0x8                   	// #8
    400057cc:	d0000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    400057d0:	9103b442 	add	x2, x2, #0xed
{
    400057d4:	910003fd 	mov	x29, sp
    400057d8:	f9000bf3 	str	x19, [sp, #16]
    400057dc:	aa0003f3 	mov	x19, x0
	shell_print(shell, "Please press the <Tab> button to see all available "
    400057e0:	97ffffdc 	bl	40005750 <shell_fprintf>
			   "commands.");
#endif

#if defined(CONFIG_SHELL_TAB_AUTOCOMPLETION)
	shell_print(shell,
    400057e4:	aa1303e0 	mov	x0, x19
    400057e8:	52800101 	mov	w1, #0x8                   	// #8
    400057ec:	d0000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    400057f0:	9104ac42 	add	x2, x2, #0x12b
    400057f4:	97ffffd7 	bl	40005750 <shell_fprintf>
		"You can also use the <Tab> button to prompt or auto-complete"
		" all commands or its subcommands.");
#endif

#if defined(CONFIG_SHELL_HELP)
	shell_print(shell,
    400057f8:	aa1303e0 	mov	x0, x19
    400057fc:	52800101 	mov	w1, #0x8                   	// #8
    40005800:	d0000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40005804:	91062842 	add	x2, x2, #0x18a
    40005808:	97ffffd2 	bl	40005750 <shell_fprintf>
		"You can try to call commands with <-h> or <--help> parameter"
		" for more information.");
#endif

#if defined(CONFIG_SHELL_METAKEYS)
	shell_print(shell,
    4000580c:	aa1303e0 	mov	x0, x19
    40005810:	52800101 	mov	w1, #0x8                   	// #8
    40005814:	d0000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40005818:	91077842 	add	x2, x2, #0x1de
    4000581c:	97ffffcd 	bl	40005750 <shell_fprintf>
		"Please refer to shell documentation for more details.");
#endif

	if (IS_ENABLED(CONFIG_SHELL_HELP)) {
		/* For NULL argument function will print all root commands */
		z_shell_help_subcmd_print(shell, NULL,
    40005820:	aa1303e0 	mov	x0, x19
    40005824:	d2800001 	mov	x1, #0x0                   	// #0
    40005828:	d0000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    4000582c:	9109e042 	add	x2, x2, #0x278
    40005830:	940005ae 	bl	40006ee8 <z_shell_help_subcmd_print>
			shell_print(shell, "  %s", entry->syntax);
		}
	}

	return 0;
}
    40005834:	52800000 	mov	w0, #0x0                   	// #0
    40005838:	f9400bf3 	ldr	x19, [sp, #16]
    4000583c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005840:	d65f03c0 	ret

0000000040005844 <shell_set_bypass>:
	sh->ctx->bypass = bypass;
    40005844:	f9400800 	ldr	x0, [x0, #16]
    40005848:	f9003401 	str	x1, [x0, #104]
}
    4000584c:	d65f03c0 	ret

0000000040005850 <z_shell_fprintf_buffer_flush>:
	}
}


void z_shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
    40005850:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005854:	910003fd 	mov	x29, sp
    40005858:	f9000bf3 	str	x19, [sp, #16]
    4000585c:	aa0003f3 	mov	x19, x0
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
    40005860:	f9400001 	ldr	x1, [x0]
    40005864:	f9400803 	ldr	x3, [x0, #16]
    40005868:	f9401000 	ldr	x0, [x0, #32]
    4000586c:	f9400002 	ldr	x2, [x0]
    40005870:	f9400e60 	ldr	x0, [x19, #24]
    40005874:	d63f0060 	blr	x3
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
    40005878:	f9401260 	ldr	x0, [x19, #32]
}
    4000587c:	f9400bf3 	ldr	x19, [sp, #16]
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
    40005880:	f900001f 	str	xzr, [x0]
}
    40005884:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005888:	d65f03c0 	ret

000000004000588c <z_shell_fprintf_fmt>:
{
    4000588c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40005890:	910003fd 	mov	x29, sp
	(void)cbvprintf(out_func, (void *)sh_fprintf, fmt, args);
    40005894:	a9401444 	ldp	x4, x5, [x2]
    40005898:	a90217e4 	stp	x4, x5, [sp, #32]
    4000589c:	a9410c42 	ldp	x2, x3, [x2, #16]
{
    400058a0:	f9000bf3 	str	x19, [sp, #16]
    400058a4:	aa0003f3 	mov	x19, x0
	(void)cbvprintf(out_func, (void *)sh_fprintf, fmt, args);
    400058a8:	a9030fe2 	stp	x2, x3, [sp, #48]
    400058ac:	aa0103e2 	mov	x2, x1
    400058b0:	910083e3 	add	x3, sp, #0x20
    400058b4:	aa0003e1 	mov	x1, x0
    400058b8:	90000000 	adrp	x0, 40005000 <shell_process+0x4c4>
    400058bc:	9123b000 	add	x0, x0, #0x8ec
    400058c0:	97fff065 	bl	40001a54 <cbvprintf>
	if (sh_fprintf->ctrl_blk->autoflush) {
    400058c4:	f9401260 	ldr	x0, [x19, #32]
    400058c8:	39402000 	ldrb	w0, [x0, #8]
    400058cc:	340000a0 	cbz	w0, 400058e0 <z_shell_fprintf_fmt+0x54>
		z_shell_fprintf_buffer_flush(sh_fprintf);
    400058d0:	aa1303e0 	mov	x0, x19
}
    400058d4:	f9400bf3 	ldr	x19, [sp, #16]
    400058d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
		z_shell_fprintf_buffer_flush(sh_fprintf);
    400058dc:	17ffffdd 	b	40005850 <z_shell_fprintf_buffer_flush>
}
    400058e0:	f9400bf3 	ldr	x19, [sp, #16]
    400058e4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400058e8:	d65f03c0 	ret

00000000400058ec <out_func>:
{
    400058ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400058f0:	910003fd 	mov	x29, sp
    400058f4:	a90153f3 	stp	x19, x20, [sp, #16]
    400058f8:	2a0003f4 	mov	w20, w0
    400058fc:	aa0103f3 	mov	x19, x1
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
    40005900:	f9400c20 	ldr	x0, [x1, #24]
    40005904:	b9402000 	ldr	w0, [x0, #32]
    40005908:	7100081f 	cmp	w0, #0x2
    4000590c:	540000a1 	b.ne	40005920 <out_func+0x34>  // b.any
    40005910:	71002a9f 	cmp	w20, #0xa
    40005914:	54000061 	b.ne	40005920 <out_func+0x34>  // b.any
		(void)out_func('\r', ctx);
    40005918:	528001a0 	mov	w0, #0xd                   	// #13
    4000591c:	97fffff4 	bl	400058ec <out_func>
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (uint8_t)c;
    40005920:	f9401260 	ldr	x0, [x19, #32]
    40005924:	f9400261 	ldr	x1, [x19]
    40005928:	f9400000 	ldr	x0, [x0]
    4000592c:	38206834 	strb	w20, [x1, x0]
	sh_fprintf->ctrl_blk->buffer_cnt++;
    40005930:	f9401261 	ldr	x1, [x19, #32]
    40005934:	f9400020 	ldr	x0, [x1]
    40005938:	91000400 	add	x0, x0, #0x1
    4000593c:	f9000020 	str	x0, [x1]
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
    40005940:	f9400661 	ldr	x1, [x19, #8]
    40005944:	eb01001f 	cmp	x0, x1
    40005948:	54000061 	b.ne	40005954 <out_func+0x68>  // b.any
		z_shell_fprintf_buffer_flush(sh_fprintf);
    4000594c:	aa1303e0 	mov	x0, x19
    40005950:	97ffffc0 	bl	40005850 <z_shell_fprintf_buffer_flush>
}
    40005954:	52800000 	mov	w0, #0x0                   	// #0
    40005958:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000595c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005960:	d65f03c0 	ret

0000000040005964 <z_shell_strlen>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40005964:	b40000e0 	cbz	x0, 40005980 <z_shell_strlen+0x1c>
{
    40005968:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000596c:	910003fd 	mov	x29, sp
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40005970:	94000cb9 	bl	40008c54 <strlen>
    40005974:	12003c00 	and	w0, w0, #0xffff
}
    40005978:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000597c:	d65f03c0 	ret
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40005980:	52800000 	mov	w0, #0x0                   	// #0
}
    40005984:	d65f03c0 	ret

0000000040005988 <z_column_span_with_buffer_offsets_get>:
/* Calculates column number of given position in buffer */
static uint32_t col_num_with_buffer_offset_get(struct shell_multiline_cons *cons,
					    uint16_t buffer_pos)
{
	/* columns are counted from 1 */
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
    40005988:	39403003 	ldrb	w3, [x0, #12]
    4000598c:	79401404 	ldrh	w4, [x0, #10]
    40005990:	0b222062 	add	w2, w3, w2, uxth
    40005994:	0b212061 	add	w1, w3, w1, uxth
    40005998:	1ac40840 	udiv	w0, w2, w4
    4000599c:	1ac40823 	udiv	w3, w1, w4
    400059a0:	1b048800 	msub	w0, w0, w4, w2
    400059a4:	1b048463 	msub	w3, w3, w4, w1
					      uint16_t offset1,
					      uint16_t offset2)
{
	return col_num_with_buffer_offset_get(cons, offset2)
			- col_num_with_buffer_offset_get(cons, offset1);
}
    400059a8:	4b030000 	sub	w0, w0, w3
    400059ac:	d65f03c0 	ret

00000000400059b0 <z_row_span_with_buffer_offsets_get>:
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
    400059b0:	39403003 	ldrb	w3, [x0, #12]
    400059b4:	79401404 	ldrh	w4, [x0, #10]
    400059b8:	0b212061 	add	w1, w3, w1, uxth
    400059bc:	0b222060 	add	w0, w3, w2, uxth
    400059c0:	1ac40821 	udiv	w1, w1, w4
    400059c4:	1ac40800 	udiv	w0, w0, w4
					   uint16_t offset1,
					   uint16_t offset2)
{
	return line_num_with_buffer_offset_get(cons, offset2)
		- line_num_with_buffer_offset_get(cons, offset1);
}
    400059c8:	4b010000 	sub	w0, w0, w1
    400059cc:	d65f03c0 	ret

00000000400059d0 <z_shell_multiline_data_calc>:
				 uint16_t buff_pos, uint16_t buff_len)
{
	/* Current cursor position in command.
	 * +1 -> because home position is (1, 1)
	 */
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    400059d0:	39403004 	ldrb	w4, [x0, #12]
    400059d4:	79401405 	ldrh	w5, [x0, #10]
    400059d8:	0b212081 	add	w1, w4, w1, uxth
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;

	/* Extreme position when cursor is at the end of command. */
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    400059dc:	0b222082 	add	w2, w4, w2, uxth
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    400059e0:	1ac50826 	udiv	w6, w1, w5
    400059e4:	1b0584c3 	msub	w3, w6, w5, w1
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
    400059e8:	110004c6 	add	w6, w6, #0x1
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    400059ec:	1ac50841 	udiv	w1, w2, w5
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
    400059f0:	79000806 	strh	w6, [x0, #4]
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    400059f4:	11000463 	add	w3, w3, #0x1
    400059f8:	79000003 	strh	w3, [x0]
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    400059fc:	11000423 	add	w3, w1, #0x1
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
    40005a00:	1b058821 	msub	w1, w1, w5, w2
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    40005a04:	79000c03 	strh	w3, [x0, #6]
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
    40005a08:	11000421 	add	w1, w1, #0x1
    40005a0c:	79000401 	strh	w1, [x0, #2]
}
    40005a10:	d65f03c0 	ret

0000000040005a14 <z_shell_make_argv>:
}


char z_shell_make_argv(size_t *argc, const char **argv, char *cmd,
		       uint8_t max_argc)
{
    40005a14:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40005a18:	910003fd 	mov	x29, sp
    40005a1c:	a90153f3 	stp	x19, x20, [sp, #16]
    40005a20:	aa0203f3 	mov	x19, x2
    40005a24:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005a28:	aa0003f5 	mov	x21, x0
    40005a2c:	aa0103f6 	mov	x22, x1
    40005a30:	a90363f7 	stp	x23, x24, [sp, #48]
    40005a34:	12001c77 	and	w23, w3, #0xff
	char quote = 0;
    40005a38:	52800018 	mov	w24, #0x0                   	// #0
{
    40005a3c:	a9046bf9 	stp	x25, x26, [sp, #64]
	char c;

	*argc = 0;
    40005a40:	f900001f 	str	xzr, [x0]
{
    40005a44:	f9002bfb 	str	x27, [sp, #80]
	do {
		c = *cmd;
    40005a48:	39400260 	ldrb	w0, [x19]
		if (c == '\0') {
    40005a4c:	340011a0 	cbz	w0, 40005c80 <z_shell_make_argv+0x26c>
    40005a50:	51002401 	sub	w1, w0, #0x9
    40005a54:	7100801f 	cmp	w0, #0x20
			break;
		}

		if (isspace((int) c)) {
    40005a58:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    40005a5c:	54000068 	b.hi	40005a68 <z_shell_make_argv+0x54>  // b.pmore
			*cmd++ = '\0';
    40005a60:	3800167f 	strb	wzr, [x19], #1
			continue;
    40005a64:	17fffff9 	b	40005a48 <z_shell_make_argv+0x34>
		}

		argv[(*argc)++] = cmd;
    40005a68:	f94002a1 	ldr	x1, [x21]
    40005a6c:	91000420 	add	x0, x1, #0x1
    40005a70:	f90002a0 	str	x0, [x21]
    40005a74:	f8217ad3 	str	x19, [x22, x1, lsl #3]
		if (*argc == max_argc) {
    40005a78:	eb37001f 	cmp	x0, w23, uxtb
    40005a7c:	54001020 	b.eq	40005c80 <z_shell_make_argv+0x26c>  // b.none
	char quote = 0;
    40005a80:	52800018 	mov	w24, #0x0                   	// #0
		c = *cmd;
    40005a84:	39400274 	ldrb	w20, [x19]
		if (c == '\0') {
    40005a88:	34fffe14 	cbz	w20, 40005a48 <z_shell_make_argv+0x34>
		if (!quote) {
    40005a8c:	35000338 	cbnz	w24, 40005af0 <z_shell_make_argv+0xdc>
			switch (c) {
    40005a90:	71009e9f 	cmp	w20, #0x27
    40005a94:	540000a0 	b.eq	40005aa8 <z_shell_make_argv+0x94>  // b.none
    40005a98:	7101729f 	cmp	w20, #0x5c
    40005a9c:	540001a0 	b.eq	40005ad0 <z_shell_make_argv+0xbc>  // b.none
    40005aa0:	71008a9f 	cmp	w20, #0x22
    40005aa4:	540003c1 	b.ne	40005b1c <z_shell_make_argv+0x108>  // b.any
				continue;
    40005aa8:	2a1403f8 	mov	w24, w20
    40005aac:	aa1303f4 	mov	x20, x19
						z_shell_strlen(cmd));
    40005ab0:	aa1303e0 	mov	x0, x19
    40005ab4:	97ffffac 	bl	40005964 <z_shell_strlen>
				memmove(cmd, cmd + 1,
    40005ab8:	91000661 	add	x1, x19, #0x1
    40005abc:	92403c02 	and	x2, x0, #0xffff
    40005ac0:	aa1303e0 	mov	x0, x19
    40005ac4:	94000c98 	bl	40008d24 <memmove>
				continue;
    40005ac8:	aa1403f3 	mov	x19, x20
    40005acc:	17ffffee 	b	40005a84 <z_shell_make_argv+0x70>
				memmove(cmd, cmd + 1,
    40005ad0:	91000674 	add	x20, x19, #0x1
						z_shell_strlen(cmd));
    40005ad4:	aa1303e0 	mov	x0, x19
    40005ad8:	97ffffa3 	bl	40005964 <z_shell_strlen>
				memmove(cmd, cmd + 1,
    40005adc:	aa1403e1 	mov	x1, x20
    40005ae0:	92403c02 	and	x2, x0, #0xffff
    40005ae4:	aa1303e0 	mov	x0, x19
    40005ae8:	94000c8f 	bl	40008d24 <memmove>
				continue;
    40005aec:	17fffff7 	b	40005ac8 <z_shell_make_argv+0xb4>
		if (quote == c) {
    40005af0:	6b18029f 	cmp	w20, w24
    40005af4:	54000141 	b.ne	40005b1c <z_shell_make_argv+0x108>  // b.any
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
    40005af8:	aa1303e0 	mov	x0, x19
    40005afc:	97ffff9a 	bl	40005964 <z_shell_strlen>
    40005b00:	91000661 	add	x1, x19, #0x1
    40005b04:	92403c02 	and	x2, x0, #0xffff
			continue;
    40005b08:	aa1303f4 	mov	x20, x19
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
    40005b0c:	aa1303e0 	mov	x0, x19
			quote = 0;
    40005b10:	52800018 	mov	w24, #0x0                   	// #0
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
    40005b14:	94000c84 	bl	40008d24 <memmove>
			continue;
    40005b18:	17ffffec 	b	40005ac8 <z_shell_make_argv+0xb4>
		if (quote && c == '\\') {
    40005b1c:	7101729f 	cmp	w20, #0x5c
    40005b20:	7a400b04 	ccmp	w24, #0x0, #0x4, eq  // eq = none
    40005b24:	54000a00 	b.eq	40005c64 <z_shell_make_argv+0x250>  // b.none
			char t = *(cmd + 1);
    40005b28:	aa1303f4 	mov	x20, x19
    40005b2c:	38401e81 	ldrb	w1, [x20, #1]!
			if (t == quote) {
    40005b30:	6b01031f 	cmp	w24, w1
    40005b34:	54fffd00 	b.eq	40005ad4 <z_shell_make_argv+0xc0>  // b.none
			if (t == '0') {
    40005b38:	7100c03f 	cmp	w1, #0x30
    40005b3c:	540003c1 	b.ne	40005bb4 <z_shell_make_argv+0x1a0>  // b.any
    40005b40:	d2800040 	mov	x0, #0x2                   	// #2
				uint8_t v = 0U;
    40005b44:	52800019 	mov	w25, #0x0                   	// #0
					t = *(cmd + i);
    40005b48:	38606a61 	ldrb	w1, [x19, x0]
    40005b4c:	12001c1a 	and	w26, w0, #0xff
					if (t >= '0' && t <= '7') {
    40005b50:	5100c022 	sub	w2, w1, #0x30
    40005b54:	12001c43 	and	w3, w2, #0xff
    40005b58:	71001c7f 	cmp	w3, #0x7
    40005b5c:	54000288 	b.hi	40005bac <z_shell_make_argv+0x198>  // b.pmore
						v = (v << 3) | (t - '0');
    40005b60:	2a190c59 	orr	w25, w2, w25, lsl #3
				for (i = 2U; i < (2 + 3); i++) {
    40005b64:	91000400 	add	x0, x0, #0x1
						v = (v << 3) | (t - '0');
    40005b68:	12001f39 	and	w25, w25, #0xff
				for (i = 2U; i < (2 + 3); i++) {
    40005b6c:	f100141f 	cmp	x0, #0x5
    40005b70:	54fffec1 	b.ne	40005b48 <z_shell_make_argv+0x134>  // b.any
    40005b74:	2a0003fa 	mov	w26, w0
						z_shell_strlen(cmd) - (i - 2));
    40005b78:	aa1303e0 	mov	x0, x19
    40005b7c:	97ffff7a 	bl	40005964 <z_shell_strlen>
    40005b80:	12003c02 	and	w2, w0, #0xffff
					memmove(cmd, cmd + (i - 1),
    40005b84:	5100075b 	sub	w27, w26, #0x1
						z_shell_strlen(cmd) - (i - 2));
    40005b88:	11000842 	add	w2, w2, #0x2
    40005b8c:	4b1a0042 	sub	w2, w2, w26
					memmove(cmd, cmd + (i - 1),
    40005b90:	8b3bc27b 	add	x27, x19, w27, sxtw
    40005b94:	aa1b03e1 	mov	x1, x27
    40005b98:	93407c42 	sxtw	x2, w2
					memmove(cmd, cmd + (i - 1),
    40005b9c:	aa1303e0 	mov	x0, x19
    40005ba0:	94000c61 	bl	40008d24 <memmove>
					*cmd++ = v;
    40005ba4:	39000279 	strb	w25, [x19]
					continue;
    40005ba8:	17ffffc8 	b	40005ac8 <z_shell_make_argv+0xb4>
				if (i > 2) {
    40005bac:	71000b5f 	cmp	w26, #0x2
    40005bb0:	54fffe41 	b.ne	40005b78 <z_shell_make_argv+0x164>  // b.any
			if (t == 'x') {
    40005bb4:	7101e03f 	cmp	w1, #0x78
    40005bb8:	54000601 	b.ne	40005c78 <z_shell_make_argv+0x264>  // b.any
    40005bbc:	d2800040 	mov	x0, #0x2                   	// #2
				uint8_t v = 0U;
    40005bc0:	52800019 	mov	w25, #0x0                   	// #0
					t = *(cmd + i);
    40005bc4:	38606a62 	ldrb	w2, [x19, x0]
    40005bc8:	12001c03 	and	w3, w0, #0xff
					if (t >= '0' && t <= '9') {
    40005bcc:	5100c041 	sub	w1, w2, #0x30
    40005bd0:	12001c24 	and	w4, w1, #0xff
    40005bd4:	7100249f 	cmp	w4, #0x9
    40005bd8:	54000248 	b.hi	40005c20 <z_shell_make_argv+0x20c>  // b.pmore
						v = (v << 4) | (t - '0');
    40005bdc:	2a191022 	orr	w2, w1, w25, lsl #4
						v = (v << 4) | (t - 'A' + 10);
    40005be0:	12001c59 	and	w25, w2, #0xff
				for (i = 2U; i < (2 + 2); i++) {
    40005be4:	f1000c1f 	cmp	x0, #0x3
    40005be8:	54000181 	b.ne	40005c18 <z_shell_make_argv+0x204>  // b.any
    40005bec:	5280009b 	mov	w27, #0x4                   	// #4
						z_shell_strlen(cmd) - (i - 2));
    40005bf0:	aa1303e0 	mov	x0, x19
    40005bf4:	97ffff5c 	bl	40005964 <z_shell_strlen>
    40005bf8:	12003c02 	and	w2, w0, #0xffff
					memmove(cmd, cmd + (i - 1),
    40005bfc:	5100077a 	sub	w26, w27, #0x1
						z_shell_strlen(cmd) - (i - 2));
    40005c00:	11000842 	add	w2, w2, #0x2
    40005c04:	4b1b0042 	sub	w2, w2, w27
					memmove(cmd, cmd + (i - 1),
    40005c08:	8b3ac27a 	add	x26, x19, w26, sxtw
    40005c0c:	aa1a03e1 	mov	x1, x26
    40005c10:	93407c42 	sxtw	x2, w2
    40005c14:	17ffffe2 	b	40005b9c <z_shell_make_argv+0x188>
    40005c18:	d2800060 	mov	x0, #0x3                   	// #3
    40005c1c:	17ffffea 	b	40005bc4 <z_shell_make_argv+0x1b0>
					} else if ((t >= 'a') &&
    40005c20:	51018441 	sub	w1, w2, #0x61
    40005c24:	12001c21 	and	w1, w1, #0xff
    40005c28:	7100143f 	cmp	w1, #0x5
    40005c2c:	54000088 	b.hi	40005c3c <z_shell_make_argv+0x228>  // b.pmore
						v = (v << 4) | (t - 'a' + 10);
    40005c30:	51015c42 	sub	w2, w2, #0x57
						v = (v << 4) | (t - 'A' + 10);
    40005c34:	2a191042 	orr	w2, w2, w25, lsl #4
    40005c38:	17ffffea 	b	40005be0 <z_shell_make_argv+0x1cc>
					} else if ((t >= 'A') && (t <= 'F')) {
    40005c3c:	51010441 	sub	w1, w2, #0x41
    40005c40:	12001c21 	and	w1, w1, #0xff
    40005c44:	7100143f 	cmp	w1, #0x5
    40005c48:	54000068 	b.hi	40005c54 <z_shell_make_argv+0x240>  // b.pmore
						v = (v << 4) | (t - 'A' + 10);
    40005c4c:	5100dc42 	sub	w2, w2, #0x37
    40005c50:	17fffff9 	b	40005c34 <z_shell_make_argv+0x220>
				if (i > 2) {
    40005c54:	7100087f 	cmp	w3, #0x2
    40005c58:	54000100 	b.eq	40005c78 <z_shell_make_argv+0x264>  // b.none
    40005c5c:	5280007b 	mov	w27, #0x3                   	// #3
    40005c60:	17ffffe4 	b	40005bf0 <z_shell_make_argv+0x1dc>
		if (!quote && isspace((int) c)) {
    40005c64:	350000b8 	cbnz	w24, 40005c78 <z_shell_make_argv+0x264>
    40005c68:	51002680 	sub	w0, w20, #0x9
    40005c6c:	7100829f 	cmp	w20, #0x20
    40005c70:	7a441800 	ccmp	w0, #0x4, #0x0, ne  // ne = any
    40005c74:	54ffeea9 	b.ls	40005a48 <z_shell_make_argv+0x34>  // b.plast
		cmd += 1;
    40005c78:	91000674 	add	x20, x19, #0x1
    40005c7c:	17ffff93 	b	40005ac8 <z_shell_make_argv+0xb4>
		}
		quote = make_argv(&cmd, c);
	} while (true);

	return quote;
}
    40005c80:	2a1803e0 	mov	w0, w24
    40005c84:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005c88:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005c8c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40005c90:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40005c94:	f9402bfb 	ldr	x27, [sp, #80]
    40005c98:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40005c9c:	d65f03c0 	ret

0000000040005ca0 <z_shell_pattern_remove>:

void z_shell_pattern_remove(char *buff, uint16_t *buff_len, const char *pattern)
{
    40005ca0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40005ca4:	910003fd 	mov	x29, sp
    40005ca8:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005cac:	aa0103f5 	mov	x21, x1
	char *pattern_addr = strstr(buff, pattern);
    40005cb0:	aa0203e1 	mov	x1, x2
{
    40005cb4:	aa0003f6 	mov	x22, x0
    40005cb8:	a90153f3 	stp	x19, x20, [sp, #16]
    40005cbc:	aa0203f4 	mov	x20, x2
	char *pattern_addr = strstr(buff, pattern);
    40005cc0:	94000ba2 	bl	40008b48 <strstr>
    40005cc4:	aa0003f3 	mov	x19, x0
	uint16_t shift;
	uint16_t pattern_len = z_shell_strlen(pattern);
    40005cc8:	aa1403e0 	mov	x0, x20
    40005ccc:	97ffff26 	bl	40005964 <z_shell_strlen>

	if (!pattern_addr) {
    40005cd0:	b4000333 	cbz	x19, 40005d34 <z_shell_pattern_remove+0x94>
    40005cd4:	12003c14 	and	w20, w0, #0xffff
		return;
	}

	if (pattern_addr > buff) {
    40005cd8:	eb1302df 	cmp	x22, x19
    40005cdc:	540000e2 	b.cs	40005cf8 <z_shell_pattern_remove+0x58>  // b.hs, b.nlast
		if (*(pattern_addr - 1) == ' ') {
    40005ce0:	385ff260 	ldurb	w0, [x19, #-1]
    40005ce4:	7100801f 	cmp	w0, #0x20
    40005ce8:	54000081 	b.ne	40005cf8 <z_shell_pattern_remove+0x58>  // b.any
			pattern_len++; /* space needs to be removed as well */
    40005cec:	11000694 	add	w20, w20, #0x1
			pattern_addr--; /* set pointer to space */
    40005cf0:	d1000673 	sub	x19, x19, #0x1
			pattern_len++; /* space needs to be removed as well */
    40005cf4:	12003e94 	and	w20, w20, #0xffff
		}
	}

	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    40005cf8:	aa1303e0 	mov	x0, x19
    40005cfc:	97ffff1a 	bl	40005964 <z_shell_strlen>
    40005d00:	12003c02 	and	w2, w0, #0xffff
	*buff_len -= pattern_len;
    40005d04:	794002a0 	ldrh	w0, [x21]
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    40005d08:	4b140042 	sub	w2, w2, w20

	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    40005d0c:	8b342261 	add	x1, x19, w20, uxth
	*buff_len -= pattern_len;
    40005d10:	4b140000 	sub	w0, w0, w20
    40005d14:	790002a0 	strh	w0, [x21]
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    40005d18:	aa1303e0 	mov	x0, x19
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    40005d1c:	11000442 	add	w2, w2, #0x1
}
    40005d20:	a94153f3 	ldp	x19, x20, [sp, #16]
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    40005d24:	92403c42 	and	x2, x2, #0xffff
}
    40005d28:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005d2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    40005d30:	14000bfd 	b	40008d24 <memmove>
}
    40005d34:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005d38:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005d3c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40005d40:	d65f03c0 	ret

0000000040005d44 <z_shell_cmd_get>:

const struct shell_static_entry *z_shell_cmd_get(
					const struct shell_static_entry *parent,
					size_t idx,
					struct shell_static_entry *dloc)
{
    40005d44:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005d48:	aa0003e3 	mov	x3, x0
    40005d4c:	aa0103e0 	mov	x0, x1
    40005d50:	910003fd 	mov	x29, sp
    40005d54:	f9000bf3 	str	x19, [sp, #16]
	const struct shell_static_entry *res = NULL;

	if (parent == NULL) {
    40005d58:	b5000203 	cbnz	x3, 40005d98 <z_shell_cmd_get+0x54>
	return ((uint8_t *)__shell_root_cmds_end -
    40005d5c:	90000042 	adrp	x2, 4000d000 <__rodata_region_start>
    40005d60:	913b6042 	add	x2, x2, #0xed8
    40005d64:	90000041 	adrp	x1, 4000d000 <__rodata_region_start>
    40005d68:	913da021 	add	x1, x1, #0xf68
    40005d6c:	cb020021 	sub	x1, x1, x2
		return  (idx < shell_root_cmd_count()) ?
				shell_root_cmd_get(idx)->u.entry : NULL;
    40005d70:	d3448c21 	ubfx	x1, x1, #4, #32
    40005d74:	eb00003f 	cmp	x1, x0
    40005d78:	54000249 	b.ls	40005dc0 <z_shell_cmd_get+0x7c>  // b.plast
    40005d7c:	d37c7c00 	ubfiz	x0, x0, #4, #32
    40005d80:	8b000040 	add	x0, x2, x0
    40005d84:	f9400413 	ldr	x19, [x0, #8]
			}
		}
	}

	return res;
}
    40005d88:	aa1303e0 	mov	x0, x19
    40005d8c:	f9400bf3 	ldr	x19, [sp, #16]
    40005d90:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005d94:	d65f03c0 	ret
	if (parent->subcmd) {
    40005d98:	f9400861 	ldr	x1, [x3, #16]
    40005d9c:	b4000121 	cbz	x1, 40005dc0 <z_shell_cmd_get+0x7c>
    40005da0:	aa0203f3 	mov	x19, x2
			parent->subcmd->u.dynamic_get(idx, dloc);
    40005da4:	f9400422 	ldr	x2, [x1, #8]
		if (parent->subcmd->is_dynamic) {
    40005da8:	39400021 	ldrb	w1, [x1]
    40005dac:	340000e1 	cbz	w1, 40005dc8 <z_shell_cmd_get+0x84>
			parent->subcmd->u.dynamic_get(idx, dloc);
    40005db0:	aa1303e1 	mov	x1, x19
    40005db4:	d63f0040 	blr	x2
			if (dloc->syntax != NULL) {
    40005db8:	f9400260 	ldr	x0, [x19]
    40005dbc:	b5fffe60 	cbnz	x0, 40005d88 <z_shell_cmd_get+0x44>
	const struct shell_static_entry *res = NULL;
    40005dc0:	d2800013 	mov	x19, #0x0                   	// #0
    40005dc4:	17fffff1 	b	40005d88 <z_shell_cmd_get+0x44>
			if (parent->subcmd->u.entry[idx].syntax != NULL) {
    40005dc8:	d2800501 	mov	x1, #0x28                  	// #40
    40005dcc:	9b017c00 	mul	x0, x0, x1
    40005dd0:	8b000053 	add	x19, x2, x0
    40005dd4:	f8606840 	ldr	x0, [x2, x0]
    40005dd8:	17fffff9 	b	40005dbc <z_shell_cmd_get+0x78>

0000000040005ddc <z_shell_find_cmd>:
 */
const struct shell_static_entry *z_shell_find_cmd(
					const struct shell_static_entry *parent,
					const char *cmd_str,
					struct shell_static_entry *dloc)
{
    40005ddc:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40005de0:	910003fd 	mov	x29, sp
    40005de4:	a90153f3 	stp	x19, x20, [sp, #16]
    40005de8:	aa0003f3 	mov	x19, x0
    40005dec:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005df0:	aa0203f6 	mov	x22, x2
    40005df4:	f9001bf7 	str	x23, [sp, #48]
    40005df8:	aa0103f7 	mov	x23, x1
	 * dynamic commands at the same time (current and subcommand) they
	 * will operate on the same memory region what can cause undefined
	 * behaviour.
	 * Hence we need a separate memory for each of them.
	 */
	if (parent) {
    40005dfc:	b40000c0 	cbz	x0, 40005e14 <z_shell_find_cmd+0x38>
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
		parent = &parent_cpy;
    40005e00:	910123f3 	add	x19, sp, #0x48
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
    40005e04:	aa0003e1 	mov	x1, x0
    40005e08:	d2800502 	mov	x2, #0x28                  	// #40
    40005e0c:	910123e0 	add	x0, sp, #0x48
    40005e10:	94000bd4 	bl	40008d60 <memcpy>
		parent = &parent_cpy;
    40005e14:	d2800015 	mov	x21, #0x0                   	// #0
	}

	while ((entry = z_shell_cmd_get(parent, idx++, dloc)) != NULL) {
    40005e18:	aa1503e1 	mov	x1, x21
    40005e1c:	aa1603e2 	mov	x2, x22
    40005e20:	aa1303e0 	mov	x0, x19
    40005e24:	910006b5 	add	x21, x21, #0x1
    40005e28:	97ffffc7 	bl	40005d44 <z_shell_cmd_get>
    40005e2c:	aa0003f4 	mov	x20, x0
    40005e30:	b40000a0 	cbz	x0, 40005e44 <z_shell_find_cmd+0x68>
		if (strcmp(cmd_str, entry->syntax) == 0) {
    40005e34:	f9400281 	ldr	x1, [x20]
    40005e38:	aa1703e0 	mov	x0, x23
    40005e3c:	94000b96 	bl	40008c94 <strcmp>
    40005e40:	35fffec0 	cbnz	w0, 40005e18 <z_shell_find_cmd+0x3c>
			return entry;
		}
	}

	return NULL;
}
    40005e44:	aa1403e0 	mov	x0, x20
    40005e48:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005e4c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005e50:	f9401bf7 	ldr	x23, [sp, #48]
    40005e54:	a8c77bfd 	ldp	x29, x30, [sp], #112
    40005e58:	d65f03c0 	ret

0000000040005e5c <z_shell_get_last_command>:
					size_t argc,
					const char *argv[],
					size_t *match_arg,
					struct shell_static_entry *dloc,
					bool only_static)
{
    40005e5c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40005e60:	910003fd 	mov	x29, sp
    40005e64:	a90153f3 	stp	x19, x20, [sp, #16]
    40005e68:	aa0303f3 	mov	x19, x3
    40005e6c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005e70:	aa0203f5 	mov	x21, x2
    40005e74:	aa0403f6 	mov	x22, x4
    40005e78:	a90363f7 	stp	x23, x24, [sp, #48]
    40005e7c:	aa0103f7 	mov	x23, x1
    40005e80:	12001cb8 	and	w24, w5, #0xff
	const struct shell_static_entry *prev_entry = NULL;

	*match_arg = Z_SHELL_CMD_ROOT_LVL;
    40005e84:	f900007f 	str	xzr, [x3]

		if (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {
			/* ignore wildcard argument */
			if (z_shell_has_wildcard(argv[*match_arg])) {
				(*match_arg)++;
				continue;
    40005e88:	aa0003f4 	mov	x20, x0
	while (*match_arg < argc) {
    40005e8c:	f9400260 	ldr	x0, [x19]
    40005e90:	eb17001f 	cmp	x0, x23
    40005e94:	540002e2 	b.cs	40005ef0 <z_shell_get_last_command+0x94>  // b.hs, b.nlast
			if (z_shell_has_wildcard(argv[*match_arg])) {
    40005e98:	f8607aa0 	ldr	x0, [x21, x0, lsl #3]
    40005e9c:	94000688 	bl	400078bc <z_shell_has_wildcard>
    40005ea0:	72001c1f 	tst	w0, #0xff
    40005ea4:	f9400260 	ldr	x0, [x19]
    40005ea8:	540000a0 	b.eq	40005ebc <z_shell_get_last_command+0x60>  // b.none
				(*match_arg)++;
    40005eac:	91000400 	add	x0, x0, #0x1
    40005eb0:	f9000260 	str	x0, [x19]
				continue;
    40005eb4:	aa1403e0 	mov	x0, x20
    40005eb8:	17fffff4 	b	40005e88 <z_shell_get_last_command+0x2c>
			}
		}

		prev_entry = entry;
		entry = z_shell_find_cmd(entry, argv[*match_arg], dloc);
    40005ebc:	f8607aa1 	ldr	x1, [x21, x0, lsl #3]
    40005ec0:	aa1603e2 	mov	x2, x22
    40005ec4:	aa1403e0 	mov	x0, x20
    40005ec8:	97ffffc5 	bl	40005ddc <z_shell_find_cmd>
		if (entry) {
    40005ecc:	b4000120 	cbz	x0, 40005ef0 <z_shell_get_last_command+0x94>
			(*match_arg)++;
    40005ed0:	f9400261 	ldr	x1, [x19]
		} else {
			entry = prev_entry;
			break;
		}

		if (only_static && (entry == dloc)) {
    40005ed4:	7100031f 	cmp	w24, #0x0
    40005ed8:	fa4012c0 	ccmp	x22, x0, #0x0, ne  // ne = any
			(*match_arg)++;
    40005edc:	91000422 	add	x2, x1, #0x1
    40005ee0:	f9000262 	str	x2, [x19]
		if (only_static && (entry == dloc)) {
    40005ee4:	54fffd21 	b.ne	40005e88 <z_shell_get_last_command+0x2c>  // b.any
			(*match_arg)--;
			return NULL;
    40005ee8:	d2800014 	mov	x20, #0x0                   	// #0
			(*match_arg)--;
    40005eec:	f9000261 	str	x1, [x19]
		}
	}

	return entry;
}
    40005ef0:	aa1403e0 	mov	x0, x20
    40005ef4:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005ef8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005efc:	a94363f7 	ldp	x23, x24, [sp, #48]
    40005f00:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40005f04:	d65f03c0 	ret

0000000040005f08 <z_shell_spaces_trim>:




void z_shell_spaces_trim(char *str)
{
    40005f08:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40005f0c:	910003fd 	mov	x29, sp
    40005f10:	a90153f3 	stp	x19, x20, [sp, #16]
    40005f14:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005f18:	aa0003f6 	mov	x22, x0
	uint16_t len = z_shell_strlen(str);
    40005f1c:	97fffe92 	bl	40005964 <z_shell_strlen>
	uint16_t shift = 0U;

	if (!str) {
    40005f20:	b50004f6 	cbnz	x22, 40005fbc <z_shell_spaces_trim+0xb4>

				break;
			}
		}
	}
}
    40005f24:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005f28:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005f2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40005f30:	d65f03c0 	ret
				if (shift > 0) {
    40005f34:	34000135 	cbz	w21, 40005f58 <z_shell_spaces_trim+0x50>
						len - j + 1);
    40005f38:	11000662 	add	w2, w19, #0x1
					len -= shift;
    40005f3c:	4b150273 	sub	w19, w19, w21
    40005f40:	12003e73 	and	w19, w19, #0xffff
						len - j + 1);
    40005f44:	4b040042 	sub	w2, w2, w4
					shift = 0U;
    40005f48:	52800015 	mov	w21, #0x0                   	// #0
					memmove(&str[i + 1],
    40005f4c:	8b34c2c0 	add	x0, x22, w20, sxtw
    40005f50:	93407c42 	sxtw	x2, w2
    40005f54:	94000b74 	bl	40008d24 <memmove>
	for (uint16_t i = 0; i < len - 1; i++) {
    40005f58:	12003e81 	and	w1, w20, #0xffff
    40005f5c:	51000660 	sub	w0, w19, #0x1
    40005f60:	6b00003f 	cmp	w1, w0
    40005f64:	54fffe0a 	b.ge	40005f24 <z_shell_spaces_trim+0x1c>  // b.tcont
		if (isspace((int)str[i])) {
    40005f68:	92403c20 	and	x0, x1, #0xffff
    40005f6c:	11000434 	add	w20, w1, #0x1
    40005f70:	38606ac0 	ldrb	w0, [x22, x0]
    40005f74:	51002402 	sub	w2, w0, #0x9
    40005f78:	7100801f 	cmp	w0, #0x20
    40005f7c:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    40005f80:	54fffec8 	b.hi	40005f58 <z_shell_spaces_trim+0x50>  // b.pmore
			for (uint16_t j = i + 1; j < len; j++) {
    40005f84:	92403e80 	and	x0, x20, #0xffff
    40005f88:	12003c04 	and	w4, w0, #0xffff
    40005f8c:	6b20227f 	cmp	w19, w0, uxth
    40005f90:	54fffe49 	b.ls	40005f58 <z_shell_spaces_trim+0x50>  // b.plast
				if (isspace((int)str[j])) {
    40005f94:	38606ac3 	ldrb	w3, [x22, x0]
    40005f98:	8b0002c1 	add	x1, x22, x0
    40005f9c:	91000400 	add	x0, x0, #0x1
    40005fa0:	51002462 	sub	w2, w3, #0x9
    40005fa4:	7100807f 	cmp	w3, #0x20
    40005fa8:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    40005fac:	54fffc48 	b.hi	40005f34 <z_shell_spaces_trim+0x2c>  // b.pmore
					shift++;
    40005fb0:	110006b5 	add	w21, w21, #0x1
    40005fb4:	12003eb5 	and	w21, w21, #0xffff
			for (uint16_t j = i + 1; j < len; j++) {
    40005fb8:	17fffff4 	b	40005f88 <z_shell_spaces_trim+0x80>
    40005fbc:	12003c13 	and	w19, w0, #0xffff
	for (uint16_t i = 0; i < len - 1; i++) {
    40005fc0:	52800001 	mov	w1, #0x0                   	// #0
	uint16_t shift = 0U;
    40005fc4:	52800015 	mov	w21, #0x0                   	// #0
    40005fc8:	17ffffe5 	b	40005f5c <z_shell_spaces_trim+0x54>

0000000040005fcc <z_shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void z_shell_cmd_trim(const struct shell *shell)
{
    40005fcc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40005fd0:	910003fd 	mov	x29, sp
    40005fd4:	a90153f3 	stp	x19, x20, [sp, #16]
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
    40005fd8:	f9400813 	ldr	x19, [x0, #16]
{
    40005fdc:	f90013f5 	str	x21, [sp, #32]
    40005fe0:	aa0003f5 	mov	x21, x0
	if (buff[0] == '\0') {
    40005fe4:	39425a60 	ldrb	w0, [x19, #150]
    40005fe8:	350001a0 	cbnz	w0, 4000601c <z_shell_cmd_trim+0x50>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    40005fec:	f9400aa0 	ldr	x0, [x21, #16]
}
    40005ff0:	a94153f3 	ldp	x19, x20, [sp, #16]
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    40005ff4:	79412001 	ldrh	w1, [x0, #144]
    40005ff8:	79012401 	strh	w1, [x0, #146]
}
    40005ffc:	f94013f5 	ldr	x21, [sp, #32]
    40006000:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40006004:	d65f03c0 	ret
		*buff_len -= 1U;
    40006008:	12003c41 	and	w1, w2, #0xffff
    4000600c:	79012261 	strh	w1, [x19, #144]
		if (*buff_len == 0U) {
    40006010:	35000081 	cbnz	w1, 40006020 <z_shell_cmd_trim+0x54>
			buff[0] = '\0';
    40006014:	39025a7f 	strb	wzr, [x19, #150]
			return;
    40006018:	17fffff5 	b	40005fec <z_shell_cmd_trim+0x20>
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
    4000601c:	91025a60 	add	x0, x19, #0x96
	while (isspace((int) buff[*buff_len - 1U])) {
    40006020:	79412261 	ldrh	w1, [x19, #144]
    40006024:	51000423 	sub	w3, w1, #0x1
    40006028:	51000422 	sub	w2, w1, #0x1
    4000602c:	38636803 	ldrb	w3, [x0, x3]
    40006030:	51002464 	sub	w4, w3, #0x9
    40006034:	7100807f 	cmp	w3, #0x20
    40006038:	7a441880 	ccmp	w4, #0x4, #0x0, ne  // ne = any
    4000603c:	54fffe69 	b.ls	40006008 <z_shell_cmd_trim+0x3c>  // b.plast
	buff[*buff_len] = '\0';
    40006040:	92403c21 	and	x1, x1, #0xffff
	uint16_t i = 0U;
    40006044:	52800002 	mov	w2, #0x0                   	// #0
	buff[*buff_len] = '\0';
    40006048:	3821681f 	strb	wzr, [x0, x1]
	while (isspace((int) buff[i++])) {
    4000604c:	2a0203f4 	mov	w20, w2
    40006050:	11000442 	add	w2, w2, #0x1
    40006054:	92403e83 	and	x3, x20, #0xffff
    40006058:	12003c42 	and	w2, w2, #0xffff
    4000605c:	8b342001 	add	x1, x0, w20, uxth
    40006060:	38636803 	ldrb	w3, [x0, x3]
    40006064:	51002464 	sub	w4, w3, #0x9
    40006068:	7100807f 	cmp	w3, #0x20
    4000606c:	7a441880 	ccmp	w4, #0x4, #0x0, ne  // ne = any
    40006070:	54fffee9 	b.ls	4000604c <z_shell_cmd_trim+0x80>  // b.plast
	if (--i > 0) {
    40006074:	34fffbd4 	cbz	w20, 40005fec <z_shell_cmd_trim+0x20>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
    40006078:	79412262 	ldrh	w2, [x19, #144]
    4000607c:	11000442 	add	w2, w2, #0x1
    40006080:	4b140042 	sub	w2, w2, w20
    40006084:	94000b28 	bl	40008d24 <memmove>
		*buff_len = *buff_len - i;
    40006088:	79412260 	ldrh	w0, [x19, #144]
    4000608c:	4b140014 	sub	w20, w0, w20
    40006090:	79012274 	strh	w20, [x19, #144]
    40006094:	17ffffd6 	b	40005fec <z_shell_cmd_trim+0x20>

0000000040006098 <z_shell_raw_fprintf>:
{
    40006098:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    4000609c:	910003fd 	mov	x29, sp
    400060a0:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    400060a4:	910403e2 	add	x2, sp, #0x100
    400060a8:	a9030be2 	stp	x2, x2, [sp, #48]
    400060ac:	910343e2 	add	x2, sp, #0xd0
    400060b0:	f90023e2 	str	x2, [sp, #64]
    400060b4:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    400060b8:	b9004be2 	str	w2, [sp, #72]
    400060bc:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    400060c0:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    400060c4:	a9430fe2 	ldp	x2, x3, [sp, #48]
    400060c8:	a9010fe2 	stp	x2, x3, [sp, #16]
    400060cc:	a9440fe2 	ldp	x2, x3, [sp, #64]
    400060d0:	a9020fe2 	stp	x2, x3, [sp, #32]
    400060d4:	910043e2 	add	x2, sp, #0x10
{
    400060d8:	3d8017e0 	str	q0, [sp, #80]
    400060dc:	3d801be1 	str	q1, [sp, #96]
    400060e0:	3d801fe2 	str	q2, [sp, #112]
    400060e4:	3d8023e3 	str	q3, [sp, #128]
    400060e8:	3d8027e4 	str	q4, [sp, #144]
    400060ec:	3d802be5 	str	q5, [sp, #160]
    400060f0:	3d802fe6 	str	q6, [sp, #176]
    400060f4:	3d8033e7 	str	q7, [sp, #192]
    400060f8:	a90e17e4 	stp	x4, x5, [sp, #224]
    400060fc:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40006100:	97fffde3 	bl	4000588c <z_shell_fprintf_fmt>
}
    40006104:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40006108:	d65f03c0 	ret

000000004000610c <z_clear_eos>:
	return sh->ctx->cfg.flags.use_vt100 == 1;
    4000610c:	f9400801 	ldr	x1, [x0, #16]
    40006110:	b942b821 	ldr	w1, [x1, #696]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
    40006114:	362800a1 	tbz	w1, #5, 40006128 <z_clear_eos+0x1c>
    40006118:	f9401400 	ldr	x0, [x0, #40]
    4000611c:	f0000021 	adrp	x1, 4000d000 <__rodata_region_start>
    40006120:	913e2021 	add	x1, x1, #0xf88
    40006124:	17ffffdd 	b	40006098 <z_shell_raw_fprintf>
}
    40006128:	d65f03c0 	ret

000000004000612c <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
    4000612c:	90000041 	adrp	x1, 4000e000 <mmu_regions+0x38>
    40006130:	91317421 	add	x1, x1, #0xc5d
    40006134:	17ffffd9 	b	40006098 <z_shell_raw_fprintf>

0000000040006138 <full_line_cmd>:

/* Function returns true if command length is equal to multiplicity of terminal
 * width.
 */
static inline bool full_line_cmd(const struct shell *shell)
{
    40006138:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000613c:	910003fd 	mov	x29, sp
    40006140:	a90153f3 	stp	x19, x20, [sp, #16]
    40006144:	aa0003f3 	mov	x19, x0
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
    40006148:	f9400800 	ldr	x0, [x0, #16]
    4000614c:	79412014 	ldrh	w20, [x0, #144]
    40006150:	f9400000 	ldr	x0, [x0]
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40006154:	b40001a0 	cbz	x0, 40006188 <full_line_cmd+0x50>
    40006158:	94000abf 	bl	40008c54 <strlen>
    4000615c:	12003c01 	and	w1, w0, #0xffff
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40006160:	f9400a60 	ldr	x0, [x19, #16]
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
    40006164:	0b140021 	add	w1, w1, w20
}
    40006168:	a94153f3 	ldp	x19, x20, [sp, #16]
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    4000616c:	79409402 	ldrh	w2, [x0, #74]
}
    40006170:	a8c27bfd 	ldp	x29, x30, [sp], #32
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40006174:	1ac20820 	udiv	w0, w1, w2
    40006178:	1b028401 	msub	w1, w0, w2, w1
    4000617c:	7100003f 	cmp	w1, #0x0
}
    40006180:	1a9f17e0 	cset	w0, eq  // eq = none
    40006184:	d65f03c0 	ret
    40006188:	52800001 	mov	w1, #0x0                   	// #0
    4000618c:	17fffff5 	b	40006160 <full_line_cmd+0x28>

0000000040006190 <z_shell_op_cursor_vert_move>:
	char dir = delta > 0 ? 'A' : 'B';
    40006190:	7100003f 	cmp	w1, #0x0
    40006194:	5400018c 	b.gt	400061c4 <z_shell_op_cursor_vert_move+0x34>
	if (delta == 0) {
    40006198:	540001a0 	b.eq	400061cc <z_shell_op_cursor_vert_move+0x3c>  // b.none
	char dir = delta > 0 ? 'A' : 'B';
    4000619c:	52800843 	mov	w3, #0x42                  	// #66
	return sh->ctx->cfg.flags.use_vt100 == 1;
    400061a0:	f9400802 	ldr	x2, [x0, #16]
    400061a4:	b942b842 	ldr	w2, [x2, #696]
	Z_SHELL_VT100_CMD(shell, "\e[%d%c", delta, dir);
    400061a8:	36280122 	tbz	w2, #5, 400061cc <z_shell_op_cursor_vert_move+0x3c>
    400061ac:	f9401400 	ldr	x0, [x0, #40]
    400061b0:	7100003f 	cmp	w1, #0x0
    400061b4:	5a81a422 	cneg	w2, w1, lt  // lt = tstop
    400061b8:	b0000041 	adrp	x1, 4000f000 <cfg_flags.0+0x5ac>
    400061bc:	910ab021 	add	x1, x1, #0x2ac
    400061c0:	17ffffb6 	b	40006098 <z_shell_raw_fprintf>
	char dir = delta > 0 ? 'A' : 'B';
    400061c4:	52800823 	mov	w3, #0x41                  	// #65
    400061c8:	17fffff6 	b	400061a0 <z_shell_op_cursor_vert_move+0x10>
}
    400061cc:	d65f03c0 	ret

00000000400061d0 <z_shell_op_cursor_horiz_move>:
	char dir = delta > 0 ? 'C' : 'D';
    400061d0:	7100003f 	cmp	w1, #0x0
    400061d4:	5400018c 	b.gt	40006204 <z_shell_op_cursor_horiz_move+0x34>
	if (delta == 0) {
    400061d8:	540001a0 	b.eq	4000620c <z_shell_op_cursor_horiz_move+0x3c>  // b.none
	char dir = delta > 0 ? 'C' : 'D';
    400061dc:	52800883 	mov	w3, #0x44                  	// #68
    400061e0:	f9400802 	ldr	x2, [x0, #16]
    400061e4:	b942b842 	ldr	w2, [x2, #696]
	Z_SHELL_VT100_CMD(shell, "\e[%d%c", delta, dir);
    400061e8:	36280122 	tbz	w2, #5, 4000620c <z_shell_op_cursor_horiz_move+0x3c>
    400061ec:	f9401400 	ldr	x0, [x0, #40]
    400061f0:	7100003f 	cmp	w1, #0x0
    400061f4:	5a81a422 	cneg	w2, w1, lt  // lt = tstop
    400061f8:	b0000041 	adrp	x1, 4000f000 <cfg_flags.0+0x5ac>
    400061fc:	910ab021 	add	x1, x1, #0x2ac
    40006200:	17ffffa6 	b	40006098 <z_shell_raw_fprintf>
	char dir = delta > 0 ? 'C' : 'D';
    40006204:	52800863 	mov	w3, #0x43                  	// #67
    40006208:	17fffff6 	b	400061e0 <z_shell_op_cursor_horiz_move+0x10>
}
    4000620c:	d65f03c0 	ret

0000000040006210 <z_shell_cursor_in_empty_line>:

/* Function returns true if cursor is at beginning of an empty line. */
bool z_shell_cursor_in_empty_line(const struct shell *shell)
{
    40006210:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40006214:	910003fd 	mov	x29, sp
    40006218:	a90153f3 	stp	x19, x20, [sp, #16]
    4000621c:	aa0003f3 	mov	x19, x0
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
    40006220:	f9400800 	ldr	x0, [x0, #16]
    40006224:	79412414 	ldrh	w20, [x0, #146]
    40006228:	f9400000 	ldr	x0, [x0]
    4000622c:	b40001a0 	cbz	x0, 40006260 <z_shell_cursor_in_empty_line+0x50>
    40006230:	94000a89 	bl	40008c54 <strlen>
    40006234:	12003c01 	and	w1, w0, #0xffff
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40006238:	f9400a60 	ldr	x0, [x19, #16]
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
    4000623c:	0b140021 	add	w1, w1, w20
}
    40006240:	a94153f3 	ldp	x19, x20, [sp, #16]
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40006244:	79409402 	ldrh	w2, [x0, #74]
}
    40006248:	a8c27bfd 	ldp	x29, x30, [sp], #32
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    4000624c:	1ac20820 	udiv	w0, w1, w2
    40006250:	1b028401 	msub	w1, w0, w2, w1
    40006254:	7100003f 	cmp	w1, #0x0
}
    40006258:	1a9f17e0 	cset	w0, eq  // eq = none
    4000625c:	d65f03c0 	ret
    40006260:	52800001 	mov	w1, #0x0                   	// #0
    40006264:	17fffff5 	b	40006238 <z_shell_cursor_in_empty_line+0x28>

0000000040006268 <z_shell_op_cond_next_line>:

void z_shell_op_cond_next_line(const struct shell *shell)
{
    40006268:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000626c:	910003fd 	mov	x29, sp
    40006270:	f9000bf3 	str	x19, [sp, #16]
    40006274:	aa0003f3 	mov	x19, x0
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
    40006278:	97ffffe6 	bl	40006210 <z_shell_cursor_in_empty_line>
    4000627c:	72001c1f 	tst	w0, #0xff
    40006280:	540000a0 	b.eq	40006294 <z_shell_op_cond_next_line+0x2c>  // b.none
		z_cursor_next_line_move(shell);
    40006284:	f9401660 	ldr	x0, [x19, #40]
	}
}
    40006288:	f9400bf3 	ldr	x19, [sp, #16]
    4000628c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_cursor_next_line_move(shell);
    40006290:	17ffffa7 	b	4000612c <z_cursor_next_line_move.isra.0>
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
    40006294:	aa1303e0 	mov	x0, x19
    40006298:	97ffffa8 	bl	40006138 <full_line_cmd>
    4000629c:	72001c1f 	tst	w0, #0xff
    400062a0:	54ffff21 	b.ne	40006284 <z_shell_op_cond_next_line+0x1c>  // b.any
}
    400062a4:	f9400bf3 	ldr	x19, [sp, #16]
    400062a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400062ac:	d65f03c0 	ret

00000000400062b0 <z_shell_op_cursor_position_synchronize>:

void z_shell_op_cursor_position_synchronize(const struct shell *shell)
{
    400062b0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400062b4:	910003fd 	mov	x29, sp
    400062b8:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    400062bc:	f9400815 	ldr	x21, [x0, #16]
{
    400062c0:	a90153f3 	stp	x19, x20, [sp, #16]
    400062c4:	aa0003f3 	mov	x19, x0
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    400062c8:	910102b4 	add	x20, x21, #0x40
	bool last_line;

	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    400062cc:	794122a2 	ldrh	w2, [x21, #144]
    400062d0:	aa1403e0 	mov	x0, x20
    400062d4:	794126a1 	ldrh	w1, [x21, #146]
{
    400062d8:	f9001bf7 	str	x23, [sp, #48]
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    400062dc:	97fffdbd 	bl	400059d0 <z_shell_multiline_data_calc>
				    shell->ctx->cmd_buff_len);
	last_line = (cons->cur_y == cons->cur_y_end);
    400062e0:	79400a97 	ldrh	w23, [x20, #4]
    400062e4:	79400e96 	ldrh	w22, [x20, #6]

	/* In case cursor reaches the bottom line of a terminal, it will
	 * be moved to the next line.
	 */
	if (full_line_cmd(shell)) {
    400062e8:	aa1303e0 	mov	x0, x19
    400062ec:	97ffff93 	bl	40006138 <full_line_cmd>
    400062f0:	72001c1f 	tst	w0, #0xff
    400062f4:	54000060 	b.eq	40006300 <z_shell_op_cursor_position_synchronize+0x50>  // b.none
		z_cursor_next_line_move(shell);
    400062f8:	f9401660 	ldr	x0, [x19, #40]
    400062fc:	97ffff8c 	bl	4000612c <z_cursor_next_line_move.isra.0>
	}

	if (last_line) {
    40006300:	6b1602ff 	cmp	w23, w22
    40006304:	54000141 	b.ne	4000632c <z_shell_op_cursor_position_synchronize+0x7c>  // b.any
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
	} else {
		z_shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
    40006308:	79400680 	ldrh	w0, [x20, #2]
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
    4000630c:	794082a1 	ldrh	w1, [x21, #64]
	}
}
    40006310:	a9425bf5 	ldp	x21, x22, [sp, #32]
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
    40006314:	4b000021 	sub	w1, w1, w0
    40006318:	aa1303e0 	mov	x0, x19
}
    4000631c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006320:	f9401bf7 	ldr	x23, [sp, #48]
    40006324:	a8c47bfd 	ldp	x29, x30, [sp], #64
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
    40006328:	17ffffaa 	b	400061d0 <z_shell_op_cursor_horiz_move>
		z_shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
    4000632c:	79400a80 	ldrh	w0, [x20, #4]
    40006330:	79400e81 	ldrh	w1, [x20, #6]
    40006334:	4b000021 	sub	w1, w1, w0
    40006338:	aa1303e0 	mov	x0, x19
    4000633c:	97ffff95 	bl	40006190 <z_shell_op_cursor_vert_move>
    40006340:	17fffff2 	b	40006308 <z_shell_op_cursor_position_synchronize+0x58>

0000000040006344 <z_shell_op_cursor_move>:

void z_shell_op_cursor_move(const struct shell *shell, int16_t val)
{
    40006344:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40006348:	910003fd 	mov	x29, sp
    4000634c:	a90153f3 	stp	x19, x20, [sp, #16]
    40006350:	aa0003f3 	mov	x19, x0
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    40006354:	f9400800 	ldr	x0, [x0, #16]
{
    40006358:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
	int32_t row_span;
	int32_t col_span;

	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    4000635c:	91010000 	add	x0, x0, #0x40
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
    40006360:	7940a403 	ldrh	w3, [x0, #82]
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    40006364:	7940a002 	ldrh	w2, [x0, #80]
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
    40006368:	0b21a061 	add	w1, w3, w1, sxth
    4000636c:	12003c34 	and	w20, w1, #0xffff
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    40006370:	2a0303e1 	mov	w1, w3
    40006374:	97fffd97 	bl	400059d0 <z_shell_multiline_data_calc>
				    shell->ctx->cmd_buff_len);

	/* Calculate the new cursor. */
	row_span = z_row_span_with_buffer_offsets_get(
						&shell->ctx->vt100_ctx.cons,
    40006378:	f9400a60 	ldr	x0, [x19, #16]
	row_span = z_row_span_with_buffer_offsets_get(
    4000637c:	2a1403e2 	mov	w2, w20
    40006380:	91010000 	add	x0, x0, #0x40
    40006384:	7940a401 	ldrh	w1, [x0, #82]
    40006388:	97fffd8a 	bl	400059b0 <z_row_span_with_buffer_offsets_get>
    4000638c:	2a0003f6 	mov	w22, w0
						shell->ctx->cmd_buff_pos,
						new_pos);
	col_span = z_column_span_with_buffer_offsets_get(
						&shell->ctx->vt100_ctx.cons,
    40006390:	f9400a60 	ldr	x0, [x19, #16]
	col_span = z_column_span_with_buffer_offsets_get(
    40006394:	2a1403e2 	mov	w2, w20
    40006398:	91010000 	add	x0, x0, #0x40
    4000639c:	7940a401 	ldrh	w1, [x0, #82]
    400063a0:	97fffd7a 	bl	40005988 <z_column_span_with_buffer_offsets_get>
    400063a4:	2a0003f5 	mov	w21, w0
						shell->ctx->cmd_buff_pos,
						new_pos);

	z_shell_op_cursor_vert_move(shell, -row_span);
    400063a8:	4b1603e1 	neg	w1, w22
    400063ac:	aa1303e0 	mov	x0, x19
    400063b0:	97ffff78 	bl	40006190 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(shell, col_span);
    400063b4:	2a1503e1 	mov	w1, w21
    400063b8:	aa1303e0 	mov	x0, x19
    400063bc:	97ffff85 	bl	400061d0 <z_shell_op_cursor_horiz_move>
	shell->ctx->cmd_buff_pos = new_pos;
    400063c0:	f9400a60 	ldr	x0, [x19, #16]
}
    400063c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
	shell->ctx->cmd_buff_pos = new_pos;
    400063c8:	79012414 	strh	w20, [x0, #146]
}
    400063cc:	a94153f3 	ldp	x19, x20, [sp, #16]
    400063d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400063d4:	d65f03c0 	ret

00000000400063d8 <z_shell_op_cursor_word_move>:

	return ret;
}

void z_shell_op_cursor_word_move(const struct shell *shell, int16_t val)
{
    400063d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400063dc:	13003c21 	sxth	w1, w1
    400063e0:	910003fd 	mov	x29, sp
    400063e4:	a90153f3 	stp	x19, x20, [sp, #16]
    400063e8:	a9025bf5 	stp	x21, x22, [sp, #32]
    400063ec:	aa0003f5 	mov	x21, x0
	int16_t shift;
	int16_t sign;

	if (val < 0) {
    400063f0:	36f80581 	tbz	w1, #31, 400064a0 <z_shell_op_cursor_word_move+0xc8>
		val = -val;
    400063f4:	4b0103e1 	neg	w1, w1
		sign = -1;
    400063f8:	12800014 	mov	w20, #0xffffffff            	// #-1
		val = -val;
    400063fc:	13003c21 	sxth	w1, w1
		sign = -1;
    40006400:	12003c33 	and	w19, w1, #0xffff
    40006404:	12003e96 	and	w22, w20, #0xffff
    40006408:	1400001d 	b	4000647c <z_shell_op_cursor_word_move+0xa4>
	} else {
		sign = 1;
	}

	while (val--) {
		shift = shift_calc(shell->ctx->cmd_buff,
    4000640c:	f9400aa0 	ldr	x0, [x21, #16]
	bool found = false;
    40006410:	52800003 	mov	w3, #0x0                   	// #0
		shift = shift_calc(shell->ctx->cmd_buff,
    40006414:	91025806 	add	x6, x0, #0x96
    40006418:	79412405 	ldrh	w5, [x0, #146]
    4000641c:	79412007 	ldrh	w7, [x0, #144]
    40006420:	2a0503e2 	mov	w2, w5
		idx = pos + ret * sign;
    40006424:	4b050041 	sub	w1, w2, w5
		if (((idx == 0U) && (sign < 0)) ||
    40006428:	7100005f 	cmp	w2, #0x0
    4000642c:	7a400a80 	ccmp	w20, #0x0, #0x0, eq  // eq = none
    40006430:	13003c21 	sxth	w1, w1
    40006434:	540001cb 	b.lt	4000646c <z_shell_op_cursor_word_move+0x94>  // b.tstop
		    ((idx == len) && (sign > 0))) {
    40006438:	7100029f 	cmp	w20, #0x0
		if (((idx == 0U) && (sign < 0)) ||
    4000643c:	7a42c0e0 	ccmp	w7, w2, #0x0, gt
    40006440:	54000160 	b.eq	4000646c <z_shell_op_cursor_word_move+0x94>  // b.none
		if (isalnum((int)str[idx]) != 0) {
    40006444:	92403c40 	and	x0, x2, #0xffff
    40006448:	386068c0 	ldrb	w0, [x6, x0]
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    4000644c:	321b0004 	orr	w4, w0, #0x20
    40006450:	51018484 	sub	w4, w4, #0x61
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
    40006454:	7100649f 	cmp	w4, #0x19
    40006458:	540001c9 	b.ls	40006490 <z_shell_op_cursor_word_move+0xb8>  // b.plast
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    4000645c:	5100c000 	sub	w0, w0, #0x30
	return (int)(isalpha(chr) || isdigit(chr));
    40006460:	7100241f 	cmp	w0, #0x9
    40006464:	54000169 	b.ls	40006490 <z_shell_op_cursor_word_move+0xb8>  // b.plast
			if (found) {
    40006468:	34000163 	cbz	w3, 40006494 <z_shell_op_cursor_word_move+0xbc>
				   shell->ctx->cmd_buff_pos,
				   shell->ctx->cmd_buff_len, sign);
		z_shell_op_cursor_move(shell, sign * shift);
    4000646c:	aa1503e0 	mov	x0, x21
    40006470:	97ffffb5 	bl	40006344 <z_shell_op_cursor_move>
    40006474:	51000661 	sub	w1, w19, #0x1
    40006478:	12003c33 	and	w19, w1, #0xffff
	while (val--) {
    4000647c:	35fffc93 	cbnz	w19, 4000640c <z_shell_op_cursor_word_move+0x34>
	}
}
    40006480:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006484:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006488:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000648c:	d65f03c0 	ret
			found = true;
    40006490:	52800023 	mov	w3, #0x1                   	// #1
	while (1) {
    40006494:	0b0202c2 	add	w2, w22, w2
    40006498:	12003c42 	and	w2, w2, #0xffff
		idx = pos + ret * sign;
    4000649c:	17ffffe2 	b	40006424 <z_shell_op_cursor_word_move+0x4c>
		sign = 1;
    400064a0:	52800034 	mov	w20, #0x1                   	// #1
    400064a4:	17ffffd7 	b	40006400 <z_shell_op_cursor_word_move+0x28>

00000000400064a8 <z_shell_op_cursor_home_move>:
	z_cursor_restore(shell);
}

void z_shell_op_cursor_home_move(const struct shell *shell)
{
	z_shell_op_cursor_move(shell, -shell->ctx->cmd_buff_pos);
    400064a8:	f9400801 	ldr	x1, [x0, #16]
    400064ac:	79412421 	ldrh	w1, [x1, #146]
    400064b0:	4b0103e1 	neg	w1, w1
    400064b4:	17ffffa4 	b	40006344 <z_shell_op_cursor_move>

00000000400064b8 <z_shell_op_cursor_end_move>:
}

void z_shell_op_cursor_end_move(const struct shell *shell)
{
	z_shell_op_cursor_move(shell, shell->ctx->cmd_buff_len -
    400064b8:	f9400802 	ldr	x2, [x0, #16]
    400064bc:	79412041 	ldrh	w1, [x2, #144]
    400064c0:	79412442 	ldrh	w2, [x2, #146]
    400064c4:	4b020021 	sub	w1, w1, w2
    400064c8:	17ffff9f 	b	40006344 <z_shell_op_cursor_move>

00000000400064cc <z_shell_op_left_arrow>:
						shell->ctx->cmd_buff_pos);
}

void z_shell_op_left_arrow(const struct shell *shell)
{
	if (shell->ctx->cmd_buff_pos > 0) {
    400064cc:	f9400801 	ldr	x1, [x0, #16]
    400064d0:	79412421 	ldrh	w1, [x1, #146]
    400064d4:	34000061 	cbz	w1, 400064e0 <z_shell_op_left_arrow+0x14>
		z_shell_op_cursor_move(shell, -1);
    400064d8:	12800001 	mov	w1, #0xffffffff            	// #-1
    400064dc:	17ffff9a 	b	40006344 <z_shell_op_cursor_move>
	}
}
    400064e0:	d65f03c0 	ret

00000000400064e4 <z_shell_op_right_arrow>:

void z_shell_op_right_arrow(const struct shell *shell)
{
	if (shell->ctx->cmd_buff_pos < shell->ctx->cmd_buff_len) {
    400064e4:	f9400801 	ldr	x1, [x0, #16]
    400064e8:	79412422 	ldrh	w2, [x1, #146]
    400064ec:	79412021 	ldrh	w1, [x1, #144]
    400064f0:	6b01005f 	cmp	w2, w1
    400064f4:	54000062 	b.cs	40006500 <z_shell_op_right_arrow+0x1c>  // b.hs, b.nlast
		z_shell_op_cursor_move(shell, 1);
    400064f8:	52800021 	mov	w1, #0x1                   	// #1
    400064fc:	17ffff92 	b	40006344 <z_shell_op_cursor_move>
	}
}
    40006500:	d65f03c0 	ret

0000000040006504 <z_shell_op_delete_from_cursor>:
	reprint_from_cursor(shell, --diff, true);
}

void z_shell_op_delete_from_cursor(const struct shell *shell)
{
	shell->ctx->cmd_buff_len = shell->ctx->cmd_buff_pos;
    40006504:	f9400802 	ldr	x2, [x0, #16]
    40006508:	79412441 	ldrh	w1, [x2, #146]
    4000650c:	79012041 	strh	w1, [x2, #144]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos] = '\0';
    40006510:	8b21c041 	add	x1, x2, w1, sxtw
    40006514:	3902583f 	strb	wzr, [x1, #150]

	z_clear_eos(shell);
    40006518:	17fffefd 	b	4000610c <z_clear_eos>

000000004000651c <z_shell_cmd_line_erase>:
{
	data_insert(shell, compl, compl_len);
}

void z_shell_cmd_line_erase(const struct shell *shell)
{
    4000651c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40006520:	910003fd 	mov	x29, sp
    40006524:	f9000bf3 	str	x19, [sp, #16]
    40006528:	aa0003f3 	mov	x19, x0
	z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
    4000652c:	f9400800 	ldr	x0, [x0, #16]
    40006530:	91010000 	add	x0, x0, #0x40
    40006534:	7940a002 	ldrh	w2, [x0, #80]
    40006538:	7940a401 	ldrh	w1, [x0, #82]
    4000653c:	97fffd25 	bl	400059d0 <z_shell_multiline_data_calc>
				    shell->ctx->cmd_buff_pos,
				    shell->ctx->cmd_buff_len);
	z_shell_op_cursor_horiz_move(shell,
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
    40006540:	f9400a60 	ldr	x0, [x19, #16]
	z_shell_op_cursor_horiz_move(shell,
    40006544:	52800021 	mov	w1, #0x1                   	// #1
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
    40006548:	79408000 	ldrh	w0, [x0, #64]
	z_shell_op_cursor_horiz_move(shell,
    4000654c:	4b000021 	sub	w1, w1, w0
    40006550:	aa1303e0 	mov	x0, x19
    40006554:	97ffff1f 	bl	400061d0 <z_shell_op_cursor_horiz_move>
	z_shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
    40006558:	f9400a60 	ldr	x0, [x19, #16]
    4000655c:	79408801 	ldrh	w1, [x0, #68]
    40006560:	aa1303e0 	mov	x0, x19
    40006564:	51000421 	sub	w1, w1, #0x1
    40006568:	97ffff0a 	bl	40006190 <z_shell_op_cursor_vert_move>

	z_clear_eos(shell);
    4000656c:	aa1303e0 	mov	x0, x19
}
    40006570:	f9400bf3 	ldr	x19, [sp, #16]
    40006574:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_clear_eos(shell);
    40006578:	17fffee5 	b	4000610c <z_clear_eos>

000000004000657c <z_shell_print_cmd>:
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
}

void z_shell_print_cmd(const struct shell *shell)
{
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", shell->ctx->cmd_buff);
    4000657c:	f9400802 	ldr	x2, [x0, #16]
    40006580:	90000041 	adrp	x1, 4000e000 <mmu_regions+0x38>
    40006584:	9135f021 	add	x1, x1, #0xd7c
    40006588:	f9401400 	ldr	x0, [x0, #40]
    4000658c:	91025842 	add	x2, x2, #0x96
    40006590:	17fffec2 	b	40006098 <z_shell_raw_fprintf>

0000000040006594 <z_shell_write>:
	}
}

void z_shell_write(const struct shell *shell, const void *data,
		 size_t length)
{
    40006594:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40006598:	910003fd 	mov	x29, sp
    4000659c:	a90153f3 	stp	x19, x20, [sp, #16]
    400065a0:	aa0003f4 	mov	x20, x0
    400065a4:	aa0203f3 	mov	x19, x2
    400065a8:	a9025bf5 	stp	x21, x22, [sp, #32]
    400065ac:	aa0103f6 	mov	x22, x1
	__ASSERT_NO_MSG(shell && data);

	size_t offset = 0;
    400065b0:	d2800015 	mov	x21, #0x0                   	// #0
{
    400065b4:	f9001bf7 	str	x23, [sp, #48]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    400065b8:	929fffb7 	mov	x23, #0xffffffffffff0002    	// #-65534
    400065bc:	f2a00017 	movk	x23, #0x0, lsl #16
	size_t tmp_cnt;

	while (length) {
    400065c0:	b50000d3 	cbnz	x19, 400065d8 <z_shell_write+0x44>
		if (tmp_cnt == 0 &&
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
			shell_pend_on_txdone(shell);
		}
	}
}
    400065c4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400065c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400065cc:	f9401bf7 	ldr	x23, [sp, #48]
    400065d0:	a8c77bfd 	ldp	x29, x30, [sp], #112
    400065d4:	d65f03c0 	ret
		int err = shell->iface->api->write(shell->iface,
    400065d8:	f9400680 	ldr	x0, [x20, #8]
    400065dc:	aa1303e2 	mov	x2, x19
    400065e0:	910103e3 	add	x3, sp, #0x40
    400065e4:	f9400001 	ldr	x1, [x0]
    400065e8:	f9400c24 	ldr	x4, [x1, #24]
    400065ec:	8b1502c1 	add	x1, x22, x21
    400065f0:	d63f0080 	blr	x4
		offset += tmp_cnt;
    400065f4:	f94023e0 	ldr	x0, [sp, #64]
    400065f8:	8b0002b5 	add	x21, x21, x0
		length -= tmp_cnt;
    400065fc:	cb000273 	sub	x19, x19, x0
		if (tmp_cnt == 0 &&
    40006600:	b5fffe00 	cbnz	x0, 400065c0 <z_shell_write+0x2c>
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
    40006604:	f9400a83 	ldr	x3, [x20, #16]
    40006608:	b9400860 	ldr	w0, [x3, #8]
		if (tmp_cnt == 0 &&
    4000660c:	71000c1f 	cmp	w0, #0x3
    40006610:	54fffd80 	b.eq	400065c0 <z_shell_write+0x2c>  // b.none
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
    40006614:	7100081f 	cmp	w0, #0x2
    40006618:	540001c8 	b.hi	40006650 <z_shell_write+0xbc>  // b.pmore
		k_poll_event_init(&event,
    4000661c:	910c4063 	add	x3, x3, #0x310
    40006620:	910123e0 	add	x0, sp, #0x48
    40006624:	52800002 	mov	w2, #0x0                   	// #0
    40006628:	52800021 	mov	w1, #0x1                   	// #1
    4000662c:	9400152c 	bl	4000badc <k_poll_event_init>
    40006630:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    40006634:	910123e0 	add	x0, sp, #0x48
    40006638:	52800021 	mov	w1, #0x1                   	// #1
    4000663c:	94001531 	bl	4000bb00 <z_impl_k_poll>
		k_poll_signal_reset(&shell->ctx->signals[SHELL_SIGNAL_TXDONE]);
    40006640:	f9400a80 	ldr	x0, [x20, #16]
    40006644:	910c4000 	add	x0, x0, #0x310
	z_impl_k_poll_signal_reset(sig);
    40006648:	94001571 	bl	4000bc0c <z_impl_k_poll_signal_reset>
    4000664c:	17ffffdd 	b	400065c0 <z_shell_write+0x2c>
	return sh->ctx->ctx.flags.tx_rdy == 1;
    40006650:	b942c060 	ldr	w0, [x3, #704]
		while (!z_flag_tx_rdy_get(shell)) {
    40006654:	360fffe0 	tbz	w0, #1, 40006650 <z_shell_write+0xbc>
    40006658:	910b0061 	add	x1, x3, #0x2c0
    4000665c:	aa1703e0 	mov	x0, x23
    40006660:	97ffea58 	bl	40000fc0 <__aarch64_ldclr8_acq_rel>
	return ret;
    40006664:	17ffffd7 	b	400065c0 <z_shell_write+0x2c>

0000000040006668 <z_shell_print_stream>:

/* Function shall be only used by the fprintf module. */
void z_shell_print_stream(const void *user_ctx, const char *data, size_t len)
{
	z_shell_write((const struct shell *) user_ctx, data, len);
    40006668:	17ffffcb 	b	40006594 <z_shell_write>

000000004000666c <z_shell_vt100_color_set>:
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
}

void z_shell_vt100_color_set(const struct shell *shell,
			     enum shell_vt100_color color)
{
    4000666c:	2a0103e2 	mov	w2, w1
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	if (color >= VT100_COLOR_END) {
    40006670:	7100203f 	cmp	w1, #0x8
    40006674:	54000288 	b.hi	400066c4 <z_shell_vt100_color_set+0x58>  // b.pmore
		return;
	}

	if (shell->ctx->vt100_ctx.col.col == color) {
    40006678:	f9400801 	ldr	x1, [x0, #16]
    4000667c:	b9405023 	ldr	w3, [x1, #80]
    40006680:	6b02007f 	cmp	w3, w2
    40006684:	54000200 	b.eq	400066c4 <z_shell_vt100_color_set+0x58>  // b.none
		return;
	}

	shell->ctx->vt100_ctx.col.col = color;
    40006688:	b9005022 	str	w2, [x1, #80]

	if (color != SHELL_NORMAL) {
    4000668c:	7100205f 	cmp	w2, #0x8
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40006690:	b942b821 	ldr	w1, [x1, #696]
    40006694:	540000c0 	b.eq	400066ac <z_shell_vt100_color_set+0x40>  // b.none
		Z_SHELL_VT100_CMD(shell, "\e[1;3%dm", color);
    40006698:	36280161 	tbz	w1, #5, 400066c4 <z_shell_vt100_color_set+0x58>
    4000669c:	f9401400 	ldr	x0, [x0, #40]
    400066a0:	b0000041 	adrp	x1, 4000f000 <cfg_flags.0+0x5ac>
    400066a4:	910acc21 	add	x1, x1, #0x2b3
    400066a8:	17fffe7c 	b	40006098 <z_shell_raw_fprintf>
	} else {
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_MODESOFF);
    400066ac:	362800c1 	tbz	w1, #5, 400066c4 <z_shell_vt100_color_set+0x58>
    400066b0:	f9401400 	ldr	x0, [x0, #40]
    400066b4:	f0000021 	adrp	x1, 4000d000 <__rodata_region_start>
    400066b8:	913e2021 	add	x1, x1, #0xf88
    400066bc:	91001421 	add	x1, x1, #0x5
    400066c0:	17fffe76 	b	40006098 <z_shell_raw_fprintf>
	}
}
    400066c4:	d65f03c0 	ret

00000000400066c8 <z_shell_vt100_colors_restore>:

void z_shell_vt100_colors_restore(const struct shell *shell,
				  const struct shell_vt100_colors *color)
{
    400066c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400066cc:	910003fd 	mov	x29, sp
    400066d0:	a90153f3 	stp	x19, x20, [sp, #16]
    400066d4:	aa0103f4 	mov	x20, x1
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	z_shell_vt100_color_set(shell, color->col);
    400066d8:	b9400021 	ldr	w1, [x1]
{
    400066dc:	aa0003f3 	mov	x19, x0
	z_shell_vt100_color_set(shell, color->col);
    400066e0:	97ffffe3 	bl	4000666c <z_shell_vt100_color_set>
	vt100_bgcolor_set(shell, color->bgcol);
    400066e4:	b9400682 	ldr	w2, [x20, #4]
	if ((bgcolor == SHELL_NORMAL) ||
    400066e8:	71001c5f 	cmp	w2, #0x7
    400066ec:	540001c8 	b.hi	40006724 <z_shell_vt100_colors_restore+0x5c>  // b.pmore
	    (shell->ctx->vt100_ctx.col.bgcol == bgcolor)) {
    400066f0:	f9400a60 	ldr	x0, [x19, #16]
	if ((bgcolor == SHELL_NORMAL) ||
    400066f4:	b9405401 	ldr	w1, [x0, #84]
    400066f8:	6b01005f 	cmp	w2, w1
    400066fc:	54000140 	b.eq	40006724 <z_shell_vt100_colors_restore+0x5c>  // b.none
	shell->ctx->vt100_ctx.col.bgcol = bgcolor;
    40006700:	b9005402 	str	w2, [x0, #84]
    40006704:	b942b800 	ldr	w0, [x0, #696]
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
    40006708:	362800e0 	tbz	w0, #5, 40006724 <z_shell_vt100_colors_restore+0x5c>
    4000670c:	f9401660 	ldr	x0, [x19, #40]
    40006710:	b0000041 	adrp	x1, 4000f000 <cfg_flags.0+0x5ac>
    40006714:	910af021 	add	x1, x1, #0x2bc
}
    40006718:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000671c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
    40006720:	17fffe5e 	b	40006098 <z_shell_raw_fprintf>
}
    40006724:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006728:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000672c:	d65f03c0 	ret

0000000040006730 <z_shell_vfprintf>:

void z_shell_vfprintf(const struct shell *shell, enum shell_vt100_color color,
		      const char *fmt, va_list args)
{
    40006730:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40006734:	910003fd 	mov	x29, sp
    40006738:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000673c:	2a0103f6 	mov	w22, w1
    40006740:	aa0203f5 	mov	x21, x2
	return sh->ctx->cfg.flags.use_colors == 1;
    40006744:	f9400801 	ldr	x1, [x0, #16]
    40006748:	a90153f3 	stp	x19, x20, [sp, #16]
    4000674c:	aa0003f3 	mov	x19, x0
    40006750:	aa0303f4 	mov	x20, x3
    40006754:	b942b820 	ldr	w0, [x1, #696]
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
    40006758:	36200340 	tbz	w0, #4, 400067c0 <z_shell_vfprintf+0x90>
	    z_flag_use_colors_get(shell)	  &&
    4000675c:	b9405020 	ldr	w0, [x1, #80]
    40006760:	6b16001f 	cmp	w0, w22
    40006764:	540002e0 	b.eq	400067c0 <z_shell_vfprintf+0x90>  // b.none
			     enum shell_vt100_color color);

static inline void z_shell_vt100_colors_store(const struct shell *sh,
					      struct shell_vt100_colors *color)
{
	memcpy(color, &sh->ctx->vt100_ctx.col, sizeof(*color));
    40006768:	d2800102 	mov	x2, #0x8                   	// #8
    4000676c:	91014021 	add	x1, x1, #0x50
    40006770:	910163e0 	add	x0, sp, #0x58
    40006774:	9400097b 	bl	40008d60 <memcpy>
	    (color != shell->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		z_shell_vt100_colors_store(shell, &col);
		z_shell_vt100_color_set(shell, color);
    40006778:	2a1603e1 	mov	w1, w22
    4000677c:	aa1303e0 	mov	x0, x19
    40006780:	97ffffbb 	bl	4000666c <z_shell_vt100_color_set>

		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
    40006784:	a9400680 	ldp	x0, x1, [x20]
    40006788:	a90307e0 	stp	x0, x1, [sp, #48]
    4000678c:	9100c3e2 	add	x2, sp, #0x30
    40006790:	a9410680 	ldp	x0, x1, [x20, #16]
    40006794:	a90407e0 	stp	x0, x1, [sp, #64]
    40006798:	f9401660 	ldr	x0, [x19, #40]
    4000679c:	aa1503e1 	mov	x1, x21
    400067a0:	97fffc3b 	bl	4000588c <z_shell_fprintf_fmt>

		z_shell_vt100_colors_restore(shell, &col);
    400067a4:	910163e1 	add	x1, sp, #0x58
    400067a8:	aa1303e0 	mov	x0, x19
    400067ac:	97ffffc7 	bl	400066c8 <z_shell_vt100_colors_restore>
	} else {
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
	}
}
    400067b0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400067b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400067b8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    400067bc:	d65f03c0 	ret
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
    400067c0:	a9400680 	ldp	x0, x1, [x20]
    400067c4:	a90307e0 	stp	x0, x1, [sp, #48]
    400067c8:	9100c3e2 	add	x2, sp, #0x30
    400067cc:	a9410680 	ldp	x0, x1, [x20, #16]
    400067d0:	a90407e0 	stp	x0, x1, [sp, #64]
    400067d4:	f9401660 	ldr	x0, [x19, #40]
    400067d8:	aa1503e1 	mov	x1, x21
    400067dc:	97fffc2c 	bl	4000588c <z_shell_fprintf_fmt>
}
    400067e0:	17fffff4 	b	400067b0 <z_shell_vfprintf+0x80>

00000000400067e4 <z_shell_fprintf>:

void z_shell_fprintf(const struct shell *sh,
		     enum shell_vt100_color color,
		     const char *fmt, ...)
{
    400067e4:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    400067e8:	910003fd 	mov	x29, sp
    400067ec:	a90d93e3 	stp	x3, x4, [sp, #216]
	__ASSERT(z_flag_panic_mode_get(sh) || !k_is_in_isr(),
		 "Thread context required.");

	va_list args;

	va_start(args, fmt);
    400067f0:	910403e3 	add	x3, sp, #0x100
    400067f4:	a9030fe3 	stp	x3, x3, [sp, #48]
    400067f8:	910343e3 	add	x3, sp, #0xd0
    400067fc:	f90023e3 	str	x3, [sp, #64]
    40006800:	128004e3 	mov	w3, #0xffffffd8            	// #-40
    40006804:	b9004be3 	str	w3, [sp, #72]
    40006808:	12800fe3 	mov	w3, #0xffffff80            	// #-128
    4000680c:	b9004fe3 	str	w3, [sp, #76]
	z_shell_vfprintf(sh, color, fmt, args);
    40006810:	910043e3 	add	x3, sp, #0x10
{
    40006814:	a90e9be5 	stp	x5, x6, [sp, #232]
	z_shell_vfprintf(sh, color, fmt, args);
    40006818:	a94317e4 	ldp	x4, x5, [sp, #48]
    4000681c:	a90117e4 	stp	x4, x5, [sp, #16]
    40006820:	a94417e4 	ldp	x4, x5, [sp, #64]
    40006824:	a90217e4 	stp	x4, x5, [sp, #32]
{
    40006828:	3d8017e0 	str	q0, [sp, #80]
    4000682c:	3d801be1 	str	q1, [sp, #96]
    40006830:	3d801fe2 	str	q2, [sp, #112]
    40006834:	3d8023e3 	str	q3, [sp, #128]
    40006838:	3d8027e4 	str	q4, [sp, #144]
    4000683c:	3d802be5 	str	q5, [sp, #160]
    40006840:	3d802fe6 	str	q6, [sp, #176]
    40006844:	3d8033e7 	str	q7, [sp, #192]
    40006848:	f9007fe7 	str	x7, [sp, #248]
	z_shell_vfprintf(sh, color, fmt, args);
    4000684c:	97ffffb9 	bl	40006730 <z_shell_vfprintf>
	va_end(args);
}
    40006850:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40006854:	d65f03c0 	ret

0000000040006858 <z_shell_op_word_remove>:
{
    40006858:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000685c:	910003fd 	mov	x29, sp
    40006860:	a90153f3 	stp	x19, x20, [sp, #16]
    40006864:	aa0003f3 	mov	x19, x0
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    40006868:	f9400800 	ldr	x0, [x0, #16]
	if ((shell->ctx->cmd_buff_len == 0) ||
    4000686c:	79412002 	ldrh	w2, [x0, #144]
{
    40006870:	f90013f5 	str	x21, [sp, #32]
	if ((shell->ctx->cmd_buff_len == 0) ||
    40006874:	340008a2 	cbz	w2, 40006988 <z_shell_op_word_remove+0x130>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    40006878:	79412403 	ldrh	w3, [x0, #146]
	if ((shell->ctx->cmd_buff_len == 0) ||
    4000687c:	34000863 	cbz	w3, 40006988 <z_shell_op_word_remove+0x130>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    40006880:	11025463 	add	w3, w3, #0x95
	char *str_start = &shell->ctx->cmd_buff[0];
    40006884:	91025801 	add	x1, x0, #0x96
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    40006888:	8b23c003 	add	x3, x0, w3, sxtw
    4000688c:	aa0303e0 	mov	x0, x3
    40006890:	4b000074 	sub	w20, w3, w0
	while ((str >= str_start) && (*str == ' ')) {
    40006894:	eb01001f 	cmp	x0, x1
    40006898:	12003e94 	and	w20, w20, #0xffff
    4000689c:	54000183 	b.cc	400068cc <z_shell_op_word_remove+0x74>  // b.lo, b.ul, b.last
    400068a0:	39400004 	ldrb	w4, [x0]
    400068a4:	7100809f 	cmp	w4, #0x20
    400068a8:	540006c0 	b.eq	40006980 <z_shell_op_word_remove+0x128>  // b.none
	while ((str >= str_start) && (*str != ' ')) {
    400068ac:	39400003 	ldrb	w3, [x0]
    400068b0:	7100807f 	cmp	w3, #0x20
    400068b4:	540000c0 	b.eq	400068cc <z_shell_op_word_remove+0x74>  // b.none
		++chars_to_delete;
    400068b8:	11000694 	add	w20, w20, #0x1
		--str;
    400068bc:	d1000400 	sub	x0, x0, #0x1
		++chars_to_delete;
    400068c0:	12003e94 	and	w20, w20, #0xffff
	while ((str >= str_start) && (*str != ' ')) {
    400068c4:	eb00003f 	cmp	x1, x0
    400068c8:	54ffff29 	b.ls	400068ac <z_shell_op_word_remove+0x54>  // b.plast
		shell->ctx->cmd_buff_len - chars_to_delete);
    400068cc:	4b140042 	sub	w2, w2, w20
	memmove(str + 1, str + 1 + chars_to_delete,
    400068d0:	92403e81 	and	x1, x20, #0xffff
    400068d4:	91000415 	add	x21, x0, #0x1
    400068d8:	91000421 	add	x1, x1, #0x1
    400068dc:	8b010001 	add	x1, x0, x1
    400068e0:	93407c42 	sxtw	x2, w2
    400068e4:	aa1503e0 	mov	x0, x21
    400068e8:	9400090f 	bl	40008d24 <memmove>
	shell->ctx->cmd_buff_len -= chars_to_delete;
    400068ec:	f9400a61 	ldr	x1, [x19, #16]
    400068f0:	79412020 	ldrh	w0, [x1, #144]
    400068f4:	4b140000 	sub	w0, w0, w20
    400068f8:	12003c00 	and	w0, w0, #0xffff
    400068fc:	79012020 	strh	w0, [x1, #144]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    40006900:	8b20c020 	add	x0, x1, w0, sxtw
	z_shell_op_cursor_move(shell, -chars_to_delete);
    40006904:	4b1403e1 	neg	w1, w20
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    40006908:	3902581f 	strb	wzr, [x0, #150]
	z_shell_op_cursor_move(shell, -chars_to_delete);
    4000690c:	aa1303e0 	mov	x0, x19
    40006910:	97fffe8d 	bl	40006344 <z_shell_op_cursor_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40006914:	f9400a60 	ldr	x0, [x19, #16]
    40006918:	b942b800 	ldr	w0, [x0, #696]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
    4000691c:	362800c0 	tbz	w0, #5, 40006934 <z_shell_op_word_remove+0xdc>
    40006920:	f9401660 	ldr	x0, [x19, #40]
    40006924:	f0000021 	adrp	x1, 4000d000 <__rodata_region_start>
    40006928:	913e2021 	add	x1, x1, #0xf88
    4000692c:	91002821 	add	x1, x1, #0xa
    40006930:	97fffdda 	bl	40006098 <z_shell_raw_fprintf>
	z_shell_fprintf(shell, SHELL_NORMAL, "%s", str + 1);
    40006934:	aa1503e3 	mov	x3, x21
    40006938:	90000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    4000693c:	9135f042 	add	x2, x2, #0xd7c
    40006940:	52800101 	mov	w1, #0x8                   	// #8
    40006944:	aa1303e0 	mov	x0, x19
    40006948:	97ffffa7 	bl	400067e4 <z_shell_fprintf>
	z_clear_eos(shell);
    4000694c:	aa1303e0 	mov	x0, x19
    40006950:	97fffdef 	bl	4000610c <z_clear_eos>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40006954:	f9400a60 	ldr	x0, [x19, #16]
    40006958:	b942b800 	ldr	w0, [x0, #696]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
    4000695c:	36280160 	tbz	w0, #5, 40006988 <z_shell_op_word_remove+0x130>
}
    40006960:	f94013f5 	ldr	x21, [sp, #32]
    40006964:	f0000021 	adrp	x1, 4000d000 <__rodata_region_start>
    40006968:	913e2021 	add	x1, x1, #0xf88
    4000696c:	f9401660 	ldr	x0, [x19, #40]
    40006970:	91003821 	add	x1, x1, #0xe
    40006974:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006978:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000697c:	17fffdc7 	b	40006098 <z_shell_raw_fprintf>
		--str;
    40006980:	d1000400 	sub	x0, x0, #0x1
    40006984:	17ffffc3 	b	40006890 <z_shell_op_word_remove+0x38>
}
    40006988:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000698c:	f94013f5 	ldr	x21, [sp, #32]
    40006990:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40006994:	d65f03c0 	ret

0000000040006998 <reprint_from_cursor>:
{
    40006998:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000699c:	910003fd 	mov	x29, sp
    400069a0:	a90153f3 	stp	x19, x20, [sp, #16]
    400069a4:	aa0003f3 	mov	x19, x0
    400069a8:	a9025bf5 	stp	x21, x22, [sp, #32]
    400069ac:	12003c36 	and	w22, w1, #0xffff
    400069b0:	f9001bf7 	str	x23, [sp, #48]
	if (data_removed) {
    400069b4:	72001c57 	ands	w23, w2, #0xff
    400069b8:	54000040 	b.eq	400069c0 <reprint_from_cursor+0x28>  // b.none
		z_clear_eos(shell);
    400069bc:	97fffdd4 	bl	4000610c <z_clear_eos>
	return sh->ctx->cfg.flags.obscure == 1;
    400069c0:	f9400a60 	ldr	x0, [x19, #16]
    400069c4:	b942b801 	ldr	w1, [x0, #696]
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
    400069c8:	79412403 	ldrh	w3, [x0, #146]
    400069cc:	91025863 	add	x3, x3, #0x96
    400069d0:	8b030000 	add	x0, x0, x3
	if (z_flag_obscure_get(shell)) {
    400069d4:	361003e1 	tbz	w1, #2, 40006a50 <reprint_from_cursor+0xb8>
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
    400069d8:	90000055 	adrp	x21, 4000e000 <mmu_regions+0x38>
    400069dc:	912e9eb5 	add	x21, x21, #0xba7
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
    400069e0:	9400089d 	bl	40008c54 <strlen>
		while (len--) {
    400069e4:	2a0003f4 	mov	w20, w0
    400069e8:	350002b4 	cbnz	w20, 40006a3c <reprint_from_cursor+0xa4>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    400069ec:	f9400a60 	ldr	x0, [x19, #16]
    400069f0:	79412001 	ldrh	w1, [x0, #144]
    400069f4:	79012401 	strh	w1, [x0, #146]
	if (full_line_cmd(shell)) {
    400069f8:	aa1303e0 	mov	x0, x19
    400069fc:	97fffdcf 	bl	40006138 <full_line_cmd>
    40006a00:	72001c1f 	tst	w0, #0xff
    40006a04:	540000e0 	b.eq	40006a20 <reprint_from_cursor+0x88>  // b.none
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
    40006a08:	710002df 	cmp	w22, #0x0
    40006a0c:	7a401ae4 	ccmp	w23, #0x0, #0x4, ne  // ne = any
    40006a10:	54000041 	b.ne	40006a18 <reprint_from_cursor+0x80>  // b.any
    40006a14:	35000077 	cbnz	w23, 40006a20 <reprint_from_cursor+0x88>
			z_cursor_next_line_move(shell);
    40006a18:	f9401660 	ldr	x0, [x19, #40]
    40006a1c:	97fffdc4 	bl	4000612c <z_cursor_next_line_move.isra.0>
	z_shell_op_cursor_move(shell, -diff);
    40006a20:	4b1603e1 	neg	w1, w22
    40006a24:	aa1303e0 	mov	x0, x19
}
    40006a28:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006a2c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006a30:	f9401bf7 	ldr	x23, [sp, #48]
    40006a34:	a8c47bfd 	ldp	x29, x30, [sp], #64
	z_shell_op_cursor_move(shell, -diff);
    40006a38:	17fffe43 	b	40006344 <z_shell_op_cursor_move>
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
    40006a3c:	f9401660 	ldr	x0, [x19, #40]
    40006a40:	aa1503e1 	mov	x1, x21
    40006a44:	51000694 	sub	w20, w20, #0x1
    40006a48:	97fffd94 	bl	40006098 <z_shell_raw_fprintf>
    40006a4c:	17ffffe7 	b	400069e8 <reprint_from_cursor+0x50>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s",
    40006a50:	aa0003e3 	mov	x3, x0
    40006a54:	90000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40006a58:	9135f042 	add	x2, x2, #0xd7c
    40006a5c:	aa1303e0 	mov	x0, x19
    40006a60:	52800101 	mov	w1, #0x8                   	// #8
    40006a64:	97ffff60 	bl	400067e4 <z_shell_fprintf>
    40006a68:	17ffffe1 	b	400069ec <reprint_from_cursor+0x54>

0000000040006a6c <data_insert>:
{
    40006a6c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40006a70:	910003fd 	mov	x29, sp
    40006a74:	a90153f3 	stp	x19, x20, [sp, #16]
    40006a78:	12003c54 	and	w20, w2, #0xffff
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    40006a7c:	f9400813 	ldr	x19, [x0, #16]
{
    40006a80:	a9025bf5 	stp	x21, x22, [sp, #32]
    40006a84:	aa0003f5 	mov	x21, x0
    40006a88:	a90363f7 	stp	x23, x24, [sp, #48]
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    40006a8c:	79412260 	ldrh	w0, [x19, #144]
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
    40006a90:	0b222002 	add	w2, w0, w2, uxth
    40006a94:	7103fc5f 	cmp	w2, #0xff
    40006a98:	540003ac 	b.gt	40006b0c <data_insert+0xa0>
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    40006a9c:	79412663 	ldrh	w3, [x19, #146]
    40006aa0:	aa0103f6 	mov	x22, x1
	memmove(curr_pos + len, curr_pos, after);
    40006aa4:	92403e97 	and	x23, x20, #0xffff
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    40006aa8:	4b030000 	sub	w0, w0, w3
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    40006aac:	92403c63 	and	x3, x3, #0xffff
    40006ab0:	91025863 	add	x3, x3, #0x96
	memmove(curr_pos + len, curr_pos, after);
    40006ab4:	92403c02 	and	x2, x0, #0xffff
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    40006ab8:	8b030273 	add	x19, x19, x3
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    40006abc:	12003c18 	and	w24, w0, #0xffff
	memmove(curr_pos + len, curr_pos, after);
    40006ac0:	aa1303e1 	mov	x1, x19
    40006ac4:	8b342260 	add	x0, x19, w20, uxth
    40006ac8:	94000897 	bl	40008d24 <memmove>
	memcpy(curr_pos, data, len);
    40006acc:	aa1703e2 	mov	x2, x23
    40006ad0:	aa1603e1 	mov	x1, x22
    40006ad4:	aa1303e0 	mov	x0, x19
    40006ad8:	940008a2 	bl	40008d60 <memcpy>
	shell->ctx->cmd_buff_len += len;
    40006adc:	f9400aa2 	ldr	x2, [x21, #16]
    40006ae0:	79412041 	ldrh	w1, [x2, #144]
    40006ae4:	0b010281 	add	w1, w20, w1
    40006ae8:	12003c21 	and	w1, w1, #0xffff
    40006aec:	79012041 	strh	w1, [x2, #144]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    40006af0:	8b21c041 	add	x1, x2, w1, sxtw
    40006af4:	3902583f 	strb	wzr, [x1, #150]
	return sh->ctx->cfg.flags.echo == 1;
    40006af8:	b942b840 	ldr	w0, [x2, #696]
	if (!z_flag_echo_get(shell)) {
    40006afc:	37080120 	tbnz	w0, #1, 40006b20 <data_insert+0xb4>
		shell->ctx->cmd_buff_pos += len;
    40006b00:	79412440 	ldrh	w0, [x2, #146]
    40006b04:	0b000294 	add	w20, w20, w0
    40006b08:	79012454 	strh	w20, [x2, #146]
}
    40006b0c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006b10:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006b14:	a94363f7 	ldp	x23, x24, [sp, #48]
    40006b18:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40006b1c:	d65f03c0 	ret
	reprint_from_cursor(shell, after, false);
    40006b20:	2a1803e1 	mov	w1, w24
    40006b24:	aa1503e0 	mov	x0, x21
}
    40006b28:	a94153f3 	ldp	x19, x20, [sp, #16]
	reprint_from_cursor(shell, after, false);
    40006b2c:	52800002 	mov	w2, #0x0                   	// #0
}
    40006b30:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006b34:	a94363f7 	ldp	x23, x24, [sp, #48]
    40006b38:	a8c47bfd 	ldp	x29, x30, [sp], #64
	reprint_from_cursor(shell, after, false);
    40006b3c:	17ffff97 	b	40006998 <reprint_from_cursor>

0000000040006b40 <z_shell_op_char_insert>:
{
    40006b40:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40006b44:	910003fd 	mov	x29, sp
    40006b48:	f9000bf3 	str	x19, [sp, #16]
    40006b4c:	aa0003f3 	mov	x19, x0
	return sh->ctx->cfg.flags.insert_mode == 1;
    40006b50:	f9400800 	ldr	x0, [x0, #16]
    40006b54:	3900bfe1 	strb	w1, [sp, #47]
    40006b58:	b942b801 	ldr	w1, [x0, #696]
	if (z_flag_insert_mode_get(shell) &&
    40006b5c:	360003a1 	tbz	w1, #0, 40006bd0 <z_shell_op_char_insert+0x90>
	    (shell->ctx->cmd_buff_len != shell->ctx->cmd_buff_pos)) {
    40006b60:	79412401 	ldrh	w1, [x0, #146]
	if (z_flag_insert_mode_get(shell) &&
    40006b64:	79412002 	ldrh	w2, [x0, #144]
    40006b68:	6b01005f 	cmp	w2, w1
    40006b6c:	54000320 	b.eq	40006bd0 <z_shell_op_char_insert+0x90>  // b.none
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
    40006b70:	11000423 	add	w3, w1, #0x1
    40006b74:	8b21c001 	add	x1, x0, w1, sxtw
		char_replace(shell, data);
    40006b78:	3940bfe2 	ldrb	w2, [sp, #47]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
    40006b7c:	79012403 	strh	w3, [x0, #146]
    40006b80:	39025822 	strb	w2, [x1, #150]
	return sh->ctx->cfg.flags.echo == 1;
    40006b84:	b942b801 	ldr	w1, [x0, #696]
	if (!z_flag_echo_get(shell)) {
    40006b88:	360801e1 	tbz	w1, #1, 40006bc4 <z_shell_op_char_insert+0x84>
	return sh->ctx->cfg.flags.obscure == 1;
    40006b8c:	b942b800 	ldr	w0, [x0, #696]
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
    40006b90:	b0000041 	adrp	x1, 4000f000 <cfg_flags.0+0x5ac>
    40006b94:	910ac021 	add	x1, x1, #0x2b0
		data = '*';
    40006b98:	f27e001f 	tst	x0, #0x4
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
    40006b9c:	52800540 	mov	w0, #0x2a                  	// #42
    40006ba0:	1a800042 	csel	w2, w2, w0, eq  // eq = none
    40006ba4:	f9401660 	ldr	x0, [x19, #40]
    40006ba8:	97fffd3c 	bl	40006098 <z_shell_raw_fprintf>
	if (z_shell_cursor_in_empty_line(shell)) {
    40006bac:	aa1303e0 	mov	x0, x19
    40006bb0:	97fffd98 	bl	40006210 <z_shell_cursor_in_empty_line>
    40006bb4:	72001c1f 	tst	w0, #0xff
    40006bb8:	54000060 	b.eq	40006bc4 <z_shell_op_char_insert+0x84>  // b.none
		z_cursor_next_line_move(shell);
    40006bbc:	f9401660 	ldr	x0, [x19, #40]
    40006bc0:	97fffd5b 	bl	4000612c <z_cursor_next_line_move.isra.0>
}
    40006bc4:	f9400bf3 	ldr	x19, [sp, #16]
    40006bc8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40006bcc:	d65f03c0 	ret
		data_insert(shell, &data, 1);
    40006bd0:	9100bfe1 	add	x1, sp, #0x2f
    40006bd4:	aa1303e0 	mov	x0, x19
    40006bd8:	52800022 	mov	w2, #0x1                   	// #1
    40006bdc:	97ffffa4 	bl	40006a6c <data_insert>
}
    40006be0:	17fffff9 	b	40006bc4 <z_shell_op_char_insert+0x84>

0000000040006be4 <z_shell_op_completion_insert>:
	data_insert(shell, compl, compl_len);
    40006be4:	17ffffa2 	b	40006a6c <data_insert>

0000000040006be8 <z_shell_op_char_delete>:
{
    40006be8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40006bec:	910003fd 	mov	x29, sp
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    40006bf0:	f9400801 	ldr	x1, [x0, #16]
{
    40006bf4:	a90153f3 	stp	x19, x20, [sp, #16]
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    40006bf8:	79412422 	ldrh	w2, [x1, #146]
    40006bfc:	79412033 	ldrh	w19, [x1, #144]
    40006c00:	4b020273 	sub	w19, w19, w2
	if (diff == 0U) {
    40006c04:	72003e73 	ands	w19, w19, #0xffff
    40006c08:	54000240 	b.eq	40006c50 <z_shell_op_char_delete+0x68>  // b.none
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    40006c0c:	92403c42 	and	x2, x2, #0xffff
    40006c10:	aa0003f4 	mov	x20, x0
    40006c14:	91025842 	add	x2, x2, #0x96
    40006c18:	8b020020 	add	x0, x1, x2
	memmove(str, str + 1, diff);
    40006c1c:	92403e62 	and	x2, x19, #0xffff
    40006c20:	91000401 	add	x1, x0, #0x1
    40006c24:	94000840 	bl	40008d24 <memmove>
	--shell->ctx->cmd_buff_len;
    40006c28:	f9400a81 	ldr	x1, [x20, #16]
	reprint_from_cursor(shell, --diff, true);
    40006c2c:	52800022 	mov	w2, #0x1                   	// #1
	--shell->ctx->cmd_buff_len;
    40006c30:	79412020 	ldrh	w0, [x1, #144]
    40006c34:	51000400 	sub	w0, w0, #0x1
    40006c38:	79012020 	strh	w0, [x1, #144]
	reprint_from_cursor(shell, --diff, true);
    40006c3c:	51000661 	sub	w1, w19, #0x1
    40006c40:	aa1403e0 	mov	x0, x20
}
    40006c44:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006c48:	a8c27bfd 	ldp	x29, x30, [sp], #32
	reprint_from_cursor(shell, --diff, true);
    40006c4c:	17ffff53 	b	40006998 <reprint_from_cursor>
}
    40006c50:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006c54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40006c58:	d65f03c0 	ret

0000000040006c5c <z_shell_op_char_backspace>:
	if ((shell->ctx->cmd_buff_len == 0) ||
    40006c5c:	f9400801 	ldr	x1, [x0, #16]
    40006c60:	79412022 	ldrh	w2, [x1, #144]
    40006c64:	340001a2 	cbz	w2, 40006c98 <z_shell_op_char_backspace+0x3c>
    40006c68:	79412421 	ldrh	w1, [x1, #146]
    40006c6c:	34000161 	cbz	w1, 40006c98 <z_shell_op_char_backspace+0x3c>
{
    40006c70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	z_shell_op_cursor_move(shell, -1);
    40006c74:	12800001 	mov	w1, #0xffffffff            	// #-1
{
    40006c78:	910003fd 	mov	x29, sp
    40006c7c:	f9000bf3 	str	x19, [sp, #16]
    40006c80:	aa0003f3 	mov	x19, x0
	z_shell_op_cursor_move(shell, -1);
    40006c84:	97fffdb0 	bl	40006344 <z_shell_op_cursor_move>
	z_shell_op_char_delete(shell);
    40006c88:	aa1303e0 	mov	x0, x19
}
    40006c8c:	f9400bf3 	ldr	x19, [sp, #16]
    40006c90:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_shell_op_char_delete(shell);
    40006c94:	17ffffd5 	b	40006be8 <z_shell_op_char_delete>
    40006c98:	d65f03c0 	ret

0000000040006c9c <z_shell_print_prompt_and_cmd>:
{
    40006c9c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    40006ca0:	90000042 	adrp	x2, 4000e000 <mmu_regions+0x38>
    40006ca4:	9135f042 	add	x2, x2, #0xd7c
{
    40006ca8:	910003fd 	mov	x29, sp
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    40006cac:	f9400801 	ldr	x1, [x0, #16]
    40006cb0:	f9400023 	ldr	x3, [x1]
{
    40006cb4:	f9000bf3 	str	x19, [sp, #16]
    40006cb8:	aa0003f3 	mov	x19, x0
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    40006cbc:	52800041 	mov	w1, #0x2                   	// #2
    40006cc0:	97fffec9 	bl	400067e4 <z_shell_fprintf>
	return sh->ctx->cfg.flags.echo == 1;
    40006cc4:	f9400a60 	ldr	x0, [x19, #16]
    40006cc8:	b942b800 	ldr	w0, [x0, #696]
	if (z_flag_echo_get(shell)) {
    40006ccc:	360800e0 	tbz	w0, #1, 40006ce8 <z_shell_print_prompt_and_cmd+0x4c>
		z_shell_print_cmd(shell);
    40006cd0:	aa1303e0 	mov	x0, x19
    40006cd4:	97fffe2a 	bl	4000657c <z_shell_print_cmd>
		z_shell_op_cursor_position_synchronize(shell);
    40006cd8:	aa1303e0 	mov	x0, x19
}
    40006cdc:	f9400bf3 	ldr	x19, [sp, #16]
    40006ce0:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_shell_op_cursor_position_synchronize(shell);
    40006ce4:	17fffd73 	b	400062b0 <z_shell_op_cursor_position_synchronize>
}
    40006ce8:	f9400bf3 	ldr	x19, [sp, #16]
    40006cec:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40006cf0:	d65f03c0 	ret

0000000040006cf4 <z_shell_raw_fprintf>:
{
    40006cf4:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40006cf8:	910003fd 	mov	x29, sp
    40006cfc:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    40006d00:	910403e2 	add	x2, sp, #0x100
    40006d04:	a9030be2 	stp	x2, x2, [sp, #48]
    40006d08:	910343e2 	add	x2, sp, #0xd0
    40006d0c:	f90023e2 	str	x2, [sp, #64]
    40006d10:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    40006d14:	b9004be2 	str	w2, [sp, #72]
    40006d18:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    40006d1c:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40006d20:	a9430fe2 	ldp	x2, x3, [sp, #48]
    40006d24:	a9010fe2 	stp	x2, x3, [sp, #16]
    40006d28:	a9440fe2 	ldp	x2, x3, [sp, #64]
    40006d2c:	a9020fe2 	stp	x2, x3, [sp, #32]
    40006d30:	910043e2 	add	x2, sp, #0x10
{
    40006d34:	3d8017e0 	str	q0, [sp, #80]
    40006d38:	3d801be1 	str	q1, [sp, #96]
    40006d3c:	3d801fe2 	str	q2, [sp, #112]
    40006d40:	3d8023e3 	str	q3, [sp, #128]
    40006d44:	3d8027e4 	str	q4, [sp, #144]
    40006d48:	3d802be5 	str	q5, [sp, #160]
    40006d4c:	3d802fe6 	str	q6, [sp, #176]
    40006d50:	3d8033e7 	str	q7, [sp, #192]
    40006d54:	a90e17e4 	stp	x4, x5, [sp, #224]
    40006d58:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40006d5c:	97fffacc 	bl	4000588c <z_shell_fprintf_fmt>
}
    40006d60:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40006d64:	d65f03c0 	ret

0000000040006d68 <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
    40006d68:	90000041 	adrp	x1, 4000e000 <mmu_regions+0x38>
    40006d6c:	91317421 	add	x1, x1, #0xc5d
    40006d70:	17ffffe1 	b	40006cf4 <z_shell_raw_fprintf>

0000000040006d74 <formatted_text_print.constprop.0>:
				 size_t terminal_offset, bool offset_first_line)
{
	size_t offset = 0;
	size_t length;

	if (str == NULL) {
    40006d74:	b4000b81 	cbz	x1, 40006ee4 <formatted_text_print.constprop.0+0x170>
static void formatted_text_print(const struct shell *shell, const char *str,
    40006d78:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40006d7c:	910003fd 	mov	x29, sp
    40006d80:	a90153f3 	stp	x19, x20, [sp, #16]
    40006d84:	aa0003f3 	mov	x19, x0
    40006d88:	d2800014 	mov	x20, #0x0                   	// #0
    40006d8c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40006d90:	aa0103f5 	mov	x21, x1
    40006d94:	a90363f7 	stp	x23, x24, [sp, #48]
    40006d98:	aa0203f7 	mov	x23, x2
    40006d9c:	f90023f9 	str	x25, [sp, #64]
		z_shell_op_cursor_horiz_move(shell, terminal_offset);
	}


	/* Skipping whitespace. */
	while (isspace((int) *(str + offset))) {
    40006da0:	38746aa0 	ldrb	w0, [x21, x20]
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    40006da4:	51002401 	sub	w1, w0, #0x9
    40006da8:	7100801f 	cmp	w0, #0x20
    40006dac:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    40006db0:	54000329 	b.ls	40006e14 <formatted_text_print.constprop.0+0xa0>  // b.plast
    40006db4:	aa1503e0 	mov	x0, x21
    40006db8:	940007a7 	bl	40008c54 <strlen>
		size_t idx = 0;

		length = z_shell_strlen(str) - offset;

		if (length <=
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
    40006dbc:	f9400a61 	ldr	x1, [x19, #16]
		length = z_shell_strlen(str) - offset;
    40006dc0:	92403c00 	and	x0, x0, #0xffff
    40006dc4:	cb140000 	sub	x0, x0, x20
		if (length <=
    40006dc8:	8b1402b8 	add	x24, x21, x20
			for (idx = 0; idx < length; idx++) {
    40006dcc:	d2800016 	mov	x22, #0x0                   	// #0
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
    40006dd0:	79409422 	ldrh	w2, [x1, #74]
    40006dd4:	cb170041 	sub	x1, x2, x23
		if (length <=
    40006dd8:	eb01001f 	cmp	x0, x1
    40006ddc:	54000229 	b.ls	40006e20 <formatted_text_print.constprop.0+0xac>  // b.plast
		length = shell->ctx->vt100_ctx.cons.terminal_wid
				- terminal_offset;

		while (true) {
			/* Determining line break. */
			if (isspace((int) (*(str + offset + idx)))) {
    40006de0:	38766b00 	ldrb	w0, [x24, x22]
    40006de4:	51002403 	sub	w3, w0, #0x9
    40006de8:	7100801f 	cmp	w0, #0x20
    40006dec:	7a441860 	ccmp	w3, #0x4, #0x0, ne  // ne = any
    40006df0:	54000088 	b.hi	40006e00 <formatted_text_print.constprop.0+0x8c>  // b.pmore
				length = idx;
				if (*(str + offset + idx) == '\n') {
    40006df4:	7100281f 	cmp	w0, #0xa
    40006df8:	540004e0 	b.eq	40006e94 <formatted_text_print.constprop.0+0x120>  // b.none
    40006dfc:	aa1603e1 	mov	x1, x22
					break;
				}
			}

			if ((idx + terminal_offset) >=
    40006e00:	8b1602e0 	add	x0, x23, x22
    40006e04:	eb00005f 	cmp	x2, x0
    40006e08:	54000449 	b.ls	40006e90 <formatted_text_print.constprop.0+0x11c>  // b.plast
			    shell->ctx->vt100_ctx.cons.terminal_wid) {
				/* End of line reached. */
				break;
			}

			++idx;
    40006e0c:	910006d6 	add	x22, x22, #0x1
			if (isspace((int) (*(str + offset + idx)))) {
    40006e10:	17fffff4 	b	40006de0 <formatted_text_print.constprop.0+0x6c>
		++offset;
    40006e14:	91000694 	add	x20, x20, #0x1
    40006e18:	17ffffe2 	b	40006da0 <formatted_text_print.constprop.0+0x2c>
			for (idx = 0; idx < length; idx++) {
    40006e1c:	910006d6 	add	x22, x22, #0x1
    40006e20:	eb16001f 	cmp	x0, x22
    40006e24:	54000220 	b.eq	40006e68 <formatted_text_print.constprop.0+0xf4>  // b.none
				if (*(str + offset + idx) == '\n') {
    40006e28:	38766b01 	ldrb	w1, [x24, x22]
    40006e2c:	8b160299 	add	x25, x20, x22
    40006e30:	7100283f 	cmp	w1, #0xa
    40006e34:	54ffff41 	b.ne	40006e1c <formatted_text_print.constprop.0+0xa8>  // b.any
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
    40006e38:	f9401660 	ldr	x0, [x19, #40]
					offset += idx + 1;
    40006e3c:	91000734 	add	x20, x25, #0x1
    40006e40:	97fffa84 	bl	40005850 <z_shell_fprintf_buffer_flush>
					z_shell_write(shell, str + offset, idx);
    40006e44:	aa1803e1 	mov	x1, x24
    40006e48:	aa1603e2 	mov	x2, x22
    40006e4c:	aa1303e0 	mov	x0, x19
    40006e50:	97fffdd1 	bl	40006594 <z_shell_write>
					z_cursor_next_line_move(shell);
    40006e54:	f9401660 	ldr	x0, [x19, #40]
    40006e58:	97ffffc4 	bl	40006d68 <z_cursor_next_line_move.isra.0>
					z_shell_op_cursor_horiz_move(shell,
    40006e5c:	2a1703e1 	mov	w1, w23
    40006e60:	aa1303e0 	mov	x0, x19
    40006e64:	97fffcdb 	bl	400061d0 <z_shell_op_cursor_horiz_move>
			z_shell_raw_fprintf(shell->fprintf_ctx, str + offset);
    40006e68:	f9401660 	ldr	x0, [x19, #40]
    40006e6c:	8b1402a1 	add	x1, x21, x20
    40006e70:	97ffffa1 	bl	40006cf4 <z_shell_raw_fprintf>
		z_cursor_next_line_move(shell);
		z_shell_op_cursor_horiz_move(shell, terminal_offset);

	}
	z_cursor_next_line_move(shell);
}
    40006e74:	a9425bf5 	ldp	x21, x22, [sp, #32]
	z_cursor_next_line_move(shell);
    40006e78:	f9401660 	ldr	x0, [x19, #40]
}
    40006e7c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006e80:	a94363f7 	ldp	x23, x24, [sp, #48]
    40006e84:	f94023f9 	ldr	x25, [sp, #64]
    40006e88:	a8c57bfd 	ldp	x29, x30, [sp], #80
	z_cursor_next_line_move(shell);
    40006e8c:	17ffffb7 	b	40006d68 <z_cursor_next_line_move.isra.0>
    40006e90:	aa0103f6 	mov	x22, x1
    40006e94:	f9401660 	ldr	x0, [x19, #40]
		offset += length;
    40006e98:	8b160294 	add	x20, x20, x22
    40006e9c:	97fffa6d 	bl	40005850 <z_shell_fprintf_buffer_flush>
		z_shell_write(shell, str + offset, length);
    40006ea0:	aa1603e2 	mov	x2, x22
    40006ea4:	aa1803e1 	mov	x1, x24
    40006ea8:	aa1303e0 	mov	x0, x19
    40006eac:	97fffdba 	bl	40006594 <z_shell_write>
		while (isspace((int) (*(str + offset)))) {
    40006eb0:	38746aa0 	ldrb	w0, [x21, x20]
    40006eb4:	51002401 	sub	w1, w0, #0x9
    40006eb8:	7100801f 	cmp	w0, #0x20
    40006ebc:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    40006ec0:	540000e9 	b.ls	40006edc <formatted_text_print.constprop.0+0x168>  // b.plast
		z_cursor_next_line_move(shell);
    40006ec4:	f9401660 	ldr	x0, [x19, #40]
    40006ec8:	97ffffa8 	bl	40006d68 <z_cursor_next_line_move.isra.0>
		z_shell_op_cursor_horiz_move(shell, terminal_offset);
    40006ecc:	2a1703e1 	mov	w1, w23
    40006ed0:	aa1303e0 	mov	x0, x19
    40006ed4:	97fffcbf 	bl	400061d0 <z_shell_op_cursor_horiz_move>
	while (true) {
    40006ed8:	17ffffb7 	b	40006db4 <formatted_text_print.constprop.0+0x40>
			++offset;
    40006edc:	91000694 	add	x20, x20, #0x1
    40006ee0:	17fffff4 	b	40006eb0 <formatted_text_print.constprop.0+0x13c>
    40006ee4:	d65f03c0 	ret

0000000040006ee8 <z_shell_help_subcmd_print>:
 * help string
 */
void z_shell_help_subcmd_print(const struct shell *shell,
			       const struct shell_static_entry *parent,
			       const char *description)
{
    40006ee8:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    40006eec:	910003fd 	mov	x29, sp
    40006ef0:	a90153f3 	stp	x19, x20, [sp, #16]
    40006ef4:	aa0003f4 	mov	x20, x0
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry dloc;
	uint16_t longest = 0U;
    40006ef8:	52800013 	mov	w19, #0x0                   	// #0
{
    40006efc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40006f00:	aa0203f5 	mov	x21, x2
    40006f04:	a90363f7 	stp	x23, x24, [sp, #48]
    40006f08:	aa0103f7 	mov	x23, x1
	size_t idx = 0;
    40006f0c:	d2800001 	mov	x1, #0x0                   	// #0
{
    40006f10:	a9046bf9 	stp	x25, x26, [sp, #64]
    40006f14:	f9002bfb 	str	x27, [sp, #80]

	/* Searching for the longest subcommand to print. */
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    40006f18:	91000436 	add	x22, x1, #0x1
    40006f1c:	9101a3e2 	add	x2, sp, #0x68
    40006f20:	aa1703e0 	mov	x0, x23
    40006f24:	97fffb88 	bl	40005d44 <z_shell_cmd_get>
    40006f28:	b5000300 	cbnz	x0, 40006f88 <z_shell_help_subcmd_print+0xa0>
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
	}

	/* No help to print */
	if (longest == 0) {
    40006f2c:	34000213 	cbz	w19, 40006f6c <z_shell_help_subcmd_print+0x84>
		return;
	}

	if (description != NULL) {
    40006f30:	b40000b5 	cbz	x21, 40006f44 <z_shell_help_subcmd_print+0x5c>
		z_shell_fprintf(shell, SHELL_NORMAL, description);
    40006f34:	aa1503e2 	mov	x2, x21
    40006f38:	aa1403e0 	mov	x0, x20
    40006f3c:	52800101 	mov	w1, #0x8                   	// #8
    40006f40:	97fffe29 	bl	400067e4 <z_shell_fprintf>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    40006f44:	b0000055 	adrp	x21, 4000f000 <cfg_flags.0+0x5ac>
    40006f48:	910b4eb5 	add	x21, x21, #0x2d3
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
    40006f4c:	b0000058 	adrp	x24, 4000f000 <cfg_flags.0+0x5ac>
    40006f50:	910b1718 	add	x24, x24, #0x2c5
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    40006f54:	d2800001 	mov	x1, #0x0                   	// #0
	}

	/* Printing subcommands and help string (if exists). */
	idx = 0;

	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    40006f58:	91000439 	add	x25, x1, #0x1
    40006f5c:	9101a3e2 	add	x2, sp, #0x68
    40006f60:	aa1703e0 	mov	x0, x23
    40006f64:	97fffb78 	bl	40005d44 <z_shell_cmd_get>
    40006f68:	b5000260 	cbnz	x0, 40006fb4 <z_shell_help_subcmd_print+0xcc>
		help_item_print(shell, entry->syntax, longest, entry->help);
	}
}
    40006f6c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006f70:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006f74:	a94363f7 	ldp	x23, x24, [sp, #48]
    40006f78:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40006f7c:	f9402bfb 	ldr	x27, [sp, #80]
    40006f80:	a8c97bfd 	ldp	x29, x30, [sp], #144
    40006f84:	d65f03c0 	ret
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
    40006f88:	f9400000 	ldr	x0, [x0]
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40006f8c:	b4000100 	cbz	x0, 40006fac <z_shell_help_subcmd_print+0xc4>
    40006f90:	94000731 	bl	40008c54 <strlen>
    40006f94:	12003c03 	and	w3, w0, #0xffff
    40006f98:	6b13007f 	cmp	w3, w19
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    40006f9c:	aa1603e1 	mov	x1, x22
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
    40006fa0:	1a938063 	csel	w3, w3, w19, hi  // hi = pmore
    40006fa4:	12003c73 	and	w19, w3, #0xffff
    40006fa8:	17ffffdc 	b	40006f18 <z_shell_help_subcmd_print+0x30>
    40006fac:	52800003 	mov	w3, #0x0                   	// #0
    40006fb0:	17fffffa 	b	40006f98 <z_shell_help_subcmd_print+0xb0>
		help_item_print(shell, entry->syntax, longest, entry->help);
    40006fb4:	a940681b 	ldp	x27, x26, [x0]
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    40006fb8:	aa1503e0 	mov	x0, x21
    40006fbc:	94000726 	bl	40008c54 <strlen>
    40006fc0:	aa0003f6 	mov	x22, x0
	if ((item_name == NULL) || (item_name[0] == '\0')) {
    40006fc4:	b40001db 	cbz	x27, 40006ffc <z_shell_help_subcmd_print+0x114>
    40006fc8:	39400360 	ldrb	w0, [x27]
    40006fcc:	34000180 	cbz	w0, 40006ffc <z_shell_help_subcmd_print+0x114>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
    40006fd0:	aa1503e6 	mov	x6, x21
    40006fd4:	aa1b03e5 	mov	x5, x27
    40006fd8:	2a1303e4 	mov	w4, w19
    40006fdc:	aa1503e3 	mov	x3, x21
    40006fe0:	aa1803e2 	mov	x2, x24
    40006fe4:	aa1403e0 	mov	x0, x20
    40006fe8:	52800101 	mov	w1, #0x8                   	// #8
    40006fec:	97fffdfe 	bl	400067e4 <z_shell_fprintf>
	if (item_help == NULL) {
    40006ff0:	b50000ba 	cbnz	x26, 40007004 <z_shell_help_subcmd_print+0x11c>
		z_cursor_next_line_move(shell);
    40006ff4:	f9401680 	ldr	x0, [x20, #40]
    40006ff8:	97ffff5c 	bl	40006d68 <z_cursor_next_line_move.isra.0>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    40006ffc:	aa1903e1 	mov	x1, x25
    40007000:	17ffffd6 	b	40006f58 <z_shell_help_subcmd_print+0x70>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    40007004:	11000662 	add	w2, w19, #0x1
	formatted_text_print(shell, item_help, offset, false);
    40007008:	aa1a03e1 	mov	x1, x26
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    4000700c:	0b160442 	add	w2, w2, w22, lsl #1
	formatted_text_print(shell, item_help, offset, false);
    40007010:	aa1403e0 	mov	x0, x20
    40007014:	92403c42 	and	x2, x2, #0xffff
    40007018:	97ffff57 	bl	40006d74 <formatted_text_print.constprop.0>
    4000701c:	17fffff8 	b	40006ffc <z_shell_help_subcmd_print+0x114>

0000000040007020 <z_shell_help_cmd_print>:

void z_shell_help_cmd_print(const struct shell *shell,
			    const struct shell_static_entry *cmd)
{
    40007020:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40007024:	910003fd 	mov	x29, sp
    40007028:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000702c:	aa0003f5 	mov	x21, x0
	static const char cmd_sep[] = " - "; /* commands separator */
	uint16_t field_width;

	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
    40007030:	f9400020 	ldr	x0, [x1]
{
    40007034:	a90153f3 	stp	x19, x20, [sp, #16]
    40007038:	aa0103f4 	mov	x20, x1
    4000703c:	b40002e0 	cbz	x0, 40007098 <z_shell_help_cmd_print+0x78>
    40007040:	94000705 	bl	40008c54 <strlen>
    40007044:	12003c13 	and	w19, w0, #0xffff
    40007048:	90000056 	adrp	x22, 4000f000 <cfg_flags.0+0x5ac>
    4000704c:	910b3ed6 	add	x22, x22, #0x2cf
    40007050:	aa1603e0 	mov	x0, x22
    40007054:	94000700 	bl	40008c54 <strlen>

	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
    40007058:	f9400283 	ldr	x3, [x20]
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
    4000705c:	0b000273 	add	w19, w19, w0
	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
    40007060:	aa1603e4 	mov	x4, x22
    40007064:	aa1503e0 	mov	x0, x21
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
    40007068:	12003e73 	and	w19, w19, #0xffff
	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
    4000706c:	52800101 	mov	w1, #0x8                   	// #8
    40007070:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007074:	91034442 	add	x2, x2, #0xd1
    40007078:	97fffddb 	bl	400067e4 <z_shell_fprintf>

	formatted_text_print(shell, cmd->help, field_width, false);
    4000707c:	92403e62 	and	x2, x19, #0xffff
    40007080:	aa1503e0 	mov	x0, x21
    40007084:	f9400681 	ldr	x1, [x20, #8]
}
    40007088:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000708c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40007090:	a8c37bfd 	ldp	x29, x30, [sp], #48
	formatted_text_print(shell, cmd->help, field_width, false);
    40007094:	17ffff38 	b	40006d74 <formatted_text_print.constprop.0>
    40007098:	52800013 	mov	w19, #0x0                   	// #0
    4000709c:	17ffffeb 	b	40007048 <z_shell_help_cmd_print+0x28>

00000000400070a0 <z_shell_help_request>:
	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
		return true;
	}

	return false;
}
    400070a0:	52800000 	mov	w0, #0x0                   	// #0
    400070a4:	d65f03c0 	ret

00000000400070a8 <z_shell_getopt_init>:
#include <shell/shell.h>
#include <shell/shell_getopt.h>

void z_shell_getopt_init(struct getopt_state *state)
{
	getopt_init(state);
    400070a8:	17fff08c 	b	400032d8 <getopt_init>

00000000400070ac <cmd_shell_stats_reset>:
				 size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell->stats->log_lost_cnt = 0;
    400070ac:	f9401800 	ldr	x0, [x0, #48]
    400070b0:	f900001f 	str	xzr, [x0]

	return 0;
}
    400070b4:	52800000 	mov	w0, #0x0                   	// #0
    400070b8:	d65f03c0 	ret

00000000400070bc <z_shell_raw_fprintf>:
{
    400070bc:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    400070c0:	910003fd 	mov	x29, sp
    400070c4:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    400070c8:	910403e2 	add	x2, sp, #0x100
    400070cc:	a9030be2 	stp	x2, x2, [sp, #48]
    400070d0:	910343e2 	add	x2, sp, #0xd0
    400070d4:	f90023e2 	str	x2, [sp, #64]
    400070d8:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    400070dc:	b9004be2 	str	w2, [sp, #72]
    400070e0:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    400070e4:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    400070e8:	a9430fe2 	ldp	x2, x3, [sp, #48]
    400070ec:	a9010fe2 	stp	x2, x3, [sp, #16]
    400070f0:	a9440fe2 	ldp	x2, x3, [sp, #64]
    400070f4:	a9020fe2 	stp	x2, x3, [sp, #32]
    400070f8:	910043e2 	add	x2, sp, #0x10
{
    400070fc:	3d8017e0 	str	q0, [sp, #80]
    40007100:	3d801be1 	str	q1, [sp, #96]
    40007104:	3d801fe2 	str	q2, [sp, #112]
    40007108:	3d8023e3 	str	q3, [sp, #128]
    4000710c:	3d8027e4 	str	q4, [sp, #144]
    40007110:	3d802be5 	str	q5, [sp, #160]
    40007114:	3d802fe6 	str	q6, [sp, #176]
    40007118:	3d8033e7 	str	q7, [sp, #192]
    4000711c:	a90e17e4 	stp	x4, x5, [sp, #224]
    40007120:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40007124:	97fff9da 	bl	4000588c <z_shell_fprintf_fmt>
}
    40007128:	a8d07bfd 	ldp	x29, x30, [sp], #256
    4000712c:	d65f03c0 	ret

0000000040007130 <cmd_resize_default>:

static int cmd_resize_default(const struct shell *shell,
			      size_t argc, char **argv)
{
    40007130:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40007134:	910003fd 	mov	x29, sp
    40007138:	f9000bf3 	str	x19, [sp, #16]
    4000713c:	aa0003f3 	mov	x19, x0
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40007140:	f9400800 	ldr	x0, [x0, #16]
    40007144:	b942b800 	ldr	w0, [x0, #696]
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
    40007148:	362800a0 	tbz	w0, #5, 4000715c <cmd_resize_default+0x2c>
    4000714c:	f9401660 	ldr	x0, [x19, #40]
    40007150:	d0000021 	adrp	x1, 4000d000 <__rodata_region_start>
    40007154:	913e6821 	add	x1, x1, #0xf9a
    40007158:	97ffffd9 	bl	400070bc <z_shell_raw_fprintf>
	shell->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
    4000715c:	f9400a60 	ldr	x0, [x19, #16]
    40007160:	52800301 	mov	w1, #0x18                  	// #24
    40007164:	72a00a01 	movk	w1, #0x50, lsl #16

	return 0;
}
    40007168:	f9400bf3 	ldr	x19, [sp, #16]
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
    4000716c:	b9004801 	str	w1, [x0, #72]
}
    40007170:	52800000 	mov	w0, #0x0                   	// #0
    40007174:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40007178:	d65f03c0 	ret

000000004000717c <cmd_shell_stats_show>:
{
    4000717c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_print(shell, "Lost logs: %lu", shell->stats->log_lost_cnt);
    40007180:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007184:	910b5842 	add	x2, x2, #0x2d6
{
    40007188:	910003fd 	mov	x29, sp
	shell_print(shell, "Lost logs: %lu", shell->stats->log_lost_cnt);
    4000718c:	f9401801 	ldr	x1, [x0, #48]
    40007190:	f9400023 	ldr	x3, [x1]
    40007194:	52800101 	mov	w1, #0x8                   	// #8
    40007198:	97fff96e 	bl	40005750 <shell_fprintf>
}
    4000719c:	52800000 	mov	w0, #0x0                   	// #0
    400071a0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400071a4:	d65f03c0 	ret

00000000400071a8 <cmd_history>:
{
    400071a8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400071ac:	910003fd 	mov	x29, sp
    400071b0:	a90153f3 	stp	x19, x20, [sp, #16]
    400071b4:	aa0003f3 	mov	x19, x0
    400071b8:	52800014 	mov	w20, #0x0                   	// #0
    400071bc:	f90013f5 	str	x21, [sp, #32]
			shell_print(shell, "[%3d] %s",
    400071c0:	90000055 	adrp	x21, 4000f000 <cfg_flags.0+0x5ac>
    400071c4:	910b9ab5 	add	x21, x21, #0x2e6
		z_shell_history_get(shell->history, true,
    400071c8:	a9410262 	ldp	x2, x0, [x19, #16]
    400071cc:	9100fbe3 	add	x3, sp, #0x3e
    400071d0:	52800021 	mov	w1, #0x1                   	// #1
    400071d4:	91065842 	add	x2, x2, #0x196
    400071d8:	94000121 	bl	4000765c <z_shell_history_get>
		if (len) {
    400071dc:	79407fe0 	ldrh	w0, [sp, #62]
    400071e0:	f9400a64 	ldr	x4, [x19, #16]
    400071e4:	34000120 	cbz	w0, 40007208 <cmd_history+0x60>
			shell_print(shell, "[%3d] %s",
    400071e8:	2a1403e3 	mov	w3, w20
    400071ec:	91065884 	add	x4, x4, #0x196
    400071f0:	aa1503e2 	mov	x2, x21
    400071f4:	aa1303e0 	mov	x0, x19
    400071f8:	52800101 	mov	w1, #0x8                   	// #8
    400071fc:	11000694 	add	w20, w20, #0x1
    40007200:	97fff954 	bl	40005750 <shell_fprintf>
		z_shell_history_get(shell->history, true,
    40007204:	17fffff1 	b	400071c8 <cmd_history+0x20>
	shell->ctx->temp_buff[0] = '\0';
    40007208:	3906589f 	strb	wzr, [x4, #406]
}
    4000720c:	52800000 	mov	w0, #0x0                   	// #0
    40007210:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007214:	f94013f5 	ldr	x21, [sp, #32]
    40007218:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000721c:	d65f03c0 	ret

0000000040007220 <cmd_echo>:
{
    40007220:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	if (argc == 2) {
    40007224:	f100083f 	cmp	x1, #0x2
{
    40007228:	910003fd 	mov	x29, sp
	if (argc == 2) {
    4000722c:	54000161 	b.ne	40007258 <cmd_echo+0x38>  // b.any
		shell_error(shell, "%s:%s%s", argv[0],
    40007230:	a9401443 	ldp	x3, x5, [x2]
    40007234:	90000044 	adrp	x4, 4000f000 <cfg_flags.0+0x5ac>
    40007238:	910bd084 	add	x4, x4, #0x2f4
    4000723c:	52800021 	mov	w1, #0x1                   	// #1
    40007240:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007244:	910c2442 	add	x2, x2, #0x309
    40007248:	97fff942 	bl	40005750 <shell_fprintf>
    4000724c:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
    40007250:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007254:	d65f03c0 	ret
	return sh->ctx->cfg.flags.echo == 1;
    40007258:	f9400801 	ldr	x1, [x0, #16]
	shell_print(shell, "Echo status: %s",
    4000725c:	f0000023 	adrp	x3, 4000e000 <mmu_regions+0x38>
    40007260:	9134e463 	add	x3, x3, #0xd39
    40007264:	b942b822 	ldr	w2, [x1, #696]
    40007268:	90000041 	adrp	x1, 4000f000 <cfg_flags.0+0x5ac>
    4000726c:	910bc021 	add	x1, x1, #0x2f0
    40007270:	f27f005f 	tst	x2, #0x2
    40007274:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007278:	910c4842 	add	x2, x2, #0x312
    4000727c:	9a811063 	csel	x3, x3, x1, ne  // ne = any
    40007280:	52800101 	mov	w1, #0x8                   	// #8
    40007284:	97fff933 	bl	40005750 <shell_fprintf>
	return 0;
    40007288:	52800000 	mov	w0, #0x0                   	// #0
    4000728c:	17fffff1 	b	40007250 <cmd_echo+0x30>

0000000040007290 <cmd_clear>:
{
    40007290:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40007294:	910003fd 	mov	x29, sp
    40007298:	f9000bf3 	str	x19, [sp, #16]
    4000729c:	aa0003f3 	mov	x19, x0
	return sh->ctx->cfg.flags.use_vt100 == 1;
    400072a0:	f9400800 	ldr	x0, [x0, #16]
    400072a4:	b942b800 	ldr	w0, [x0, #696]
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
    400072a8:	362800c0 	tbz	w0, #5, 400072c0 <cmd_clear+0x30>
    400072ac:	f9401660 	ldr	x0, [x19, #40]
    400072b0:	d0000021 	adrp	x1, 4000d000 <__rodata_region_start>
    400072b4:	913e6821 	add	x1, x1, #0xf9a
    400072b8:	91001c21 	add	x1, x1, #0x7
    400072bc:	97ffff80 	bl	400070bc <z_shell_raw_fprintf>
    400072c0:	f9400a60 	ldr	x0, [x19, #16]
    400072c4:	b942b800 	ldr	w0, [x0, #696]
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
    400072c8:	362800c0 	tbz	w0, #5, 400072e0 <cmd_clear+0x50>
    400072cc:	f9401660 	ldr	x0, [x19, #40]
    400072d0:	d0000021 	adrp	x1, 4000d000 <__rodata_region_start>
    400072d4:	913e6821 	add	x1, x1, #0xf9a
    400072d8:	91003021 	add	x1, x1, #0xc
    400072dc:	97ffff78 	bl	400070bc <z_shell_raw_fprintf>
}
    400072e0:	52800000 	mov	w0, #0x0                   	// #0
    400072e4:	f9400bf3 	ldr	x19, [sp, #16]
    400072e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400072ec:	d65f03c0 	ret

00000000400072f0 <cmd_resize>:

static int cmd_resize(const struct shell *shell, size_t argc, char **argv)
{
    400072f0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	int err;

	if (argc != 1) {
    400072f4:	f100043f 	cmp	x1, #0x1
{
    400072f8:	910003fd 	mov	x29, sp
    400072fc:	a90153f3 	stp	x19, x20, [sp, #16]
    40007300:	f90013f5 	str	x21, [sp, #32]
	if (argc != 1) {
    40007304:	540001c0 	b.eq	4000733c <cmd_resize+0x4c>  // b.none
		shell_error(shell, "%s:%s%s", argv[0],
    40007308:	a9401443 	ldp	x3, x5, [x2]
    4000730c:	90000044 	adrp	x4, 4000f000 <cfg_flags.0+0x5ac>
    40007310:	910bd084 	add	x4, x4, #0x2f4
    40007314:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007318:	910c2442 	add	x2, x2, #0x309
    4000731c:	52800021 	mov	w1, #0x1                   	// #1
			    SHELL_MSG_UNKNOWN_PARAMETER, argv[1]);
		return -EINVAL;
    40007320:	128002b4 	mov	w20, #0xffffffea            	// #-22
		shell_error(shell, "%s:%s%s", argv[0],
    40007324:	97fff90b 	bl	40005750 <shell_fprintf>
			   " screen size");
		return -ENOEXEC;
	}

	return 0;
}
    40007328:	2a1403e0 	mov	w0, w20
    4000732c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007330:	f94013f5 	ldr	x21, [sp, #32]
    40007334:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40007338:	d65f03c0 	ret
    4000733c:	aa0003f3 	mov	x19, x0
    40007340:	f9400800 	ldr	x0, [x0, #16]
    40007344:	b942b800 	ldr	w0, [x0, #696]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
    40007348:	362800c0 	tbz	w0, #5, 40007360 <cmd_resize+0x70>
    4000734c:	f9401660 	ldr	x0, [x19, #40]
    40007350:	d0000021 	adrp	x1, 4000d000 <__rodata_region_start>
    40007354:	913e6821 	add	x1, x1, #0xf9a
    40007358:	91004821 	add	x1, x1, #0x12
    4000735c:	97ffff58 	bl	400070bc <z_shell_raw_fprintf>
	z_shell_op_cursor_vert_move(shell, -SHELL_MAX_TERMINAL_SIZE);
    40007360:	aa1303e0 	mov	x0, x19
    40007364:	12801f21 	mov	w1, #0xffffff06            	// #-250
    40007368:	97fffb8a 	bl	40006190 <z_shell_op_cursor_vert_move>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
    4000736c:	52807d15 	mov	w21, #0x3e8                 	// #1000
	z_shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
    40007370:	aa1303e0 	mov	x0, x19
    40007374:	52801f41 	mov	w1, #0xfa                  	// #250
    40007378:	97fffb96 	bl	400061d0 <z_shell_op_cursor_horiz_move>
	char c = 0;
    4000737c:	3900dfff 	strb	wzr, [sp, #55]
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    40007380:	f9400a60 	ldr	x0, [x19, #16]
    40007384:	d2802002 	mov	x2, #0x100                 	// #256
    40007388:	52800001 	mov	w1, #0x0                   	// #0
	uint16_t buff_idx = 0U;
    4000738c:	52800014 	mov	w20, #0x0                   	// #0
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    40007390:	91065800 	add	x0, x0, #0x196
    40007394:	9400067b 	bl	40008d80 <memset>
	z_shell_raw_fprintf(shell->fprintf_ctx, cmd_get_terminal_size);
    40007398:	f9401660 	ldr	x0, [x19, #40]
    4000739c:	90000041 	adrp	x1, 4000f000 <cfg_flags.0+0x5ac>
    400073a0:	911c6821 	add	x1, x1, #0x71a
    400073a4:	97ffff46 	bl	400070bc <z_shell_raw_fprintf>
    400073a8:	f9401660 	ldr	x0, [x19, #40]
    400073ac:	97fff929 	bl	40005850 <z_shell_fprintf_buffer_flush>
			(void)shell->iface->api->read(shell->iface, &c,
    400073b0:	f9400660 	ldr	x0, [x19, #8]
    400073b4:	9100e3e3 	add	x3, sp, #0x38
    400073b8:	d2800022 	mov	x2, #0x1                   	// #1
    400073bc:	f9400001 	ldr	x1, [x0]
    400073c0:	f9401024 	ldr	x4, [x1, #32]
    400073c4:	9100dfe1 	add	x1, sp, #0x37
    400073c8:	d63f0080 	blr	x4
			if (cnt == 0) {
    400073cc:	f9401fe0 	ldr	x0, [sp, #56]
    400073d0:	b5000100 	cbnz	x0, 400073f0 <cmd_resize+0x100>
	z_impl_k_busy_wait(usec_to_wait);
    400073d4:	52807d00 	mov	w0, #0x3e8                 	// #1000
	for (uint16_t i = 0; i < 1000; i++) {
    400073d8:	510006b5 	sub	w21, w21, #0x1
    400073dc:	94000fe9 	bl	4000b380 <z_impl_k_busy_wait>
    400073e0:	72003eb5 	ands	w21, w21, #0xffff
    400073e4:	54fffe61 	b.ne	400073b0 <cmd_resize+0xc0>  // b.any
		ret_val = -ENOTSUP;
    400073e8:	128010b4 	mov	w20, #0xffffff7a            	// #-134
    400073ec:	1400002c 	b	4000749c <cmd_resize+0x1ac>
			if ((c != SHELL_VT100_ASCII_ESC) &&
    400073f0:	3940dfe1 	ldrb	w1, [sp, #55]
			    (shell->ctx->temp_buff[0] !=
    400073f4:	f9400a60 	ldr	x0, [x19, #16]
			if ((c != SHELL_VT100_ASCII_ESC) &&
    400073f8:	71006c3f 	cmp	w1, #0x1b
    400073fc:	54000920 	b.eq	40007520 <cmd_resize+0x230>  // b.none
    40007400:	39465802 	ldrb	w2, [x0, #406]
    40007404:	71006c5f 	cmp	w2, #0x1b
    40007408:	54fffd41 	b.ne	400073b0 <cmd_resize+0xc0>  // b.any
			if (c == 'R') { /* End of response from the terminal. */
    4000740c:	7101483f 	cmp	w1, #0x52
    40007410:	54000881 	b.ne	40007520 <cmd_resize+0x230>  // b.any
				shell->ctx->temp_buff[buff_idx] = '\0';
    40007414:	8b34c014 	add	x20, x0, w20, sxtw
    40007418:	39065a9f 	strb	wzr, [x20, #406]
				if (shell->ctx->temp_buff[1] != '[') {
    4000741c:	39465c01 	ldrb	w1, [x0, #407]
    40007420:	71016c3f 	cmp	w1, #0x5b
    40007424:	54000640 	b.eq	400074ec <cmd_resize+0x1fc>  // b.none
				shell->ctx->temp_buff[0] = 0;
    40007428:	3906581f 	strb	wzr, [x0, #406]
				return -ENOMEM;
    4000742c:	17ffffef 	b	400073e8 <cmd_resize+0xf8>
					*y = *y * 10U +
    40007430:	1b061042 	madd	w2, w2, w6, w4
					if (buff_idx >=
    40007434:	91000421 	add	x1, x1, #0x1
    40007438:	f103f83f 	cmp	x1, #0xfe
					*y = *y * 10U +
    4000743c:	5100c042 	sub	w2, w2, #0x30
    40007440:	12003c42 	and	w2, w2, #0xffff
					if (buff_idx >=
    40007444:	54fffd20 	b.eq	400073e8 <cmd_resize+0xf8>  // b.none
				while (shell->ctx->temp_buff[buff_idx] != ';') {
    40007448:	386168a4 	ldrb	w4, [x5, x1]
					(shell->ctx->temp_buff[buff_idx++] -
    4000744c:	11000c23 	add	w3, w1, #0x3
    40007450:	12003c63 	and	w3, w3, #0xffff
				while (shell->ctx->temp_buff[buff_idx] != ';') {
    40007454:	7100ec9f 	cmp	w4, #0x3b
    40007458:	54fffec1 	b.ne	40007430 <cmd_resize+0x140>  // b.any
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
    4000745c:	7104007f 	cmp	w3, #0x100
    40007460:	54fffc40 	b.eq	400073e8 <cmd_resize+0xf8>  // b.none
	*x = 0U;
    40007464:	52800001 	mov	w1, #0x0                   	// #0
					*x = *x * 10U +
    40007468:	52800145 	mov	w5, #0xa                   	// #10
				while (shell->ctx->temp_buff[buff_idx]
    4000746c:	8b23c004 	add	x4, x0, w3, sxtw
    40007470:	39465884 	ldrb	w4, [x4, #406]
    40007474:	35000464 	cbnz	w4, 40007500 <cmd_resize+0x210>
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
    40007478:	7103e83f 	cmp	w1, #0xfa
    4000747c:	52801f43 	mov	w3, #0xfa                  	// #250
    40007480:	1a839021 	csel	w1, w1, w3, ls  // ls = plast
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
    40007484:	7103e85f 	cmp	w2, #0xfa
    40007488:	1a839042 	csel	w2, w2, w3, ls  // ls = plast
	int ret_val = 0;
    4000748c:	52800014 	mov	w20, #0x0                   	// #0
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
    40007490:	79009002 	strh	w2, [x0, #72]
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
    40007494:	79009401 	strh	w1, [x0, #74]
				shell->ctx->temp_buff[0] = 0;
    40007498:	3906581f 	strb	wzr, [x0, #406]
	return sh->ctx->cfg.flags.use_vt100 == 1;
    4000749c:	f9400a60 	ldr	x0, [x19, #16]
    400074a0:	b942b800 	ldr	w0, [x0, #696]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
    400074a4:	362800c0 	tbz	w0, #5, 400074bc <cmd_resize+0x1cc>
    400074a8:	f9401660 	ldr	x0, [x19, #40]
    400074ac:	d0000021 	adrp	x1, 4000d000 <__rodata_region_start>
    400074b0:	913e6821 	add	x1, x1, #0xf9a
    400074b4:	91005821 	add	x1, x1, #0x16
    400074b8:	97ffff01 	bl	400070bc <z_shell_raw_fprintf>
	if (err != 0) {
    400074bc:	34fff374 	cbz	w20, 40007328 <cmd_resize+0x38>
		shell->ctx->vt100_ctx.cons.terminal_hei =
    400074c0:	f9400a60 	ldr	x0, [x19, #16]
    400074c4:	52800301 	mov	w1, #0x18                  	// #24
    400074c8:	72a00a01 	movk	w1, #0x50, lsl #16
		shell_warn(shell, "No response from the terminal, assumed 80x24"
    400074cc:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    400074d0:	910c8c42 	add	x2, x2, #0x323
    400074d4:	128000f4 	mov	w20, #0xfffffff8            	// #-8
		shell->ctx->vt100_ctx.cons.terminal_hei =
    400074d8:	b9004801 	str	w1, [x0, #72]
		shell_warn(shell, "No response from the terminal, assumed 80x24"
    400074dc:	aa1303e0 	mov	x0, x19
    400074e0:	52800061 	mov	w1, #0x3                   	// #3
    400074e4:	97fff89b 	bl	40005750 <shell_fprintf>
		return -ENOEXEC;
    400074e8:	17ffff90 	b	40007328 <cmd_resize+0x38>
				while (shell->ctx->temp_buff[buff_idx] != ';') {
    400074ec:	91066005 	add	x5, x0, #0x198
    400074f0:	d2800001 	mov	x1, #0x0                   	// #0
	*y = 0U;
    400074f4:	52800002 	mov	w2, #0x0                   	// #0
					*y = *y * 10U +
    400074f8:	52800146 	mov	w6, #0xa                   	// #10
    400074fc:	17ffffd3 	b	40007448 <cmd_resize+0x158>
					*x = *x * 10U +
    40007500:	1b051021 	madd	w1, w1, w5, w4
					if (buff_idx >=
    40007504:	11000463 	add	w3, w3, #0x1
    40007508:	12003c64 	and	w4, w3, #0xffff
					*x = *x * 10U +
    4000750c:	5100c021 	sub	w1, w1, #0x30
					if (buff_idx >=
    40007510:	7103fc9f 	cmp	w4, #0xff
					*x = *x * 10U +
    40007514:	12003c21 	and	w1, w1, #0xffff
					if (buff_idx >=
    40007518:	54fffaa9 	b.ls	4000746c <cmd_resize+0x17c>  // b.plast
    4000751c:	17ffffb3 	b	400073e8 <cmd_resize+0xf8>
			shell->ctx->temp_buff[buff_idx] = c;
    40007520:	8b34c002 	add	x2, x0, w20, sxtw
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
    40007524:	11000694 	add	w20, w20, #0x1
    40007528:	12003e94 	and	w20, w20, #0xffff
    4000752c:	7100269f 	cmp	w20, #0x9
			shell->ctx->temp_buff[buff_idx] = c;
    40007530:	39065841 	strb	w1, [x2, #406]
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
    40007534:	54fff3e9 	b.ls	400073b0 <cmd_resize+0xc0>  // b.plast
    40007538:	17ffffbc 	b	40007428 <cmd_resize+0x138>

000000004000753c <cmd_bacskpace_mode_backspace>:
{
    4000753c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40007540:	910003fd 	mov	x29, sp
    40007544:	f9400801 	ldr	x1, [x0, #16]
    40007548:	d2800100 	mov	x0, #0x8                   	// #8
    4000754c:	910ae021 	add	x1, x1, #0x2b8
    40007550:	97ffe69c 	bl	40000fc0 <__aarch64_ldclr8_acq_rel>
}
    40007554:	52800000 	mov	w0, #0x0                   	// #0
    40007558:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000755c:	d65f03c0 	ret

0000000040007560 <cmd_bacskpace_mode_delete>:
{
    40007560:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40007564:	910003fd 	mov	x29, sp
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    40007568:	f9400801 	ldr	x1, [x0, #16]
    4000756c:	d2800100 	mov	x0, #0x8                   	// #8
    40007570:	910ae021 	add	x1, x1, #0x2b8
    40007574:	97ffe69f 	bl	40000ff0 <__aarch64_ldset8_acq_rel>
}
    40007578:	52800000 	mov	w0, #0x0                   	// #0
    4000757c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007580:	d65f03c0 	ret

0000000040007584 <cmd_echo_off>:
{
    40007584:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40007588:	910003fd 	mov	x29, sp
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4000758c:	f9400801 	ldr	x1, [x0, #16]
    40007590:	d2800040 	mov	x0, #0x2                   	// #2
    40007594:	910ae021 	add	x1, x1, #0x2b8
    40007598:	97ffe68a 	bl	40000fc0 <__aarch64_ldclr8_acq_rel>
}
    4000759c:	52800000 	mov	w0, #0x0                   	// #0
    400075a0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400075a4:	d65f03c0 	ret

00000000400075a8 <cmd_colors_off>:
{
    400075a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400075ac:	910003fd 	mov	x29, sp
    400075b0:	f9400801 	ldr	x1, [x0, #16]
    400075b4:	d2800200 	mov	x0, #0x10                  	// #16
    400075b8:	910ae021 	add	x1, x1, #0x2b8
    400075bc:	97ffe681 	bl	40000fc0 <__aarch64_ldclr8_acq_rel>
}
    400075c0:	52800000 	mov	w0, #0x0                   	// #0
    400075c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400075c8:	d65f03c0 	ret

00000000400075cc <cmd_colors_on>:
{
    400075cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400075d0:	910003fd 	mov	x29, sp
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    400075d4:	f9400801 	ldr	x1, [x0, #16]
    400075d8:	d2800200 	mov	x0, #0x10                  	// #16
    400075dc:	910ae021 	add	x1, x1, #0x2b8
    400075e0:	97ffe684 	bl	40000ff0 <__aarch64_ldset8_acq_rel>
}
    400075e4:	52800000 	mov	w0, #0x0                   	// #0
    400075e8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400075ec:	d65f03c0 	ret

00000000400075f0 <cmd_echo_on>:
{
    400075f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400075f4:	910003fd 	mov	x29, sp
    400075f8:	f9400801 	ldr	x1, [x0, #16]
    400075fc:	d2800040 	mov	x0, #0x2                   	// #2
    40007600:	910ae021 	add	x1, x1, #0x2b8
    40007604:	97ffe67b 	bl	40000ff0 <__aarch64_ldset8_acq_rel>
}
    40007608:	52800000 	mov	w0, #0x0                   	// #0
    4000760c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007610:	d65f03c0 	ret

0000000040007614 <remove_from_tail.part.0>:
	memcpy(item->data, src, len);
	sys_dlist_prepend(&history->list, &item->dnode);
}

/* Returns true if element was removed. */
static bool remove_from_tail(struct shell_history *history)
    40007614:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40007618:	910003fd 	mov	x29, sp
 * @return a pointer to the tail element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_tail(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    4000761c:	f9400802 	ldr	x2, [x0, #16]

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	total_len = offsetof(struct shell_history_item, data) +
			h_item->len + h_item->padding;
	ring_buf_get_finish(history->ring_buf, total_len);
    40007620:	f9400000 	ldr	x0, [x0]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    40007624:	a9400c41 	ldp	x1, x3, [x2]
	sys_dnode_t *const next = node->next;

	prev->next = next;
    40007628:	f9000061 	str	x1, [x3]
	next->prev = prev;
    4000762c:	f9000423 	str	x3, [x1, #8]
			h_item->len + h_item->padding;
    40007630:	79402041 	ldrh	w1, [x2, #16]
	node->prev = NULL;
    40007634:	a9007c5f 	stp	xzr, xzr, [x2]
    40007638:	79402442 	ldrh	w2, [x2, #18]
    4000763c:	0b020021 	add	w1, w1, w2
	ring_buf_get_finish(history->ring_buf, total_len);
    40007640:	11005021 	add	w1, w1, #0x14
    40007644:	97ffedfe 	bl	40002e3c <ring_buf_get_finish>

	return true;
}
    40007648:	52800020 	mov	w0, #0x1                   	// #1
    4000764c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007650:	d65f03c0 	ret

0000000040007654 <z_shell_history_mode_exit>:
	history->current = NULL;
    40007654:	f9000c1f 	str	xzr, [x0, #24]
}
    40007658:	d65f03c0 	ret

000000004000765c <z_shell_history_get>:
{
    4000765c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40007660:	910003fd 	mov	x29, sp
    40007664:	a90153f3 	stp	x19, x20, [sp, #16]
    40007668:	aa0203f4 	mov	x20, x2
	return list->head == list;
    4000766c:	aa0003e2 	mov	x2, x0
    40007670:	f8408c53 	ldr	x19, [x2, #8]!
    40007674:	f90013f5 	str	x21, [sp, #32]
    40007678:	aa0303f5 	mov	x21, x3
	if (sys_dlist_is_empty(&history->list)) {
    4000767c:	eb02027f 	cmp	x19, x2
    40007680:	540000e1 	b.ne	4000769c <z_shell_history_get+0x40>  // b.any
		return false;
    40007684:	52800000 	mov	w0, #0x0                   	// #0
		*len = 0U;
    40007688:	790002bf 	strh	wzr, [x21]
}
    4000768c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007690:	f94013f5 	ldr	x21, [sp, #32]
    40007694:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40007698:	d65f03c0 	ret
    4000769c:	12001c21 	and	w1, w1, #0xff
		if (history->current == NULL) {
    400076a0:	f9400c04 	ldr	x4, [x0, #24]
	if (!up) { /* button down */
    400076a4:	35000261 	cbnz	w1, 400076f0 <z_shell_history_get+0x94>
		if (history->current == NULL) {
    400076a8:	b4fffee4 	cbz	x4, 40007684 <z_shell_history_get+0x28>
	return (node == list->head) ? NULL : node->prev;
    400076ac:	eb04027f 	cmp	x19, x4
    400076b0:	54000061 	b.ne	400076bc <z_shell_history_get+0x60>  // b.any
	history->current = l_item;
    400076b4:	f9000c1f 	str	xzr, [x0, #24]
	if (l_item) {
    400076b8:	17fffff3 	b	40007684 <z_shell_history_get+0x28>
    400076bc:	f9400493 	ldr	x19, [x4, #8]
	history->current = l_item;
    400076c0:	f9000c13 	str	x19, [x0, #24]
	if (l_item) {
    400076c4:	b4fffe13 	cbz	x19, 40007684 <z_shell_history_get+0x28>
		memcpy(dst, h_item->data, h_item->len);
    400076c8:	79402262 	ldrh	w2, [x19, #16]
    400076cc:	91005261 	add	x1, x19, #0x14
    400076d0:	aa1403e0 	mov	x0, x20
    400076d4:	940005a3 	bl	40008d60 <memcpy>
		*len = h_item->len;
    400076d8:	79402261 	ldrh	w1, [x19, #16]
		return true;
    400076dc:	52800020 	mov	w0, #0x1                   	// #1
		*len = h_item->len;
    400076e0:	790002a1 	strh	w1, [x21]
		dst[*len] = '\0';
    400076e4:	92403c21 	and	x1, x1, #0xffff
    400076e8:	38216a9f 	strb	wzr, [x20, x1]
		return true;
    400076ec:	17ffffe8 	b	4000768c <z_shell_history_get+0x30>
		sys_dlist_peek_head_not_empty(&history->list) :
    400076f0:	b4fffe84 	cbz	x4, 400076c0 <z_shell_history_get+0x64>
	return (node == list->tail) ? NULL : node->next;
    400076f4:	f9400801 	ldr	x1, [x0, #16]
    400076f8:	eb04003f 	cmp	x1, x4
    400076fc:	54fffdc0 	b.eq	400076b4 <z_shell_history_get+0x58>  // b.none
    40007700:	f9400093 	ldr	x19, [x4]
    40007704:	17ffffef 	b	400076c0 <z_shell_history_get+0x64>

0000000040007708 <z_shell_history_purge>:

void z_shell_history_purge(struct shell_history *history)
{
    40007708:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000770c:	910003fd 	mov	x29, sp
    40007710:	a90153f3 	stp	x19, x20, [sp, #16]
    40007714:	aa0003f3 	mov	x19, x0
	if (sys_dlist_is_empty(&history->list)) {
    40007718:	91002014 	add	x20, x0, #0x8
    4000771c:	f9400660 	ldr	x0, [x19, #8]
    40007720:	eb14001f 	cmp	x0, x20
    40007724:	540000a0 	b.eq	40007738 <z_shell_history_purge+0x30>  // b.none
    40007728:	aa1303e0 	mov	x0, x19
    4000772c:	97ffffba 	bl	40007614 <remove_from_tail.part.0>
	while (remove_from_tail(history)) {
    40007730:	72001c1f 	tst	w0, #0xff
    40007734:	54ffff41 	b.ne	4000771c <z_shell_history_purge+0x14>  // b.any
	}
}
    40007738:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000773c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40007740:	d65f03c0 	ret

0000000040007744 <z_shell_history_put>:

void z_shell_history_put(struct shell_history *history, uint8_t *line,
			 size_t len)
{
    40007744:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40007748:	910003fd 	mov	x29, sp
    4000774c:	a90153f3 	stp	x19, x20, [sp, #16]
    40007750:	aa0003f3 	mov	x19, x0
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;
	uint32_t total_len = len + offsetof(struct shell_history_item, data);
    40007754:	11005054 	add	w20, w2, #0x14
 *
 * @return Ring buffer capacity (in 32-bit words or bytes).
 */
static inline uint32_t ring_buf_capacity_get(struct ring_buf *buf)
{
	return buf->size;
    40007758:	f9400000 	ldr	x0, [x0]
{
    4000775c:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint32_t claim_len;
	uint32_t claim2_len;
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
    40007760:	4b1403f5 	neg	w21, w20
{
    40007764:	a90363f7 	stp	x23, x24, [sp, #48]
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
    40007768:	12000ab7 	and	w23, w21, #0x7

	/* align to word. */
	total_len += padding;

	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
    4000776c:	b9401000 	ldr	w0, [x0, #16]
{
    40007770:	f90023f9 	str	x25, [sp, #64]
	total_len += padding;
    40007774:	0b1402f4 	add	w20, w23, w20
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
    40007778:	6b00029f 	cmp	w20, w0
    4000777c:	54000688 	b.hi	4000784c <z_shell_history_put+0x108>  // b.pmore
	history->current = NULL;
    40007780:	f9000e7f 	str	xzr, [x19, #24]
    40007784:	aa0203f6 	mov	x22, x2
		return;
	}

	z_shell_history_mode_exit(history);

	if (len == 0) {
    40007788:	b4000622 	cbz	x2, 4000784c <z_shell_history_put+0x108>
	return list->head == list;
    4000778c:	f9400660 	ldr	x0, [x19, #8]
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
    40007790:	91002278 	add	x24, x19, #0x8
    40007794:	aa0103f9 	mov	x25, x1
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40007798:	eb00031f 	cmp	x24, x0
    4000779c:	54000481 	b.ne	4000782c <z_shell_history_put+0xe8>  // b.any
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
    400077a0:	f9002fff 	str	xzr, [sp, #88]
		/* Same command as before, do not store */
		return;
	}

	do {
		claim_len = ring_buf_put_claim(history->ring_buf,
    400077a4:	f9400260 	ldr	x0, [x19]
    400077a8:	2a1403e2 	mov	w2, w20
    400077ac:	910163e1 	add	x1, sp, #0x58
    400077b0:	97ffed2b 	bl	40002c5c <ring_buf_put_claim>
    400077b4:	2a0003f5 	mov	w21, w0
						(uint8_t **)&h_item, total_len);
		/* second allocation may succeed if we were at the end of the
		 * buffer.
		 */
		if (claim_len < total_len) {
    400077b8:	6b00029f 	cmp	w20, w0
    400077bc:	54000549 	b.ls	40007864 <z_shell_history_put+0x120>  // b.plast
			claim2_len =
				ring_buf_put_claim(history->ring_buf,
    400077c0:	f9400260 	ldr	x0, [x19]
    400077c4:	2a1403e2 	mov	w2, w20
    400077c8:	910163e1 	add	x1, sp, #0x58
    400077cc:	97ffed24 	bl	40002c5c <ring_buf_put_claim>
						   (uint8_t **)&h_item, total_len);
			if (claim2_len == total_len) {
    400077d0:	6b00029f 	cmp	w20, w0
    400077d4:	540004a1 	b.ne	40007868 <z_shell_history_put+0x124>  // b.any
				ring_buf_put_finish(history->ring_buf,
    400077d8:	f9400260 	ldr	x0, [x19]
    400077dc:	2a1503e1 	mov	w1, w21
						    claim_len);
				padding += claim_len;
    400077e0:	0b1502f5 	add	w21, w23, w21
    400077e4:	12003eb7 	and	w23, w21, #0xffff
    400077e8:	2a1403f5 	mov	w21, w20
				ring_buf_put_finish(history->ring_buf,
    400077ec:	97ffed33 	bl	40002cb8 <ring_buf_put_finish>
				claim_len = total_len;
			}
		}

		if (claim_len == total_len) {
			add_to_head(history, h_item, line, len, padding);
    400077f0:	f9402ff4 	ldr	x20, [sp, #88]
	memcpy(item->data, src, len);
    400077f4:	aa1903e1 	mov	x1, x25
    400077f8:	aa1603e2 	mov	x2, x22
    400077fc:	91005280 	add	x0, x20, #0x14
	item->len = len;
    40007800:	79002296 	strh	w22, [x20, #16]
	item->padding = padding;
    40007804:	79002697 	strh	w23, [x20, #18]
	memcpy(item->data, src, len);
    40007808:	94000556 	bl	40008d60 <memcpy>
	sys_dnode_t *const head = list->head;
    4000780c:	f9400660 	ldr	x0, [x19, #8]
	node->prev = list;
    40007810:	a9006280 	stp	x0, x24, [x20]
			ring_buf_put_finish(history->ring_buf, claim_len);
    40007814:	2a1503e1 	mov	w1, w21
	head->prev = node;
    40007818:	f9000414 	str	x20, [x0, #8]
    4000781c:	f9400260 	ldr	x0, [x19]
	list->head = node;
    40007820:	f9000674 	str	x20, [x19, #8]
    40007824:	97ffed25 	bl	40002cb8 <ring_buf_put_finish>
			break;
    40007828:	14000009 	b	4000784c <z_shell_history_put+0x108>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
    4000782c:	f9002fe0 	str	x0, [sp, #88]
	if (l_item &&
    40007830:	b4fffba0 	cbz	x0, 400077a4 <z_shell_history_put+0x60>
	   (h_item->len == len) &&
    40007834:	79402003 	ldrh	w3, [x0, #16]
	if (l_item &&
    40007838:	eb02007f 	cmp	x3, x2
    4000783c:	54fffb41 	b.ne	400077a4 <z_shell_history_put+0x60>  // b.any
	   (memcmp(h_item->data, line, len) == 0)) {
    40007840:	91005000 	add	x0, x0, #0x14
    40007844:	9400052a 	bl	40008cec <memcmp>
	   (h_item->len == len) &&
    40007848:	35fffae0 	cbnz	w0, 400077a4 <z_shell_history_put+0x60>
			 * of ring buffer capacity length.
			 */
			ring_buf_reset(history->ring_buf);
		}
	} while (1);
}
    4000784c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007850:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40007854:	a94363f7 	ldp	x23, x24, [sp, #48]
    40007858:	f94023f9 	ldr	x25, [sp, #64]
    4000785c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40007860:	d65f03c0 	ret
		if (claim_len == total_len) {
    40007864:	54fffc60 	b.eq	400077f0 <z_shell_history_put+0xac>  // b.none
		ring_buf_put_finish(history->ring_buf, 0);
    40007868:	f9400260 	ldr	x0, [x19]
    4000786c:	52800001 	mov	w1, #0x0                   	// #0
    40007870:	97ffed12 	bl	40002cb8 <ring_buf_put_finish>
	if (sys_dlist_is_empty(&history->list)) {
    40007874:	f9400660 	ldr	x0, [x19, #8]
    40007878:	eb00031f 	cmp	x24, x0
    4000787c:	540000e1 	b.ne	40007898 <z_shell_history_put+0x154>  // b.any
	buf->head = 0;
    40007880:	f9400260 	ldr	x0, [x19]
	memset(&buf->misc, 0, sizeof(buf->misc));
    40007884:	d2800102 	mov	x2, #0x8                   	// #8
    40007888:	52800001 	mov	w1, #0x0                   	// #0
	buf->head = 0;
    4000788c:	f800841f 	str	xzr, [x0], #8
	memset(&buf->misc, 0, sizeof(buf->misc));
    40007890:	9400053c 	bl	40008d80 <memset>
}
    40007894:	17ffffc4 	b	400077a4 <z_shell_history_put+0x60>
    40007898:	aa1303e0 	mov	x0, x19
    4000789c:	97ffff5e 	bl	40007614 <remove_from_tail.part.0>
		if (remove_from_tail(history) == false) {
    400078a0:	72001c1f 	tst	w0, #0xff
    400078a4:	54fff801 	b.ne	400077a4 <z_shell_history_put+0x60>  // b.any
    400078a8:	17fffff6 	b	40007880 <z_shell_history_put+0x13c>

00000000400078ac <z_shell_history_init>:

void z_shell_history_init(struct shell_history *history)
{
	sys_dlist_init(&history->list);
    400078ac:	91002001 	add	x1, x0, #0x8
	list->tail = (sys_dnode_t *)list;
    400078b0:	a9008401 	stp	x1, x1, [x0, #8]
	history->current = NULL;
    400078b4:	f9000c1f 	str	xzr, [x0, #24]
}
    400078b8:	d65f03c0 	ret

00000000400078bc <z_shell_has_wildcard>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
    400078bc:	b5000060 	cbnz	x0, 400078c8 <z_shell_has_wildcard+0xc>
		if ((str[i] == '?') || (str[i] == '*')) {
			return true;
		}
	}

	return false;
    400078c0:	52800000 	mov	w0, #0x0                   	// #0
}
    400078c4:	d65f03c0 	ret
{
    400078c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400078cc:	910003fd 	mov	x29, sp
    400078d0:	f9000bf3 	str	x19, [sp, #16]
    400078d4:	aa0003f3 	mov	x19, x0
    400078d8:	940004df 	bl	40008c54 <strlen>
	for (size_t i = 0; i < str_len; i++) {
    400078dc:	92403c03 	and	x3, x0, #0xffff
    400078e0:	d2800002 	mov	x2, #0x0                   	// #0
    400078e4:	eb03005f 	cmp	x2, x3
    400078e8:	540000a3 	b.cc	400078fc <z_shell_has_wildcard+0x40>  // b.lo, b.ul, b.last
	return false;
    400078ec:	52800000 	mov	w0, #0x0                   	// #0
}
    400078f0:	f9400bf3 	ldr	x19, [sp, #16]
    400078f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400078f8:	d65f03c0 	ret
		if ((str[i] == '?') || (str[i] == '*')) {
    400078fc:	38626a60 	ldrb	w0, [x19, x2]
    40007900:	7100fc1f 	cmp	w0, #0x3f
    40007904:	1a9f17e1 	cset	w1, eq  // eq = none
    40007908:	7100a81f 	cmp	w0, #0x2a
    4000790c:	1a9f17e0 	cset	w0, eq  // eq = none
    40007910:	2a000020 	orr	w0, w1, w0
    40007914:	35fffee0 	cbnz	w0, 400078f0 <z_shell_has_wildcard+0x34>
	for (size_t i = 0; i < str_len; i++) {
    40007918:	91000442 	add	x2, x2, #0x1
    4000791c:	17fffff2 	b	400078e4 <z_shell_has_wildcard+0x28>

0000000040007920 <z_shell_wildcard_prepare>:

void z_shell_wildcard_prepare(const struct shell *shell)
{
    40007920:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	 *    buffer with all expanded commands is copied to Command buffer.
	 * 7. Deepest found handler is executed and all lower level commands,
	 *    including expanded commands, are passed as arguments.
	 */

	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    40007924:	d2802002 	mov	x2, #0x100                 	// #256
    40007928:	52800001 	mov	w1, #0x0                   	// #0
{
    4000792c:	910003fd 	mov	x29, sp
    40007930:	f9000bf3 	str	x19, [sp, #16]
    40007934:	aa0003f3 	mov	x19, x0
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    40007938:	f9400800 	ldr	x0, [x0, #16]
    4000793c:	91065800 	add	x0, x0, #0x196
    40007940:	94000510 	bl	40008d80 <memset>
	memcpy(shell->ctx->temp_buff,
    40007944:	f9400a60 	ldr	x0, [x19, #16]
    40007948:	91025801 	add	x1, x0, #0x96
    4000794c:	79412002 	ldrh	w2, [x0, #144]
    40007950:	91065800 	add	x0, x0, #0x196
    40007954:	94000503 	bl	40008d60 <memcpy>

	/* Function shell_spaces_trim must be used instead of shell_make_argv.
	 * At this point it is important to keep temp_buff as one string.
	 * It will allow to find wildcard commands easily with strstr function.
	 */
	z_shell_spaces_trim(shell->ctx->temp_buff);
    40007958:	f9400a60 	ldr	x0, [x19, #16]
    4000795c:	91065800 	add	x0, x0, #0x196
    40007960:	97fff96a 	bl	40005f08 <z_shell_spaces_trim>

	/* +1 for EOS*/
	shell->ctx->cmd_tmp_buff_len = z_shell_strlen(shell->ctx->temp_buff) + 1;
    40007964:	f9400a60 	ldr	x0, [x19, #16]
    40007968:	b1065800 	adds	x0, x0, #0x196
    4000796c:	54000120 	b.eq	40007990 <z_shell_wildcard_prepare+0x70>  // b.none
    40007970:	940004b9 	bl	40008c54 <strlen>
    40007974:	12003c00 	and	w0, w0, #0xffff
    40007978:	f9400a61 	ldr	x1, [x19, #16]
    4000797c:	11000400 	add	w0, w0, #0x1
}
    40007980:	f9400bf3 	ldr	x19, [sp, #16]
	shell->ctx->cmd_tmp_buff_len = z_shell_strlen(shell->ctx->temp_buff) + 1;
    40007984:	79012820 	strh	w0, [x1, #148]
}
    40007988:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000798c:	d65f03c0 	ret
    40007990:	52800000 	mov	w0, #0x0                   	// #0
    40007994:	17fffff9 	b	40007978 <z_shell_wildcard_prepare+0x58>

0000000040007998 <z_shell_wildcard_process>:


enum shell_wildcard_status z_shell_wildcard_process(const struct shell *shell,
					const struct shell_static_entry *cmd,
					const char *pattern)
{
    40007998:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    4000799c:	910003fd 	mov	x29, sp
    400079a0:	a90153f3 	stp	x19, x20, [sp, #16]
    400079a4:	a9025bf5 	stp	x21, x22, [sp, #32]
    400079a8:	a90363f7 	stp	x23, x24, [sp, #48]
    400079ac:	a9046bf9 	stp	x25, x26, [sp, #64]
    400079b0:	a90573fb 	stp	x27, x28, [sp, #80]
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
    400079b4:	b5000141 	cbnz	x1, 400079dc <z_shell_wildcard_process+0x44>
		return ret_val;
    400079b8:	52800073 	mov	w19, #0x3                   	// #3
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(shell, cmd, pattern);

	return ret_val;
}
    400079bc:	2a1303e0 	mov	w0, w19
    400079c0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400079c4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400079c8:	a94363f7 	ldp	x23, x24, [sp, #48]
    400079cc:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400079d0:	a94573fb 	ldp	x27, x28, [sp, #80]
    400079d4:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    400079d8:	d65f03c0 	ret
    400079dc:	aa0003f5 	mov	x21, x0
    400079e0:	aa0103f6 	mov	x22, x1
    400079e4:	aa0203f4 	mov	x20, x2
	if (!z_shell_has_wildcard(pattern)) {
    400079e8:	aa0203e0 	mov	x0, x2
    400079ec:	97ffffb4 	bl	400078bc <z_shell_has_wildcard>
    400079f0:	72001c1f 	tst	w0, #0xff
    400079f4:	54fffe20 	b.eq	400079b8 <z_shell_wildcard_process+0x20>  // b.none
	size_t cnt = 0;
    400079f8:	d2800018 	mov	x24, #0x0                   	// #0
	size_t cmd_idx = 0;
    400079fc:	d2800001 	mov	x1, #0x0                   	// #0
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
    40007a00:	52800053 	mov	w19, #0x2                   	// #2
	completion_addr[cmd_len] = ' ';
    40007a04:	5280041a 	mov	w26, #0x20                  	// #32
    40007a08:	1400001c 	b	40007a78 <z_shell_wildcard_process+0xe0>
    40007a0c:	52800013 	mov	w19, #0x0                   	// #0
    40007a10:	1400002c 	b	40007ac0 <z_shell_wildcard_process+0x128>
	completion_addr = strstr(buff, pattern);
    40007a14:	aa1403e1 	mov	x1, x20
    40007a18:	91065ae0 	add	x0, x23, #0x196
    40007a1c:	9400044b 	bl	40008b48 <strstr>
    40007a20:	aa0003fb 	mov	x27, x0
	if (!completion_addr) {
    40007a24:	b4000740 	cbz	x0, 40007b0c <z_shell_wildcard_process+0x174>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
    40007a28:	92403e79 	and	x25, x19, #0xffff
    40007a2c:	9400048a 	bl	40008c54 <strlen>
    40007a30:	92403c02 	and	x2, x0, #0xffff
    40007a34:	91000720 	add	x0, x25, #0x1
    40007a38:	91000442 	add	x2, x2, #0x1
    40007a3c:	aa1b03e1 	mov	x1, x27
    40007a40:	8b000360 	add	x0, x27, x0
    40007a44:	940004b8 	bl	40008d24 <memmove>
	memcpy(completion_addr, cmd, cmd_len);
    40007a48:	aa1903e2 	mov	x2, x25
    40007a4c:	aa1c03e1 	mov	x1, x28
    40007a50:	aa1b03e0 	mov	x0, x27
    40007a54:	940004c3 	bl	40008d60 <memcpy>
	completion_addr[cmd_len] = ' ';
    40007a58:	38396b7a 	strb	w26, [x27, x25]
			cnt++;
    40007a5c:	91000718 	add	x24, x24, #0x1
	*buff_len += cmd_len + 1; /* + 1 for space */
    40007a60:	79412ae0 	ldrh	w0, [x23, #148]
    40007a64:	0b000273 	add	w19, w19, w0
    40007a68:	11000673 	add	w19, w19, #0x1
    40007a6c:	79012af3 	strh	w19, [x23, #148]
			ret_val = command_add(shell->ctx->temp_buff,
    40007a70:	52800013 	mov	w19, #0x0                   	// #0
    40007a74:	f94037e1 	ldr	x1, [sp, #104]
	while ((entry = z_shell_cmd_get(cmd, cmd_idx++, &dloc)) != NULL) {
    40007a78:	91000420 	add	x0, x1, #0x1
    40007a7c:	9101e3e2 	add	x2, sp, #0x78
    40007a80:	f90037e0 	str	x0, [sp, #104]
    40007a84:	aa1603e0 	mov	x0, x22
    40007a88:	97fff8af 	bl	40005d44 <z_shell_cmd_get>
    40007a8c:	aa0003fb 	mov	x27, x0
    40007a90:	b4000300 	cbz	x0, 40007af0 <z_shell_wildcard_process+0x158>
		if (fnmatch(pattern, entry->syntax, 0) == 0) {
    40007a94:	f9400361 	ldr	x1, [x27]
    40007a98:	aa1403e0 	mov	x0, x20
    40007a9c:	52800002 	mov	w2, #0x0                   	// #0
    40007aa0:	97ffee0c 	bl	400032d0 <fnmatch>
    40007aa4:	35fffe80 	cbnz	w0, 40007a74 <z_shell_wildcard_process+0xdc>
			ret_val = command_add(shell->ctx->temp_buff,
    40007aa8:	f940037c 	ldr	x28, [x27]
    40007aac:	f9400ab7 	ldr	x23, [x21, #16]
    40007ab0:	b4fffafc 	cbz	x28, 40007a0c <z_shell_wildcard_process+0x74>
    40007ab4:	aa1c03e0 	mov	x0, x28
    40007ab8:	94000467 	bl	40008c54 <strlen>
    40007abc:	12003c13 	and	w19, w0, #0xffff
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
    40007ac0:	79412ae0 	ldrh	w0, [x23, #148]
    40007ac4:	11000400 	add	w0, w0, #0x1
    40007ac8:	0b130000 	add	w0, w0, w19
    40007acc:	7104001f 	cmp	w0, #0x100
    40007ad0:	54fffa2d 	b.le	40007a14 <z_shell_wildcard_process+0x7c>
			ret_val = command_add(shell->ctx->temp_buff,
    40007ad4:	52800033 	mov	w19, #0x1                   	// #1
				z_shell_fprintf(shell, SHELL_WARNING,
    40007ad8:	aa1403e3 	mov	x3, x20
    40007adc:	aa1503e0 	mov	x0, x21
    40007ae0:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007ae4:	911c7c42 	add	x2, x2, #0x71f
    40007ae8:	52800061 	mov	w1, #0x3                   	// #3
    40007aec:	97fffb3e 	bl	400067e4 <z_shell_fprintf>
	if (cnt > 0) {
    40007af0:	b4fff678 	cbz	x24, 400079bc <z_shell_wildcard_process+0x24>
		z_shell_pattern_remove(shell->ctx->temp_buff,
    40007af4:	f9400aa0 	ldr	x0, [x21, #16]
    40007af8:	aa1403e2 	mov	x2, x20
    40007afc:	91025001 	add	x1, x0, #0x94
    40007b00:	91065800 	add	x0, x0, #0x196
    40007b04:	97fff867 	bl	40005ca0 <z_shell_pattern_remove>
	return ret_val;
    40007b08:	17ffffad 	b	400079bc <z_shell_wildcard_process+0x24>
		return SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
    40007b0c:	52800053 	mov	w19, #0x2                   	// #2
    40007b10:	17fffff8 	b	40007af0 <z_shell_wildcard_process+0x158>

0000000040007b14 <z_shell_wildcard_finalize>:

void z_shell_wildcard_finalize(const struct shell *shell)
{
    40007b14:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40007b18:	910003fd 	mov	x29, sp
    40007b1c:	f9000bf3 	str	x19, [sp, #16]
    40007b20:	aa0003f3 	mov	x19, x0
	memcpy(shell->ctx->cmd_buff,
    40007b24:	f9400800 	ldr	x0, [x0, #16]
    40007b28:	91065801 	add	x1, x0, #0x196
    40007b2c:	91025800 	add	x0, x0, #0x96
    40007b30:	785fe002 	ldurh	w2, [x0, #-2]
    40007b34:	9400048b 	bl	40008d60 <memcpy>
	       shell->ctx->temp_buff,
	       shell->ctx->cmd_tmp_buff_len);
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
    40007b38:	f9400a60 	ldr	x0, [x19, #16]
}
    40007b3c:	f9400bf3 	ldr	x19, [sp, #16]
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
    40007b40:	79412801 	ldrh	w1, [x0, #148]
    40007b44:	79012001 	strh	w1, [x0, #144]
}
    40007b48:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40007b4c:	d65f03c0 	ret

0000000040007b50 <cmd_zvisor_delete>:
    shell_fprintf(shell, SHELL_NORMAL, "List a new vm success.\n");
    return 0;
}

static int cmd_zvisor_delete(const struct shell *shell, size_t argc, char **argv)
{
    40007b50:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    /* Delete vm code. */
    ARG_UNUSED(argc);
    ARG_UNUSED(argv);

    shell_fprintf(shell, SHELL_NORMAL, "Delete a new vm success.\n");
    40007b54:	52800101 	mov	w1, #0x8                   	// #8
    40007b58:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007b5c:	911dc442 	add	x2, x2, #0x771
{
    40007b60:	910003fd 	mov	x29, sp
    shell_fprintf(shell, SHELL_NORMAL, "Delete a new vm success.\n");
    40007b64:	97fff6fb 	bl	40005750 <shell_fprintf>
    return 0;
}
    40007b68:	52800000 	mov	w0, #0x0                   	// #0
    40007b6c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007b70:	d65f03c0 	ret

0000000040007b74 <cmd_zvisor_list>:
{
    40007b74:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    shell_fprintf(shell, SHELL_NORMAL, "List a new vm success.\n");
    40007b78:	52800101 	mov	w1, #0x8                   	// #8
    40007b7c:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007b80:	911e2c42 	add	x2, x2, #0x78b
{
    40007b84:	910003fd 	mov	x29, sp
    shell_fprintf(shell, SHELL_NORMAL, "List a new vm success.\n");
    40007b88:	97fff6f2 	bl	40005750 <shell_fprintf>
}
    40007b8c:	52800000 	mov	w0, #0x0                   	// #0
    40007b90:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007b94:	d65f03c0 	ret

0000000040007b98 <cmd_zvisor_update>:
{
    40007b98:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    shell_fprintf(shell, SHELL_NORMAL, "Update a new vm success.\n");
    40007b9c:	52800101 	mov	w1, #0x8                   	// #8
    40007ba0:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007ba4:	911e8c42 	add	x2, x2, #0x7a3
{
    40007ba8:	910003fd 	mov	x29, sp
    shell_fprintf(shell, SHELL_NORMAL, "Update a new vm success.\n");
    40007bac:	97fff6e9 	bl	40005750 <shell_fprintf>
}
    40007bb0:	52800000 	mov	w0, #0x0                   	// #0
    40007bb4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007bb8:	d65f03c0 	ret

0000000040007bbc <cmd_zvisor_run>:
{
    40007bbc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    shell_fprintf(shell, SHELL_NORMAL, "Run a new vm success.\n");
    40007bc0:	52800101 	mov	w1, #0x8                   	// #8
    40007bc4:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007bc8:	911ef442 	add	x2, x2, #0x7bd
{
    40007bcc:	910003fd 	mov	x29, sp
    shell_fprintf(shell, SHELL_NORMAL, "Run a new vm success.\n");
    40007bd0:	97fff6e0 	bl	40005750 <shell_fprintf>
}
    40007bd4:	52800000 	mov	w0, #0x0                   	// #0
    40007bd8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007bdc:	d65f03c0 	ret

0000000040007be0 <cmd_zvisor_set>:
{
    40007be0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    shell_fprintf(shell, SHELL_NORMAL, "Set a new vm success.\n");
    40007be4:	52800101 	mov	w1, #0x8                   	// #8
    40007be8:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007bec:	911f5042 	add	x2, x2, #0x7d4
{
    40007bf0:	910003fd 	mov	x29, sp
    shell_fprintf(shell, SHELL_NORMAL, "Set a new vm success.\n");
    40007bf4:	97fff6d7 	bl	40005750 <shell_fprintf>
}
    40007bf8:	52800000 	mov	w0, #0x0                   	// #0
    40007bfc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007c00:	d65f03c0 	ret

0000000040007c04 <cmd_zvisor_new>:
{
    40007c04:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    shell_fprintf(shell, SHELL_NORMAL, "Create a new vm success.\n");
    40007c08:	52800101 	mov	w1, #0x8                   	// #8
    40007c0c:	90000042 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40007c10:	911fac42 	add	x2, x2, #0x7eb
{
    40007c14:	910003fd 	mov	x29, sp
    shell_fprintf(shell, SHELL_NORMAL, "Create a new vm success.\n");
    40007c18:	97fff6ce 	bl	40005750 <shell_fprintf>
}
    40007c1c:	52800000 	mov	w0, #0x0                   	// #0
    40007c20:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007c24:	d65f03c0 	ret

0000000040007c28 <arch_cpu_idle>:
#ifdef CONFIG_TRACING
	stp	xzr, x30, [sp, #-16]!
	bl	sys_trace_idle
	ldp	xzr, x30, [sp], #16
#endif
	dsb	sy
    40007c28:	d5033f9f 	dsb	sy
	wfi
    40007c2c:	d503207f 	wfi
	msr	daifclr, #(DAIFCLR_IRQ_BIT)
    40007c30:	d50342ff 	msr	daifclr, #0x2
	ret
    40007c34:	d65f03c0 	ret

0000000040007c38 <z_arm64_fatal_error>:

	return false;
}

void z_arm64_fatal_error(unsigned int reason, z_arch_esf_t *esf)
{
    40007c38:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	uint64_t esr = 0;
	uint64_t elr = 0;
	uint64_t far = 0;
	uint64_t el;

	if (reason != K_ERR_SPURIOUS_IRQ) {
    40007c3c:	7100041f 	cmp	w0, #0x1
{
    40007c40:	910003fd 	mov	x29, sp
	if (reason != K_ERR_SPURIOUS_IRQ) {
    40007c44:	540000e0 	b.eq	40007c60 <z_arm64_fatal_error+0x28>  // b.none
MAKE_REG_HELPER(currentel);
    40007c48:	d5384242 	mrs	x2, currentel
		el = read_currentel();

		switch (GET_EL(el)) {
    40007c4c:	d3420c42 	ubfx	x2, x2, #2, #2
    40007c50:	f100045f 	cmp	x2, #0x1
    40007c54:	54000080 	b.eq	40007c64 <z_arm64_fatal_error+0x2c>  // b.none
    40007c58:	f1000c5f 	cmp	x2, #0x3
    40007c5c:	540000c0 	b.eq	40007c74 <z_arm64_fatal_error+0x3c>  // b.none
	if (esf != NULL) {
		esf_dump(esf);
	}
#endif /* CONFIG_EXCEPTION_DEBUG */

	z_fatal_error(reason, esf);
    40007c60:	94000781 	bl	40009a64 <z_fatal_error>
MAKE_REG_HELPER_EL123(esr)
    40007c64:	d5385202 	mrs	x2, esr_el1
MAKE_REG_HELPER_EL123(far)
    40007c68:	d5386002 	mrs	x2, far_el1
MAKE_REG_HELPER_EL123(elr)
    40007c6c:	d5384022 	mrs	x2, elr_el1
			break;
    40007c70:	17fffffc 	b	40007c60 <z_arm64_fatal_error+0x28>
MAKE_REG_HELPER_EL123(esr)
    40007c74:	d53e5202 	mrs	x2, esr_el3
MAKE_REG_HELPER_EL123(far)
    40007c78:	d53e6002 	mrs	x2, far_el3
MAKE_REG_HELPER_EL123(elr)
    40007c7c:	d53e4022 	mrs	x2, elr_el3
			break;
    40007c80:	17fffff8 	b	40007c60 <z_arm64_fatal_error+0x28>

0000000040007c84 <z_arm64_do_kernel_oops>:
 * (e.g. kernel oops, panic, etc.).
 *
 * @param esf exception frame
 */
void z_arm64_do_kernel_oops(z_arch_esf_t *esf)
{
    40007c84:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40007c88:	aa0003e1 	mov	x1, x0
    40007c8c:	910003fd 	mov	x29, sp
		reason != K_ERR_STACK_CHK_FAIL) {
		reason = K_ERR_KERNEL_OOPS;
	}
#endif

	z_arm64_fatal_error(reason, esf);
    40007c90:	b9404000 	ldr	w0, [x0, #64]
    40007c94:	97ffffe9 	bl	40007c38 <z_arm64_fatal_error>

0000000040007c98 <z_arm64_interrupt_init>:
{
#ifdef CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER
	/* Invoke SoC-specific interrupt controller initialisation */
	z_soc_irq_init();
#endif
}
    40007c98:	d65f03c0 	ret

0000000040007c9c <arch_irq_enable>:
 * `include/arch/arm64/irq.h`.
 */

void arch_irq_enable(unsigned int irq)
{
	arm_gic_irq_enable(irq);
    40007c9c:	14000553 	b	400091e8 <arm_gic_irq_enable>

0000000040007ca0 <z_arm64_irq_priority_set>:
	return arm_gic_irq_is_enabled(irq);
}

void z_arm64_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	arm_gic_irq_set_priority(irq, prio, flags);
    40007ca0:	14000523 	b	4000912c <arm_gic_irq_set_priority>

0000000040007ca4 <z_irq_spurious>:

void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm64_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    40007ca4:	d2800001 	mov	x1, #0x0                   	// #0
    40007ca8:	52800020 	mov	w0, #0x1                   	// #1
    40007cac:	17ffffe3 	b	40007c38 <z_arm64_fatal_error>

0000000040007cb0 <z_arm64_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm64_prep_c(void)
{
    40007cb0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER(tpidrro_el0);
    40007cb4:	f0000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    40007cb8:	91094000 	add	x0, x0, #0x250
    40007cbc:	910003fd 	mov	x29, sp
    40007cc0:	d51bd060 	msr	tpidrro_el0, x0
	uint64_t *p = (uint64_t *)__bss_start;
    40007cc4:	b0000040 	adrp	x0, 40010000 <__aarch64_have_lse_atomics>
    40007cc8:	91000000 	add	x0, x0, #0x0
	while (p < end) {
    40007ccc:	f00002c1 	adrp	x1, 40062000 <z_page_frames+0x47bdf>
    40007cd0:	91109021 	add	x1, x1, #0x424
    40007cd4:	eb01001f 	cmp	x0, x1
    40007cd8:	540000a3 	b.cc	40007cec <z_arm64_prep_c+0x3c>  // b.lo, b.ul, b.last

	z_arm64_bss_zero();
#ifdef CONFIG_XIP
	z_data_copy();
#endif
	z_arm64_mm_init(true);
    40007cdc:	52800020 	mov	w0, #0x1                   	// #1
    40007ce0:	94000223 	bl	4000856c <z_arm64_mm_init>
	z_arm64_interrupt_init();
    40007ce4:	97ffffed 	bl	40007c98 <z_arm64_interrupt_init>
	z_cstart();
    40007ce8:	940007b5 	bl	40009bbc <z_cstart>
		*p++ = 0U;
    40007cec:	f800841f 	str	xzr, [x0], #8
    40007cf0:	17fffff9 	b	40007cd4 <z_arm64_prep_c+0x24>

0000000040007cf4 <z_arm64_el3_plat_prep_c>:
	ret
    40007cf4:	d65f03c0 	ret

0000000040007cf8 <z_arm64_el2_plat_prep_c>:
	ret
    40007cf8:	d65f03c0 	ret

0000000040007cfc <z_arm64_el1_plat_prep_c>:
	ret
    40007cfc:	d65f03c0 	ret

0000000040007d00 <el3_get_next_el>:
MAKE_REG_HELPER(id_aa64pfr0_el1);
    40007d00:	d5380400 	mrs	x0, id_aa64pfr0_el1
	EL3_TO_EL1_SKIP_EL2
};

static inline enum el3_next_el el3_get_next_el(void)
{
	if (!is_el_implemented(2)) {
    40007d04:	f2780c1f 	tst	x0, #0xf00
    40007d08:	540000c0 	b.eq	40007d20 <el3_get_next_el+0x20>  // b.none
    40007d0c:	d5380400 	mrs	x0, id_aa64pfr0_el1
		 * implemented and the value of the SCR_EL3.NS bit is 0 if
		 * ARMv8.4-SecEL2 is not implemented" (D1.11.2 from ARM DDI 0487E.a)
		 */
		return EL3_TO_EL1_SKIP_EL2;
	} else {
		return EL3_TO_EL2;
    40007d10:	f25c0c1f 	tst	x0, #0xf000000000
    40007d14:	1a9f17e0 	cset	w0, eq  // eq = none
    40007d18:	531f7800 	lsl	w0, w0, #1
	}
}
    40007d1c:	d65f03c0 	ret
		return EL3_TO_EL1_NO_EL2;
    40007d20:	52800020 	mov	w0, #0x1                   	// #1
    40007d24:	17fffffe 	b	40007d1c <el3_get_next_el+0x1c>

0000000040007d28 <z_arm64_el_highest_plat_init>:
}
    40007d28:	d65f03c0 	ret

0000000040007d2c <z_arm64_el2_plat_init>:
    40007d2c:	d65f03c0 	ret

0000000040007d30 <z_arm64_el1_plat_init>:
    40007d30:	d65f03c0 	ret

0000000040007d34 <z_arm64_el_highest_init>:
{
    40007d34:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40007d38:	910003fd 	mov	x29, sp
    40007d3c:	d5380400 	mrs	x0, id_aa64pfr0_el1
static inline bool is_el_highest_implemented(void)
{
	uint32_t el_highest;
	uint32_t curr_el;

	el_highest = read_id_aa64pfr0_el1() & 0xFFFF;
    40007d40:	12003c00 	and	w0, w0, #0xffff
	el_highest = (31U - __builtin_clz(el_highest)) / 4;
    40007d44:	5ac01000 	clz	w0, w0
MAKE_REG_HELPER(currentel);
    40007d48:	d5384241 	mrs	x1, currentel
	el_highest = (31U - __builtin_clz(el_highest)) / 4;
    40007d4c:	528003e2 	mov	w2, #0x1f                  	// #31
    40007d50:	4b000040 	sub	w0, w2, w0

	curr_el = GET_EL(read_currentel());
    40007d54:	53020c21 	ubfx	w1, w1, #2, #2

	if (curr_el < el_highest)
    40007d58:	6b40083f 	cmp	w1, w0, lsr #2
    40007d5c:	54000083 	b.cc	40007d6c <z_arm64_el_highest_init+0x38>  // b.lo, b.ul, b.last
MAKE_REG_HELPER(cntfrq_el0);
    40007d60:	d2959400 	mov	x0, #0xaca0                	// #44192
    40007d64:	f2a07720 	movk	x0, #0x3b9, lsl #16
    40007d68:	d51be000 	msr	cntfrq_el0, x0
	z_arm64_el_highest_plat_init();
    40007d6c:	97ffffef 	bl	40007d28 <z_arm64_el_highest_plat_init>
	isb();
    40007d70:	d5033fdf 	isb
}
    40007d74:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007d78:	d65f03c0 	ret

0000000040007d7c <z_arm64_el2_init>:
		z_arm64_el2_init();
	}
}

void z_arm64_el2_init(void)
{
    40007d7c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40007d80:	910003fd 	mov	x29, sp
MAKE_REG_HELPER_EL123(sctlr)
    40007d84:	d53c1000 	mrs	x0, sctlr_el2
	uint64_t reg;

	reg = read_sctlr_el2();
	reg |= (SCTLR_EL2_RES1 |	/* RES1 */
    40007d88:	d2830701 	mov	x1, #0x1838                	// #6200
    40007d8c:	f2a618a1 	movk	x1, #0x30c5, lsl #16
    40007d90:	aa010000 	orr	x0, x0, x1
    40007d94:	d51c1000 	msr	sctlr_el2, x0
MAKE_REG_HELPER(hcr_el2);
    40007d98:	d53c1100 	mrs	x0, hcr_el2
		SCTLR_I_BIT |		/* Enable i-cache */
		SCTLR_SA_BIT);		/* Enable SP alignment check */
	write_sctlr_el2(reg);

	reg = read_hcr_el2();
	reg |= HCR_RW_BIT;		/* EL1 Execution state is AArch64 */
    40007d9c:	b2610000 	orr	x0, x0, #0x80000000
    40007da0:	d51c1100 	msr	hcr_el2, x0
MAKE_REG_HELPER_EL123(cptr)
    40007da4:	d2865fe0 	mov	x0, #0x32ff                	// #13055
    40007da8:	d51c1140 	msr	cptr_el2, x0
MAKE_REG_HELPER(cntvoff_el2);
    40007dac:	d51ce07f 	msr	cntvoff_el2, xzr
MAKE_REG_HELPER(cnthctl_el2);
    40007db0:	d51ce11f 	msr	cnthctl_el2, xzr
MAKE_REG_HELPER(cnthp_ctl_el2);
    40007db4:	d51ce23f 	msr	cnthp_ctl_el2, xzr
	/*
	 * Enable this if/when we use the hypervisor timer.
	 * write_cnthp_cval_el2(~(uint64_t)0);
	 */

	z_arm64_el2_plat_init();
    40007db8:	97ffffdd 	bl	40007d2c <z_arm64_el2_plat_init>

	isb();
    40007dbc:	d5033fdf 	isb
}
    40007dc0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007dc4:	d65f03c0 	ret

0000000040007dc8 <z_arm64_el3_init>:
{
    40007dc8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER_EL123(vbar)
    40007dcc:	b0ffffc0 	adrp	x0, 40000000 <__text_region_start>
    40007dd0:	91200000 	add	x0, x0, #0x800
    40007dd4:	910003fd 	mov	x29, sp
    40007dd8:	d51ec000 	msr	vbar_el3, x0
	isb();
    40007ddc:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(cptr)
    40007de0:	d2800000 	mov	x0, #0x0                   	// #0
    40007de4:	d51e1140 	msr	cptr_el3, x0
MAKE_REG_HELPER(scr_el3);
    40007de8:	d281b600 	mov	x0, #0xdb0                 	// #3504
    40007dec:	d51e1100 	msr	scr_el3, x0
	reg = read_sysreg(ICC_SRE_EL3);
    40007df0:	d53ecca0 	mrs	x0, s3_6_c12_c12_5
	write_sysreg(reg, ICC_SRE_EL3);
    40007df4:	d2800120 	mov	x0, #0x9                   	// #9
    40007df8:	d51ecca0 	msr	s3_6_c12_c12_5, x0
	z_arm64_el3_plat_init();
    40007dfc:	97ffed3f 	bl	400032f8 <z_arm64_el3_plat_init>
	isb();
    40007e00:	d5033fdf 	isb
	if (el3_get_next_el() == EL3_TO_EL1_SKIP_EL2) {
    40007e04:	97ffffbf 	bl	40007d00 <el3_get_next_el>
    40007e08:	7100081f 	cmp	w0, #0x2
    40007e0c:	54000061 	b.ne	40007e18 <z_arm64_el3_init+0x50>  // b.any
}
    40007e10:	a8c17bfd 	ldp	x29, x30, [sp], #16
		z_arm64_el2_init();
    40007e14:	17ffffda 	b	40007d7c <z_arm64_el2_init>
}
    40007e18:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007e1c:	d65f03c0 	ret

0000000040007e20 <z_arm64_el1_init>:

void z_arm64_el1_init(void)
{
    40007e20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER_EL123(vbar)
    40007e24:	b0ffffc0 	adrp	x0, 40000000 <__text_region_start>
    40007e28:	91200000 	add	x0, x0, #0x800
    40007e2c:	910003fd 	mov	x29, sp
    40007e30:	d518c000 	msr	vbar_el1, x0
	uint64_t reg;

	/* Setup vector table */
	write_vbar_el1((uint64_t)_vector_table);
	isb();
    40007e34:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(cpacr)
    40007e38:	d2a00600 	mov	x0, #0x300000              	// #3145728
    40007e3c:	d5181040 	msr	cpacr_el1, x0
MAKE_REG_HELPER_EL123(sctlr)
    40007e40:	d5381000 	mrs	x0, sctlr_el1
	reg |= CPACR_EL1_FPEN_NOTRAP;	/* Do not trap NEON/SIMD/FP initially */
					/* TODO: CONFIG_FLOAT_*_FORBIDDEN */
	write_cpacr_el1(reg);

	reg = read_sctlr_el1();
	reg |= (SCTLR_EL1_RES1 |	/* RES1 */
    40007e44:	d2830101 	mov	x1, #0x1808                	// #6152
    40007e48:	f2a61a01 	movk	x1, #0x30d0, lsl #16
    40007e4c:	aa010000 	orr	x0, x0, x1
    40007e50:	d5181000 	msr	sctlr_el1, x0
MAKE_REG_HELPER(cntv_cval_el0)
    40007e54:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    40007e58:	d51be340 	msr	cntv_cval_el0, x0
	 * Enable these if/when we use the corresponding timers.
	 * write_cntp_cval_el0(~(uint64_t)0);
	 * write_cntps_cval_el1(~(uint64_t)0);
	 */

	z_arm64_el1_plat_init();
    40007e5c:	97ffffb5 	bl	40007d30 <z_arm64_el1_plat_init>

	isb();
    40007e60:	d5033fdf 	isb
}
    40007e64:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007e68:	d65f03c0 	ret

0000000040007e6c <z_arm64_el3_get_next_el>:

void z_arm64_el3_get_next_el(uint64_t switch_addr)
{
    40007e6c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40007e70:	910003fd 	mov	x29, sp
MAKE_REG_HELPER_EL123(elr)
    40007e74:	d51e4020 	msr	elr_el3, x0
	write_elr_el3(switch_addr);

	/* Mask the DAIF */
	spsr = SPSR_DAIF_MASK;

	if (el3_get_next_el() == EL3_TO_EL2) {
    40007e78:	97ffffa2 	bl	40007d00 <el3_get_next_el>
		/* Dropping into EL2 */
		spsr |= SPSR_MODE_EL2T;
	} else {
		/* Dropping into EL1 */
		spsr |= SPSR_MODE_EL1T;
    40007e7c:	7100001f 	cmp	w0, #0x0
    40007e80:	d2807881 	mov	x1, #0x3c4                 	// #964
    40007e84:	d2807900 	mov	x0, #0x3c8                 	// #968
    40007e88:	9a810000 	csel	x0, x0, x1, eq  // eq = none
MAKE_REG_HELPER_EL123(spsr)
    40007e8c:	d51e4000 	msr	spsr_el3, x0
	}

	write_spsr_el3(spsr);
}
    40007e90:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007e94:	d65f03c0 	ret

0000000040007e98 <z_arm64_context_switch>:

GTEXT(z_arm64_context_switch)
SECTION_FUNC(TEXT, z_arm64_context_switch)

	/* Save the current SP_EL0 */
	mrs	x4, sp_el0
    40007e98:	d5384104 	mrs	x4, sp_el0

	stp	x19, x20, [x1, #_thread_offset_to_callee_saved_x19_x20]
    40007e9c:	a904d033 	stp	x19, x20, [x1, #72]
	stp	x21, x22, [x1, #_thread_offset_to_callee_saved_x21_x22]
    40007ea0:	a905d835 	stp	x21, x22, [x1, #88]
	stp	x23, x24, [x1, #_thread_offset_to_callee_saved_x23_x24]
    40007ea4:	a906e037 	stp	x23, x24, [x1, #104]
	stp	x25, x26, [x1, #_thread_offset_to_callee_saved_x25_x26]
    40007ea8:	a907e839 	stp	x25, x26, [x1, #120]
	stp	x27, x28, [x1, #_thread_offset_to_callee_saved_x27_x28]
    40007eac:	a908f03b 	stp	x27, x28, [x1, #136]
	stp	x29, x4,  [x1, #_thread_offset_to_callee_saved_x29_sp_el0]
    40007eb0:	a909903d 	stp	x29, x4, [x1, #152]

	/* Save the current SP_ELx */
	mov	x4, sp
    40007eb4:	910003e4 	mov	x4, sp
	str	x4, [x1, #_thread_offset_to_callee_saved_sp_elx]
    40007eb8:	f9005424 	str	x4, [x1, #168]

	/* save current thread's exception depth */
	mrs	x4, tpidrro_el0
    40007ebc:	d53bd064 	mrs	x4, tpidrro_el0
	lsr	x2, x4, #TPIDRROEL0_EXC_SHIFT
    40007ec0:	d378fc82 	lsr	x2, x4, #56
	strb	w2, [x1, #_thread_offset_to_exception_depth]
    40007ec4:	390d8022 	strb	w2, [x1, #864]

	/* retrieve next thread's exception depth */
	ldrb	w2, [x0, #_thread_offset_to_exception_depth]
    40007ec8:	394d8002 	ldrb	w2, [x0, #864]
	bic	x4, x4, #TPIDRROEL0_EXC_DEPTH
    40007ecc:	9240dc84 	and	x4, x4, #0xffffffffffffff
	orr	x4, x4, x2, lsl #TPIDRROEL0_EXC_SHIFT
    40007ed0:	aa02e084 	orr	x4, x4, x2, lsl #56
	msr	tpidrro_el0, x4
    40007ed4:	d51bd064 	msr	tpidrro_el0, x4
	 * thread variables with offsets added by toolchain.
	 */
	msr	tpidr_el0, x2
#endif

	ldp	x19, x20, [x0, #_thread_offset_to_callee_saved_x19_x20]
    40007ed8:	a944d013 	ldp	x19, x20, [x0, #72]
	ldp	x21, x22, [x0, #_thread_offset_to_callee_saved_x21_x22]
    40007edc:	a945d815 	ldp	x21, x22, [x0, #88]
	ldp	x23, x24, [x0, #_thread_offset_to_callee_saved_x23_x24]
    40007ee0:	a946e017 	ldp	x23, x24, [x0, #104]
	ldp	x25, x26, [x0, #_thread_offset_to_callee_saved_x25_x26]
    40007ee4:	a947e819 	ldp	x25, x26, [x0, #120]
	ldp	x27, x28, [x0, #_thread_offset_to_callee_saved_x27_x28]
    40007ee8:	a948f01b 	ldp	x27, x28, [x0, #136]
	ldp	x29, x4,  [x0, #_thread_offset_to_callee_saved_x29_sp_el0]
    40007eec:	a949901d 	ldp	x29, x4, [x0, #152]

	/* Restore SP_EL0 */
	msr	sp_el0, x4
    40007ef0:	d5184104 	msr	sp_el0, x4

	/* Restore SP_EL1 */
	ldr	x4, [x0, #_thread_offset_to_callee_saved_sp_elx]
    40007ef4:	f9405404 	ldr	x4, [x0, #168]
	mov	sp, x4
    40007ef8:	9100009f 	mov	sp, x4
	bl	z_thread_mark_switched_in
	ldp	xzr, x30, [sp], #16
#endif

	/* Return to z_arm64_sync_exc() or _isr_wrapper() */
	ret
    40007efc:	d65f03c0 	ret

0000000040007f00 <z_arm64_sync_exc>:
 */

GTEXT(z_arm64_sync_exc)
SECTION_FUNC(TEXT, z_arm64_sync_exc)

	mrs	x0, esr_el1
    40007f00:	d5385200 	mrs	x0, esr_el1
	lsr	x1, x0, #26
    40007f04:	d35afc01 	lsr	x1, x0, #26

#ifdef CONFIG_FPU_SHARING
	cmp	x1, #0x07 /*Access to SIMD or floating-point */
    40007f08:	f1001c3f 	cmp	x1, #0x7
	bne	1f
    40007f0c:	54000081 	b.ne	40007f1c <z_arm64_sync_exc+0x1c>  // b.any
	mov	x0, sp
    40007f10:	910003e0 	mov	x0, sp
	bl	z_arm64_fpu_trap
    40007f14:	94000048 	bl	40008034 <z_arm64_fpu_trap>
	b	z_arm64_exit_exc_fpu_done
    40007f18:	1400002c 	b	40007fc8 <z_arm64_exit_exc_fpu_done>
1:
#endif

	cmp	x1, #0x15 /* 0x15 = SVC */
    40007f1c:	f100543f 	cmp	x1, #0x15
	bne	inv
    40007f20:	540001a1 	b.ne	40007f54 <inv>  // b.any

	/* Demux the SVC call */
	and	x1, x0, #0xff
    40007f24:	92401c01 	and	x1, x0, #0xff

	cmp	x1, #_SVC_CALL_CONTEXT_SWITCH
    40007f28:	f100003f 	cmp	x1, #0x0
	beq	context_switch
    40007f2c:	540000c0 	b.eq	40007f44 <context_switch>  // b.none

	cmp	x1, #_SVC_CALL_RUNTIME_EXCEPT
    40007f30:	f100083f 	cmp	x1, #0x2
	beq	oops
    40007f34:	54000040 	b.eq	40007f3c <oops>  // b.none

	/* --(_kernel->nested) */
	dec_nest_counter x0, x1
	b	z_arm64_exit_exc
#endif
	b	inv
    40007f38:	14000007 	b	40007f54 <inv>

0000000040007f3c <oops>:

oops:
	mov	x0, sp
    40007f3c:	910003e0 	mov	x0, sp
	b	z_arm64_do_kernel_oops
    40007f40:	17ffff51 	b	40007c84 <z_arm64_do_kernel_oops>

0000000040007f44 <context_switch>:
	 * Retrieve x0 and x1 from the stack:
	 *
	 *  - x0 = new_thread->switch_handle = switch_to thread
	 *  - x1 = &old_thread->switch_handle = current thread
	 */
	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    40007f44:	a94007e0 	ldp	x0, x1, [sp]

	/* Get old thread from x1 */
	sub	x1, x1, ___thread_t_switch_handle_OFFSET
    40007f48:	d1050021 	sub	x1, x1, #0x140

	/* Switch thread */
	bl	z_arm64_context_switch
    40007f4c:	97ffffd3 	bl	40007e98 <z_arm64_context_switch>
	b	z_arm64_exit_exc
    40007f50:	1400001d 	b	40007fc4 <z_arm64_exit_exc>

0000000040007f54 <inv>:

inv:
	mov	x0, #0 /* K_ERR_CPU_EXCEPTION */
    40007f54:	d2800000 	mov	x0, #0x0                   	// #0
	mov	x1, sp
    40007f58:	910003e1 	mov	x1, sp
	bl	z_arm64_fatal_error
    40007f5c:	97ffff37 	bl	40007c38 <z_arm64_fatal_error>

	/* Return here only in case of recoverable error */
	b	z_arm64_exit_exc
    40007f60:	14000019 	b	40007fc4 <z_arm64_exit_exc>

0000000040007f64 <z_arm64_call_svc>:

GTEXT(z_arm64_call_svc)
SECTION_FUNC(TEXT, z_arm64_call_svc)
	svc	#_SVC_CALL_CONTEXT_SWITCH
    40007f64:	d4000001 	svc	#0x0
	ret
    40007f68:	d65f03c0 	ret

0000000040007f6c <arch_new_thread>:
	 * dropping into EL0.
	 */

	pInitCtx = Z_STACK_PTR_TO_FRAME(struct __esf, stack_ptr);

	pInitCtx->x0 = (uint64_t)entry;
    40007f6c:	d102c041 	sub	x1, x2, #0xb0
	pInitCtx->x1 = (uint64_t)p1;
    40007f70:	a9351043 	stp	x3, x4, [x2, #-176]
	pInitCtx->x2 = (uint64_t)p2;
	pInitCtx->x3 = (uint64_t)p3;
    40007f74:	a9361845 	stp	x5, x6, [x2, #-160]
		pInitCtx->elr = (uint64_t)arch_user_mode_enter;
	} else {
		pInitCtx->elr = (uint64_t)z_thread_entry;
	}
#else
	pInitCtx->elr = (uint64_t)z_thread_entry;
    40007f78:	d0ffffc2 	adrp	x2, 40001000 <__aarch64_ldset8_acq_rel+0x10>
    40007f7c:	910f5042 	add	x2, x2, #0x3d4
    40007f80:	f9005422 	str	x2, [x1, #168]
#endif
	/* Keep using SP_EL1 */
	pInitCtx->spsr = SPSR_MODE_EL1H | DAIF_FIQ_BIT;
    40007f84:	d28008a2 	mov	x2, #0x45                  	// #69
    40007f88:	f9005022 	str	x2, [x1, #160]

	/* thread birth happens through the exception return path */
	thread->arch.exception_depth = 1;
    40007f8c:	52800022 	mov	w2, #0x1                   	// #1
	 * We are saving SP_EL1 to pop out entry and parameters when going
	 * through z_arm64_exit_exc(). For user threads the definitive location
	 * of SP_EL1 will be set implicitly when going through
	 * z_arm64_userspace_enter() (see comments there)
	 */
	thread->callee_saved.sp_elx = (uint64_t)pInitCtx;
    40007f90:	f9005401 	str	x1, [x0, #168]

	thread->switch_handle = thread;
    40007f94:	f900a000 	str	x0, [x0, #320]
	thread->arch.exception_depth = 1;
    40007f98:	390d8002 	strb	w2, [x0, #864]
}
    40007f9c:	d65f03c0 	ret

0000000040007fa0 <z_arch_get_next_switch_handle>:

void *z_arch_get_next_switch_handle(struct k_thread **old_thread)
{
    40007fa0:	aa0003e1 	mov	x1, x0
	*old_thread =  _current;
    40007fa4:	f0000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    40007fa8:	f9413000 	ldr	x0, [x0, #608]
    40007fac:	f9000020 	str	x0, [x1]

	return z_get_next_switch_handle(*old_thread);
    40007fb0:	140009c3 	b	4000a6bc <z_get_next_switch_handle>

0000000040007fb4 <z_arm64_serror>:

GTEXT(z_arm64_serror)
SECTION_FUNC(TEXT, z_arm64_serror)

	mov	x1, sp
    40007fb4:	910003e1 	mov	x1, sp
	mov	x0, #0 /* K_ERR_CPU_EXCEPTION */
    40007fb8:	d2800000 	mov	x0, #0x0                   	// #0

	bl	z_arm64_fatal_error
    40007fbc:	97ffff1f 	bl	40007c38 <z_arm64_fatal_error>
	/* Return here only in case of recoverable error */
	b	z_arm64_exit_exc
    40007fc0:	14000001 	b	40007fc4 <z_arm64_exit_exc>

0000000040007fc4 <z_arm64_exit_exc>:

GTEXT(z_arm64_exit_exc)
SECTION_FUNC(TEXT, z_arm64_exit_exc)

#ifdef CONFIG_FPU_SHARING
	bl	z_arm64_fpu_exit_exc
    40007fc4:	94000055 	bl	40008118 <z_arm64_fpu_exit_exc>

0000000040007fc8 <z_arm64_exit_exc_fpu_done>:

 GTEXT(z_arm64_exit_exc_fpu_done)
 z_arm64_exit_exc_fpu_done:
#endif

	ldp	x0, x1, [sp, ___esf_t_spsr_elr_OFFSET]
    40007fc8:	a94a07e0 	ldp	x0, x1, [sp, #160]
	msr	spsr_el1, x0
    40007fcc:	d5184000 	msr	spsr_el1, x0
	msr	elr_el1, x1
    40007fd0:	d5184021 	msr	elr_el1, x1

	/* Restore the kernel/user mode flag and decrement exception depth */
	tst	x0, #SPSR_MODE_MASK	/* EL0 == 0 */
    40007fd4:	f2400c1f 	tst	x0, #0xf
	mrs	x0, tpidrro_el0
    40007fd8:	d53bd060 	mrs	x0, tpidrro_el0
	mov	x1, #TPIDRROEL0_EXC_UNIT
    40007fdc:	d2e02001 	mov	x1, #0x100000000000000     	// #72057594037927936
	orr	x2, x0, #TPIDRROEL0_IN_EL0
    40007fe0:	b2400002 	orr	x2, x0, #0x1
	csel	x0, x2, x0, eq
    40007fe4:	9a800040 	csel	x0, x2, x0, eq  // eq = none
	sub	x0, x0, x1
    40007fe8:	cb010000 	sub	x0, x0, x1
	msr	tpidrro_el0, x0
    40007fec:	d51bd060 	msr	tpidrro_el0, x0

	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    40007ff0:	a94007e0 	ldp	x0, x1, [sp]
	ldp	x2, x3, [sp, ___esf_t_x2_x3_OFFSET]
    40007ff4:	a9410fe2 	ldp	x2, x3, [sp, #16]
	ldp	x4, x5, [sp, ___esf_t_x4_x5_OFFSET]
    40007ff8:	a94217e4 	ldp	x4, x5, [sp, #32]
	ldp	x6, x7, [sp, ___esf_t_x6_x7_OFFSET]
    40007ffc:	a9431fe6 	ldp	x6, x7, [sp, #48]
	ldp	x8, x9, [sp, ___esf_t_x8_x9_OFFSET]
    40008000:	a94427e8 	ldp	x8, x9, [sp, #64]
	ldp	x10, x11, [sp, ___esf_t_x10_x11_OFFSET]
    40008004:	a9452fea 	ldp	x10, x11, [sp, #80]
	ldp	x12, x13, [sp, ___esf_t_x12_x13_OFFSET]
    40008008:	a94637ec 	ldp	x12, x13, [sp, #96]
	ldp	x14, x15, [sp, ___esf_t_x14_x15_OFFSET]
    4000800c:	a9473fee 	ldp	x14, x15, [sp, #112]
	ldp	x16, x17, [sp, ___esf_t_x16_x17_OFFSET]
    40008010:	a94847f0 	ldp	x16, x17, [sp, #128]
	ldp	x18, x30, [sp, ___esf_t_x18_x30_OFFSET]
    40008014:	a9497bf2 	ldp	x18, x30, [sp, #144]

	add	sp, sp, ___esf_t_SIZEOF
    40008018:	9102c3ff 	add	sp, sp, #0xb0
	 * - The address of ret in z_arm64_call_svc()
	 * - The address of the next instruction at the time of the IRQ when the
	 *   thread was switched out.
	 * - The address of z_thread_entry() for new threads (see thread.c).
	 */
	eret
    4000801c:	d69f03e0 	eret

0000000040008020 <z_arm64_fpu_enter_exc>:
MAKE_REG_HELPER_EL123(cpacr)
    40008020:	d5381040 	mrs	x0, cpacr_el1
void z_arm64_fpu_enter_exc(void)
{
	__ASSERT(read_daif() & DAIF_IRQ_BIT, "must be called with IRQs disabled");

	/* always deny FPU access whenever an exception is entered */
	write_cpacr_el1(read_cpacr_el1() & ~CPACR_EL1_FPEN_NOTRAP);
    40008024:	926af400 	and	x0, x0, #0xffffffffffcfffff
    40008028:	d5181040 	msr	cpacr_el1, x0
	isb();
    4000802c:	d5033fdf 	isb
}
    40008030:	d65f03c0 	ret

0000000040008034 <z_arm64_fpu_trap>:
 * there is nothing to save/restore for that context... as long as we
 * don't get interrupted that is. To ensure that we mask interrupts to
 * the triggering exception context.
 */
void z_arm64_fpu_trap(z_arch_esf_t *esf)
{
    40008034:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40008038:	910003fd 	mov	x29, sp
    4000803c:	a90153f3 	stp	x19, x20, [sp, #16]
    40008040:	aa0003f3 	mov	x19, x0
MAKE_REG_HELPER(tpidrro_el0);
    40008044:	d53bd060 	mrs	x0, tpidrro_el0
	return (_cpu_t *)(read_tpidrro_el0() & TPIDRROEL0_CURR_CPU);
}

static ALWAYS_INLINE int arch_exception_depth(void)
{
	return (read_tpidrro_el0() & TPIDRROEL0_EXC_DEPTH) / TPIDRROEL0_EXC_UNIT;
    40008048:	d378fc00 	lsr	x0, x0, #56
	if (arch_exception_depth() <= 1) {
    4000804c:	f100041f 	cmp	x0, #0x1
    40008050:	54000309 	b.ls	400080b0 <z_arm64_fpu_trap+0x7c>  // b.plast
	uint32_t *pc = (uint32_t *)esf->elr;
    40008054:	f9405662 	ldr	x2, [x19, #168]
	uintptr_t sp = (uintptr_t)esf + sizeof(*esf);
    40008058:	9102c263 	add	x3, x19, #0xb0
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    4000805c:	52807f04 	mov	w4, #0x3f8                 	// #1016
    40008060:	72bff804 	movk	w4, #0xffc0, lsl #16
	uint32_t *pc = (uint32_t *)esf->elr;
    40008064:	aa0203e0 	mov	x0, x2
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    40008068:	52807c05 	mov	w5, #0x3e0                 	// #992
    4000806c:	72a7b005 	movk	w5, #0x3d80, lsl #16
		uint32_t insn = *pc;
    40008070:	b9400001 	ldr	w1, [x0]
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    40008074:	0a040026 	and	w6, w1, w4
    40008078:	6b0500df 	cmp	w6, w5
    4000807c:	540000e1 	b.ne	40008098 <z_arm64_fpu_trap+0x64>  // b.any
		uint32_t pimm = (insn >> 10) & 0xfff;
    40008080:	d34a5421 	ubfx	x1, x1, #10, #12
		pc++;
    40008084:	91001000 	add	x0, x0, #0x4
		*(__int128 *)(sp + pimm * 16) = 0;
    40008088:	d37c2c21 	ubfiz	x1, x1, #4, #12
    4000808c:	8b030021 	add	x1, x1, x3
    40008090:	a9007c3f 	stp	xzr, xzr, [x1]
	for (;;) {
    40008094:	17fffff7 	b	40008070 <z_arm64_fpu_trap+0x3c>
	if (pc != (uint32_t *)esf->elr) {
    40008098:	eb00005f 	cmp	x2, x0
    4000809c:	540000a0 	b.eq	400080b0 <z_arm64_fpu_trap+0x7c>  // b.none
		esf->elr = (uintptr_t)pc;
    400080a0:	f9005660 	str	x0, [x19, #168]
	_current_cpu->arch.fpu_owner = _current;

	/* restore our content */
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
	DBG("restore", _current);
}
    400080a4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400080a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400080ac:	d65f03c0 	ret
MAKE_REG_HELPER_EL123(cpacr)
    400080b0:	d5381040 	mrs	x0, cpacr_el1
	write_cpacr_el1(read_cpacr_el1() | CPACR_EL1_FPEN_NOTRAP);
    400080b4:	b26c0400 	orr	x0, x0, #0x300000
    400080b8:	d5181040 	msr	cpacr_el1, x0
	isb();
    400080bc:	d5033fdf 	isb
	struct k_thread *owner = _current_cpu->arch.fpu_owner;
    400080c0:	d0000094 	adrp	x20, 4001a000 <shell_uart_ctx+0x1c8>
    400080c4:	91094294 	add	x20, x20, #0x250
    400080c8:	f9401680 	ldr	x0, [x20, #40]
	if (owner) {
    400080cc:	b40000a0 	cbz	x0, 400080e0 <z_arm64_fpu_trap+0xac>
		z_arm64_fpu_save(&owner->arch.saved_fp_context);
    400080d0:	91054000 	add	x0, x0, #0x150
    400080d4:	94000021 	bl	40008158 <z_arm64_fpu_save>
		dsb();
    400080d8:	d5033f9f 	dsb	sy
		_current_cpu->arch.fpu_owner = NULL;
    400080dc:	f900169f 	str	xzr, [x20, #40]
MAKE_REG_HELPER(tpidrro_el0);
    400080e0:	d53bd060 	mrs	x0, tpidrro_el0
    400080e4:	d378fc00 	lsr	x0, x0, #56
	if (arch_exception_depth() > 1) {
    400080e8:	f100041f 	cmp	x0, #0x1
    400080ec:	540000a9 	b.ls	40008100 <z_arm64_fpu_trap+0xcc>  // b.plast
		esf->spsr |= DAIF_IRQ_BIT;
    400080f0:	f9405260 	ldr	x0, [x19, #160]
    400080f4:	b2790000 	orr	x0, x0, #0x80
    400080f8:	f9005260 	str	x0, [x19, #160]
		return;
    400080fc:	17ffffea 	b	400080a4 <z_arm64_fpu_trap+0x70>
	_current_cpu->arch.fpu_owner = _current;
    40008100:	f9400a80 	ldr	x0, [x20, #16]
    40008104:	f9001680 	str	x0, [x20, #40]
}
    40008108:	a94153f3 	ldp	x19, x20, [sp, #16]
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
    4000810c:	91054000 	add	x0, x0, #0x150
}
    40008110:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
    40008114:	14000026 	b	400081ac <z_arm64_fpu_restore>

0000000040008118 <z_arm64_fpu_exit_exc>:
MAKE_REG_HELPER_EL123(cpacr)
    40008118:	d5381040 	mrs	x0, cpacr_el1
MAKE_REG_HELPER(tpidrro_el0);
    4000811c:	d53bd061 	mrs	x1, tpidrro_el0
    40008120:	d378fc21 	lsr	x1, x1, #56
{
	__ASSERT(read_daif() & DAIF_IRQ_BIT, "must be called with IRQs disabled");

	uint64_t cpacr = read_cpacr_el1();

	if (arch_exception_depth() == 1) {
    40008124:	f100043f 	cmp	x1, #0x1
    40008128:	54000141 	b.ne	40008150 <z_arm64_fpu_exit_exc+0x38>  // b.any
		/* We're about to leave exception mode */
		if (_current_cpu->arch.fpu_owner == _current) {
    4000812c:	d0000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    40008130:	91094021 	add	x1, x1, #0x250
    40008134:	f9401422 	ldr	x2, [x1, #40]
    40008138:	f9400821 	ldr	x1, [x1, #16]
    4000813c:	eb01005f 	cmp	x2, x1
    40008140:	54000081 	b.ne	40008150 <z_arm64_fpu_exit_exc+0x38>  // b.any
			/* turn on FPU access */
			write_cpacr_el1(cpacr | CPACR_EL1_FPEN_NOTRAP);
    40008144:	b26c0400 	orr	x0, x0, #0x300000
MAKE_REG_HELPER_EL123(cpacr)
    40008148:	d5181040 	msr	cpacr_el1, x0
		 * access as we want to make sure IRQs are disabled before
		 * granting them access.
		 */
		write_cpacr_el1(cpacr & ~CPACR_EL1_FPEN_NOTRAP);
	}
}
    4000814c:	d65f03c0 	ret
		write_cpacr_el1(cpacr & ~CPACR_EL1_FPEN_NOTRAP);
    40008150:	926af400 	and	x0, x0, #0xffffffffffcfffff
    40008154:	17fffffd 	b	40008148 <z_arm64_fpu_exit_exc+0x30>

0000000040008158 <z_arm64_fpu_save>:
_ASM_FILE_PROLOGUE

GTEXT(z_arm64_fpu_save)
SECTION_FUNC(TEXT, z_arm64_fpu_save)

	stp	q0,  q1,  [x0, #(16 *  0)]
    40008158:	ad000400 	stp	q0, q1, [x0]
	stp	q2,  q3,  [x0, #(16 *  2)]
    4000815c:	ad010c02 	stp	q2, q3, [x0, #32]
	stp	q4,  q5,  [x0, #(16 *  4)]
    40008160:	ad021404 	stp	q4, q5, [x0, #64]
	stp	q6,  q7,  [x0, #(16 *  6)]
    40008164:	ad031c06 	stp	q6, q7, [x0, #96]
	stp	q8,  q9,  [x0, #(16 *  8)]
    40008168:	ad042408 	stp	q8, q9, [x0, #128]
	stp	q10, q11, [x0, #(16 * 10)]
    4000816c:	ad052c0a 	stp	q10, q11, [x0, #160]
	stp	q12, q13, [x0, #(16 * 12)]
    40008170:	ad06340c 	stp	q12, q13, [x0, #192]
	stp	q14, q15, [x0, #(16 * 14)]
    40008174:	ad073c0e 	stp	q14, q15, [x0, #224]
	stp	q16, q17, [x0, #(16 * 16)]
    40008178:	ad084410 	stp	q16, q17, [x0, #256]
	stp	q18, q19, [x0, #(16 * 18)]
    4000817c:	ad094c12 	stp	q18, q19, [x0, #288]
	stp	q20, q21, [x0, #(16 * 20)]
    40008180:	ad0a5414 	stp	q20, q21, [x0, #320]
	stp	q22, q23, [x0, #(16 * 22)]
    40008184:	ad0b5c16 	stp	q22, q23, [x0, #352]
	stp	q24, q25, [x0, #(16 * 24)]
    40008188:	ad0c6418 	stp	q24, q25, [x0, #384]
	stp	q26, q27, [x0, #(16 * 26)]
    4000818c:	ad0d6c1a 	stp	q26, q27, [x0, #416]
	stp	q28, q29, [x0, #(16 * 28)]
    40008190:	ad0e741c 	stp	q28, q29, [x0, #448]
	stp	q30, q31, [x0, #(16 * 30)]
    40008194:	ad0f7c1e 	stp	q30, q31, [x0, #480]

	mrs	x1, fpsr
    40008198:	d53b4421 	mrs	x1, fpsr
	mrs	x2, fpcr
    4000819c:	d53b4402 	mrs	x2, fpcr
	str	w1, [x0, #(16 * 32 + 0)]
    400081a0:	b9020001 	str	w1, [x0, #512]
	str	w2, [x0, #(16 * 32 + 4)]
    400081a4:	b9020402 	str	w2, [x0, #516]

	ret
    400081a8:	d65f03c0 	ret

00000000400081ac <z_arm64_fpu_restore>:

GTEXT(z_arm64_fpu_restore)
SECTION_FUNC(TEXT, z_arm64_fpu_restore)

	ldp	q0,  q1,  [x0, #(16 *  0)]
    400081ac:	ad400400 	ldp	q0, q1, [x0]
	ldp	q2,  q3,  [x0, #(16 *  2)]
    400081b0:	ad410c02 	ldp	q2, q3, [x0, #32]
	ldp	q4,  q5,  [x0, #(16 *  4)]
    400081b4:	ad421404 	ldp	q4, q5, [x0, #64]
	ldp	q6,  q7,  [x0, #(16 *  6)]
    400081b8:	ad431c06 	ldp	q6, q7, [x0, #96]
	ldp	q8,  q9,  [x0, #(16 *  8)]
    400081bc:	ad442408 	ldp	q8, q9, [x0, #128]
	ldp	q10, q11, [x0, #(16 * 10)]
    400081c0:	ad452c0a 	ldp	q10, q11, [x0, #160]
	ldp	q12, q13, [x0, #(16 * 12)]
    400081c4:	ad46340c 	ldp	q12, q13, [x0, #192]
	ldp	q14, q15, [x0, #(16 * 14)]
    400081c8:	ad473c0e 	ldp	q14, q15, [x0, #224]
	ldp	q16, q17, [x0, #(16 * 16)]
    400081cc:	ad484410 	ldp	q16, q17, [x0, #256]
	ldp	q18, q19, [x0, #(16 * 18)]
    400081d0:	ad494c12 	ldp	q18, q19, [x0, #288]
	ldp	q20, q21, [x0, #(16 * 20)]
    400081d4:	ad4a5414 	ldp	q20, q21, [x0, #320]
	ldp	q22, q23, [x0, #(16 * 22)]
    400081d8:	ad4b5c16 	ldp	q22, q23, [x0, #352]
	ldp	q24, q25, [x0, #(16 * 24)]
    400081dc:	ad4c6418 	ldp	q24, q25, [x0, #384]
	ldp	q26, q27, [x0, #(16 * 26)]
    400081e0:	ad4d6c1a 	ldp	q26, q27, [x0, #416]
	ldp	q28, q29, [x0, #(16 * 28)]
    400081e4:	ad4e741c 	ldp	q28, q29, [x0, #448]
	ldp	q30, q31, [x0, #(16 * 30)]
    400081e8:	ad4f7c1e 	ldp	q30, q31, [x0, #480]

	ldr	w1, [x0, #(16 * 32 + 0)]
    400081ec:	b9420001 	ldr	w1, [x0, #512]
	ldr	w2, [x0, #(16 * 32 + 4)]
    400081f0:	b9420402 	ldr	w2, [x0, #516]
	msr	fpsr, x1
    400081f4:	d51b4421 	msr	fpsr, x1
	msr	fpcr, x2
    400081f8:	d51b4402 	msr	fpcr, x2

	ret
    400081fc:	d65f03c0 	ret

0000000040008200 <new_table>:
{
	unsigned int i;

	/* Look for a free table. */
	for (i = 0U; i < CONFIG_MAX_XLAT_TABLES; i++) {
		if (xlat_use_count[i] == 0U) {
    40008200:	d0000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    40008204:	910fb042 	add	x2, x2, #0x3ec
{
    40008208:	d2800001 	mov	x1, #0x0                   	// #0
		if (xlat_use_count[i] == 0U) {
    4000820c:	78617843 	ldrh	w3, [x2, x1, lsl #1]
    40008210:	2a0103e0 	mov	w0, w1
    40008214:	35000103 	cbnz	w3, 40008234 <new_table+0x34>
			xlat_use_count[i] = 1U;
    40008218:	52800021 	mov	w1, #0x1                   	// #1
    4000821c:	78205841 	strh	w1, [x2, w0, uxtw #1]
			return &xlat_tables[i * Ln_XLAT_NUM_ENTRIES];
    40008220:	d3745800 	ubfiz	x0, x0, #12, #23
    40008224:	b0000041 	adrp	x1, 40011000 <xlat_tables>
    40008228:	91000021 	add	x1, x1, #0x0
    4000822c:	8b010000 	add	x0, x0, x1
		}
	}

	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
	return NULL;
}
    40008230:	d65f03c0 	ret
	for (i = 0U; i < CONFIG_MAX_XLAT_TABLES; i++) {
    40008234:	91000421 	add	x1, x1, #0x1
    40008238:	f100203f 	cmp	x1, #0x8
    4000823c:	54fffe81 	b.ne	4000820c <new_table+0xc>  // b.any
	return NULL;
    40008240:	d2800000 	mov	x0, #0x0                   	// #0
    40008244:	17fffffb 	b	40008230 <new_table+0x30>

0000000040008248 <table_usage>:

static inline unsigned int table_index(uint64_t *pte)
{
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    40008248:	b0000042 	adrp	x2, 40011000 <xlat_tables>
    4000824c:	91000042 	add	x2, x2, #0x0
    40008250:	cb020002 	sub	x2, x0, x2
    40008254:	d2804000 	mov	x0, #0x200                 	// #512
/* Adjusts usage count and returns current count. */
static int table_usage(uint64_t *table, int adjustment)
{
	unsigned int i = table_index(table);

	xlat_use_count[i] += adjustment;
    40008258:	d0000083 	adrp	x3, 4001a000 <shell_uart_ctx+0x1c8>
    4000825c:	910fb063 	add	x3, x3, #0x3ec
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    40008260:	9343fc42 	asr	x2, x2, #3
    40008264:	9ac00c42 	sdiv	x2, x2, x0
	xlat_use_count[i] += adjustment;
    40008268:	2a0203e2 	mov	w2, w2
    4000826c:	78627860 	ldrh	w0, [x3, x2, lsl #1]
    40008270:	0b000020 	add	w0, w1, w0
    40008274:	12003c00 	and	w0, w0, #0xffff
    40008278:	78227860 	strh	w0, [x3, x2, lsl #1]
	__ASSERT(xlat_use_count[i] > 0, "usage count underflow");
	return xlat_use_count[i];
}
    4000827c:	d65f03c0 	ret

0000000040008280 <set_mapping.constprop.0>:
}

static inline bool is_desc_superset(uint64_t desc1, uint64_t desc2,
				    unsigned int level)
{
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    40008280:	1281ff8d 	mov	w13, #0xfffff003            	// #-4093
    40008284:	d281ff8e 	mov	x14, #0xffc                 	// #4092
		       uintptr_t virt, size_t size,
		       uint64_t desc, bool may_overwrite)
{
	uint64_t *pte, *ptes[XLAT_LAST_LEVEL + 1];
	uint64_t level_size;
	uint64_t *table = ptables->base_xlat_table;
    40008288:	d000008a 	adrp	x10, 4001a000 <shell_uart_ctx+0x1c8>
    4000828c:	f9411945 	ldr	x5, [x10, #560]
	xlat_use_count[i] = 0U;
    40008290:	d000008b 	adrp	x11, 4001a000 <shell_uart_ctx+0x1c8>
    40008294:	910fb16b 	add	x11, x11, #0x3ec
static int set_mapping(struct arm_mmu_ptables *ptables,
    40008298:	aa0003e8 	mov	x8, x0
    4000829c:	aa0103e7 	mov	x7, x1
    400082a0:	aa0203e6 	mov	x6, x2
    400082a4:	12001c6c 	and	w12, w3, #0xff
	unsigned int level = BASE_XLAT_LEVEL;
    400082a8:	5280002f 	mov	w15, #0x1                   	// #1
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    400082ac:	f2dfffed 	movk	x13, #0xffff, lsl #32
    400082b0:	f2ffff0e 	movk	x14, #0xfff8, lsl #48
	int ret = 0;

	while (size) {
    400082b4:	b5000d21 	cbnz	x1, 40008458 <set_mapping.constprop.0+0x1d8>
	int ret = 0;
    400082b8:	52800000 	mov	w0, #0x0                   	// #0
		table = ptables->base_xlat_table;
		level = BASE_XLAT_LEVEL;
	}

	return ret;
}
    400082bc:	d65f03c0 	ret
		if (!may_overwrite && !is_free_desc(*pte)) {
    400082c0:	3500006c 	cbnz	w12, 400082cc <set_mapping.constprop.0+0x4c>
    400082c4:	f24004bf 	tst	x5, #0x3
    400082c8:	54000b61 	b.ne	40008434 <set_mapping.constprop.0+0x1b4>  // b.any
		level_size = 1ULL << LEVEL_TO_VA_SIZE_SHIFT(level);
    400082cc:	d2800021 	mov	x1, #0x1                   	// #1
	return (desc1 & mask) == (desc2 & mask);
    400082d0:	ca0600a2 	eor	x2, x5, x6
		level_size = 1ULL << LEVEL_TO_VA_SIZE_SHIFT(level);
    400082d4:	9ac02033 	lsl	x19, x1, x0
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    400082d8:	cb1303e0 	neg	x0, x19
    400082dc:	8a0d0000 	and	x0, x0, x13
    400082e0:	aa0e0000 	orr	x0, x0, x14
		if (is_desc_superset(*pte, desc, level)) {
    400082e4:	ea02001f 	tst	x0, x2
    400082e8:	540001c1 	b.ne	40008320 <set_mapping.constprop.0+0xa0>  // b.any
			level_size -= (virt & (level_size - 1));
    400082ec:	d1000660 	sub	x0, x19, #0x1
    400082f0:	8a080000 	and	x0, x0, x8
    400082f4:	cb000260 	sub	x0, x19, x0
			if (level_size > size) {
    400082f8:	eb07001f 	cmp	x0, x7
    400082fc:	9a879013 	csel	x19, x0, x7, ls  // ls = plast
		desc += desc ? level_size : 0;
    40008300:	f10000df 	cmp	x6, #0x0
		virt += level_size;
    40008304:	8b130108 	add	x8, x8, x19
		desc += desc ? level_size : 0;
    40008308:	9a9f1260 	csel	x0, x19, xzr, ne  // ne = any
		size -= level_size;
    4000830c:	cb1300e7 	sub	x7, x7, x19
		table = ptables->base_xlat_table;
    40008310:	f9411945 	ldr	x5, [x10, #560]
		desc += desc ? level_size : 0;
    40008314:	8b0000c6 	add	x6, x6, x0
		level = BASE_XLAT_LEVEL;
    40008318:	5280002f 	mov	w15, #0x1                   	// #1
    4000831c:	14000062 	b	400084a4 <set_mapping.constprop.0+0x224>
		if ((size < level_size) || (virt & (level_size - 1)) ||
    40008320:	eb07027f 	cmp	x19, x7
    40008324:	54000108 	b.hi	40008344 <set_mapping.constprop.0+0xc4>  // b.pmore
	bool aligned = !((desc & mask) & (level_size - 1));
    40008328:	51000660 	sub	w0, w19, #0x1
		if ((size < level_size) || (virt & (level_size - 1)) ||
    4000832c:	d1000662 	sub	x2, x19, #0x1
	bool aligned = !((desc & mask) & (level_size - 1));
    40008330:	8a060000 	and	x0, x0, x6
		if ((size < level_size) || (virt & (level_size - 1)) ||
    40008334:	8a080042 	and	x2, x2, x8
	bool aligned = !((desc & mask) & (level_size - 1));
    40008338:	92748c00 	and	x0, x0, #0xfffffffff000
		if ((size < level_size) || (virt & (level_size - 1)) ||
    4000833c:	aa020000 	orr	x0, x0, x2
    40008340:	b40003c0 	cbz	x0, 400083b8 <set_mapping.constprop.0+0x138>
	table = new_table();
    40008344:	97ffffaf 	bl	40008200 <new_table>
    40008348:	aa0003e5 	mov	x5, x0
	if (!table) {
    4000834c:	b4000780 	cbz	x0, 4000843c <set_mapping.constprop.0+0x1bc>
	if (!is_free_desc(*pte)) {
    40008350:	f9400080 	ldr	x0, [x4]
    40008354:	f240041f 	tst	x0, #0x3
    40008358:	540002a0 	b.eq	400083ac <set_mapping.constprop.0+0x12c>  // b.none
		if (level + 1 == XLAT_LAST_LEVEL) {
    4000835c:	710009ff 	cmp	w15, #0x2
    40008360:	54000041 	b.ne	40008368 <set_mapping.constprop.0+0xe8>  // b.any
			desc |= PTE_PAGE_DESC;
    40008364:	b2400400 	orr	x0, x0, #0x3
		stride_shift = LEVEL_TO_VA_SIZE_SHIFT(level + 1);
    40008368:	11007929 	add	w9, w9, #0x1e
    4000836c:	d2800001 	mov	x1, #0x0                   	// #0
			table[i] = desc | (i << stride_shift);
    40008370:	1ac92022 	lsl	w2, w1, w9
    40008374:	aa000042 	orr	x2, x2, x0
    40008378:	f82178a2 	str	x2, [x5, x1, lsl #3]
		for (i = 0U; i < Ln_XLAT_NUM_ENTRIES; i++) {
    4000837c:	91000421 	add	x1, x1, #0x1
    40008380:	f108003f 	cmp	x1, #0x200
    40008384:	54ffff61 	b.ne	40008370 <set_mapping.constprop.0+0xf0>  // b.any
		table_usage(table, Ln_XLAT_NUM_ENTRIES);
    40008388:	aa0503e0 	mov	x0, x5
		table_usage(pte, 1);
    4000838c:	97ffffaf 	bl	40008248 <table_usage>
	table_usage(table, 1);
    40008390:	52800021 	mov	w1, #0x1                   	// #1
	*pte = PTE_TABLE_DESC | (uint64_t)table;
    40008394:	b24004a0 	orr	x0, x5, #0x3
    40008398:	f9000080 	str	x0, [x4]
			level++;
    4000839c:	0b0101ef 	add	w15, w15, w1
	table_usage(table, 1);
    400083a0:	aa0503e0 	mov	x0, x5
    400083a4:	97ffffa9 	bl	40008248 <table_usage>
			continue;
    400083a8:	1400003f 	b	400084a4 <set_mapping.constprop.0+0x224>
		table_usage(pte, 1);
    400083ac:	aa0403e0 	mov	x0, x4
    400083b0:	52800021 	mov	w1, #0x1                   	// #1
    400083b4:	17fffff6 	b	4000838c <set_mapping.constprop.0+0x10c>
		if (is_free_desc(*pte)) {
    400083b8:	f24004bf 	tst	x5, #0x3
    400083bc:	54000061 	b.ne	400083c8 <set_mapping.constprop.0+0x148>  // b.any
			table_usage(pte, 1);
    400083c0:	aa0403e0 	mov	x0, x4
    400083c4:	97ffffa1 	bl	40008248 <table_usage>
		if (!desc) {
    400083c8:	b50003e6 	cbnz	x6, 40008444 <set_mapping.constprop.0+0x1c4>
			table_usage(pte, -1);
    400083cc:	aa0403e0 	mov	x0, x4
    400083d0:	12800001 	mov	w1, #0xffffffff            	// #-1
    400083d4:	97ffff9d 	bl	40008248 <table_usage>
    400083d8:	d2800000 	mov	x0, #0x0                   	// #0
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    400083dc:	b0000045 	adrp	x5, 40011000 <xlat_tables>
    400083e0:	910000a5 	add	x5, x5, #0x0
    400083e4:	d2804009 	mov	x9, #0x200                 	// #512
	*pte = desc;
    400083e8:	f9000080 	str	x0, [x4]
		while (level != BASE_XLAT_LEVEL &&
    400083ec:	710005ff 	cmp	w15, #0x1
    400083f0:	54fff880 	b.eq	40008300 <set_mapping.constprop.0+0x80>  // b.none
	return table_usage(table, 0) == 1;
    400083f4:	aa0403e0 	mov	x0, x4
    400083f8:	52800001 	mov	w1, #0x0                   	// #0
    400083fc:	97ffff93 	bl	40008248 <table_usage>
		while (level != BASE_XLAT_LEVEL &&
    40008400:	7100041f 	cmp	w0, #0x1
    40008404:	54fff7e1 	b.ne	40008300 <set_mapping.constprop.0+0x80>  // b.any
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    40008408:	cb050084 	sub	x4, x4, x5
			pte = ptes[--level];
    4000840c:	510005ef 	sub	w15, w15, #0x1
			table_usage(pte, -1);
    40008410:	12800001 	mov	w1, #0xffffffff            	// #-1
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    40008414:	9343fc84 	asr	x4, x4, #3
    40008418:	9ac90c84 	sdiv	x4, x4, x9
	xlat_use_count[i] = 0U;
    4000841c:	7824597f 	strh	wzr, [x11, w4, uxtw #1]
			pte = ptes[--level];
    40008420:	f86f5a44 	ldr	x4, [x18, w15, uxtw #3]
			table_usage(pte, -1);
    40008424:	aa0403e0 	mov	x0, x4
	*pte = desc;
    40008428:	f900009f 	str	xzr, [x4]
			table_usage(pte, -1);
    4000842c:	97ffff87 	bl	40008248 <table_usage>
    40008430:	17ffffef 	b	400083ec <set_mapping.constprop.0+0x16c>
			ret = -EBUSY;
    40008434:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    40008438:	1400001d 	b	400084ac <set_mapping.constprop.0+0x22c>
				ret = -ENOMEM;
    4000843c:	12800160 	mov	w0, #0xfffffff4            	// #-12
	return ret;
    40008440:	1400001b 	b	400084ac <set_mapping.constprop.0+0x22c>
		desc |= (level == XLAT_LAST_LEVEL) ? PTE_PAGE_DESC : PTE_BLOCK_DESC;
    40008444:	71000dff 	cmp	w15, #0x3
    40008448:	d2800060 	mov	x0, #0x3                   	// #3
    4000844c:	9a9f0400 	csinc	x0, x0, xzr, eq  // eq = none
    40008450:	aa0000c0 	orr	x0, x6, x0
    40008454:	17ffffe2 	b	400083dc <set_mapping.constprop.0+0x15c>
static int set_mapping(struct arm_mmu_ptables *ptables,
    40008458:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000845c:	910003fd 	mov	x29, sp
    40008460:	f9000bf3 	str	x19, [sp, #16]
		pte = &table[XLAT_TABLE_VA_IDX(virt, level)];
    40008464:	12800109 	mov	w9, #0xfffffff7            	// #-9
		ptes[level] = pte;
    40008468:	910083f2 	add	x18, sp, #0x20
	return level != XLAT_LAST_LEVEL &&
    4000846c:	71000dff 	cmp	w15, #0x3
		pte = &table[XLAT_TABLE_VA_IDX(virt, level)];
    40008470:	1b097de9 	mul	w9, w15, w9
    40008474:	11009d20 	add	w0, w9, #0x27
    40008478:	9ac02501 	lsr	x1, x8, x0
    4000847c:	d37d2021 	ubfiz	x1, x1, #3, #9
    40008480:	8b0100a4 	add	x4, x5, x1
		ptes[level] = pte;
    40008484:	f82f5a44 	str	x4, [x18, w15, uxtw #3]
		if (is_table_desc(*pte, level)) {
    40008488:	f86168a5 	ldr	x5, [x5, x1]
	return level != XLAT_LAST_LEVEL &&
    4000848c:	54fff1a0 	b.eq	400082c0 <set_mapping.constprop.0+0x40>  // b.none
	       (desc & PTE_DESC_TYPE_MASK) == PTE_TABLE_DESC;
    40008490:	924004a1 	and	x1, x5, #0x3
		if (is_table_desc(*pte, level)) {
    40008494:	f1000c3f 	cmp	x1, #0x3
    40008498:	54fff141 	b.ne	400082c0 <set_mapping.constprop.0+0x40>  // b.any
			level++;
    4000849c:	110005ef 	add	w15, w15, #0x1
	uint64_t address = desc & GENMASK(47, PAGE_SIZE_SHIFT);
    400084a0:	92748ca5 	and	x5, x5, #0xfffffffff000
	while (size) {
    400084a4:	b5fffe07 	cbnz	x7, 40008464 <set_mapping.constprop.0+0x1e4>
	int ret = 0;
    400084a8:	52800000 	mov	w0, #0x0                   	// #0
}
    400084ac:	f9400bf3 	ldr	x19, [sp, #16]
    400084b0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400084b4:	d65f03c0 	ret

00000000400084b8 <__add_map.constprop.0>:
{
	unsigned int mem_type;
	uint64_t desc = 0U;

	/* NS bit for security memory access from secure state */
	desc |= (attrs & MT_NS) ? PTE_BLOCK_DESC_NS : 0;
    400084b8:	d37f7c65 	ubfiz	x5, x3, #1, #32
	 *     10      RO   NA
	 *     11      RO   RO
	 */

	/* AP bits for Data access permission */
	desc |= (attrs & MT_RW) ? PTE_BLOCK_DESC_AP_RW : PTE_BLOCK_DESC_AP_RO;
    400084bc:	f27d007f 	tst	x3, #0x8
	desc |= (attrs & MT_NS) ? PTE_BLOCK_DESC_NS : 0;
    400084c0:	927b00a7 	and	x7, x5, #0x20

	/* Mirror permissions to EL0 */
	desc |= (attrs & MT_RW_AP_ELx) ?
		 PTE_BLOCK_DESC_AP_ELx : PTE_BLOCK_DESC_AP_EL_HIGHER;
    400084c4:	53017c65 	lsr	w5, w3, #1
	desc |= (attrs & MT_RW) ? PTE_BLOCK_DESC_AP_RW : PTE_BLOCK_DESC_AP_RO;
    400084c8:	9a9f17e4 	cset	x4, eq  // eq = none
		 PTE_BLOCK_DESC_AP_ELx : PTE_BLOCK_DESC_AP_EL_HIGHER;
    400084cc:	927a00a5 	and	x5, x5, #0x40
    400084d0:	aa0700a5 	orr	x5, x5, x7
	/* the access flag */
	desc |= PTE_BLOCK_DESC_AF;

	/* memory attribute index field */
	mem_type = MT_TYPE(attrs);
	desc |= PTE_BLOCK_DESC_MEMTYPE(mem_type);
    400084d4:	d37e0867 	ubfiz	x7, x3, #2, #3
    400084d8:	aa041ce4 	orr	x4, x7, x4, lsl #7
	}

	return desc;
}

static int __add_map(struct arm_mmu_ptables *ptables, const char *name,
    400084dc:	aa0003e6 	mov	x6, x0
    400084e0:	aa0400a5 	orr	x5, x5, x4
    400084e4:	aa0103e0 	mov	x0, x1
    400084e8:	aa0203e1 	mov	x1, x2
	mem_type = MT_TYPE(attrs);
    400084ec:	12000862 	and	w2, w3, #0x7
	desc |= PTE_BLOCK_DESC_MEMTYPE(mem_type);
    400084f0:	b27600a4 	orr	x4, x5, #0x400
	switch (mem_type) {
    400084f4:	7100085f 	cmp	w2, #0x2
    400084f8:	54000109 	b.ls	40008518 <__add_map.constprop.0+0x60>  // b.plast
    400084fc:	51000c47 	sub	w7, w2, #0x3
    40008500:	710004ff 	cmp	w7, #0x1
    40008504:	54000129 	b.ls	40008528 <__add_map.constprop.0+0x70>  // b.plast
		     uintptr_t phys, uintptr_t virt, size_t size, uint32_t attrs)
{
	uint64_t desc = get_region_desc(attrs);
	bool may_overwrite = !(attrs & MT_NO_OVERWRITE);
    40008508:	d2780063 	eor	x3, x3, #0x100
	MMU_DEBUG("mmap [%s]: virt %lx phys %lx size %lx attr %llx\n",
		  name, virt, phys, size, desc);
	__ASSERT(((virt | phys | size) & (CONFIG_MMU_PAGE_SIZE - 1)) == 0,
		 "address/size are not page aligned\n");
	desc |= phys;
	return set_mapping(ptables, virt, size, desc, may_overwrite);
    4000850c:	aa0400c2 	orr	x2, x6, x4
    40008510:	53082063 	ubfx	w3, w3, #8, #1
    40008514:	17ffff5b 	b	40008280 <set_mapping.constprop.0>
		desc |= PTE_BLOCK_DESC_UXN;
    40008518:	d280c004 	mov	x4, #0x600                 	// #1536
    4000851c:	f2e00c04 	movk	x4, #0x60, lsl #48
    40008520:	aa0400a4 	orr	x4, x5, x4
		break;
    40008524:	17fffff9 	b	40008508 <__add_map.constprop.0+0x50>
		if ((attrs & MT_RW) || (attrs & MT_P_EXECUTE_NEVER))
    40008528:	52800507 	mov	w7, #0x28                  	// #40
    4000852c:	6a07007f 	tst	w3, w7
    40008530:	54000080 	b.eq	40008540 <__add_map.constprop.0+0x88>  // b.none
			desc |= PTE_BLOCK_DESC_PXN;
    40008534:	d2808004 	mov	x4, #0x400                 	// #1024
    40008538:	f2e00404 	movk	x4, #0x20, lsl #48
    4000853c:	aa0400a4 	orr	x4, x5, x4
		if (((attrs & MT_RW) && (attrs & MT_RW_AP_ELx)) ||
    40008540:	52801105 	mov	w5, #0x88                  	// #136
    40008544:	0a050065 	and	w5, w3, w5
    40008548:	710220bf 	cmp	w5, #0x88
    4000854c:	54000040 	b.eq	40008554 <__add_map.constprop.0+0x9c>  // b.none
    40008550:	36300043 	tbz	w3, #6, 40008558 <__add_map.constprop.0+0xa0>
			desc |= PTE_BLOCK_DESC_UXN;
    40008554:	b24a0084 	orr	x4, x4, #0x40000000000000
			desc |= PTE_BLOCK_DESC_INNER_SHARE;
    40008558:	b2780485 	orr	x5, x4, #0x300
    4000855c:	7100105f 	cmp	w2, #0x4
    40008560:	b2770084 	orr	x4, x4, #0x200
    40008564:	9a851084 	csel	x4, x4, x5, ne  // ne = any
    40008568:	17ffffe8 	b	40008508 <__add_map.constprop.0+0x50>

000000004000856c <z_arm64_mm_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Management Unit (MMU).
 */
void z_arm64_mm_init(bool is_primary_core)
{
    4000856c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	__ASSERT((read_sctlr_el1() & SCTLR_M_BIT) == 0, "MMU is already enabled\n");

	/*
	 * Only booting core setup up the page tables.
	 */
	if (is_primary_core) {
    40008570:	72001c1f 	tst	w0, #0xff
{
    40008574:	910003fd 	mov	x29, sp
    40008578:	a90153f3 	stp	x19, x20, [sp, #16]
    4000857c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008580:	d0000095 	adrp	x21, 4001a000 <shell_uart_ctx+0x1c8>
    40008584:	f9001bf7 	str	x23, [sp, #48]
	if (is_primary_core) {
    40008588:	54000360 	b.eq	400085f4 <z_arm64_mm_init+0x88>  // b.none
		kernel_ptables.base_xlat_table = new_table();
    4000858c:	97ffff1d 	bl	40008200 <new_table>
    40008590:	f9011aa0 	str	x0, [x21, #560]
	for (index = 0U; index < mmu_config.num_regions; index++) {
    40008594:	b0000020 	adrp	x0, 4000d000 <__rodata_region_start>
    40008598:	b94fb801 	ldr	w1, [x0, #4024]
    4000859c:	d0000033 	adrp	x19, 4000e000 <mmu_regions+0x38>
    400085a0:	9122c273 	add	x19, x19, #0x8b0
    400085a4:	2a0103f7 	mov	w23, w1
    400085a8:	aa0003f4 	mov	x20, x0
    400085ac:	52800076 	mov	w22, #0x3                   	// #3
	size_t size = (uintptr_t)range->end - address;
    400085b0:	a9408a61 	ldp	x1, x2, [x19, #8]
	if (size) {
    400085b4:	eb010042 	subs	x2, x2, x1
    400085b8:	54000080 	b.eq	400085c8 <z_arm64_mm_init+0x5c>  // b.none
		__add_map(ptables, range->name, address, address,
    400085bc:	b9401a63 	ldr	w3, [x19, #24]
    400085c0:	aa0103e0 	mov	x0, x1
    400085c4:	97ffffbd 	bl	400084b8 <__add_map.constprop.0>
	for (index = 0U; index < ARRAY_SIZE(mmu_zephyr_ranges); index++) {
    400085c8:	91008273 	add	x19, x19, #0x20
    400085cc:	710006d6 	subs	w22, w22, #0x1
    400085d0:	54ffff01 	b.ne	400085b0 <z_arm64_mm_init+0x44>  // b.any
		region = &mmu_config.mmu_regions[index];
    400085d4:	913ee294 	add	x20, x20, #0xfb8
    400085d8:	d2800013 	mov	x19, #0x0                   	// #0
    400085dc:	d2800516 	mov	x22, #0x28                  	// #40
	for (index = 0U; index < mmu_config.num_regions; index++) {
    400085e0:	6b1302ff 	cmp	w23, w19
    400085e4:	54000348 	b.hi	4000864c <z_arm64_mm_init+0xe0>  // b.pmore
	__asm__ volatile (
    400085e8:	d508871f 	tlbi	vmalle1
    400085ec:	d5033f9f 	dsb	sy
    400085f0:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(mair)
    400085f4:	d2808000 	mov	x0, #0x400                 	// #1024
    400085f8:	f2a88180 	movk	x0, #0x440c, lsl #16
    400085fc:	f2d77fe0 	movk	x0, #0xbbff, lsl #32
    40008600:	d518a200 	msr	mair_el1, x0
MAKE_REG_HELPER_EL123(tcr)
    40008604:	d286a400 	mov	x0, #0x3520                	// #13600
    40008608:	f2a01000 	movk	x0, #0x80, lsl #16
    4000860c:	d5182040 	msr	tcr_el1, x0
MAKE_REG_HELPER_EL123(ttbr0)
    40008610:	f9411aa0 	ldr	x0, [x21, #560]
    40008614:	d5182000 	msr	ttbr0_el1, x0
	isb();
    40008618:	d5033fdf 	isb

__syscall int sys_cache_data_all(int op);
static inline int z_impl_sys_cache_data_all(int op)
{
#if defined(CONFIG_CACHE_MANAGEMENT)
	return cache_data_all(op);
    4000861c:	52800040 	mov	w0, #0x2                   	// #2
    40008620:	9400004d 	bl	40008754 <arch_dcache_all>
MAKE_REG_HELPER_EL123(sctlr)
    40008624:	d5381000 	mrs	x0, sctlr_el1
	write_sctlr_el1(val | SCTLR_M_BIT | SCTLR_C_BIT);
    40008628:	d28000a1 	mov	x1, #0x5                   	// #5
    4000862c:	aa010000 	orr	x0, x0, x1
    40008630:	d5181000 	msr	sctlr_el1, x0
	isb();
    40008634:	d5033fdf 	isb
		setup_page_tables(&kernel_ptables);
	}

	/* currently only EL1 is supported */
	enable_mmu_el1(&kernel_ptables, flags);
}
    40008638:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000863c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008640:	f9401bf7 	ldr	x23, [sp, #48]
    40008644:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40008648:	d65f03c0 	ret
		region = &mmu_config.mmu_regions[index];
    4000864c:	f9400685 	ldr	x5, [x20, #8]
    40008650:	9b167e64 	mul	x4, x19, x22
    40008654:	8b0400a0 	add	x0, x5, x4
	if (region->size || region->attrs) {
    40008658:	f9400802 	ldr	x2, [x0, #16]
    4000865c:	b9402003 	ldr	w3, [x0, #32]
    40008660:	b5000042 	cbnz	x2, 40008668 <z_arm64_mm_init+0xfc>
    40008664:	340000a3 	cbz	w3, 40008678 <z_arm64_mm_init+0x10c>
		__add_map(ptables, region->name, region->base_pa, region->base_va,
    40008668:	f9400401 	ldr	x1, [x0, #8]
    4000866c:	32180063 	orr	w3, w3, #0x100
    40008670:	f86468a0 	ldr	x0, [x5, x4]
    40008674:	97ffff91 	bl	400084b8 <__add_map.constprop.0>
	for (index = 0U; index < mmu_config.num_regions; index++) {
    40008678:	91000673 	add	x19, x19, #0x1
    4000867c:	17ffffd9 	b	400085e0 <z_arm64_mm_init+0x74>

0000000040008680 <arch_mem_map>:

	return add_map(ptables, "generic", phys, (uintptr_t)virt, size, entry_flags);
}

void arch_mem_map(void *virt, uintptr_t phys, size_t size, uint32_t flags)
{
    40008680:	2a0303e4 	mov	w4, w3
	switch (flags & K_MEM_CACHE_MASK) {
    40008684:	12000863 	and	w3, w3, #0x7
    40008688:	7100087f 	cmp	w3, #0x2
    4000868c:	54000129 	b.ls	400086b0 <arch_mem_map+0x30>  // b.plast
	int ret = __arch_mem_map(virt, phys, size, flags);

	if (ret) {
		LOG_ERR("__arch_mem_map() returned %d", ret);
		k_panic();
    40008690:	d2800088 	mov	x8, #0x4                   	// #4
    40008694:	d4000041 	svc	#0x2
    40008698:	d65f03c0 	ret
    4000869c:	d2800088 	mov	x8, #0x4                   	// #4
    400086a0:	d4000041 	svc	#0x2
	} else {
		sync_domains((uintptr_t)virt, size);
		invalidate_tlb_all();
	}
}
    400086a4:	f9400bf3 	ldr	x19, [sp, #16]
    400086a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400086ac:	d65f03c0 	ret
    400086b0:	aa0003e5 	mov	x5, x0
    400086b4:	aa0103e0 	mov	x0, x1
    400086b8:	f0000021 	adrp	x1, 4000f000 <cfg_flags.0+0x5ac>
    400086bc:	9123e421 	add	x1, x1, #0x8f9
    400086c0:	38636823 	ldrb	w3, [x1, x3]
	if ((flags & K_MEM_PERM_RW) != 0U) {
    400086c4:	36180044 	tbz	w4, #3, 400086cc <arch_mem_map+0x4c>
		entry_flags |= MT_RW;
    400086c8:	321d0063 	orr	w3, w3, #0x8
	if ((flags & K_MEM_PERM_EXEC) == 0U) {
    400086cc:	37200044 	tbnz	w4, #4, 400086d4 <arch_mem_map+0x54>
		entry_flags |= MT_P_EXECUTE_NEVER;
    400086d0:	321b0063 	orr	w3, w3, #0x20
	if ((flags & K_MEM_PERM_USER) != 0U) {
    400086d4:	372ffde4 	tbnz	w4, #5, 40008690 <arch_mem_map+0x10>
{
    400086d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400086dc:	910003fd 	mov	x29, sp
    400086e0:	f9000bf3 	str	x19, [sp, #16]
MAKE_REG_HELPER(daif)
    400086e4:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400086e8:	d50342df 	msr	daifset, #0x2
	ret = __add_map(ptables, name, phys, virt, size, attrs);
    400086ec:	aa0503e1 	mov	x1, x5
MAKE_REG_HELPER(daif)
    400086f0:	92407e73 	and	x19, x19, #0xffffffff
    400086f4:	97ffff71 	bl	400084b8 <__add_map.constprop.0>
    400086f8:	d51b4233 	msr	daif, x19
	if (ret) {
    400086fc:	35fffd00 	cbnz	w0, 4000869c <arch_mem_map+0x1c>
	__asm__ volatile (
    40008700:	d508871f 	tlbi	vmalle1
    40008704:	d5033f9f 	dsb	sy
    40008708:	d5033fdf 	isb
}
    4000870c:	17ffffe6 	b	400086a4 <arch_mem_map+0x24>

0000000040008710 <arch_virt_region_align>:
	int level;

	for (level = XLAT_LAST_LEVEL; level >= BASE_XLAT_LEVEL; level--) {
		level_size = 1 << LEVEL_TO_VA_SIZE_SHIFT(level);

		if (size < level_size) {
    40008710:	b24053e2 	mov	x2, #0x1fffff              	// #2097151
    40008714:	eb02003f 	cmp	x1, x2
    40008718:	54000169 	b.ls	40008744 <arch_virt_region_align+0x34>  // b.plast
			break;
		}

		if ((phys & (level_size - 1))) {
    4000871c:	f240501f 	tst	x0, #0x1fffff
    40008720:	54000121 	b.ne	40008744 <arch_virt_region_align+0x34>  // b.any
		if (size < level_size) {
    40008724:	b24077e2 	mov	x2, #0x3fffffff            	// #1073741823
    40008728:	eb02003f 	cmp	x1, x2
    4000872c:	54000109 	b.ls	4000874c <arch_virt_region_align+0x3c>  // b.plast
		level_size = 1 << LEVEL_TO_VA_SIZE_SHIFT(level);
    40008730:	f240741f 	tst	x0, #0x3fffffff
    40008734:	d2a80001 	mov	x1, #0x40000000            	// #1073741824
    40008738:	d2a00400 	mov	x0, #0x200000              	// #2097152
    4000873c:	9a811000 	csel	x0, x0, x1, ne  // ne = any

		alignment = level_size;
	}

	return alignment;
}
    40008740:	d65f03c0 	ret
	size_t alignment = CONFIG_MMU_PAGE_SIZE;
    40008744:	d2820000 	mov	x0, #0x1000                	// #4096
    40008748:	17fffffe 	b	40008740 <arch_virt_region_align+0x30>
		level_size = 1 << LEVEL_TO_VA_SIZE_SHIFT(level);
    4000874c:	d2a00400 	mov	x0, #0x200000              	// #2097152
    40008750:	17fffffc 	b	40008740 <arch_virt_region_align+0x30>

0000000040008754 <arch_dcache_all>:
{
	uint32_t clidr_el1, csselr_el1, ccsidr_el1;
	uint8_t loc, ctype, cache_level, line_size, way_pos;
	uint32_t max_ways, max_sets, dc_val, set, way;

	if (op != K_CACHE_INVD && op != K_CACHE_WB && op != K_CACHE_WB_INVD)
    40008754:	51000401 	sub	w1, w0, #0x1
    40008758:	7100083f 	cmp	w1, #0x2
    4000875c:	540006a8 	b.hi	40008830 <arch_dcache_all+0xdc>  // b.pmore
		return -ENOTSUP;

	/* Data barrier before start */
	dsb();
    40008760:	d5033f9f 	dsb	sy
MAKE_REG_HELPER(clidr_el1);
    40008764:	d5390021 	mrs	x1, clidr_el1

	clidr_el1 = read_clidr_el1();
    40008768:	2a0103ea 	mov	w10, w1

	loc = (clidr_el1 >> CLIDR_EL1_LOC_SHIFT) & CLIDR_EL1_LOC_MASK;
    4000876c:	53186829 	ubfx	w9, w1, #24, #3
	if (!loc)
    40008770:	7208083f 	tst	w1, #0x7000000
    40008774:	54000620 	b.eq	40008838 <arch_dcache_all+0xe4>  // b.none
    40008778:	d2800001 	mov	x1, #0x0                   	// #0
		return 0;

	for (cache_level = 0; cache_level < loc; cache_level++) {
		ctype = (clidr_el1 >> CLIDR_EL1_CTYPE_SHIFT(cache_level))
    4000877c:	0b010422 	add	w2, w1, w1, lsl #1
    40008780:	531f782b 	lsl	w11, w1, #1
    40008784:	1ac22542 	lsr	w2, w10, w2
				& CLIDR_EL1_CTYPE_MASK;
		/* No data cache, continue */
		if (ctype < 2)
    40008788:	721f045f 	tst	w2, #0x6
    4000878c:	54000320 	b.eq	400087f0 <arch_dcache_all+0x9c>  // b.none
MAKE_REG_HELPER(csselr_el1);
    40008790:	d37ff822 	lsl	x2, x1, #1
    40008794:	d51a0002 	msr	csselr_el1, x2
			continue;

		/* select cache level */
		csselr_el1 = cache_level << 1;
		write_csselr_el1(csselr_el1);
		isb();
    40008798:	d5033fdf 	isb
MAKE_REG_HELPER(ccsidr_el1);
    4000879c:	d5390002 	mrs	x2, ccsidr_el1

		ccsidr_el1 = read_ccsidr_el1();
		line_size = (ccsidr_el1 >> CCSIDR_EL1_LN_SZ_SHIFT
				& CCSIDR_EL1_LN_SZ_MASK) + 4;
    400087a0:	12000847 	and	w7, w2, #0x7
		max_ways = (ccsidr_el1 >> CCSIDR_EL1_WAYS_SHIFT)
    400087a4:	53033048 	ubfx	w8, w2, #3, #10
		line_size = (ccsidr_el1 >> CCSIDR_EL1_LN_SZ_SHIFT
    400087a8:	110010e7 	add	w7, w7, #0x4
				& CCSIDR_EL1_WAYS_MASK;
		max_sets = (ccsidr_el1 >> CCSIDR_EL1_SETS_SHIFT)
    400087ac:	530d6c42 	ubfx	w2, w2, #13, #15
				& CCSIDR_EL1_SETS_MASK;
		/* 32-log2(ways), bit position of way in DC operand */
		way_pos = __builtin_clz(max_ways);
    400087b0:	5ac0110c 	clz	w12, w8

		for (set = 0; set <= max_sets; set++) {
    400087b4:	52800005 	mov	w5, #0x0                   	// #0
				/* way number, aligned to pos in DC operand */
				dc_val = way << way_pos;
				/* cache level, aligned to pos in DC operand */
				dc_val |= csselr_el1;
				/* set number, aligned to pos in DC operand */
				dc_val |= set << line_size;
    400087b8:	1ac720a6 	lsl	w6, w5, w7
    400087bc:	2a0b00c6 	orr	w6, w6, w11
			for (way = 0; way <= max_ways; way++) {
    400087c0:	52800004 	mov	w4, #0x0                   	// #0
				dc_val = way << way_pos;
    400087c4:	1acc2083 	lsl	w3, w4, w12

				if (op == K_CACHE_INVD) {
    400087c8:	7100081f 	cmp	w0, #0x2
				dc_val |= set << line_size;
    400087cc:	2a060063 	orr	w3, w3, w6
				if (op == K_CACHE_INVD) {
    400087d0:	54000201 	b.ne	40008810 <arch_dcache_all+0xbc>  // b.any
					dc_ops("isw", dc_val);
    400087d4:	d5087643 	dc	isw, x3
			for (way = 0; way <= max_ways; way++) {
    400087d8:	11000484 	add	w4, w4, #0x1
    400087dc:	6b04011f 	cmp	w8, w4
    400087e0:	54ffff22 	b.cs	400087c4 <arch_dcache_all+0x70>  // b.hs, b.nlast
		for (set = 0; set <= max_sets; set++) {
    400087e4:	110004a5 	add	w5, w5, #0x1
    400087e8:	6b05005f 	cmp	w2, w5
    400087ec:	54fffe62 	b.cs	400087b8 <arch_dcache_all+0x64>  // b.hs, b.nlast
	for (cache_level = 0; cache_level < loc; cache_level++) {
    400087f0:	91000421 	add	x1, x1, #0x1
    400087f4:	6b21013f 	cmp	w9, w1, uxtb
    400087f8:	54fffc28 	b.hi	4000877c <arch_dcache_all+0x28>  // b.pmore
MAKE_REG_HELPER(csselr_el1);
    400087fc:	d2800000 	mov	x0, #0x0                   	// #0
    40008800:	d51a0000 	msr	csselr_el1, x0
		}
	}

	/* Restore csselr_el1 to level 0 */
	write_csselr_el1(0);
	dsb();
    40008804:	d5033f9f 	dsb	sy
	isb();
    40008808:	d5033fdf 	isb

	return 0;
}
    4000880c:	d65f03c0 	ret
				} else if (op == K_CACHE_WB_INVD) {
    40008810:	71000c1f 	cmp	w0, #0x3
    40008814:	54000061 	b.ne	40008820 <arch_dcache_all+0xcc>  // b.any
					dc_ops("cisw", dc_val);
    40008818:	d5087e43 	dc	cisw, x3
    4000881c:	17ffffef 	b	400087d8 <arch_dcache_all+0x84>
				} else if (op == K_CACHE_WB) {
    40008820:	7100041f 	cmp	w0, #0x1
    40008824:	54fffda1 	b.ne	400087d8 <arch_dcache_all+0x84>  // b.any
					dc_ops("csw", dc_val);
    40008828:	d5087a43 	dc	csw, x3
    4000882c:	17ffffeb 	b	400087d8 <arch_dcache_all+0x84>
		return -ENOTSUP;
    40008830:	128010a0 	mov	w0, #0xffffff7a            	// #-134
    40008834:	17fffff6 	b	4000880c <arch_dcache_all+0xb8>
		return 0;
    40008838:	52800000 	mov	w0, #0x0                   	// #0
    4000883c:	17fffff4 	b	4000880c <arch_dcache_all+0xb8>

0000000040008840 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
    40008840:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40008844:	aa0003e6 	mov	x6, x0
    40008848:	910003fd 	mov	x29, sp
    4000884c:	a90153f3 	stp	x19, x20, [sp, #16]
	register const char *s = nptr;
    40008850:	aa0003f3 	mov	x19, x0
{
    40008854:	f90013f5 	str	x21, [sp, #32]
    40008858:	aa0103f5 	mov	x21, x1
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
    4000885c:	aa1303e0 	mov	x0, x19
    40008860:	38401663 	ldrb	w3, [x19], #1
    40008864:	51002461 	sub	w1, w3, #0x9
    40008868:	7100807f 	cmp	w3, #0x20
	} while (isspace(c));
    4000886c:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    40008870:	54ffff69 	b.ls	4000885c <strtol+0x1c>  // b.plast
	if (c == '-') {
    40008874:	7100b47f 	cmp	w3, #0x2d
    40008878:	54000541 	b.ne	40008920 <strtol+0xe0>  // b.any
		neg = 1;
		c = *s++;
    4000887c:	39400263 	ldrb	w3, [x19]
    40008880:	91000813 	add	x19, x0, #0x2
		neg = 1;
    40008884:	52800021 	mov	w1, #0x1                   	// #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
    40008888:	721b785f 	tst	w2, #0xffffffef
    4000888c:	54000161 	b.ne	400088b8 <strtol+0x78>  // b.any
    40008890:	7100c07f 	cmp	w3, #0x30
    40008894:	540008c1 	b.ne	400089ac <strtol+0x16c>  // b.any
	    c == '0' && (*s == 'x' || *s == 'X')) {
    40008898:	39400260 	ldrb	w0, [x19]
    4000889c:	121a7800 	and	w0, w0, #0xffffffdf
    400088a0:	12001c00 	and	w0, w0, #0xff
    400088a4:	7101601f 	cmp	w0, #0x58
    400088a8:	540008a1 	b.ne	400089bc <strtol+0x17c>  // b.any
		c = s[1];
    400088ac:	39400663 	ldrb	w3, [x19, #1]
		s += 2;
    400088b0:	91000a73 	add	x19, x19, #0x2
		base = 16;
    400088b4:	52800202 	mov	w2, #0x10                  	// #16
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    400088b8:	92f00014 	mov	x20, #0x7fffffffffffffff    	// #9223372036854775807
	cutlim = cutoff % (unsigned long)base;
    400088bc:	93407c47 	sxtw	x7, w2
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    400088c0:	8b21c294 	add	x20, x20, w1, sxtw
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
    400088c4:	52800005 	mov	w5, #0x0                   	// #0
    400088c8:	d2800000 	mov	x0, #0x0                   	// #0
		if (isdigit(c)) {
			c -= '0';
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    400088cc:	528006ea 	mov	w10, #0x37                  	// #55
    400088d0:	52800aeb 	mov	w11, #0x57                  	// #87
	cutlim = cutoff % (unsigned long)base;
    400088d4:	9ac70a88 	udiv	x8, x20, x7
    400088d8:	1b07d109 	msub	w9, w8, w7, w20
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    400088dc:	5100c064 	sub	w4, w3, #0x30
		if (isdigit(c)) {
    400088e0:	7100249f 	cmp	w4, #0x9
    400088e4:	540002a8 	b.hi	40008938 <strtol+0xf8>  // b.pmore
			c -= '0';
    400088e8:	2a0403e3 	mov	w3, w4
		} else {
			break;
		}
		if (c >= base) {
    400088ec:	6b03005f 	cmp	w2, w3
    400088f0:	540003ad 	b.le	40008964 <strtol+0x124>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
    400088f4:	710000bf 	cmp	w5, #0x0
    400088f8:	fa48a002 	ccmp	x0, x8, #0x2, ge  // ge = tcont
    400088fc:	54000308 	b.hi	4000895c <strtol+0x11c>  // b.pmore
    40008900:	eb08001f 	cmp	x0, x8
    40008904:	7a490064 	ccmp	w3, w9, #0x4, eq  // eq = none
    40008908:	540002ac 	b.gt	4000895c <strtol+0x11c>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
    4000890c:	93407c63 	sxtw	x3, w3
			any = 1;
    40008910:	52800025 	mov	w5, #0x1                   	// #1
			acc += c;
    40008914:	9b000ce0 	madd	x0, x7, x0, x3
	for (acc = 0, any = 0;; c = *s++) {
    40008918:	38401663 	ldrb	w3, [x19], #1
		if (isdigit(c)) {
    4000891c:	17fffff0 	b	400088dc <strtol+0x9c>
	} else if (c == '+') {
    40008920:	7100ac7f 	cmp	w3, #0x2b
    40008924:	54000061 	b.ne	40008930 <strtol+0xf0>  // b.any
		c = *s++;
    40008928:	39400263 	ldrb	w3, [x19]
    4000892c:	91000813 	add	x19, x0, #0x2
	register int neg = 0, any, cutlim;
    40008930:	52800001 	mov	w1, #0x0                   	// #0
    40008934:	17ffffd5 	b	40008888 <strtol+0x48>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    40008938:	321b0064 	orr	w4, w3, #0x20
    4000893c:	51018484 	sub	w4, w4, #0x61
		} else if (isalpha(c)) {
    40008940:	7100649f 	cmp	w4, #0x19
    40008944:	54000108 	b.hi	40008964 <strtol+0x124>  // b.pmore
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    40008948:	51010464 	sub	w4, w3, #0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    4000894c:	7100689f 	cmp	w4, #0x1a
    40008950:	1a8b3144 	csel	w4, w10, w11, cc  // cc = lo, ul, last
    40008954:	4b040063 	sub	w3, w3, w4
    40008958:	17ffffe5 	b	400088ec <strtol+0xac>
			any = -1;
    4000895c:	12800005 	mov	w5, #0xffffffff            	// #-1
    40008960:	17ffffee 	b	40008918 <strtol+0xd8>
		}
	}

	if (any < 0) {
    40008964:	310004bf 	cmn	w5, #0x1
    40008968:	54000141 	b.ne	40008990 <strtol+0x150>  // b.any
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
    4000896c:	94000434 	bl	40009a3c <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
    40008970:	52800441 	mov	w1, #0x22                  	// #34
    40008974:	b9000001 	str	w1, [x0]
		acc = neg ? LONG_MIN : LONG_MAX;
    40008978:	aa1403e0 	mov	x0, x20
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
    4000897c:	b5000135 	cbnz	x21, 400089a0 <strtol+0x160>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
    40008980:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008984:	f94013f5 	ldr	x21, [sp, #32]
    40008988:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000898c:	d65f03c0 	ret
	} else if (neg) {
    40008990:	34000041 	cbz	w1, 40008998 <strtol+0x158>
		acc = -acc;
    40008994:	cb0003e0 	neg	x0, x0
	if (endptr != NULL) {
    40008998:	b4ffff55 	cbz	x21, 40008980 <strtol+0x140>
		*endptr = (char *)(any ? s - 1 : nptr);
    4000899c:	34000045 	cbz	w5, 400089a4 <strtol+0x164>
    400089a0:	d1000666 	sub	x6, x19, #0x1
    400089a4:	f90002a6 	str	x6, [x21]
	return acc;
    400089a8:	17fffff6 	b	40008980 <strtol+0x140>
		base = c == '0' ? 8 : 10;
    400089ac:	7100005f 	cmp	w2, #0x0
    400089b0:	52800140 	mov	w0, #0xa                   	// #10
    400089b4:	1a801042 	csel	w2, w2, w0, ne  // ne = any
    400089b8:	17ffffc0 	b	400088b8 <strtol+0x78>
    400089bc:	7100005f 	cmp	w2, #0x0
    400089c0:	52800100 	mov	w0, #0x8                   	// #8
    400089c4:	17fffffc 	b	400089b4 <strtol+0x174>

00000000400089c8 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
    400089c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400089cc:	aa0003e6 	mov	x6, x0
    400089d0:	910003fd 	mov	x29, sp
    400089d4:	a90153f3 	stp	x19, x20, [sp, #16]
    400089d8:	aa0103f4 	mov	x20, x1
	register const char *s = nptr;
    400089dc:	aa0003f3 	mov	x19, x0

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
    400089e0:	aa1303e0 	mov	x0, x19
    400089e4:	38401663 	ldrb	w3, [x19], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    400089e8:	51002461 	sub	w1, w3, #0x9
    400089ec:	7100807f 	cmp	w3, #0x20
	} while (isspace(c));
    400089f0:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    400089f4:	54ffff69 	b.ls	400089e0 <strtoul+0x18>  // b.plast
	if (c == '-') {
    400089f8:	7100b47f 	cmp	w3, #0x2d
    400089fc:	54000541 	b.ne	40008aa4 <strtoul+0xdc>  // b.any
		neg = 1;
		c = *s++;
    40008a00:	39400263 	ldrb	w3, [x19]
    40008a04:	91000813 	add	x19, x0, #0x2
		neg = 1;
    40008a08:	52800027 	mov	w7, #0x1                   	// #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
    40008a0c:	721b785f 	tst	w2, #0xffffffef
    40008a10:	54000161 	b.ne	40008a3c <strtoul+0x74>  // b.any
    40008a14:	7100c07f 	cmp	w3, #0x30
    40008a18:	54000921 	b.ne	40008b3c <strtoul+0x174>  // b.any
	    c == '0' && (*s == 'x' || *s == 'X')) {
    40008a1c:	39400260 	ldrb	w0, [x19]
    40008a20:	121a7800 	and	w0, w0, #0xffffffdf
    40008a24:	12001c00 	and	w0, w0, #0xff
    40008a28:	7101601f 	cmp	w0, #0x58
    40008a2c:	54000801 	b.ne	40008b2c <strtoul+0x164>  // b.any
		c = s[1];
    40008a30:	39400663 	ldrb	w3, [x19, #1]
		s += 2;
    40008a34:	91000a73 	add	x19, x19, #0x2
		base = 16;
    40008a38:	52800202 	mov	w2, #0x10                  	// #16

	if (base == 0) {
		base = c == '0' ? 8 : 10;
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    40008a3c:	93407c48 	sxtw	x8, w2
    40008a40:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
    40008a44:	52800005 	mov	w5, #0x0                   	// #0
    40008a48:	d2800000 	mov	x0, #0x0                   	// #0
		if (isdigit(c)) {
			c -= '0';
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    40008a4c:	528006ea 	mov	w10, #0x37                  	// #55
    40008a50:	52800aeb 	mov	w11, #0x57                  	// #87
	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    40008a54:	9ac80821 	udiv	x1, x1, x8
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
    40008a58:	9b087c29 	mul	x9, x1, x8
    40008a5c:	2a2903e9 	mvn	w9, w9
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    40008a60:	5100c064 	sub	w4, w3, #0x30
		if (isdigit(c)) {
    40008a64:	7100249f 	cmp	w4, #0x9
    40008a68:	540002a8 	b.hi	40008abc <strtoul+0xf4>  // b.pmore
			c -= '0';
    40008a6c:	2a0403e3 	mov	w3, w4
		} else {
			break;
		}
		if (c >= base) {
    40008a70:	6b03005f 	cmp	w2, w3
    40008a74:	540003ad 	b.le	40008ae8 <strtoul+0x120>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
    40008a78:	710000bf 	cmp	w5, #0x0
    40008a7c:	fa41a002 	ccmp	x0, x1, #0x2, ge  // ge = tcont
    40008a80:	54000308 	b.hi	40008ae0 <strtoul+0x118>  // b.pmore
    40008a84:	eb01001f 	cmp	x0, x1
    40008a88:	7a490064 	ccmp	w3, w9, #0x4, eq  // eq = none
    40008a8c:	540002ac 	b.gt	40008ae0 <strtoul+0x118>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
    40008a90:	93407c63 	sxtw	x3, w3
			any = 1;
    40008a94:	52800025 	mov	w5, #0x1                   	// #1
			acc += c;
    40008a98:	9b000d00 	madd	x0, x8, x0, x3
	for (acc = 0, any = 0;; c = *s++) {
    40008a9c:	38401663 	ldrb	w3, [x19], #1
		if (isdigit(c)) {
    40008aa0:	17fffff0 	b	40008a60 <strtoul+0x98>
	} else if (c == '+') {
    40008aa4:	7100ac7f 	cmp	w3, #0x2b
    40008aa8:	54000061 	b.ne	40008ab4 <strtoul+0xec>  // b.any
		c = *s++;
    40008aac:	39400263 	ldrb	w3, [x19]
    40008ab0:	91000813 	add	x19, x0, #0x2
	register int neg = 0, any, cutlim;
    40008ab4:	52800007 	mov	w7, #0x0                   	// #0
    40008ab8:	17ffffd5 	b	40008a0c <strtoul+0x44>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    40008abc:	321b0064 	orr	w4, w3, #0x20
    40008ac0:	51018484 	sub	w4, w4, #0x61
		} else if (isalpha(c)) {
    40008ac4:	7100649f 	cmp	w4, #0x19
    40008ac8:	54000108 	b.hi	40008ae8 <strtoul+0x120>  // b.pmore
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    40008acc:	51010464 	sub	w4, w3, #0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    40008ad0:	7100689f 	cmp	w4, #0x1a
    40008ad4:	1a8b3144 	csel	w4, w10, w11, cc  // cc = lo, ul, last
    40008ad8:	4b040063 	sub	w3, w3, w4
    40008adc:	17ffffe5 	b	40008a70 <strtoul+0xa8>
			any = -1;
    40008ae0:	12800005 	mov	w5, #0xffffffff            	// #-1
    40008ae4:	17ffffee 	b	40008a9c <strtoul+0xd4>
		}
	}
	if (any < 0) {
    40008ae8:	310004bf 	cmn	w5, #0x1
    40008aec:	54000121 	b.ne	40008b10 <strtoul+0x148>  // b.any
    40008af0:	940003d3 	bl	40009a3c <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
    40008af4:	52800441 	mov	w1, #0x22                  	// #34
    40008af8:	b9000001 	str	w1, [x0]
		acc = ULONG_MAX;
    40008afc:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
    40008b00:	b5000114 	cbnz	x20, 40008b20 <strtoul+0x158>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
    40008b04:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008b08:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40008b0c:	d65f03c0 	ret
	} else if (neg) {
    40008b10:	34000047 	cbz	w7, 40008b18 <strtoul+0x150>
		acc = -acc;
    40008b14:	cb0003e0 	neg	x0, x0
	if (endptr != NULL) {
    40008b18:	b4ffff74 	cbz	x20, 40008b04 <strtoul+0x13c>
		*endptr = (char *)(any ? s - 1 : nptr);
    40008b1c:	34000045 	cbz	w5, 40008b24 <strtoul+0x15c>
    40008b20:	d1000666 	sub	x6, x19, #0x1
    40008b24:	f9000286 	str	x6, [x20]
	return acc;
    40008b28:	17fffff7 	b	40008b04 <strtoul+0x13c>
		base = c == '0' ? 8 : 10;
    40008b2c:	7100005f 	cmp	w2, #0x0
    40008b30:	52800100 	mov	w0, #0x8                   	// #8
    40008b34:	1a801042 	csel	w2, w2, w0, ne  // ne = any
    40008b38:	17ffffc1 	b	40008a3c <strtoul+0x74>
    40008b3c:	7100005f 	cmp	w2, #0x0
    40008b40:	52800140 	mov	w0, #0xa                   	// #10
    40008b44:	17fffffc 	b	40008b34 <strtoul+0x16c>

0000000040008b48 <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
    40008b48:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40008b4c:	910003fd 	mov	x29, sp
    40008b50:	a90153f3 	stp	x19, x20, [sp, #16]
    40008b54:	aa0003f4 	mov	x20, x0
    40008b58:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008b5c:	f9001bf7 	str	x23, [sp, #48]
	char c, sc;
	size_t len;

	c = *find++;
    40008b60:	39400037 	ldrb	w23, [x1]
	if (c != 0) {
    40008b64:	340001f7 	cbz	w23, 40008ba0 <strstr+0x58>
	c = *find++;
    40008b68:	91000433 	add	x19, x1, #0x1
		len = strlen(find);
    40008b6c:	aa1303e0 	mov	x0, x19
    40008b70:	94000039 	bl	40008c54 <strlen>
    40008b74:	aa0003f6 	mov	x22, x0
		do {
			do {
				sc = *s++;
    40008b78:	aa1403f5 	mov	x21, x20
    40008b7c:	384016a0 	ldrb	w0, [x21], #1
				if (sc == 0) {
    40008b80:	34000200 	cbz	w0, 40008bc0 <strstr+0x78>
					return NULL;
				}
			} while (sc != c);
    40008b84:	6b0002ff 	cmp	w23, w0
    40008b88:	54000181 	b.ne	40008bb8 <strstr+0x70>  // b.any
		} while (strncmp(s, find, len) != 0);
    40008b8c:	aa1603e2 	mov	x2, x22
    40008b90:	aa1303e1 	mov	x1, x19
    40008b94:	aa1503e0 	mov	x0, x21
    40008b98:	94000048 	bl	40008cb8 <strncmp>
    40008b9c:	350000e0 	cbnz	w0, 40008bb8 <strstr+0x70>
	s--;
	}
	return (char *)s;
}
    40008ba0:	aa1403e0 	mov	x0, x20
    40008ba4:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008ba8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008bac:	f9401bf7 	ldr	x23, [sp, #48]
    40008bb0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40008bb4:	d65f03c0 	ret
{
    40008bb8:	aa1503f4 	mov	x20, x21
    40008bbc:	17ffffef 	b	40008b78 <strstr+0x30>
					return NULL;
    40008bc0:	d2800014 	mov	x20, #0x0                   	// #0
    40008bc4:	17fffff7 	b	40008ba0 <strstr+0x58>

0000000040008bc8 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
    40008bc8:	d2800002 	mov	x2, #0x0                   	// #0
    40008bcc:	38626823 	ldrb	w3, [x1, x2]
    40008bd0:	8b020004 	add	x4, x0, x2
    40008bd4:	35000063 	cbnz	w3, 40008be0 <strcpy+0x18>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
    40008bd8:	3900009f 	strb	wzr, [x4]

	return dest;
}
    40008bdc:	d65f03c0 	ret
		*d = *s;
    40008be0:	38226803 	strb	w3, [x0, x2]
		s++;
    40008be4:	91000442 	add	x2, x2, #0x1
    40008be8:	17fffff9 	b	40008bcc <strcpy+0x4>

0000000040008bec <strncpy>:

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    40008bec:	d2800003 	mov	x3, #0x0                   	// #0
    40008bf0:	cb030045 	sub	x5, x2, x3
    40008bf4:	8b030006 	add	x6, x0, x3
    40008bf8:	eb02007f 	cmp	x3, x2
    40008bfc:	54000100 	b.eq	40008c1c <strncpy+0x30>  // b.none
    40008c00:	38636824 	ldrb	w4, [x1, x3]
    40008c04:	350000e4 	cbnz	w4, 40008c20 <strncpy+0x34>
    40008c08:	d2800001 	mov	x1, #0x0                   	// #0
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
    40008c0c:	382168df 	strb	wzr, [x6, x1]
	while (n > 0) {
    40008c10:	91000421 	add	x1, x1, #0x1
    40008c14:	eb05003f 	cmp	x1, x5
    40008c18:	54ffffa1 	b.ne	40008c0c <strncpy+0x20>  // b.any
		d++;
		n--;
	}

	return dest;
}
    40008c1c:	d65f03c0 	ret
		*d = *s;
    40008c20:	38236804 	strb	w4, [x0, x3]
		n--;
    40008c24:	91000463 	add	x3, x3, #0x1
    40008c28:	17fffff2 	b	40008bf0 <strncpy+0x4>

0000000040008c2c <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
    40008c2c:	12001c21 	and	w1, w1, #0xff

	while ((*s != tmp) && (*s != '\0')) {
    40008c30:	39400002 	ldrb	w2, [x0]
    40008c34:	6b01005f 	cmp	w2, w1
    40008c38:	54000080 	b.eq	40008c48 <strchr+0x1c>  // b.none
    40008c3c:	35000082 	cbnz	w2, 40008c4c <strchr+0x20>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
    40008c40:	7100003f 	cmp	w1, #0x0
    40008c44:	9a9f0000 	csel	x0, x0, xzr, eq  // eq = none
}
    40008c48:	d65f03c0 	ret
		s++;
    40008c4c:	91000400 	add	x0, x0, #0x1
    40008c50:	17fffff8 	b	40008c30 <strchr+0x4>

0000000040008c54 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    40008c54:	aa0003e1 	mov	x1, x0
	size_t n = 0;
    40008c58:	d2800000 	mov	x0, #0x0                   	// #0

	while (*s != '\0') {
    40008c5c:	38606822 	ldrb	w2, [x1, x0]
    40008c60:	35000042 	cbnz	w2, 40008c68 <strlen+0x14>
		s++;
		n++;
	}

	return n;
}
    40008c64:	d65f03c0 	ret
		n++;
    40008c68:	91000400 	add	x0, x0, #0x1
    40008c6c:	17fffffc 	b	40008c5c <strlen+0x8>

0000000040008c70 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    40008c70:	aa0003e2 	mov	x2, x0
	size_t n = 0;
    40008c74:	d2800000 	mov	x0, #0x0                   	// #0

	while (*s != '\0' && n < maxlen) {
    40008c78:	38606843 	ldrb	w3, [x2, x0]
    40008c7c:	34000063 	cbz	w3, 40008c88 <strnlen+0x18>
    40008c80:	eb01001f 	cmp	x0, x1
    40008c84:	54000041 	b.ne	40008c8c <strnlen+0x1c>  // b.any
		s++;
		n++;
	}

	return n;
}
    40008c88:	d65f03c0 	ret
		n++;
    40008c8c:	91000400 	add	x0, x0, #0x1
    40008c90:	17fffffa 	b	40008c78 <strnlen+0x8>

0000000040008c94 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    40008c94:	d2800002 	mov	x2, #0x0                   	// #0
    40008c98:	38626803 	ldrb	w3, [x0, x2]
    40008c9c:	38626824 	ldrb	w4, [x1, x2]
    40008ca0:	6b04007f 	cmp	w3, w4
    40008ca4:	54000061 	b.ne	40008cb0 <strcmp+0x1c>  // b.any
    40008ca8:	91000442 	add	x2, x2, #0x1
    40008cac:	35ffff63 	cbnz	w3, 40008c98 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    40008cb0:	4b040060 	sub	w0, w3, w4
    40008cb4:	d65f03c0 	ret

0000000040008cb8 <strncmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    40008cb8:	d2800004 	mov	x4, #0x0                   	// #0
    40008cbc:	eb04005f 	cmp	x2, x4
    40008cc0:	54000120 	b.eq	40008ce4 <strncmp+0x2c>  // b.none
    40008cc4:	38646803 	ldrb	w3, [x0, x4]
    40008cc8:	38646825 	ldrb	w5, [x1, x4]
    40008ccc:	6b05007f 	cmp	w3, w5
    40008cd0:	54000061 	b.ne	40008cdc <strncmp+0x24>  // b.any
    40008cd4:	91000484 	add	x4, x4, #0x1
    40008cd8:	35ffff23 	cbnz	w3, 40008cbc <strncmp+0x4>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
    40008cdc:	4b050060 	sub	w0, w3, w5
    40008ce0:	14000002 	b	40008ce8 <strncmp+0x30>
    40008ce4:	52800000 	mov	w0, #0x0                   	// #0
}
    40008ce8:	d65f03c0 	ret

0000000040008cec <memcmp>:
int memcmp(const void *m1, const void *m2, size_t n)
{
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
    40008cec:	b4000182 	cbz	x2, 40008d1c <memcmp+0x30>
    40008cf0:	d1000442 	sub	x2, x2, #0x1
    40008cf4:	d2800004 	mov	x4, #0x0                   	// #0
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
    40008cf8:	38646803 	ldrb	w3, [x0, x4]
    40008cfc:	eb04005f 	cmp	x2, x4
    40008d00:	38646825 	ldrb	w5, [x1, x4]
    40008d04:	54000080 	b.eq	40008d14 <memcmp+0x28>  // b.none
    40008d08:	91000484 	add	x4, x4, #0x1
    40008d0c:	6b05007f 	cmp	w3, w5
    40008d10:	54ffff40 	b.eq	40008cf8 <memcmp+0xc>  // b.none
		c1++;
		c2++;
	}

	return *c1 - *c2;
    40008d14:	4b050060 	sub	w0, w3, w5
}
    40008d18:	d65f03c0 	ret
		return 0;
    40008d1c:	52800000 	mov	w0, #0x0                   	// #0
    40008d20:	17fffffe 	b	40008d18 <memcmp+0x2c>

0000000040008d24 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
    40008d24:	cb010003 	sub	x3, x0, x1
    40008d28:	eb02007f 	cmp	x3, x2
    40008d2c:	54000163 	b.cc	40008d58 <memmove+0x34>  // b.lo, b.ul, b.last
    40008d30:	d2800003 	mov	x3, #0x0                   	// #0
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
    40008d34:	eb03005f 	cmp	x2, x3
    40008d38:	54000120 	b.eq	40008d5c <memmove+0x38>  // b.none
			*dest = *src;
    40008d3c:	38636824 	ldrb	w4, [x1, x3]
    40008d40:	38236804 	strb	w4, [x0, x3]
			dest++;
			src++;
			n--;
    40008d44:	91000463 	add	x3, x3, #0x1
    40008d48:	17fffffb 	b	40008d34 <memmove+0x10>
			n--;
    40008d4c:	d1000442 	sub	x2, x2, #0x1
			dest[n] = src[n];
    40008d50:	38626823 	ldrb	w3, [x1, x2]
    40008d54:	38226803 	strb	w3, [x0, x2]
		while (n > 0) {
    40008d58:	b5ffffa2 	cbnz	x2, 40008d4c <memmove+0x28>
		}
	}

	return d;
}
    40008d5c:	d65f03c0 	ret

0000000040008d60 <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
    40008d60:	d2800003 	mov	x3, #0x0                   	// #0
    40008d64:	eb03005f 	cmp	x2, x3
    40008d68:	54000041 	b.ne	40008d70 <memcpy+0x10>  // b.any
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    40008d6c:	d65f03c0 	ret
		*(d_byte++) = *(s_byte++);
    40008d70:	38636824 	ldrb	w4, [x1, x3]
    40008d74:	38236804 	strb	w4, [x0, x3]
		n--;
    40008d78:	91000463 	add	x3, x3, #0x1
    40008d7c:	17fffffa 	b	40008d64 <memcpy+0x4>

0000000040008d80 <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    40008d80:	12001c21 	and	w1, w1, #0xff
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    40008d84:	d2800003 	mov	x3, #0x0                   	// #0
    40008d88:	eb03005f 	cmp	x2, x3
    40008d8c:	54000041 	b.ne	40008d94 <memset+0x14>  // b.any
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    40008d90:	d65f03c0 	ret
		*(d_byte++) = c_byte;
    40008d94:	38236801 	strb	w1, [x0, x3]
		n--;
    40008d98:	91000463 	add	x3, x3, #0x1
    40008d9c:	17fffffb 	b	40008d88 <memset+0x8>

0000000040008da0 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
    40008da0:	12800000 	mov	w0, #0xffffffff            	// #-1
    40008da4:	d65f03c0 	ret

0000000040008da8 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    40008da8:	d00002e1 	adrp	x1, 40066000 <sys_work_q_stack+0x3d0>
    40008dac:	f9079c20 	str	x0, [x1, #3896]
}
    40008db0:	d65f03c0 	ret

0000000040008db4 <sprintf_out>:
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
	if (p->len > 1) { /* need to reserve a byte for EOS */
    40008db4:	b9400822 	ldr	w2, [x1, #8]
    40008db8:	7100045f 	cmp	w2, #0x1
    40008dbc:	5400012d 	b.le	40008de0 <sprintf_out+0x2c>
		*(p->ptr) = c;
    40008dc0:	f9400022 	ldr	x2, [x1]
    40008dc4:	39000040 	strb	w0, [x2]
		p->ptr += 1;
    40008dc8:	f9400020 	ldr	x0, [x1]
    40008dcc:	91000400 	add	x0, x0, #0x1
    40008dd0:	f9000020 	str	x0, [x1]
		p->len -= 1;
    40008dd4:	b9400820 	ldr	w0, [x1, #8]
    40008dd8:	51000400 	sub	w0, w0, #0x1
    40008ddc:	b9000820 	str	w0, [x1, #8]
	}
	return 0; /* indicate keep going so we get the total count */
}
    40008de0:	52800000 	mov	w0, #0x0                   	// #0
    40008de4:	d65f03c0 	ret

0000000040008de8 <snprintf>:

int snprintf(char *ZRESTRICT str, size_t len,
	     const char *ZRESTRICT format, ...)
{
    40008de8:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
    40008dec:	910003fd 	mov	x29, sp
    40008df0:	3d801fe0 	str	q0, [sp, #112]
    40008df4:	3d8023e1 	str	q1, [sp, #128]
    40008df8:	3d8027e2 	str	q2, [sp, #144]
    40008dfc:	3d802be3 	str	q3, [sp, #160]
    40008e00:	3d802fe4 	str	q4, [sp, #176]
    40008e04:	3d8033e5 	str	q5, [sp, #192]
    40008e08:	3d8037e6 	str	q6, [sp, #208]
    40008e0c:	3d803be7 	str	q7, [sp, #224]
    40008e10:	a90f93e3 	stp	x3, x4, [sp, #248]
    40008e14:	a9109be5 	stp	x5, x6, [sp, #264]
    40008e18:	f9008fe7 	str	x7, [sp, #280]

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
    40008e1c:	b5000041 	cbnz	x1, 40008e24 <snprintf+0x3c>
		str = &dummy; /* write final NUL to dummy, can't change *s */
    40008e20:	9100ffe0 	add	x0, sp, #0x3f
	}

	p.ptr = str;
    40008e24:	f90023e0 	str	x0, [sp, #64]
	p.len = (int) len;

	va_start(vargs, format);
    40008e28:	910483e0 	add	x0, sp, #0x120
    40008e2c:	a90503e0 	stp	x0, x0, [sp, #80]
    40008e30:	9103c3e0 	add	x0, sp, #0xf0
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
    40008e34:	910043e3 	add	x3, sp, #0x10
	va_start(vargs, format);
    40008e38:	f90033e0 	str	x0, [sp, #96]
    40008e3c:	128004e0 	mov	w0, #0xffffffd8            	// #-40
    40008e40:	b9006be0 	str	w0, [sp, #104]
    40008e44:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    40008e48:	b9006fe0 	str	w0, [sp, #108]
	p.len = (int) len;
    40008e4c:	b9004be1 	str	w1, [sp, #72]
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
    40008e50:	a94507e0 	ldp	x0, x1, [sp, #80]
    40008e54:	a90107e0 	stp	x0, x1, [sp, #16]
    40008e58:	a94607e0 	ldp	x0, x1, [sp, #96]
    40008e5c:	a90207e0 	stp	x0, x1, [sp, #32]
    40008e60:	910103e1 	add	x1, sp, #0x40
    40008e64:	90000000 	adrp	x0, 40008000 <z_arm64_exit_exc_fpu_done+0x38>
    40008e68:	9136d000 	add	x0, x0, #0xdb4
    40008e6c:	97ffe2fa 	bl	40001a54 <cbvprintf>
	va_end(vargs);

	*(p.ptr) = 0;
    40008e70:	f94023e1 	ldr	x1, [sp, #64]
    40008e74:	3900003f 	strb	wzr, [x1]
	return r;
}
    40008e78:	a8d27bfd 	ldp	x29, x30, [sp], #288
    40008e7c:	d65f03c0 	ret

0000000040008e80 <gic_get_rdist>:
MAKE_REG_HELPER(tpidrro_el0);
    40008e80:	d53bd060 	mrs	x0, tpidrro_el0
	return (_cpu_t *)(read_tpidrro_el0() & TPIDRROEL0_CURR_CPU);
    40008e84:	927db000 	and	x0, x0, #0xfffffffffff8
atomic_t nlpi_intid = ATOMIC_INIT(8192);
#endif

static inline mem_addr_t gic_get_rdist(void)
{
	return gic_rdists[arch_curr_cpu()->id];
    40008e88:	39409001 	ldrb	w1, [x0, #36]
}
    40008e8c:	d0000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    40008e90:	9108e000 	add	x0, x0, #0x238
    40008e94:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    40008e98:	d65f03c0 	ret

0000000040008e9c <gic_wait_rwp.isra.0>:
static int gic_wait_rwp(uint32_t intid)
{
	uint32_t rwp_mask;
	mem_addr_t base;

	if (intid < GIC_SPI_INT_BASE) {
    40008e9c:	71007c1f 	cmp	w0, #0x1f
    40008ea0:	54000168 	b.hi	40008ecc <gic_wait_rwp.isra.0+0x30>  // b.pmore
static int gic_wait_rwp(uint32_t intid)
    40008ea4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40008ea8:	910003fd 	mov	x29, sp
		base = (gic_get_rdist() + GICR_CTLR);
    40008eac:	97fffff5 	bl	40008e80 <gic_get_rdist>
		rwp_mask = BIT(GICR_CTLR_RWP);
    40008eb0:	52800101 	mov	w1, #0x8                   	// #8
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    40008eb4:	b9400002 	ldr	w2, [x0]
	__DMB();
    40008eb8:	d5033fbf 	dmb	sy
	} else {
		base = GICD_CTLR;
		rwp_mask = BIT(GICD_CTLR_RWP);
	}

	while (sys_read32(base) & rwp_mask)
    40008ebc:	6a01005f 	tst	w2, w1
    40008ec0:	54ffffa1 	b.ne	40008eb4 <gic_wait_rwp.isra.0+0x18>  // b.any
		;

	return 0;
}
    40008ec4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40008ec8:	d65f03c0 	ret
		base = GICD_CTLR;
    40008ecc:	d2a10000 	mov	x0, #0x8000000             	// #134217728
		rwp_mask = BIT(GICD_CTLR_RWP);
    40008ed0:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    40008ed4:	b9400002 	ldr	w2, [x0]
	__DMB();
    40008ed8:	d5033fbf 	dmb	sy
	while (sys_read32(base) & rwp_mask)
    40008edc:	6a01005f 	tst	w2, w1
    40008ee0:	54ffffa1 	b.ne	40008ed4 <gic_wait_rwp.isra.0+0x38>  // b.any
    40008ee4:	d65f03c0 	ret

0000000040008ee8 <arm_gic_init>:

	gicv3_cpuif_init();
}

int arm_gic_init(const struct device *unused)
{
    40008ee8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    40008eec:	d2800083 	mov	x3, #0x4                   	// #4
    40008ef0:	f2a10003 	movk	x3, #0x800, lsl #16
    40008ef4:	910003fd 	mov	x29, sp
    40008ef8:	b9400063 	ldr	w3, [x3]
	__DMB();
    40008efc:	d5033fbf 	dmb	sy
	num_ints = (num_ints + 1) << 5;
    40008f00:	531b1063 	ubfiz	w3, w3, #5, #5
    40008f04:	11008063 	add	w3, w3, #0x20
	__DMB();
    40008f08:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40008f0c:	52800000 	mov	w0, #0x0                   	// #0
    40008f10:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    40008f14:	b9000020 	str	w0, [x1]
	gic_wait_rwp(GIC_SPI_INT_BASE);
    40008f18:	52800400 	mov	w0, #0x20                  	// #32
    40008f1c:	97ffffe0 	bl	40008e9c <gic_wait_rwp.isra.0>
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    40008f20:	52803005 	mov	w5, #0x180                 	// #384
    40008f24:	72a10005 	movk	w5, #0x800, lsl #16
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    40008f28:	52805006 	mov	w6, #0x280                 	// #640
    40008f2c:	72a10006 	movk	w6, #0x800, lsl #16
		sys_write32(IGROUPR_VAL, IGROUPR(base, idx));
    40008f30:	52801008 	mov	w8, #0x80                  	// #128
    40008f34:	72a10008 	movk	w8, #0x800, lsl #16
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    40008f38:	5281a009 	mov	w9, #0xd00                 	// #3328
    40008f3c:	72a10009 	movk	w9, #0x800, lsl #16
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    40008f40:	52800401 	mov	w1, #0x20                  	// #32
    40008f44:	12800002 	mov	w2, #0xffffffff            	// #-1
    40008f48:	52800007 	mov	w7, #0x0                   	// #0
    40008f4c:	6b01007f 	cmp	w3, w1
    40008f50:	54000ba8 	b.hi	400090c4 <arm_gic_init+0x1dc>  // b.pmore
	gic_wait_rwp(GIC_SPI_INT_BASE);
    40008f54:	52800400 	mov	w0, #0x20                  	// #32
    40008f58:	97ffffd1 	bl	40008e9c <gic_wait_rwp.isra.0>
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    40008f5c:	d2808400 	mov	x0, #0x420                 	// #1056
    40008f60:	f2a10000 	movk	x0, #0x800, lsl #16
    40008f64:	529f8002 	mov	w2, #0xfc00                	// #64512
    40008f68:	72beffe2 	movk	w2, #0xf7ff, lsl #16
    40008f6c:	52941404 	mov	w4, #0xa0a0                	// #41120
    40008f70:	72b41404 	movk	w4, #0xa0a0, lsl #16
    40008f74:	0b020001 	add	w1, w0, w2
    40008f78:	6b01007f 	cmp	w3, w1
    40008f7c:	54000c48 	b.hi	40009104 <arm_gic_init+0x21c>  // b.pmore
		sys_write32(0, ICFGR(base, idx));
    40008f80:	52818004 	mov	w4, #0xc00                 	// #3072
    40008f84:	72a10004 	movk	w4, #0x800, lsl #16
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    40008f88:	52800401 	mov	w1, #0x20                  	// #32
    40008f8c:	52800002 	mov	w2, #0x0                   	// #0
    40008f90:	6b01007f 	cmp	w3, w1
    40008f94:	54000c08 	b.hi	40009114 <arm_gic_init+0x22c>  // b.pmore
extern "C" {
#endif

static ALWAYS_INLINE void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
    40008f98:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    40008f9c:	b9400020 	ldr	w0, [x1]

	*(volatile uint32_t *)addr = temp | (1 << bit);
    40008fa0:	321e0000 	orr	w0, w0, #0x4
    40008fa4:	b9000020 	str	w0, [x1]
    40008fa8:	d53bd060 	mrs	x0, tpidrro_el0
    40008fac:	927db000 	and	x0, x0, #0xfffffffffff8
	cpu = arch_curr_cpu()->id;
    40008fb0:	39409002 	ldrb	w2, [x0, #36]
	gic_rdists[cpu] = GIC_RDIST_BASE + MPIDR_TO_CORE(GET_MPIDR()) * 0x20000;
    40008fb4:	d53800a0 	mrs	x0, mpidr_el1
    40008fb8:	92401c00 	and	x0, x0, #0xff
    40008fbc:	d0000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    40008fc0:	9108e021 	add	x1, x1, #0x238
    40008fc4:	91101400 	add	x0, x0, #0x405
    40008fc8:	d36fb800 	lsl	x0, x0, #17
    40008fcc:	f822d820 	str	x0, [x1, w2, sxtw #3]
	gicv3_rdist_enable(gic_get_rdist());
    40008fd0:	97ffffac 	bl	40008e80 <gic_get_rdist>
	if (!(sys_read32(rdist + GICR_WAKER) & BIT(GICR_WAKER_CA)))
    40008fd4:	91005002 	add	x2, x0, #0x14
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    40008fd8:	b9400041 	ldr	w1, [x2]
	__DMB();
    40008fdc:	d5033fbf 	dmb	sy
    40008fe0:	361000e1 	tbz	w1, #2, 40008ffc <arm_gic_init+0x114>
}

static ALWAYS_INLINE void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
    40008fe4:	b9401401 	ldr	w1, [x0, #20]

	*(volatile uint32_t *)addr = temp & ~(1 << bit);
    40008fe8:	121e7821 	and	w1, w1, #0xfffffffd
    40008fec:	b9001401 	str	w1, [x0, #20]
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    40008ff0:	b9400040 	ldr	w0, [x2]
	__DMB();
    40008ff4:	d5033fbf 	dmb	sy
	while (sys_read32(rdist + GICR_WAKER) & BIT(GICR_WAKER_CA))
    40008ff8:	3717ffc0 	tbnz	w0, #2, 40008ff0 <arm_gic_init+0x108>
	mem_addr_t base = gic_get_rdist() + GICR_SGI_BASE_OFF;
    40008ffc:	97ffffa1 	bl	40008e80 <gic_get_rdist>
    40009000:	aa0003e3 	mov	x3, x0
	__DMB();
    40009004:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), ICENABLER(base, 0));
    40009008:	91404000 	add	x0, x0, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000900c:	12800004 	mov	w4, #0xffffffff            	// #-1
    40009010:	91060000 	add	x0, x0, #0x180
    40009014:	b9000004 	str	w4, [x0]
	gic_wait_rwp(0);
    40009018:	52800000 	mov	w0, #0x0                   	// #0
    4000901c:	97ffffa0 	bl	40008e9c <gic_wait_rwp.isra.0>
	__DMB();
    40009020:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), ICPENDR(base, 0));
    40009024:	91404060 	add	x0, x3, #0x10, lsl #12
    40009028:	910a0000 	add	x0, x0, #0x280
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000902c:	b9000004 	str	w4, [x0]
	__DMB();
    40009030:	d5033fbf 	dmb	sy
	sys_write32(IGROUPR_VAL, IGROUPR(base, 0));
    40009034:	91404061 	add	x1, x3, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40009038:	52800000 	mov	w0, #0x0                   	// #0
    4000903c:	91020021 	add	x1, x1, #0x80
    40009040:	b9000020 	str	w0, [x1]
	__DMB();
    40009044:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), IGROUPMODR(base, 0));
    40009048:	91404060 	add	x0, x3, #0x10, lsl #12
    4000904c:	91340000 	add	x0, x0, #0xd00
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40009050:	b9000004 	str	w4, [x0]
	for (intid = 0; intid < GIC_SPI_INT_BASE;
    40009054:	91404060 	add	x0, x3, #0x10, lsl #12
    40009058:	91404061 	add	x1, x3, #0x10, lsl #12
    4000905c:	91100000 	add	x0, x0, #0x400
    40009060:	91108021 	add	x1, x1, #0x420
    40009064:	52941402 	mov	w2, #0xa0a0                	// #41120
    40009068:	72b41402 	movk	w2, #0xa0a0, lsl #16
	__DMB();
    4000906c:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40009070:	b9000002 	str	w2, [x0]
    40009074:	91001000 	add	x0, x0, #0x4
    40009078:	eb01001f 	cmp	x0, x1
    4000907c:	54ffff81 	b.ne	4000906c <arm_gic_init+0x184>  // b.any
	__DMB();
    40009080:	d5033fbf 	dmb	sy
	sys_write32(0, ICFGR(base, 1));
    40009084:	91404063 	add	x3, x3, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40009088:	52800000 	mov	w0, #0x0                   	// #0
    4000908c:	91301063 	add	x3, x3, #0xc04
    40009090:	b9000060 	str	w0, [x3]
	icc_sre = read_sysreg(ICC_SRE_EL1);
    40009094:	d538cca0 	mrs	x0, s3_0_c12_c12_5
	if (!(icc_sre & ICC_SRE_ELx_SRE_BIT)) {
    40009098:	37000080 	tbnz	w0, #0, 400090a8 <arm_gic_init+0x1c0>
		icc_sre = (icc_sre | ICC_SRE_ELx_SRE_BIT |
    4000909c:	32000800 	orr	w0, w0, #0x7
		write_sysreg(icc_sre, ICC_SRE_EL1);
    400090a0:	d518cca0 	msr	s3_0_c12_c12_5, x0
		icc_sre = read_sysreg(ICC_SRE_EL1);
    400090a4:	d538cca0 	mrs	x0, s3_0_c12_c12_5
	write_sysreg(GIC_IDLE_PRIO, ICC_PMR_EL1);
    400090a8:	52801fe0 	mov	w0, #0xff                  	// #255
    400090ac:	d5184600 	msr	s3_0_c4_c6_0, x0
	write_sysreg(1, ICC_IGRPEN1_EL1);
    400090b0:	52800020 	mov	w0, #0x1                   	// #1
    400090b4:	d518cce0 	msr	s3_0_c12_c12_7, x0
	gicv3_dist_init();

	__arm_gic_init();

	return 0;
}
    400090b8:	52800000 	mov	w0, #0x0                   	// #0
    400090bc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400090c0:	d65f03c0 	ret
		idx = intid / GIC_NUM_INTR_PER_REG;
    400090c4:	53057c20 	lsr	w0, w1, #5
			    ICENABLER(base, idx));
    400090c8:	531e7400 	lsl	w0, w0, #2
	__DMB();
    400090cc:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    400090d0:	0b050004 	add	w4, w0, w5
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400090d4:	b9000082 	str	w2, [x4]
	__DMB();
    400090d8:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    400090dc:	0b060004 	add	w4, w0, w6
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400090e0:	b9000082 	str	w2, [x4]
	__DMB();
    400090e4:	d5033fbf 	dmb	sy
		sys_write32(IGROUPR_VAL, IGROUPR(base, idx));
    400090e8:	0b080004 	add	w4, w0, w8
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400090ec:	b9000087 	str	w7, [x4]
	__DMB();
    400090f0:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    400090f4:	0b090000 	add	w0, w0, w9
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400090f8:	b9000002 	str	w2, [x0]
	     intid += GIC_NUM_INTR_PER_REG) {
    400090fc:	11008021 	add	w1, w1, #0x20
    40009100:	17ffff93 	b	40008f4c <arm_gic_init+0x64>
	__DMB();
    40009104:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40009108:	b9000004 	str	w4, [x0]
	     intid += GIC_NUM_PRI_PER_REG) {
    4000910c:	91001000 	add	x0, x0, #0x4
    40009110:	17ffff99 	b	40008f74 <arm_gic_init+0x8c>
	__DMB();
    40009114:	d5033fbf 	dmb	sy
		idx = intid / GIC_NUM_CFG_PER_REG;
    40009118:	53047c20 	lsr	w0, w1, #4
		sys_write32(0, ICFGR(base, idx));
    4000911c:	0b000880 	add	w0, w4, w0, lsl #2
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40009120:	b9000002 	str	w2, [x0]
	     intid += GIC_NUM_CFG_PER_REG) {
    40009124:	11004021 	add	w1, w1, #0x10
    40009128:	17ffff9a 	b	40008f90 <arm_gic_init+0xa8>

000000004000912c <arm_gic_irq_set_priority>:
{
    4000912c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009130:	2a0003e3 	mov	w3, w0
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    40009134:	12001000 	and	w0, w0, #0x1f
{
    40009138:	910003fd 	mov	x29, sp
    4000913c:	2a0203e6 	mov	w6, w2
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    40009140:	d2800022 	mov	x2, #0x1                   	// #1
{
    40009144:	2a0103e7 	mov	w7, w1
	uint32_t idx = intid / GIC_NUM_INTR_PER_REG;
    40009148:	53057c64 	lsr	w4, w3, #5
	mem_addr_t base = GET_DIST_BASE(intid);
    4000914c:	71007c7f 	cmp	w3, #0x1f
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    40009150:	9ac02042 	lsl	x2, x2, x0
	mem_addr_t base = GET_DIST_BASE(intid);
    40009154:	54000468 	b.hi	400091e0 <arm_gic_irq_set_priority+0xb4>  // b.pmore
    40009158:	97ffff4a 	bl	40008e80 <gic_get_rdist>
    4000915c:	91404005 	add	x5, x0, #0x10, lsl #12
	__DMB();
    40009160:	d5033fbf 	dmb	sy
	sys_write32(mask, ICENABLER(base, idx));
    40009164:	531e7484 	lsl	w4, w4, #2
    40009168:	11060084 	add	w4, w4, #0x180
    4000916c:	8b2440a4 	add	x4, x5, w4, uxtw
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40009170:	b9000082 	str	w2, [x4]
	gic_wait_rwp(intid);
    40009174:	2a0303e0 	mov	w0, w3
    40009178:	97ffff49 	bl	40008e9c <gic_wait_rwp.isra.0>
	__DMB();
    4000917c:	d5033fbf 	dmb	sy
	sys_write8(prio & GIC_PRI_MASK, IPRIORITYR(base, intid));
    40009180:	2a0303e0 	mov	w0, w3
    40009184:	91100000 	add	x0, x0, #0x400
    40009188:	8b050000 	add	x0, x0, x5
	__asm__ volatile("strb %w0, [%1]" : : "r" (data), "r" (addr));
    4000918c:	39000007 	strb	w7, [x0]
	if (!GIC_IS_SGI(intid)) {
    40009190:	71003c7f 	cmp	w3, #0xf
    40009194:	54000229 	b.ls	400091d8 <arm_gic_irq_set_priority+0xac>  // b.plast
		idx = intid / GIC_NUM_CFG_PER_REG;
    40009198:	53047c60 	lsr	w0, w3, #4
		shift = (intid & (GIC_NUM_CFG_PER_REG - 1)) * 2;
    4000919c:	531f0c64 	ubfiz	w4, w3, #1, #4
		val = sys_read32(ICFGR(base, idx));
    400091a0:	531e7400 	lsl	w0, w0, #2
    400091a4:	11300000 	add	w0, w0, #0xc00
    400091a8:	8b2040a0 	add	x0, x5, w0, uxtw
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    400091ac:	b9400002 	ldr	w2, [x0]
	__DMB();
    400091b0:	d5033fbf 	dmb	sy
		val &= ~(GICD_ICFGR_MASK << shift);
    400091b4:	d2800061 	mov	x1, #0x3                   	// #3
    400091b8:	9ac42021 	lsl	x1, x1, x4
    400091bc:	0a210041 	bic	w1, w2, w1
		if (flags & IRQ_TYPE_EDGE) {
    400091c0:	36100086 	tbz	w6, #2, 400091d0 <arm_gic_irq_set_priority+0xa4>
			val |= (GICD_ICFGR_TYPE << shift);
    400091c4:	d2800042 	mov	x2, #0x2                   	// #2
    400091c8:	9ac42042 	lsl	x2, x2, x4
    400091cc:	2a020021 	orr	w1, w1, w2
	__DMB();
    400091d0:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    400091d4:	b9000001 	str	w1, [x0]
}
    400091d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400091dc:	d65f03c0 	ret
	mem_addr_t base = GET_DIST_BASE(intid);
    400091e0:	d2a10005 	mov	x5, #0x8000000             	// #134217728
    400091e4:	17ffffdf 	b	40009160 <arm_gic_irq_set_priority+0x34>

00000000400091e8 <arm_gic_irq_enable>:
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    400091e8:	12001001 	and	w1, w0, #0x1f
    400091ec:	d2800023 	mov	x3, #0x1                   	// #1
	uint32_t idx = intid / GIC_NUM_INTR_PER_REG;
    400091f0:	53057c02 	lsr	w2, w0, #5
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    400091f4:	71007c1f 	cmp	w0, #0x1f
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    400091f8:	9ac12063 	lsl	x3, x3, x1
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    400091fc:	54000188 	b.hi	4000922c <arm_gic_irq_enable+0x44>  // b.pmore
{
    40009200:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009204:	910003fd 	mov	x29, sp
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    40009208:	97ffff1e 	bl	40008e80 <gic_get_rdist>
    4000920c:	91404000 	add	x0, x0, #0x10, lsl #12
    40009210:	91040000 	add	x0, x0, #0x100
	__DMB();
    40009214:	d5033fbf 	dmb	sy
    40009218:	d37e6842 	ubfiz	x2, x2, #2, #27
    4000921c:	8b000042 	add	x2, x2, x0
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40009220:	b9000043 	str	w3, [x2]
}
    40009224:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40009228:	d65f03c0 	ret
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    4000922c:	d2802000 	mov	x0, #0x100                 	// #256
    40009230:	f2a10000 	movk	x0, #0x800, lsl #16
	__DMB();
    40009234:	d5033fbf 	dmb	sy
    40009238:	d37e6842 	ubfiz	x2, x2, #2, #27
    4000923c:	8b000042 	add	x2, x2, x0
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    40009240:	b9000043 	str	w3, [x2]
    40009244:	d65f03c0 	ret

0000000040009248 <arm_gic_get_active>:
	intid = read_sysreg(ICC_IAR1_EL1);
    40009248:	d538cc00 	mrs	x0, s3_0_c12_c12_0
}
    4000924c:	d65f03c0 	ret

0000000040009250 <arm_gic_eoi>:
	__DSB();
    40009250:	d5033f9f 	dsb	sy
	write_sysreg(intid, ICC_EOIR1_EL1);
    40009254:	d518cc20 	msr	s3_0_c12_c12_1, x0
}
    40009258:	d65f03c0 	ret

000000004000925c <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    4000925c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    40009260:	b0000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    40009264:	90000020 	adrp	x0, 4000d000 <__rodata_region_start>
    40009268:	91018000 	add	x0, x0, #0x60
{
    4000926c:	910003fd 	mov	x29, sp
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    40009270:	f9012020 	str	x0, [x1, #576]
{
    40009274:	f9000bf3 	str	x19, [sp, #16]
    40009278:	940001d8 	bl	400099d8 <z_device_ready>
    4000927c:	72001c1f 	tst	w0, #0xff
    40009280:	54000160 	b.eq	400092ac <uart_console_init+0x50>  // b.none
	__stdout_hook_install(console_out);
    40009284:	90000013 	adrp	x19, 40009000 <arm_gic_init+0x118>
    40009288:	910ad273 	add	x19, x19, #0x2b4
    4000928c:	aa1303e0 	mov	x0, x19
    40009290:	97fffec6 	bl	40008da8 <__stdout_hook_install>
	__printk_hook_install(console_out);
    40009294:	aa1303e0 	mov	x0, x19
    40009298:	97ffdfec 	bl	40001248 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
    4000929c:	52800000 	mov	w0, #0x0                   	// #0
}
    400092a0:	f9400bf3 	ldr	x19, [sp, #16]
    400092a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400092a8:	d65f03c0 	ret
		return -ENODEV;
    400092ac:	12800240 	mov	w0, #0xffffffed            	// #-19
    400092b0:	17fffffc 	b	400092a0 <uart_console_init+0x44>

00000000400092b4 <console_out>:
{
    400092b4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if ('\n' == c) {
    400092b8:	7100281f 	cmp	w0, #0xa
{
    400092bc:	910003fd 	mov	x29, sp
    400092c0:	a90153f3 	stp	x19, x20, [sp, #16]
    400092c4:	2a0003f3 	mov	w19, w0
    400092c8:	b0000094 	adrp	x20, 4001a000 <shell_uart_ctx+0x1c8>
	if ('\n' == c) {
    400092cc:	540000c1 	b.ne	400092e4 <console_out+0x30>  // b.any
		uart_poll_out(uart_console_dev, '\r');
    400092d0:	f9412280 	ldr	x0, [x20, #576]
	api->poll_out(dev, out_char);
    400092d4:	f9400801 	ldr	x1, [x0, #16]
    400092d8:	f9400422 	ldr	x2, [x1, #8]
    400092dc:	528001a1 	mov	w1, #0xd                   	// #13
    400092e0:	d63f0040 	blr	x2
	uart_poll_out(uart_console_dev, c);
    400092e4:	f9412280 	ldr	x0, [x20, #576]
    400092e8:	f9400801 	ldr	x1, [x0, #16]
    400092ec:	f9400422 	ldr	x2, [x1, #8]
    400092f0:	2a1303e1 	mov	w1, w19
    400092f4:	d63f0040 	blr	x2
}
    400092f8:	2a1303e0 	mov	w0, w19
    400092fc:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009300:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40009304:	d65f03c0 	ret

0000000040009308 <pl011_poll_in>:
	return 0;
}

static bool pl011_is_readable(const struct device *dev)
{
	if (!DEV_DATA(dev)->sbsa &&
    40009308:	f9401003 	ldr	x3, [x0, #32]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    4000930c:	f9400402 	ldr	x2, [x0, #8]
	if (!DEV_DATA(dev)->sbsa &&
    40009310:	39401063 	ldrb	w3, [x3, #4]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    40009314:	f9400042 	ldr	x2, [x2]
	if (!DEV_DATA(dev)->sbsa &&
    40009318:	350000a3 	cbnz	w3, 4000932c <pl011_poll_in+0x24>
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    4000931c:	b9403043 	ldr	w3, [x2, #48]
	if (!DEV_DATA(dev)->sbsa &&
    40009320:	36000183 	tbz	w3, #0, 40009350 <pl011_poll_in+0x48>
	     !(PL011_REGS(dev)->cr & PL011_CR_RXE)))
    40009324:	b9403043 	ldr	w3, [x2, #48]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    40009328:	36480143 	tbz	w3, #9, 40009350 <pl011_poll_in+0x48>
		return false;

	return (PL011_REGS(dev)->fr & PL011_FR_RXFE) == 0U;
    4000932c:	b9401843 	ldr	w3, [x2, #24]
}

static int pl011_poll_in(const struct device *dev, unsigned char *c)
{
	if (!pl011_is_readable(dev)) {
    40009330:	37200103 	tbnz	w3, #4, 40009350 <pl011_poll_in+0x48>
		return -1;
	}

	/* got a character */
	*c = (unsigned char)PL011_REGS(dev)->dr;
    40009334:	b9400042 	ldr	w2, [x2]
    40009338:	39000022 	strb	w2, [x1]

	return PL011_REGS(dev)->rsr & PL011_RSR_ERROR_MASK;
    4000933c:	f9400400 	ldr	x0, [x0, #8]
    40009340:	f9400000 	ldr	x0, [x0]
    40009344:	b9400400 	ldr	w0, [x0, #4]
    40009348:	12000c00 	and	w0, w0, #0xf
}
    4000934c:	d65f03c0 	ret
		return -1;
    40009350:	12800000 	mov	w0, #0xffffffff            	// #-1
    40009354:	17fffffe 	b	4000934c <pl011_poll_in+0x44>

0000000040009358 <pl011_poll_out>:

static void pl011_poll_out(const struct device *dev,
					     unsigned char c)
{
	/* Wait for space in FIFO */
	while (PL011_REGS(dev)->fr & PL011_FR_TXFF) {
    40009358:	f9400400 	ldr	x0, [x0, #8]
{
    4000935c:	12001c21 	and	w1, w1, #0xff
	while (PL011_REGS(dev)->fr & PL011_FR_TXFF) {
    40009360:	f9400000 	ldr	x0, [x0]
    40009364:	b9401802 	ldr	w2, [x0, #24]
    40009368:	372fffe2 	tbnz	w2, #5, 40009364 <pl011_poll_out+0xc>
		; /* Wait */
	}

	/* Send a character */
	PL011_REGS(dev)->dr = (uint32_t)c;
    4000936c:	b9000001 	str	w1, [x0]
}
    40009370:	d65f03c0 	ret

0000000040009374 <pl011_fifo_fill>:
static int pl011_fifo_fill(const struct device *dev,
				    const uint8_t *tx_data, int len)
{
	uint8_t num_tx = 0U;

	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    40009374:	f9400400 	ldr	x0, [x0, #8]
    40009378:	f9400003 	ldr	x3, [x0]
	uint8_t num_tx = 0U;
    4000937c:	52800000 	mov	w0, #0x0                   	// #0
	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    40009380:	b9401864 	ldr	w4, [x3, #24]
    40009384:	37280084 	tbnz	w4, #5, 40009394 <pl011_fifo_fill+0x20>
	       (len - num_tx > 0)) {
    40009388:	4b000044 	sub	w4, w2, w0
	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    4000938c:	7100009f 	cmp	w4, #0x0
    40009390:	5400004c 	b.gt	40009398 <pl011_fifo_fill+0x24>
		PL011_REGS(dev)->dr = tx_data[num_tx++];
	}
	return num_tx;
}
    40009394:	d65f03c0 	ret
		PL011_REGS(dev)->dr = tx_data[num_tx++];
    40009398:	11000404 	add	w4, w0, #0x1
    4000939c:	92401c00 	and	x0, x0, #0xff
    400093a0:	38606820 	ldrb	w0, [x1, x0]
    400093a4:	b9000060 	str	w0, [x3]
    400093a8:	12001c80 	and	w0, w4, #0xff
    400093ac:	17fffff5 	b	40009380 <pl011_fifo_fill+0xc>

00000000400093b0 <pl011_fifo_read>:

static int pl011_fifo_read(const struct device *dev,
				    uint8_t *rx_data, const int len)
{
    400093b0:	aa0003e4 	mov	x4, x0
	uint8_t num_rx = 0U;
    400093b4:	52800000 	mov	w0, #0x0                   	// #0

	while ((len - num_rx > 0) &&
    400093b8:	4b000043 	sub	w3, w2, w0
    400093bc:	7100007f 	cmp	w3, #0x0
    400093c0:	540000ad 	b.le	400093d4 <pl011_fifo_read+0x24>
	       !(PL011_REGS(dev)->fr & PL011_FR_RXFE)) {
    400093c4:	f9400483 	ldr	x3, [x4, #8]
    400093c8:	f9400063 	ldr	x3, [x3]
    400093cc:	b9401865 	ldr	w5, [x3, #24]
	while ((len - num_rx > 0) &&
    400093d0:	36200045 	tbz	w5, #4, 400093d8 <pl011_fifo_read+0x28>
		rx_data[num_rx++] = PL011_REGS(dev)->dr;
	}

	return num_rx;
}
    400093d4:	d65f03c0 	ret
		rx_data[num_rx++] = PL011_REGS(dev)->dr;
    400093d8:	b9400066 	ldr	w6, [x3]
    400093dc:	92401c03 	and	x3, x0, #0xff
    400093e0:	11000405 	add	w5, w0, #0x1
    400093e4:	12001ca0 	and	w0, w5, #0xff
    400093e8:	38236826 	strb	w6, [x1, x3]
    400093ec:	17fffff3 	b	400093b8 <pl011_fifo_read+0x8>

00000000400093f0 <pl011_irq_tx_enable>:

static void pl011_irq_tx_enable(const struct device *dev)
{
	PL011_REGS(dev)->imsc |= PL011_IMSC_TXIM;
    400093f0:	f9400400 	ldr	x0, [x0, #8]
    400093f4:	f9400001 	ldr	x1, [x0]
    400093f8:	b9403820 	ldr	w0, [x1, #56]
    400093fc:	321b0000 	orr	w0, w0, #0x20
    40009400:	b9003820 	str	w0, [x1, #56]
}
    40009404:	d65f03c0 	ret

0000000040009408 <pl011_irq_tx_disable>:

static void pl011_irq_tx_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~PL011_IMSC_TXIM;
    40009408:	f9400400 	ldr	x0, [x0, #8]
    4000940c:	f9400001 	ldr	x1, [x0]
    40009410:	b9403820 	ldr	w0, [x1, #56]
    40009414:	121a7800 	and	w0, w0, #0xffffffdf
    40009418:	b9003820 	str	w0, [x1, #56]
}
    4000941c:	d65f03c0 	ret

0000000040009420 <pl011_irq_tx_complete>:

static int pl011_irq_tx_complete(const struct device *dev)
{
	/* check for TX FIFO empty */
	return PL011_REGS(dev)->fr & PL011_FR_TXFE;
    40009420:	f9400400 	ldr	x0, [x0, #8]
    40009424:	f9400000 	ldr	x0, [x0]
    40009428:	b9401800 	ldr	w0, [x0, #24]
}
    4000942c:	12190000 	and	w0, w0, #0x80
    40009430:	d65f03c0 	ret

0000000040009434 <pl011_irq_rx_enable>:
		pl011_irq_tx_complete(dev));
}

static void pl011_irq_rx_enable(const struct device *dev)
{
	PL011_REGS(dev)->imsc |= PL011_IMSC_RXIM |
    40009434:	f9400400 	ldr	x0, [x0, #8]
    40009438:	52800a02 	mov	w2, #0x50                  	// #80
    4000943c:	f9400001 	ldr	x1, [x0]
    40009440:	b9403820 	ldr	w0, [x1, #56]
    40009444:	2a020000 	orr	w0, w0, w2
    40009448:	b9003820 	str	w0, [x1, #56]
				 PL011_IMSC_RTIM;
}
    4000944c:	d65f03c0 	ret

0000000040009450 <pl011_irq_rx_disable>:

static void pl011_irq_rx_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~(PL011_IMSC_RXIM |
    40009450:	f9400400 	ldr	x0, [x0, #8]
    40009454:	12800a02 	mov	w2, #0xffffffaf            	// #-81
    40009458:	f9400001 	ldr	x1, [x0]
    4000945c:	b9403820 	ldr	w0, [x1, #56]
    40009460:	0a020000 	and	w0, w0, w2
    40009464:	b9003820 	str	w0, [x1, #56]
				   PL011_IMSC_RTIM);
}
    40009468:	d65f03c0 	ret

000000004000946c <pl011_irq_rx_ready>:

static int pl011_irq_rx_ready(const struct device *dev)
{
	if (!DEV_DATA(dev)->sbsa && !(PL011_REGS(dev)->cr & PL011_CR_RXE))
    4000946c:	f9400401 	ldr	x1, [x0, #8]
    40009470:	f9401000 	ldr	x0, [x0, #32]
    40009474:	f9400021 	ldr	x1, [x1]
    40009478:	39401000 	ldrb	w0, [x0, #4]
    4000947c:	35000060 	cbnz	w0, 40009488 <pl011_irq_rx_ready+0x1c>
    40009480:	b9403020 	ldr	w0, [x1, #48]
    40009484:	364800e0 	tbz	w0, #9, 400094a0 <pl011_irq_rx_ready+0x34>
		return false;

	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    40009488:	b9403820 	ldr	w0, [x1, #56]
    4000948c:	362000a0 	tbz	w0, #4, 400094a0 <pl011_irq_rx_ready+0x34>
		(!(PL011_REGS(dev)->fr & PL011_FR_RXFE)));
    40009490:	b9401820 	ldr	w0, [x1, #24]
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    40009494:	d27c0000 	eor	x0, x0, #0x10
    40009498:	d3441000 	ubfx	x0, x0, #4, #1
}
    4000949c:	d65f03c0 	ret
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    400094a0:	52800000 	mov	w0, #0x0                   	// #0
    400094a4:	17fffffe 	b	4000949c <pl011_irq_rx_ready+0x30>

00000000400094a8 <pl011_irq_err_enable>:

static void pl011_irq_err_enable(const struct device *dev)
{
	/* enable framing, parity, break, and overrun */
	PL011_REGS(dev)->imsc |= PL011_IMSC_ERROR_MASK;
    400094a8:	f9400400 	ldr	x0, [x0, #8]
    400094ac:	f9400001 	ldr	x1, [x0]
    400094b0:	b9403820 	ldr	w0, [x1, #56]
    400094b4:	32190c00 	orr	w0, w0, #0x780
    400094b8:	b9003820 	str	w0, [x1, #56]
}
    400094bc:	d65f03c0 	ret

00000000400094c0 <pl011_irq_err_disable>:

static void pl011_irq_err_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~PL011_IMSC_ERROR_MASK;
    400094c0:	f9400400 	ldr	x0, [x0, #8]
    400094c4:	f9400001 	ldr	x1, [x0]
    400094c8:	b9403820 	ldr	w0, [x1, #56]
    400094cc:	12156c00 	and	w0, w0, #0xfffff87f
    400094d0:	b9003820 	str	w0, [x1, #56]
}
    400094d4:	d65f03c0 	ret

00000000400094d8 <pl011_irq_update>:
}

static int pl011_irq_update(const struct device *dev)
{
	return 1;
}
    400094d8:	52800020 	mov	w0, #0x1                   	// #1
    400094dc:	d65f03c0 	ret

00000000400094e0 <pl011_irq_callback_set>:

static void pl011_irq_callback_set(const struct device *dev,
					    uart_irq_callback_user_data_t cb,
					    void *cb_data)
{
	DEV_DATA(dev)->irq_cb = cb;
    400094e0:	f9401000 	ldr	x0, [x0, #32]
	DEV_DATA(dev)->irq_cb_data = cb_data;
    400094e4:	a9008801 	stp	x1, x2, [x0, #8]
}
    400094e8:	d65f03c0 	ret

00000000400094ec <pl011_isr>:
}

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
void pl011_isr(const struct device *dev)
{
	struct pl011_data *data = DEV_DATA(dev);
    400094ec:	f9401001 	ldr	x1, [x0, #32]

	/* Verify if the callback has been registered */
	if (data->irq_cb) {
    400094f0:	f9400422 	ldr	x2, [x1, #8]
    400094f4:	b4000082 	cbz	x2, 40009504 <pl011_isr+0x18>
		data->irq_cb(dev, data->irq_cb_data);
    400094f8:	f9400821 	ldr	x1, [x1, #16]
    400094fc:	aa0203f0 	mov	x16, x2
    40009500:	d61f0200 	br	x16
	}
}
    40009504:	d65f03c0 	ret

0000000040009508 <pl011_irq_config_func_0>:
		    CONFIG_SERIAL_INIT_PRIORITY,
		    &pl011_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void pl011_irq_config_func_0(const struct device *dev)
{
    40009508:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
#if DT_NUM_IRQS(DT_INST(0, arm_pl011)) == 1
	IRQ_CONNECT(DT_INST_IRQN(0),
    4000950c:	52800002 	mov	w2, #0x0                   	// #0
    40009510:	52800001 	mov	w1, #0x0                   	// #0
{
    40009514:	910003fd 	mov	x29, sp
	IRQ_CONNECT(DT_INST_IRQN(0),
    40009518:	52800420 	mov	w0, #0x21                  	// #33
    4000951c:	97fff9e1 	bl	40007ca0 <z_arm64_irq_priority_set>
		    pl011_isr,
		    DEVICE_DT_INST_GET(0),
		    0);
	irq_enable(DT_INST_IRQ_BY_NAME(0, rxtim, irq));
#endif
}
    40009520:	a8c17bfd 	ldp	x29, x30, [sp], #16
	irq_enable(DT_INST_IRQN(0));
    40009524:	52800420 	mov	w0, #0x21                  	// #33
    40009528:	17fff9dd 	b	40007c9c <arch_irq_enable>

000000004000952c <pl011_irq_tx_ready>:
	if (!DEV_DATA(dev)->sbsa && !(PL011_REGS(dev)->cr & PL011_CR_TXE))
    4000952c:	f9401002 	ldr	x2, [x0, #32]
    40009530:	f9400401 	ldr	x1, [x0, #8]
    40009534:	39401042 	ldrb	w2, [x2, #4]
    40009538:	f9400021 	ldr	x1, [x1]
    4000953c:	35000062 	cbnz	w2, 40009548 <pl011_irq_tx_ready+0x1c>
    40009540:	b9403022 	ldr	w2, [x1, #48]
    40009544:	36400142 	tbz	w2, #8, 4000956c <pl011_irq_tx_ready+0x40>
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_TXIM) &&
    40009548:	b9403821 	ldr	w1, [x1, #56]
    4000954c:	36280101 	tbz	w1, #5, 4000956c <pl011_irq_tx_ready+0x40>
{
    40009550:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009554:	910003fd 	mov	x29, sp
		pl011_irq_tx_complete(dev));
    40009558:	97ffffb2 	bl	40009420 <pl011_irq_tx_complete>
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_TXIM) &&
    4000955c:	7100001f 	cmp	w0, #0x0
    40009560:	1a9f07e0 	cset	w0, ne  // ne = any
}
    40009564:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40009568:	d65f03c0 	ret
		return false;
    4000956c:	52800000 	mov	w0, #0x0                   	// #0
}
    40009570:	d65f03c0 	ret

0000000040009574 <pl011_irq_is_pending>:
{
    40009574:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009578:	aa0003e2 	mov	x2, x0
    4000957c:	910003fd 	mov	x29, sp
	return pl011_irq_rx_ready(dev) || pl011_irq_tx_ready(dev);
    40009580:	97ffffbb 	bl	4000946c <pl011_irq_rx_ready>
    40009584:	350000e0 	cbnz	w0, 400095a0 <pl011_irq_is_pending+0x2c>
    40009588:	aa0203e0 	mov	x0, x2
    4000958c:	97ffffe8 	bl	4000952c <pl011_irq_tx_ready>
    40009590:	7100001f 	cmp	w0, #0x0
    40009594:	1a9f07e0 	cset	w0, ne  // ne = any
}
    40009598:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000959c:	d65f03c0 	ret
	return pl011_irq_rx_ready(dev) || pl011_irq_tx_ready(dev);
    400095a0:	52800020 	mov	w0, #0x1                   	// #1
    400095a4:	17fffffd 	b	40009598 <pl011_irq_is_pending+0x24>

00000000400095a8 <pl011_init>:
{
    400095a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400095ac:	910003fd 	mov	x29, sp
	if (!DEV_DATA(dev)->sbsa) {
    400095b0:	f9401002 	ldr	x2, [x0, #32]
{
    400095b4:	f9000bf3 	str	x19, [sp, #16]
    400095b8:	aa0003f3 	mov	x19, x0
	if (!DEV_DATA(dev)->sbsa) {
    400095bc:	39401040 	ldrb	w0, [x2, #4]
    400095c0:	35000460 	cbnz	w0, 4000964c <pl011_init+0xa4>
    400095c4:	f9400663 	ldr	x3, [x19, #8]
				/ (baudrate * 16U);
    400095c8:	b9400042 	ldr	w2, [x2]
	PL011_REGS(dev)->cr &= ~PL011_CR_UARTEN;
    400095cc:	f9400061 	ldr	x1, [x3]
				/ (baudrate * 16U);
    400095d0:	531c6c42 	lsl	w2, w2, #4
	PL011_REGS(dev)->cr &= ~PL011_CR_UARTEN;
    400095d4:	b9403020 	ldr	w0, [x1, #48]
    400095d8:	121f7800 	and	w0, w0, #0xfffffffe
    400095dc:	b9003020 	str	w0, [x1, #48]
	PL011_REGS(dev)->lcr_h &= ~PL011_LCRH_FEN;
    400095e0:	b9402c20 	ldr	w0, [x1, #44]
    400095e4:	121b7800 	and	w0, w0, #0xffffffef
    400095e8:	b9002c20 	str	w0, [x1, #44]
	uint64_t bauddiv = (((uint64_t)clk) << PL011_FBRD_WIDTH)
    400095ec:	b9400860 	ldr	w0, [x3, #8]
    400095f0:	d37ae400 	lsl	x0, x0, #6
    400095f4:	9ac20800 	udiv	x0, x0, x2
	if ((bauddiv < (1u << PL011_FBRD_WIDTH))
    400095f8:	b2793be2 	mov	x2, #0x3fff80              	// #4194176
		|| (bauddiv > (65535u << PL011_FBRD_WIDTH))) {
    400095fc:	d1010003 	sub	x3, x0, #0x40
	if ((bauddiv < (1u << PL011_FBRD_WIDTH))
    40009600:	eb02007f 	cmp	x3, x2
    40009604:	54000688 	b.hi	400096d4 <pl011_init+0x12c>  // b.pmore
	PL011_REGS(dev)->ibrd = bauddiv >> PL011_FBRD_WIDTH;
    40009608:	d346fc02 	lsr	x2, x0, #6
    4000960c:	b9002422 	str	w2, [x1, #36]
	PL011_REGS(dev)->fbrd = bauddiv & ((1u << PL011_FBRD_WIDTH) - 1u);
    40009610:	12001400 	and	w0, w0, #0x3f
    40009614:	b9002820 	str	w0, [x1, #40]
	__DMB();
    40009618:	d5033fbf 	dmb	sy
	PL011_REGS(dev)->lcr_h = PL011_REGS(dev)->lcr_h;
    4000961c:	f9400660 	ldr	x0, [x19, #8]
		lcrh &= ~(BIT(0) | BIT(7));
    40009620:	12801ce2 	mov	w2, #0xffffff18            	// #-232
	PL011_REGS(dev)->lcr_h = PL011_REGS(dev)->lcr_h;
    40009624:	f9400000 	ldr	x0, [x0]
    40009628:	b9402c01 	ldr	w1, [x0, #44]
    4000962c:	b9002c01 	str	w1, [x0, #44]
		lcrh = PL011_REGS(dev)->lcr_h & ~(PL011_LCRH_FORMAT_MASK);
    40009630:	b9402c01 	ldr	w1, [x0, #44]
		lcrh &= ~(BIT(0) | BIT(7));
    40009634:	0a020021 	and	w1, w1, w2
		lcrh |= PL011_LCRH_WLEN_SIZE(8) << PL011_LCRH_WLEN_SHIFT;
    40009638:	321b0421 	orr	w1, w1, #0x60
		PL011_REGS(dev)->lcr_h = lcrh;
    4000963c:	b9002c01 	str	w1, [x0, #44]
	PL011_REGS(dev)->lcr_h |= PL011_LCRH_FEN;
    40009640:	b9402c01 	ldr	w1, [x0, #44]
    40009644:	321c0021 	orr	w1, w1, #0x10
    40009648:	b9002c01 	str	w1, [x0, #44]
	PL011_REGS(dev)->imsc = 0U;
    4000964c:	f9400660 	ldr	x0, [x19, #8]
	PL011_REGS(dev)->icr = PL011_IMSC_MASK_ALL;
    40009650:	5280ffe1 	mov	w1, #0x7ff                 	// #2047
	PL011_REGS(dev)->imsc = 0U;
    40009654:	f9400000 	ldr	x0, [x0]
    40009658:	b900381f 	str	wzr, [x0, #56]
	PL011_REGS(dev)->icr = PL011_IMSC_MASK_ALL;
    4000965c:	b9004401 	str	w1, [x0, #68]
	if (!DEV_DATA(dev)->sbsa) {
    40009660:	f9401261 	ldr	x1, [x19, #32]
    40009664:	39401021 	ldrb	w1, [x1, #4]
    40009668:	350001a1 	cbnz	w1, 4000969c <pl011_init+0xf4>
		PL011_REGS(dev)->dmacr = 0U;
    4000966c:	b900481f 	str	wzr, [x0, #72]
		__ISB();
    40009670:	d5033fdf 	isb
		PL011_REGS(dev)->cr &= ~(BIT(14) | BIT(15) | BIT(1));
    40009674:	f9400660 	ldr	x0, [x19, #8]
    40009678:	12980042 	mov	w2, #0xffff3ffd            	// #-49155
    4000967c:	f9400000 	ldr	x0, [x0]
    40009680:	b9403001 	ldr	w1, [x0, #48]
    40009684:	0a020021 	and	w1, w1, w2
    40009688:	b9003001 	str	w1, [x0, #48]
		PL011_REGS(dev)->cr |= PL011_CR_RXE | PL011_CR_TXE;
    4000968c:	b9403001 	ldr	w1, [x0, #48]
    40009690:	32180421 	orr	w1, w1, #0x300
    40009694:	b9003001 	str	w1, [x0, #48]
		__ISB();
    40009698:	d5033fdf 	isb
	DEV_CFG(dev)->irq_config_func(dev);
    4000969c:	f9400660 	ldr	x0, [x19, #8]
    400096a0:	f9400801 	ldr	x1, [x0, #16]
    400096a4:	aa1303e0 	mov	x0, x19
    400096a8:	d63f0020 	blr	x1
	if (!DEV_DATA(dev)->sbsa)
    400096ac:	f9401260 	ldr	x0, [x19, #32]
    400096b0:	39401000 	ldrb	w0, [x0, #4]
    400096b4:	350000c0 	cbnz	w0, 400096cc <pl011_init+0x124>
	PL011_REGS(dev)->cr |=  PL011_CR_UARTEN;
    400096b8:	f9400660 	ldr	x0, [x19, #8]
    400096bc:	f9400001 	ldr	x1, [x0]
    400096c0:	b9403020 	ldr	w0, [x1, #48]
    400096c4:	32000000 	orr	w0, w0, #0x1
    400096c8:	b9003020 	str	w0, [x1, #48]
	return 0;
    400096cc:	52800000 	mov	w0, #0x0                   	// #0
    400096d0:	14000002 	b	400096d8 <pl011_init+0x130>
		return -EINVAL;
    400096d4:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
    400096d8:	f9400bf3 	ldr	x19, [sp, #16]
    400096dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400096e0:	d65f03c0 	ret

00000000400096e4 <arm_arch_timer_compare_isr>:
MAKE_REG_HELPER(daif)
    400096e4:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400096e8:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    400096ec:	d53be040 	mrs	x0, cntvct_el0
		return;
	}
#endif /* CONFIG_ARM_ARCH_TIMER_ERRATUM_740657 */

	uint64_t curr_cycle = arm_arch_timer_count();
	uint32_t delta_ticks = (uint32_t)((curr_cycle - last_cycle) / CYC_PER_TICK);
    400096f0:	b0000083 	adrp	x3, 4001a000 <shell_uart_ctx+0x1c8>
    400096f4:	f9412464 	ldr	x4, [x3, #584]
    400096f8:	d2912d05 	mov	x5, #0x8968                	// #35176
    400096fc:	f2a00125 	movk	x5, #0x9, lsl #16
    40009700:	cb040000 	sub	x0, x0, x4
    40009704:	9ac50800 	udiv	x0, x0, x5

	last_cycle += delta_ticks * CYC_PER_TICK;
    40009708:	92407c02 	and	x2, x0, #0xffffffff
    4000970c:	9b051042 	madd	x2, x2, x5, x4
    40009710:	f9012462 	str	x2, [x3, #584]
MAKE_REG_HELPER(cntv_ctl_el0)
    40009714:	d53be322 	mrs	x2, cntv_ctl_el0
	uint64_t cntv_ctl;

	cntv_ctl = read_cntv_ctl_el0();

	if (mask) {
		cntv_ctl |= CNTV_CTL_IMASK_BIT;
    40009718:	b27f0042 	orr	x2, x2, #0x2
    4000971c:	d51be322 	msr	cntv_ctl_el0, x2
MAKE_REG_HELPER(daif)
    40009720:	92407c21 	and	x1, x1, #0xffffffff
    40009724:	d51b4221 	msr	daif, x1
	}
#endif /* CONFIG_ARM_ARCH_TIMER_ERRATUM_740657 */

	k_spin_unlock(&lock, key);

	sys_clock_announce(delta_ticks);
    40009728:	140006d2 	b	4000b270 <sys_clock_announce>

000000004000972c <sys_clock_driver_init>:
}

int sys_clock_driver_init(const struct device *dev)
{
    4000972c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(dev);

	IRQ_CONNECT(ARM_ARCH_TIMER_IRQ, ARM_ARCH_TIMER_PRIO,
    40009730:	52800042 	mov	w2, #0x2                   	// #2
    40009734:	52801401 	mov	w1, #0xa0                  	// #160
{
    40009738:	910003fd 	mov	x29, sp
	IRQ_CONNECT(ARM_ARCH_TIMER_IRQ, ARM_ARCH_TIMER_PRIO,
    4000973c:	52800360 	mov	w0, #0x1b                  	// #27
    40009740:	97fff958 	bl	40007ca0 <z_arm64_irq_priority_set>
MAKE_REG_HELPER(cntvct_el0);
    40009744:	d53be040 	mrs	x0, cntvct_el0
		    arm_arch_timer_compare_isr, NULL, ARM_ARCH_TIMER_FLAGS);
	arm_arch_timer_init();
	arm_arch_timer_set_compare(arm_arch_timer_count() + CYC_PER_TICK);
    40009748:	91426000 	add	x0, x0, #0x98, lsl #12
    4000974c:	9125a000 	add	x0, x0, #0x968
MAKE_REG_HELPER(cntv_cval_el0)
    40009750:	d51be340 	msr	cntv_cval_el0, x0
MAKE_REG_HELPER(cntv_ctl_el0)
    40009754:	d53be320 	mrs	x0, cntv_ctl_el0
		cntv_ctl |= CNTV_CTL_ENABLE_BIT;
    40009758:	b2400000 	orr	x0, x0, #0x1
    4000975c:	d51be320 	msr	cntv_ctl_el0, x0
	arm_arch_timer_enable(true);
	irq_enable(ARM_ARCH_TIMER_IRQ);
    40009760:	52800360 	mov	w0, #0x1b                  	// #27
    40009764:	97fff94e 	bl	40007c9c <arch_irq_enable>
    40009768:	d53be320 	mrs	x0, cntv_ctl_el0
	} else {
		cntv_ctl &= ~CNTV_CTL_IMASK_BIT;
    4000976c:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    40009770:	d51be320 	msr	cntv_ctl_el0, x0
	arm_arch_timer_set_irq_mask(false);

	return 0;
}
    40009774:	52800000 	mov	w0, #0x0                   	// #0
    40009778:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000977c:	d65f03c0 	ret

0000000040009780 <sys_clock_set_timeout>:

void sys_clock_set_timeout(int32_t ticks, bool idle)
{
#if defined(CONFIG_TICKLESS_KERNEL)

	if (ticks == K_TICKS_FOREVER && idle) {
    40009780:	72001c3f 	tst	w1, #0xff
    40009784:	3a411800 	ccmn	w0, #0x1, #0x0, ne  // ne = any
    40009788:	54000420 	b.eq	4000980c <sys_clock_set_timeout+0x8c>  // b.none
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : \
    4000978c:	3100041f 	cmn	w0, #0x1
    40009790:	54000400 	b.eq	40009810 <sys_clock_set_timeout+0x90>  // b.none
    40009794:	71000400 	subs	w0, w0, #0x1
    40009798:	1a9f5000 	csel	w0, w0, wzr, pl  // pl = nfrst
MAKE_REG_HELPER(daif)
    4000979c:	d53b4224 	mrs	x4, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400097a0:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    400097a4:	d53be042 	mrs	x2, cntvct_el0
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t curr_cycle = arm_arch_timer_count();
	uint64_t req_cycle = ticks * CYC_PER_TICK;

	/* Round up to next tick boundary */
	req_cycle += (curr_cycle - last_cycle) + (CYC_PER_TICK - 1);
    400097a8:	b0000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    400097ac:	f9412423 	ldr	x3, [x1, #584]
    400097b0:	52912d05 	mov	w5, #0x8968                	// #35176
    400097b4:	72a00125 	movk	w5, #0x9, lsl #16
    400097b8:	d2912ce1 	mov	x1, #0x8967                	// #35175
    400097bc:	f2a00121 	movk	x1, #0x9, lsl #16
    400097c0:	cb030021 	sub	x1, x1, x3
    400097c4:	9b250800 	smaddl	x0, w0, w5, x2

	req_cycle = (req_cycle / CYC_PER_TICK) * CYC_PER_TICK;

	if ((req_cycle + last_cycle - curr_cycle) < MIN_DELAY) {
    400097c8:	cb020062 	sub	x2, x3, x2
	req_cycle += (curr_cycle - last_cycle) + (CYC_PER_TICK - 1);
    400097cc:	8b000020 	add	x0, x1, x0
	req_cycle = (req_cycle / CYC_PER_TICK) * CYC_PER_TICK;
    400097d0:	d2912d01 	mov	x1, #0x8968                	// #35176
    400097d4:	f2a00121 	movk	x1, #0x9, lsl #16
    400097d8:	9ac10800 	udiv	x0, x0, x1
    400097dc:	9b017c00 	mul	x0, x0, x1
	if ((req_cycle + last_cycle - curr_cycle) < MIN_DELAY) {
    400097e0:	8b000042 	add	x2, x2, x0
    400097e4:	f10f9c5f 	cmp	x2, #0x3e7
    400097e8:	54000048 	b.hi	400097f0 <sys_clock_set_timeout+0x70>  // b.pmore
		req_cycle += CYC_PER_TICK;
    400097ec:	8b010000 	add	x0, x0, x1
	}

	arm_arch_timer_set_compare(req_cycle + last_cycle);
    400097f0:	8b000060 	add	x0, x3, x0
MAKE_REG_HELPER(cntv_cval_el0)
    400097f4:	d51be340 	msr	cntv_cval_el0, x0
MAKE_REG_HELPER(cntv_ctl_el0)
    400097f8:	d53be320 	mrs	x0, cntv_ctl_el0
    400097fc:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    40009800:	d51be320 	msr	cntv_ctl_el0, x0
MAKE_REG_HELPER(daif)
    40009804:	92407c80 	and	x0, x4, #0xffffffff
    40009808:	d51b4220 	msr	daif, x0

#else  /* CONFIG_TICKLESS_KERNEL */
	ARG_UNUSED(ticks);
	ARG_UNUSED(idle);
#endif
}
    4000980c:	d65f03c0 	ret
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : \
    40009810:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    40009814:	17ffffe2 	b	4000979c <sys_clock_set_timeout+0x1c>

0000000040009818 <sys_clock_elapsed>:
    40009818:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000981c:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    40009820:	d53be040 	mrs	x0, cntvct_el0
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = (uint32_t)((arm_arch_timer_count() - last_cycle)
    40009824:	b0000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    40009828:	f9412442 	ldr	x2, [x2, #584]
MAKE_REG_HELPER(daif)
    4000982c:	92407c21 	and	x1, x1, #0xffffffff
    40009830:	cb020000 	sub	x0, x0, x2
		    / CYC_PER_TICK);
    40009834:	d2912d02 	mov	x2, #0x8968                	// #35176
    40009838:	f2a00122 	movk	x2, #0x9, lsl #16
    4000983c:	9ac20800 	udiv	x0, x0, x2
    40009840:	d51b4221 	msr	daif, x1

	k_spin_unlock(&lock, key);
	return ret;
}
    40009844:	d65f03c0 	ret

0000000040009848 <sys_clock_cycle_get_32>:
MAKE_REG_HELPER(cntvct_el0);
    40009848:	d53be040 	mrs	x0, cntvct_el0

uint32_t sys_clock_cycle_get_32(void)
{
	return (uint32_t)arm_arch_timer_count();
}
    4000984c:	d65f03c0 	ret

0000000040009850 <arch_busy_wait>:
}

#ifdef CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT
void arch_busy_wait(uint32_t usec_to_wait)
{
	if (usec_to_wait == 0) {
    40009850:	34000100 	cbz	w0, 40009870 <arch_busy_wait+0x20>
    40009854:	d53be042 	mrs	x2, cntvct_el0
		return;
	}

	uint64_t start_cycles = arm_arch_timer_count();

	uint64_t cycles_to_wait = sys_clock_hw_cycles_per_sec() / USEC_PER_SEC * usec_to_wait;
    40009858:	528007c1 	mov	w1, #0x3e                  	// #62
    4000985c:	1b017c00 	mul	w0, w0, w1
    40009860:	d53be041 	mrs	x1, cntvct_el0

	for (;;) {
		uint64_t current_cycles = arm_arch_timer_count();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
    40009864:	cb020021 	sub	x1, x1, x2
    40009868:	eb00003f 	cmp	x1, x0
    4000986c:	54ffffa3 	b.cc	40009860 <arch_busy_wait+0x10>  // b.lo, b.ul, b.last
			break;
		}
	}
}
    40009870:	d65f03c0 	ret

0000000040009874 <device_visitor>:

static int device_visitor(const device_handle_t *handles,
			   size_t handle_count,
			   device_visitor_callback_t visitor_cb,
			   void *context)
{
    40009874:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40009878:	910003fd 	mov	x29, sp
    4000987c:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t numdev = __device_end - __device_start;
    40009880:	90000033 	adrp	x19, 4000d000 <__rodata_region_start>
    40009884:	91030273 	add	x19, x19, #0xc0
    40009888:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000988c:	90000035 	adrp	x21, 4000d000 <__rodata_region_start>
    40009890:	910182b5 	add	x21, x21, #0x60
    40009894:	cb150273 	sub	x19, x19, x21
    40009898:	a90363f7 	stp	x23, x24, [sp, #48]
    4000989c:	aa0003f7 	mov	x23, x0
    400098a0:	9344fe73 	asr	x19, x19, #4
    400098a4:	b201f3e0 	mov	x0, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
    400098a8:	f2955560 	movk	x0, #0xaaab
    400098ac:	aa0103f6 	mov	x22, x1
    400098b0:	aa0203f8 	mov	x24, x2
    400098b4:	a9046bf9 	stp	x25, x26, [sp, #64]
    400098b8:	9b007e73 	mul	x19, x19, x0
    400098bc:	aa0303f9 	mov	x25, x3
	/* Iterate over fixed devices */
	for (size_t i = 0; i < handle_count; ++i) {
    400098c0:	d2800014 	mov	x20, #0x0                   	// #0
		dev = &__device_start[dev_handle - 1];
    400098c4:	5280061a 	mov	w26, #0x30                  	// #48
    400098c8:	eb16029f 	cmp	x20, x22
    400098cc:	54000101 	b.ne	400098ec <device_visitor+0x78>  // b.any
		if (rc < 0) {
			return rc;
		}
	}

	return handle_count;
    400098d0:	2a1403e0 	mov	w0, w20
}
    400098d4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400098d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400098dc:	a94363f7 	ldp	x23, x24, [sp, #48]
    400098e0:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400098e4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    400098e8:	d65f03c0 	ret
		device_handle_t dh = handles[i];
    400098ec:	78f47ae0 	ldrsh	w0, [x23, x20, lsl #1]
	if ((dev_handle > 0) && ((size_t)dev_handle <= numdev)) {
    400098f0:	7100001f 	cmp	w0, #0x0
    400098f4:	5400016d 	b.le	40009920 <device_visitor+0xac>
		dev = &__device_start[dev_handle - 1];
    400098f8:	51000404 	sub	w4, w0, #0x1
    400098fc:	eb20a27f 	cmp	x19, w0, sxth
    40009900:	13003c84 	sxth	w4, w4
    40009904:	9b3a5484 	smaddl	x4, w4, w26, x21
    40009908:	9a9f2080 	csel	x0, x4, xzr, cs  // cs = hs, nlast
		int rc = visitor_cb(rdev, context);
    4000990c:	aa1903e1 	mov	x1, x25
    40009910:	d63f0300 	blr	x24
		if (rc < 0) {
    40009914:	37fffe00 	tbnz	w0, #31, 400098d4 <device_visitor+0x60>
	for (size_t i = 0; i < handle_count; ++i) {
    40009918:	91000694 	add	x20, x20, #0x1
    4000991c:	17ffffeb 	b	400098c8 <device_visitor+0x54>
	const struct device *dev = NULL;
    40009920:	d2800000 	mov	x0, #0x0                   	// #0
    40009924:	17fffffa 	b	4000990c <device_visitor+0x98>

0000000040009928 <z_device_state_init>:
}
    40009928:	d65f03c0 	ret

000000004000992c <z_sys_init_run_level>:
{
    4000992c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    40009930:	b0000021 	adrp	x1, 4000e000 <mmu_regions+0x38>
    40009934:	9126a021 	add	x1, x1, #0x9a8
{
    40009938:	910003fd 	mov	x29, sp
    4000993c:	a90153f3 	stp	x19, x20, [sp, #16]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    40009940:	f860d833 	ldr	x19, [x1, w0, sxtw #3]
    40009944:	11000400 	add	w0, w0, #0x1
{
    40009948:	a9025bf5 	stp	x21, x22, [sp, #32]
				dev->state->init_res = rc;
    4000994c:	52801ff6 	mov	w22, #0xff                  	// #255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    40009950:	f860d835 	ldr	x21, [x1, w0, sxtw #3]
    40009954:	eb1302bf 	cmp	x21, x19
    40009958:	540000a8 	b.hi	4000996c <z_sys_init_run_level+0x40>  // b.pmore
}
    4000995c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009960:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009964:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40009968:	d65f03c0 	ret
		const struct device *dev = entry->dev;
    4000996c:	a9405261 	ldp	x1, x20, [x19]
		int rc = entry->init(dev);
    40009970:	aa1403e0 	mov	x0, x20
    40009974:	d63f0020 	blr	x1
		if (dev != NULL) {
    40009978:	b4000174 	cbz	x20, 400099a4 <z_sys_init_run_level+0x78>
			if (rc != 0) {
    4000997c:	7100001f 	cmp	w0, #0x0
				dev->state->init_res = rc;
    40009980:	f9400e81 	ldr	x1, [x20, #24]
			if (rc != 0) {
    40009984:	340000a0 	cbz	w0, 40009998 <z_sys_init_run_level+0x6c>
				if (rc < 0) {
    40009988:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
				dev->state->init_res = rc;
    4000998c:	7103fc1f 	cmp	w0, #0xff
    40009990:	1a96d000 	csel	w0, w0, w22, le
    40009994:	39000020 	strb	w0, [x1]
			dev->state->initialized = true;
    40009998:	79400020 	ldrh	w0, [x1]
    4000999c:	32180000 	orr	w0, w0, #0x100
    400099a0:	79000020 	strh	w0, [x1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    400099a4:	91004273 	add	x19, x19, #0x10
    400099a8:	17ffffeb 	b	40009954 <z_sys_init_run_level+0x28>

00000000400099ac <z_device_get_all_static>:
	*devices = __device_start;
    400099ac:	90000021 	adrp	x1, 4000d000 <__rodata_region_start>
    400099b0:	91018021 	add	x1, x1, #0x60
    400099b4:	f9000001 	str	x1, [x0]
	return __device_end - __device_start;
    400099b8:	90000020 	adrp	x0, 4000d000 <__rodata_region_start>
    400099bc:	91030000 	add	x0, x0, #0xc0
    400099c0:	cb010000 	sub	x0, x0, x1
}
    400099c4:	b201f3e1 	mov	x1, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
    400099c8:	f2955561 	movk	x1, #0xaaab
	return __device_end - __device_start;
    400099cc:	9344fc00 	asr	x0, x0, #4
}
    400099d0:	9b017c00 	mul	x0, x0, x1
    400099d4:	d65f03c0 	ret

00000000400099d8 <z_device_ready>:
	if (dev == NULL) {
    400099d8:	b40000e0 	cbz	x0, 400099f4 <z_device_ready+0x1c>
	return dev->state->initialized && (dev->state->init_res == 0U);
    400099dc:	f9400c00 	ldr	x0, [x0, #24]
    400099e0:	b9400000 	ldr	w0, [x0]
    400099e4:	12002000 	and	w0, w0, #0x1ff
    400099e8:	7104001f 	cmp	w0, #0x100
    400099ec:	1a9f17e0 	cset	w0, eq  // eq = none
}
    400099f0:	d65f03c0 	ret
		return false;
    400099f4:	52800000 	mov	w0, #0x0                   	// #0
    400099f8:	17fffffe 	b	400099f0 <z_device_ready+0x18>

00000000400099fc <device_required_foreach>:
int device_required_foreach(const struct device *dev,
			    device_visitor_callback_t visitor_cb,
			    void *context)
{
	size_t handle_count = 0;
	const device_handle_t *handles = device_required_handles_get(dev, &handle_count);
    400099fc:	f9401400 	ldr	x0, [x0, #40]
{
    40009a00:	aa0103e4 	mov	x4, x1
    40009a04:	aa0203e3 	mov	x3, x2
		size_t i = 0;
    40009a08:	d2800001 	mov	x1, #0x0                   	// #0
	if (rv != NULL) {
    40009a0c:	b5000120 	cbnz	x0, 40009a30 <device_required_foreach+0x34>

	return device_visitor(handles, handle_count, visitor_cb, context);
    40009a10:	aa0403e2 	mov	x2, x4
    40009a14:	17ffff98 	b	40009874 <device_visitor>
			++i;
    40009a18:	91000421 	add	x1, x1, #0x1
		       && (rv[i] != DEVICE_HANDLE_SEP)) {
    40009a1c:	78617802 	ldrh	w2, [x0, x1, lsl #1]
    40009a20:	0b060042 	add	w2, w2, w6
		while ((rv[i] != DEVICE_HANDLE_ENDS)
    40009a24:	6b2220bf 	cmp	w5, w2, uxth
    40009a28:	54ffff82 	b.cs	40009a18 <device_required_foreach+0x1c>  // b.hs, b.nlast
    40009a2c:	17fffff9 	b	40009a10 <device_required_foreach+0x14>
		       && (rv[i] != DEVICE_HANDLE_SEP)) {
    40009a30:	528fffe6 	mov	w6, #0x7fff                	// #32767
		while ((rv[i] != DEVICE_HANDLE_ENDS)
    40009a34:	529fffa5 	mov	w5, #0xfffd                	// #65533
    40009a38:	17fffff9 	b	40009a1c <device_required_foreach+0x20>

0000000040009a3c <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
    40009a3c:	b0000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    40009a40:	f9413000 	ldr	x0, [x0, #608]
}
    40009a44:	91046000 	add	x0, x0, #0x118
    40009a48:	d65f03c0 	ret

0000000040009a4c <arch_system_halt>:
MAKE_REG_HELPER(daif)
    40009a4c:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40009a50:	d50342df 	msr	daifset, #0x2
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
    40009a54:	14000000 	b	40009a54 <arch_system_halt+0x8>

0000000040009a58 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    40009a58:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009a5c:	910003fd 	mov	x29, sp
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
    40009a60:	97fffffb 	bl	40009a4c <arch_system_halt>

0000000040009a64 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    40009a64:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40009a68:	910003fd 	mov	x29, sp
    40009a6c:	a90153f3 	stp	x19, x20, [sp, #16]
    40009a70:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009a74:	2a0003f5 	mov	w21, w0
    40009a78:	aa0103f6 	mov	x22, x1
MAKE_REG_HELPER(daif)
    40009a7c:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40009a80:	d50342df 	msr	daifset, #0x2
	return z_impl_z_current_get();
    40009a84:	940004e8 	bl	4000ae24 <z_impl_z_current_get>
MAKE_REG_HELPER(daif)
    40009a88:	92407e94 	and	x20, x20, #0xffffffff
    40009a8c:	aa0003f3 	mov	x19, x0
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    40009a90:	aa1603e1 	mov	x1, x22
    40009a94:	2a1503e0 	mov	w0, w21
    40009a98:	97fffff0 	bl	40009a58 <k_sys_fatal_error_handler>
    40009a9c:	d51b4234 	msr	daif, x20
	z_impl_k_thread_abort(thread);
    40009aa0:	aa1303e0 	mov	x0, x19
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    40009aa4:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009aa8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009aac:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40009ab0:	14000529 	b	4000af54 <z_impl_k_thread_abort>

0000000040009ab4 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    40009ab4:	d10143ff 	sub	sp, sp, #0x50
	k_thread_stack_t *stack = z_idle_stacks[i];

#ifdef CONFIG_THREAD_NAME
	char tname[8];

	snprintk(tname, 8, "idle %02d", i);
    40009ab8:	d2800101 	mov	x1, #0x8                   	// #8
    40009abc:	d0000022 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40009ac0:	91243442 	add	x2, x2, #0x90d
{
    40009ac4:	a9017bfd 	stp	x29, x30, [sp, #16]
    40009ac8:	910043fd 	add	x29, sp, #0x10
    40009acc:	a90253f3 	stp	x19, x20, [sp, #32]
    40009ad0:	93407c14 	sxtw	x20, w0
	snprintk(tname, 8, "idle %02d", i);
    40009ad4:	2a1403e3 	mov	w3, w20
{
    40009ad8:	a9035bf5 	stp	x21, x22, [sp, #48]
	snprintk(tname, 8, "idle %02d", i);
    40009adc:	910123f6 	add	x22, sp, #0x48
    40009ae0:	aa1603e0 	mov	x0, x22
    40009ae4:	97ffde1f 	bl	40001360 <snprintk>
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
    40009ae8:	f90007f6 	str	x22, [sp, #8]
	struct k_thread *thread = &z_idle_threads[i];
    40009aec:	90000080 	adrp	x0, 40019000 <shell_uart_thread>
    40009af0:	910dc015 	add	x21, x0, #0x370
	z_setup_new_thread(thread, stack,
    40009af4:	52800020 	mov	w0, #0x1                   	// #1
    40009af8:	b90003e0 	str	w0, [sp]
    40009afc:	b0000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    40009b00:	91094000 	add	x0, x0, #0x250
    40009b04:	52800604 	mov	w4, #0x30                  	// #48
	k_thread_stack_t *stack = z_idle_stacks[i];
    40009b08:	93747e81 	sbfiz	x1, x20, #12, #32
	z_setup_new_thread(thread, stack,
    40009b0c:	528001e7 	mov	w7, #0xf                   	// #15
    40009b10:	d2800006 	mov	x6, #0x0                   	// #0
    40009b14:	9b240284 	smaddl	x4, w20, w4, x0
    40009b18:	d00002c0 	adrp	x0, 40063000 <z_main_stack+0x3d0>
    40009b1c:	9130c000 	add	x0, x0, #0xc30
    40009b20:	d2800005 	mov	x5, #0x0                   	// #0
    40009b24:	8b010001 	add	x1, x0, x1
    40009b28:	52806e00 	mov	w0, #0x370                 	// #880
    40009b2c:	d2820002 	mov	x2, #0x1000                	// #4096
    40009b30:	b0000003 	adrp	x3, 4000a000 <z_impl_k_thread_create+0x5c>
    40009b34:	91049063 	add	x3, x3, #0x124
    40009b38:	9b205680 	smaddl	x0, w20, w0, x21
    40009b3c:	940000d2 	bl	40009e84 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    40009b40:	d2806e00 	mov	x0, #0x370                 	// #880
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    40009b44:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40009b48:	9b005680 	madd	x0, x20, x0, x21
    40009b4c:	a94253f3 	ldp	x19, x20, [sp, #32]
    40009b50:	a9435bf5 	ldp	x21, x22, [sp, #48]
    40009b54:	39406401 	ldrb	w1, [x0, #25]
    40009b58:	121d7821 	and	w1, w1, #0xfffffffb
    40009b5c:	39006401 	strb	w1, [x0, #25]
    40009b60:	910143ff 	add	sp, sp, #0x50
    40009b64:	d65f03c0 	ret

0000000040009b68 <bg_thread_main>:
{
    40009b68:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009b6c:	910003fd 	mov	x29, sp
	z_mem_manage_init();
    40009b70:	940006ae 	bl	4000b628 <z_mem_manage_init>
	z_sys_post_kernel = true;
    40009b74:	b0000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    40009b78:	52800021 	mov	w1, #0x1                   	// #1
    40009b7c:	39107c01 	strb	w1, [x0, #1055]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    40009b80:	52800040 	mov	w0, #0x2                   	// #2
    40009b84:	97ffff6a 	bl	4000992c <z_sys_init_run_level>
	boot_banner();
    40009b88:	94000846 	bl	4000bca0 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    40009b8c:	52800060 	mov	w0, #0x3                   	// #3
    40009b90:	97ffff67 	bl	4000992c <z_sys_init_run_level>
	z_init_static_threads();
    40009b94:	9400011e 	bl	4000a00c <z_init_static_threads>
	z_mem_manage_boot_finish();
    40009b98:	940006d8 	bl	4000b6f8 <z_mem_manage_boot_finish>
	main();
    40009b9c:	97ffdd88 	bl	400011bc <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    40009ba0:	90000080 	adrp	x0, 40019000 <shell_uart_thread>
    40009ba4:	911b8000 	add	x0, x0, #0x6e0
    40009ba8:	39406001 	ldrb	w1, [x0, #24]
    40009bac:	121f7821 	and	w1, w1, #0xfffffffe
    40009bb0:	39006001 	strb	w1, [x0, #24]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    40009bb4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40009bb8:	d65f03c0 	ret

0000000040009bbc <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    40009bbc:	d10ec3ff 	sub	sp, sp, #0x3b0
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    40009bc0:	52802020 	mov	w0, #0x101                 	// #257
    40009bc4:	a9017bfd 	stp	x29, x30, [sp, #16]
    40009bc8:	910043fd 	add	x29, sp, #0x10
    40009bcc:	a90253f3 	stp	x19, x20, [sp, #32]
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    40009bd0:	b0000093 	adrp	x19, 4001a000 <shell_uart_ctx+0x1c8>
    40009bd4:	91094273 	add	x19, x19, #0x250
	dummy_thread->base.user_options = K_ESSENTIAL;
    40009bd8:	7900b3e0 	strh	w0, [sp, #88]
	_current_cpu->current = dummy_thread;
    40009bdc:	910103e0 	add	x0, sp, #0x40
    40009be0:	a9035bf5 	stp	x21, x22, [sp, #48]
	_kernel.ready_q.cache = &z_main_thread;
    40009be4:	90000094 	adrp	x20, 40019000 <shell_uart_thread>
    40009be8:	911b8294 	add	x20, x20, #0x6e0
    40009bec:	f9000a60 	str	x0, [x19, #16]
	dummy_thread->stack_info.size = 0U;
    40009bf0:	a9167fff 	stp	xzr, xzr, [sp, #352]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    40009bf4:	97ffff4d 	bl	40009928 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    40009bf8:	52800000 	mov	w0, #0x0                   	// #0
    40009bfc:	97ffff4c 	bl	4000992c <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    40009c00:	52800020 	mov	w0, #0x1                   	// #1
    40009c04:	97ffff4a 	bl	4000992c <z_sys_init_run_level>
	z_sched_init();
    40009c08:	9400044c 	bl	4000ad38 <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
    40009c0c:	f9001a74 	str	x20, [x19, #48]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    40009c10:	d0000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    40009c14:	91245c00 	add	x0, x0, #0x917
    40009c18:	f90007e0 	str	x0, [sp, #8]
    40009c1c:	52800020 	mov	w0, #0x1                   	// #1
    40009c20:	b90003e0 	str	w0, [sp]
    40009c24:	52800007 	mov	w7, #0x0                   	// #0
    40009c28:	d2800006 	mov	x6, #0x0                   	// #0
    40009c2c:	d2800005 	mov	x5, #0x0                   	// #0
    40009c30:	d2800004 	mov	x4, #0x0                   	// #0
    40009c34:	d2820002 	mov	x2, #0x1000                	// #4096
    40009c38:	aa1403e0 	mov	x0, x20
    40009c3c:	90000003 	adrp	x3, 40009000 <arm_gic_init+0x118>
    40009c40:	912da063 	add	x3, x3, #0xb68
    40009c44:	b00002c1 	adrp	x1, 40062000 <z_page_frames+0x47bdf>
    40009c48:	9130c021 	add	x1, x1, #0xc30
    40009c4c:	9400008e 	bl	40009e84 <z_setup_new_thread>
    40009c50:	39406680 	ldrb	w0, [x20, #25]
    40009c54:	121d7800 	and	w0, w0, #0xfffffffb
    40009c58:	39006680 	strb	w0, [x20, #25]
	z_ready_thread(&z_main_thread);
    40009c5c:	aa1403e0 	mov	x0, x20
    40009c60:	9400033e 	bl	4000a958 <z_ready_thread>
		init_idle_thread(i);
    40009c64:	52800000 	mov	w0, #0x0                   	// #0
    40009c68:	97ffff93 	bl	40009ab4 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    40009c6c:	90000080 	adrp	x0, 40019000 <shell_uart_thread>
    40009c70:	910dc000 	add	x0, x0, #0x370
    40009c74:	f9000e60 	str	x0, [x19, #24]
		_kernel.cpus[i].irq_stack =
    40009c78:	900002e0 	adrp	x0, 40065000 <z_interrupt_stacks+0x3d0>
    40009c7c:	9130c000 	add	x0, x0, #0xc30
    40009c80:	f9000660 	str	x0, [x19, #8]
		_kernel.cpus[i].id = i;
    40009c84:	3900927f 	strb	wzr, [x19, #36]
    40009c88:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40009c8c:	d50342df 	msr	daifset, #0x2
	old_thread = _current;
    40009c90:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    40009c94:	12800140 	mov	w0, #0xfffffff5            	// #-11
    40009c98:	b9013ac0 	str	w0, [x22, #312]
MAKE_REG_HELPER(daif)
    40009c9c:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40009ca0:	d50342df 	msr	daifset, #0x2
	new_thread = z_swap_next_thread();
    40009ca4:	94000283 	bl	4000a6b0 <z_swap_next_thread>
	if (new_thread != old_thread) {
    40009ca8:	eb0002df 	cmp	x22, x0
    40009cac:	540000e0 	b.eq	40009cc8 <z_cstart+0x10c>  // b.none
    40009cb0:	aa0003f4 	mov	x20, x0
		z_reset_time_slice();
    40009cb4:	940001e0 	bl	4000a434 <z_reset_time_slice>
{
}

static inline void arch_switch(void *switch_to, void **switched_from)
{
	z_arm64_call_svc(switch_to, switched_from);
    40009cb8:	910502c1 	add	x1, x22, #0x140
		_current_cpu->current = new_thread;
    40009cbc:	f9000a74 	str	x20, [x19, #16]
    40009cc0:	f940a280 	ldr	x0, [x20, #320]
    40009cc4:	97fff8a8 	bl	40007f64 <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    40009cc8:	92407eb5 	and	x21, x21, #0xffffffff
    40009ccc:	d51b4235 	msr	daif, x21

0000000040009cd0 <k_thread_foreach>:

#define _FOREACH_STATIC_THREAD(thread_data)              \
	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data)

void k_thread_foreach(k_thread_user_cb_t user_cb, void *user_data)
{
    40009cd0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40009cd4:	910003fd 	mov	x29, sp
    40009cd8:	a90153f3 	stp	x19, x20, [sp, #16]
    40009cdc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009ce0:	aa0003f5 	mov	x21, x0
    40009ce4:	aa0103f6 	mov	x22, x1
    40009ce8:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40009cec:	d50342df 	msr	daifset, #0x2
	 */
	key = k_spin_lock(&z_thread_monitor_lock);

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, foreach);

	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
    40009cf0:	b0000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    40009cf4:	f9415013 	ldr	x19, [x0, #672]
    40009cf8:	b50000f3 	cbnz	x19, 40009d14 <k_thread_foreach+0x44>
MAKE_REG_HELPER(daif)
    40009cfc:	92407e94 	and	x20, x20, #0xffffffff
    40009d00:	d51b4234 	msr	daif, x20

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, foreach);

	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
}
    40009d04:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009d08:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009d0c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40009d10:	d65f03c0 	ret
		user_cb(thread, user_data);
    40009d14:	aa1303e0 	mov	x0, x19
    40009d18:	aa1603e1 	mov	x1, x22
    40009d1c:	d63f02a0 	blr	x21
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
    40009d20:	f9407a73 	ldr	x19, [x19, #240]
    40009d24:	17fffff5 	b	40009cf8 <k_thread_foreach+0x28>

0000000040009d28 <k_is_in_isr>:
MAKE_REG_HELPER(tpidrro_el0);
    40009d28:	d53bd060 	mrs	x0, tpidrro_el0
    40009d2c:	927db000 	and	x0, x0, #0xfffffffffff8
extern void z_arm64_offload(void);
#endif

static ALWAYS_INLINE bool arch_is_in_isr(void)
{
	return arch_curr_cpu()->nested != 0U;
    40009d30:	b9400000 	ldr	w0, [x0]
    40009d34:	7100001f 	cmp	w0, #0x0
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
    40009d38:	1a9f07e0 	cset	w0, ne  // ne = any
    40009d3c:	d65f03c0 	ret

0000000040009d40 <z_thread_monitor_exit>:
MAKE_REG_HELPER(daif)
    40009d40:	d53b4223 	mrs	x3, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40009d44:	d50342df 	msr	daifset, #0x2
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
    40009d48:	b0000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    40009d4c:	91094042 	add	x2, x2, #0x250
    40009d50:	f9402841 	ldr	x1, [x2, #80]
    40009d54:	eb00003f 	cmp	x1, x0
    40009d58:	540000e1 	b.ne	40009d74 <z_thread_monitor_exit+0x34>  // b.any
		_kernel.threads = _kernel.threads->next_thread;
    40009d5c:	f9407820 	ldr	x0, [x1, #240]
    40009d60:	f9002840 	str	x0, [x2, #80]
MAKE_REG_HELPER(daif)
    40009d64:	92407c63 	and	x3, x3, #0xffffffff
    40009d68:	d51b4223 	msr	daif, x3
			prev_thread->next_thread = thread->next_thread;
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
    40009d6c:	d65f03c0 	ret
    40009d70:	aa0203e1 	mov	x1, x2
		while ((prev_thread != NULL) &&
    40009d74:	b4ffff81 	cbz	x1, 40009d64 <z_thread_monitor_exit+0x24>
			(thread != prev_thread->next_thread)) {
    40009d78:	f9407822 	ldr	x2, [x1, #240]
		while ((prev_thread != NULL) &&
    40009d7c:	eb00005f 	cmp	x2, x0
    40009d80:	54ffff81 	b.ne	40009d70 <z_thread_monitor_exit+0x30>  // b.any
			prev_thread->next_thread = thread->next_thread;
    40009d84:	f9407800 	ldr	x0, [x0, #240]
    40009d88:	f9007820 	str	x0, [x1, #240]
    40009d8c:	17fffff6 	b	40009d64 <z_thread_monitor_exit+0x24>

0000000040009d90 <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
    40009d90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009d94:	910003fd 	mov	x29, sp
    40009d98:	f9000bf3 	str	x19, [sp, #16]
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
    40009d9c:	b5000160 	cbnz	x0, 40009dc8 <z_impl_k_thread_name_set+0x38>
		thread = _current;
    40009da0:	b0000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    40009da4:	f9413013 	ldr	x19, [x0, #608]
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
    40009da8:	9103e260 	add	x0, x19, #0xf8
    40009dac:	d2800402 	mov	x2, #0x20                  	// #32
    40009db0:	97fffb8f 	bl	40008bec <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    40009db4:	39045e7f 	strb	wzr, [x19, #279]

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
    40009db8:	52800000 	mov	w0, #0x0                   	// #0
    40009dbc:	f9400bf3 	ldr	x19, [sp, #16]
    40009dc0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40009dc4:	d65f03c0 	ret
    40009dc8:	aa0003f3 	mov	x19, x0
    40009dcc:	17fffff7 	b	40009da8 <z_impl_k_thread_name_set+0x18>

0000000040009dd0 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
    40009dd0:	9103e000 	add	x0, x0, #0xf8
    40009dd4:	d65f03c0 	ret

0000000040009dd8 <k_thread_state_str>:
#endif /* CONFIG_THREAD_NAME */
}

const char *k_thread_state_str(k_tid_t thread_id)
{
	switch (thread_id->base.thread_state) {
    40009dd8:	39406401 	ldrb	w1, [x0, #25]
    40009ddc:	7100403f 	cmp	w1, #0x10
    40009de0:	54000148 	b.hi	40009e08 <k_thread_state_str+0x30>  // b.pmore
    40009de4:	b0000020 	adrp	x0, 4000e000 <mmu_regions+0x38>
    40009de8:	912b2000 	add	x0, x0, #0xac8
    40009dec:	38614800 	ldrb	w0, [x0, w1, uxtw]
    40009df0:	10000061 	adr	x1, 40009dfc <k_thread_state_str+0x24>
    40009df4:	8b208820 	add	x0, x1, w0, sxtb #2
    40009df8:	d61f0000 	br	x0
    40009dfc:	d0000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    40009e00:	91251000 	add	x0, x0, #0x944
	 * this bit of defensive programming will be useful
	 */
		break;
	}
	return "unknown";
}
    40009e04:	d65f03c0 	ret
	switch (thread_id->base.thread_state) {
    40009e08:	7100803f 	cmp	w1, #0x20
    40009e0c:	54000340 	b.eq	40009e74 <k_thread_state_str+0x9c>  // b.none
		return "queued";
    40009e10:	7102003f 	cmp	w1, #0x80
    40009e14:	d0000022 	adrp	x2, 4000f000 <cfg_flags.0+0x5ac>
    40009e18:	d0000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    40009e1c:	91254c41 	add	x1, x2, #0x953
    40009e20:	91247000 	add	x0, x0, #0x91c
    40009e24:	9a811000 	csel	x0, x0, x1, ne  // ne = any
    40009e28:	17fffff7 	b	40009e04 <k_thread_state_str+0x2c>
		return "pending";
    40009e2c:	d0000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    40009e30:	91249000 	add	x0, x0, #0x924
    40009e34:	17fffff4 	b	40009e04 <k_thread_state_str+0x2c>
		return "prestart";
    40009e38:	d0000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    40009e3c:	9124b000 	add	x0, x0, #0x92c
    40009e40:	17fffff1 	b	40009e04 <k_thread_state_str+0x2c>
		return "dead";
    40009e44:	d0000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    40009e48:	9124d400 	add	x0, x0, #0x935
    40009e4c:	17ffffee 	b	40009e04 <k_thread_state_str+0x2c>
		return "suspended";
    40009e50:	d0000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    40009e54:	9124e800 	add	x0, x0, #0x93a
    40009e58:	17ffffeb 	b	40009e04 <k_thread_state_str+0x2c>
	return "unknown";
    40009e5c:	d0000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    40009e60:	91247000 	add	x0, x0, #0x91c
    40009e64:	17ffffe8 	b	40009e04 <k_thread_state_str+0x2c>
		return "";
    40009e68:	b0000020 	adrp	x0, 4000e000 <mmu_regions+0x38>
    40009e6c:	91317800 	add	x0, x0, #0xc5e
    40009e70:	17ffffe5 	b	40009e04 <k_thread_state_str+0x2c>
		return "aborting";
    40009e74:	d0000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    40009e78:	91252800 	add	x0, x0, #0x94a
    40009e7c:	17ffffe2 	b	40009e04 <k_thread_state_str+0x2c>

0000000040009e80 <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
    40009e80:	140002c1 	b	4000a984 <z_sched_start>

0000000040009e84 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    40009e84:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    40009e88:	91003c42 	add	x2, x2, #0xf
{
    40009e8c:	910003fd 	mov	x29, sp
    40009e90:	a90153f3 	stp	x19, x20, [sp, #16]
    40009e94:	aa0003f3 	mov	x19, x0
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    40009e98:	9102e000 	add	x0, x0, #0xb8
    40009e9c:	a9025bf5 	stp	x21, x22, [sp, #32]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    40009ea0:	927cec54 	and	x20, x2, #0xfffffffffffffff0
{
    40009ea4:	aa0103f5 	mov	x21, x1
    40009ea8:	a90363f7 	stp	x23, x24, [sp, #48]
    40009eac:	aa0603f6 	mov	x22, x6
    40009eb0:	aa0503f7 	mov	x23, x5
    40009eb4:	a9046bf9 	stp	x25, x26, [sp, #64]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    40009eb8:	aa1403e2 	mov	x2, x20
{
    40009ebc:	aa0403f9 	mov	x25, x4
    40009ec0:	a90b8260 	stp	x0, x0, [x19, #184]
	stack_ptr = (char *)stack + stack_obj_size;
    40009ec4:	8b14003a 	add	x26, x1, x20
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    40009ec8:	b94063e0 	ldr	w0, [sp, #96]
	thread_base->pended_on = NULL;
    40009ecc:	f9000a7f 	str	xzr, [x19, #16]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    40009ed0:	52801541 	mov	w1, #0xaa                  	// #170
	thread_base->user_options = (uint8_t)options;
    40009ed4:	39006260 	strb	w0, [x19, #24]
	thread_base->thread_state = (uint8_t)initial_state;
    40009ed8:	52800080 	mov	w0, #0x4                   	// #4
    40009edc:	39006660 	strb	w0, [x19, #25]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    40009ee0:	aa1503e0 	mov	x0, x21

	thread_base->prio = priority;
    40009ee4:	39006a67 	strb	w7, [x19, #26]

	thread_base->sched_locked = 0U;
    40009ee8:	39006e7f 	strb	wzr, [x19, #27]
	node->prev = NULL;
    40009eec:	a902fe7f 	stp	xzr, xzr, [x19, #40]
{
    40009ef0:	f9002bfb 	str	x27, [sp, #80]
    40009ef4:	aa0303fb 	mov	x27, x3
    40009ef8:	f94037f8 	ldr	x24, [sp, #104]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    40009efc:	97fffba1 	bl	40008d80 <memset>
	new_thread->stack_info.size = stack_buf_size;
    40009f00:	a9125275 	stp	x21, x20, [x19, #288]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    40009f04:	aa1603e6 	mov	x6, x22
    40009f08:	aa1703e5 	mov	x5, x23
	new_thread->stack_info.delta = delta;
    40009f0c:	f9009a7f 	str	xzr, [x19, #304]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    40009f10:	aa1903e4 	mov	x4, x25
    40009f14:	aa1b03e3 	mov	x3, x27
    40009f18:	aa1a03e2 	mov	x2, x26
    40009f1c:	aa1503e1 	mov	x1, x21
    40009f20:	aa1303e0 	mov	x0, x19
    40009f24:	97fff812 	bl	40007f6c <arch_new_thread>
	new_thread->init_data = NULL;
    40009f28:	f9005a7f 	str	xzr, [x19, #176]
	new_thread->entry.parameter1 = p1;
    40009f2c:	a90d667b 	stp	x27, x25, [x19, #208]
	new_thread->entry.parameter3 = p3;
    40009f30:	a90e5a77 	stp	x23, x22, [x19, #224]
    40009f34:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40009f38:	d50342df 	msr	daifset, #0x2
	new_thread->next_thread = _kernel.threads;
    40009f3c:	b0000094 	adrp	x20, 4001a000 <shell_uart_ctx+0x1c8>
    40009f40:	91094294 	add	x20, x20, #0x250
MAKE_REG_HELPER(daif)
    40009f44:	92407c00 	and	x0, x0, #0xffffffff
    40009f48:	f9402a81 	ldr	x1, [x20, #80]
	_kernel.threads = new_thread;
    40009f4c:	f9002a93 	str	x19, [x20, #80]
	new_thread->next_thread = _kernel.threads;
    40009f50:	f9007a61 	str	x1, [x19, #240]
    40009f54:	d51b4220 	msr	daif, x0
	if (name != NULL) {
    40009f58:	b4000238 	cbz	x24, 40009f9c <z_setup_new_thread+0x118>
		strncpy(new_thread->name, name,
    40009f5c:	aa1803e1 	mov	x1, x24
    40009f60:	9103e260 	add	x0, x19, #0xf8
    40009f64:	d28003e2 	mov	x2, #0x1f                  	// #31
    40009f68:	97fffb21 	bl	40008bec <strncpy>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    40009f6c:	39045e7f 	strb	wzr, [x19, #279]
	new_thread->resource_pool = _current->resource_pool;
    40009f70:	f9400a80 	ldr	x0, [x20, #16]
}
    40009f74:	a9425bf5 	ldp	x21, x22, [sp, #32]
	new_thread->resource_pool = _current->resource_pool;
    40009f78:	f940a400 	ldr	x0, [x0, #328]
}
    40009f7c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40009f80:	f9402bfb 	ldr	x27, [sp, #80]
	new_thread->resource_pool = _current->resource_pool;
    40009f84:	f900a660 	str	x0, [x19, #328]
}
    40009f88:	aa1a03e0 	mov	x0, x26
    40009f8c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009f90:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40009f94:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40009f98:	d65f03c0 	ret
		new_thread->name[0] = '\0';
    40009f9c:	3903e27f 	strb	wzr, [x19, #248]
    40009fa0:	17fffff4 	b	40009f70 <z_setup_new_thread+0xec>

0000000040009fa4 <z_impl_k_thread_create>:
{
    40009fa4:	d100c3ff 	sub	sp, sp, #0x30
    40009fa8:	a9017bfd 	stp	x29, x30, [sp, #16]
    40009fac:	910043fd 	add	x29, sp, #0x10
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    40009fb0:	b94033e8 	ldr	w8, [sp, #48]
    40009fb4:	b90003e8 	str	w8, [sp]
    40009fb8:	f90007ff 	str	xzr, [sp, #8]
{
    40009fbc:	a90253f3 	stp	x19, x20, [sp, #32]
    40009fc0:	aa0003f3 	mov	x19, x0
    40009fc4:	f9401ff4 	ldr	x20, [sp, #56]
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    40009fc8:	97ffffaf 	bl	40009e84 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    40009fcc:	b100069f 	cmn	x20, #0x1
    40009fd0:	54000080 	b.eq	40009fe0 <z_impl_k_thread_create+0x3c>  // b.none
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    40009fd4:	b5000114 	cbnz	x20, 40009ff4 <z_impl_k_thread_create+0x50>
	z_sched_start(thread);
    40009fd8:	aa1303e0 	mov	x0, x19
    40009fdc:	9400026a 	bl	4000a984 <z_sched_start>
}
    40009fe0:	aa1303e0 	mov	x0, x19
    40009fe4:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40009fe8:	a94253f3 	ldp	x19, x20, [sp, #32]
    40009fec:	9100c3ff 	add	sp, sp, #0x30
    40009ff0:	d65f03c0 	ret

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    40009ff4:	aa1403e2 	mov	x2, x20
    40009ff8:	9100a260 	add	x0, x19, #0x28
    40009ffc:	b0000001 	adrp	x1, 4000a000 <z_impl_k_thread_create+0x5c>
    4000a000:	91276021 	add	x1, x1, #0x9d8
    4000a004:	9400042d 	bl	4000b0b8 <z_add_timeout>
    4000a008:	17fffff6 	b	40009fe0 <z_impl_k_thread_create+0x3c>

000000004000a00c <z_init_static_threads>:
{
    4000a00c:	d10103ff 	sub	sp, sp, #0x40
    4000a010:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000a014:	910043fd 	add	x29, sp, #0x10
    4000a018:	a90253f3 	stp	x19, x20, [sp, #32]
	_FOREACH_STATIC_THREAD(thread_data) {
    4000a01c:	900002f3 	adrp	x19, 40066000 <sys_work_q_stack+0x3d0>
    4000a020:	913ea273 	add	x19, x19, #0xfa8
    4000a024:	aa1303f4 	mov	x20, x19
{
    4000a028:	a9035bf5 	stp	x21, x22, [sp, #48]
	_FOREACH_STATIC_THREAD(thread_data) {
    4000a02c:	900002f5 	adrp	x21, 40066000 <sys_work_q_stack+0x3d0>
    4000a030:	913ea2b5 	add	x21, x21, #0xfa8
    4000a034:	eb15027f 	cmp	x19, x21
    4000a038:	540001a3 	b.cc	4000a06c <z_init_static_threads+0x60>  // b.lo, b.ul, b.last
	_FOREACH_STATIC_THREAD(thread_data) {
    4000a03c:	aa1403f3 	mov	x19, x20
    4000a040:	90000014 	adrp	x20, 4000a000 <z_impl_k_thread_create+0x5c>
    4000a044:	91276294 	add	x20, x20, #0x9d8
	if (div_ratio) {
		t += off;
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
    4000a048:	d2800156 	mov	x22, #0xa                   	// #10
	k_sched_lock();
    4000a04c:	9400018f 	bl	4000a688 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    4000a050:	eb15027f 	cmp	x19, x21
    4000a054:	54000283 	b.cc	4000a0a4 <z_init_static_threads+0x98>  // b.lo, b.ul, b.last
}
    4000a058:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000a05c:	a94253f3 	ldp	x19, x20, [sp, #32]
    4000a060:	a9435bf5 	ldp	x21, x22, [sp, #48]
    4000a064:	910103ff 	add	sp, sp, #0x40
	k_sched_unlock();
    4000a068:	14000312 	b	4000acb0 <k_sched_unlock>
		z_setup_new_thread(
    4000a06c:	f9402a60 	ldr	x0, [x19, #80]
    4000a070:	f90007e0 	str	x0, [sp, #8]
    4000a074:	b9403e60 	ldr	w0, [x19, #60]
    4000a078:	b90003e0 	str	w0, [sp]
    4000a07c:	a9400660 	ldp	x0, x1, [x19]
    4000a080:	a9419263 	ldp	x3, x4, [x19, #24]
    4000a084:	a9429a65 	ldp	x5, x6, [x19, #40]
    4000a088:	b9401262 	ldr	w2, [x19, #16]
    4000a08c:	b9403a67 	ldr	w7, [x19, #56]
    4000a090:	97ffff7d 	bl	40009e84 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    4000a094:	f9400260 	ldr	x0, [x19]
    4000a098:	f9005813 	str	x19, [x0, #176]
	_FOREACH_STATIC_THREAD(thread_data) {
    4000a09c:	91016273 	add	x19, x19, #0x58
    4000a0a0:	17ffffe5 	b	4000a034 <z_init_static_threads+0x28>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    4000a0a4:	b9404262 	ldr	w2, [x19, #64]
    4000a0a8:	3100045f 	cmn	w2, #0x1
    4000a0ac:	54000100 	b.eq	4000a0cc <z_init_static_threads+0xc0>  // b.none
					    K_MSEC(thread_data->init_delay));
    4000a0b0:	7100005f 	cmp	w2, #0x0
    4000a0b4:	1a9fa042 	csel	w2, w2, wzr, ge  // ge = tcont
			schedule_new_thread(thread_data->init_thread,
    4000a0b8:	f9400260 	ldr	x0, [x19]
					    K_MSEC(thread_data->init_delay));
    4000a0bc:	93407c43 	sxtw	x3, w2
		t += off;
    4000a0c0:	91002462 	add	x2, x3, #0x9
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    4000a0c4:	b5000083 	cbnz	x3, 4000a0d4 <z_init_static_threads+0xc8>
	z_sched_start(thread);
    4000a0c8:	9400022f 	bl	4000a984 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    4000a0cc:	91016273 	add	x19, x19, #0x58
    4000a0d0:	17ffffe0 	b	4000a050 <z_init_static_threads+0x44>
    4000a0d4:	9ad60842 	udiv	x2, x2, x22
    4000a0d8:	aa1403e1 	mov	x1, x20
    4000a0dc:	9100a000 	add	x0, x0, #0x28
    4000a0e0:	940003f6 	bl	4000b0b8 <z_add_timeout>
    4000a0e4:	17fffffa 	b	4000a0cc <z_init_static_threads+0xc0>

000000004000a0e8 <z_impl_k_thread_stack_space_get>:

int z_impl_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
	const uint8_t *start = (uint8_t *)thread->stack_info.start;
	size_t size = thread->stack_info.size;
    4000a0e8:	a9520803 	ldp	x3, x2, [x0, #288]
	size_t unused = 0;
    4000a0ec:	d2800000 	mov	x0, #0x0                   	// #0
		 */
		checked_stack += 4;
		size -= 4;
	}

	for (size_t i = 0; i < size; i++) {
    4000a0f0:	eb02001f 	cmp	x0, x2
    4000a0f4:	54000081 	b.ne	4000a104 <z_impl_k_thread_stack_space_get+0x1c>  // b.any
		} else {
			break;
		}
	}

	*unused_ptr = unused;
    4000a0f8:	f9000020 	str	x0, [x1]

	return 0;
}
    4000a0fc:	52800000 	mov	w0, #0x0                   	// #0
    4000a100:	d65f03c0 	ret
		if ((checked_stack[i]) == 0xaaU) {
    4000a104:	38606864 	ldrb	w4, [x3, x0]
    4000a108:	7102a89f 	cmp	w4, #0xaa
    4000a10c:	54ffff61 	b.ne	4000a0f8 <z_impl_k_thread_stack_space_get+0x10>  // b.any
			unused++;
    4000a110:	91000400 	add	x0, x0, #0x1
	for (size_t i = 0; i < size; i++) {
    4000a114:	17fffff7 	b	4000a0f0 <z_impl_k_thread_stack_space_get+0x8>

000000004000a118 <sys_kernel_version_get>:
 * @return kernel version
 */
uint32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
    4000a118:	528c6000 	mov	w0, #0x6300                	// #25344
    4000a11c:	72a040e0 	movk	w0, #0x207, lsl #16
    4000a120:	d65f03c0 	ret

000000004000a124 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    4000a124:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000a128:	910003fd 	mov	x29, sp
    4000a12c:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a130:	d50342df 	msr	daifset, #0x2
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    4000a134:	97fff6bd 	bl	40007c28 <arch_cpu_idle>
    4000a138:	17fffffd 	b	4000a12c <idle+0x8>

000000004000a13c <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
    4000a13c:	39c06802 	ldrsb	w2, [x0, #26]
    4000a140:	6b01005f 	cmp	w2, w1
    4000a144:	54000040 	b.eq	4000a14c <adjust_owner_prio.isra.0+0x10>  // b.none
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
    4000a148:	140002a0 	b	4000abc8 <z_set_prio>
	}
	return false;
}
    4000a14c:	52800000 	mov	w0, #0x0                   	// #0
    4000a150:	d65f03c0 	ret

000000004000a154 <z_impl_k_mutex_init>:
	list->tail = (sys_dnode_t *)list;
    4000a154:	a9000000 	stp	x0, x0, [x0]
	mutex->owner = NULL;
    4000a158:	f900081f 	str	xzr, [x0, #16]
	mutex->lock_count = 0U;
    4000a15c:	b900181f 	str	wzr, [x0, #24]
}
    4000a160:	52800000 	mov	w0, #0x0                   	// #0
    4000a164:	d65f03c0 	ret

000000004000a168 <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    4000a168:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000a16c:	910003fd 	mov	x29, sp
    4000a170:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a174:	aa0003f3 	mov	x19, x0
    4000a178:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000a17c:	f9001bf7 	str	x23, [sp, #48]
    4000a180:	aa0103f7 	mov	x23, x1
MAKE_REG_HELPER(daif)
    4000a184:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a188:	d50342df 	msr	daifset, #0x2

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    4000a18c:	b9401801 	ldr	w1, [x0, #24]
    4000a190:	90000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    4000a194:	91094042 	add	x2, x2, #0x250
    4000a198:	34000141 	cbz	w1, 4000a1c0 <z_impl_k_mutex_lock+0x58>
    4000a19c:	f9400844 	ldr	x4, [x2, #16]
    4000a1a0:	f9400800 	ldr	x0, [x0, #16]
    4000a1a4:	eb04001f 	cmp	x0, x4
    4000a1a8:	54000280 	b.eq	4000a1f8 <z_impl_k_mutex_lock+0x90>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    4000a1ac:	b50002b7 	cbnz	x23, 4000a200 <z_impl_k_mutex_lock+0x98>
MAKE_REG_HELPER(daif)
    4000a1b0:	92407e94 	and	x20, x20, #0xffffffff
    4000a1b4:	d51b4234 	msr	daif, x20
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
    4000a1b8:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    4000a1bc:	1400000a 	b	4000a1e4 <z_impl_k_mutex_lock+0x7c>
					_current->base.prio :
    4000a1c0:	f9400840 	ldr	x0, [x2, #16]
    4000a1c4:	39c06800 	ldrsb	w0, [x0, #26]
		mutex->lock_count++;
    4000a1c8:	11000421 	add	w1, w1, #0x1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    4000a1cc:	29030261 	stp	w1, w0, [x19, #24]
		mutex->owner = _current;
    4000a1d0:	f9400840 	ldr	x0, [x2, #16]
    4000a1d4:	92407e94 	and	x20, x20, #0xffffffff
    4000a1d8:	f9000a60 	str	x0, [x19, #16]
    4000a1dc:	d51b4234 	msr	daif, x20
		return 0;
    4000a1e0:	52800000 	mov	w0, #0x0                   	// #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
    4000a1e4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a1e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a1ec:	f9401bf7 	ldr	x23, [sp, #48]
    4000a1f0:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000a1f4:	d65f03c0 	ret
					_current->base.prio :
    4000a1f8:	b9401e60 	ldr	w0, [x19, #28]
    4000a1fc:	17fffff3 	b	4000a1c8 <z_impl_k_mutex_lock+0x60>
	new_prio = new_prio_for_inheritance(_current->base.prio,
    4000a200:	39c06803 	ldrsb	w3, [x0, #26]
    4000a204:	39c06882 	ldrsb	w2, [x4, #26]
    4000a208:	6b03005f 	cmp	w2, w3
    4000a20c:	1a83d041 	csel	w1, w2, w3, le
    4000a210:	12800fc2 	mov	w2, #0xffffff81            	// #-127
    4000a214:	3101fc3f 	cmn	w1, #0x7f
    4000a218:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    4000a21c:	6b01007f 	cmp	w3, w1
    4000a220:	5400044d 	b.le	4000a2a8 <z_impl_k_mutex_lock+0x140>
		resched = adjust_owner_prio(mutex, new_prio);
    4000a224:	97ffffc6 	bl	4000a13c <adjust_owner_prio.isra.0>
    4000a228:	12001c16 	and	w22, w0, #0xff
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    4000a22c:	90000095 	adrp	x21, 4001a000 <shell_uart_ctx+0x1c8>
    4000a230:	911082b5 	add	x21, x21, #0x420
    4000a234:	aa1703e3 	mov	x3, x23
    4000a238:	aa1303e2 	mov	x2, x19
    4000a23c:	2a1403e1 	mov	w1, w20
    4000a240:	aa1503e0 	mov	x0, x21
    4000a244:	94000252 	bl	4000ab8c <z_pend_curr>
	if (got_mutex == 0) {
    4000a248:	34fffce0 	cbz	w0, 4000a1e4 <z_impl_k_mutex_lock+0x7c>
    4000a24c:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a250:	d50342df 	msr	daifset, #0x2
	return list->head == list;
    4000a254:	f9400260 	ldr	x0, [x19]
    4000a258:	b9401e61 	ldr	w1, [x19, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000a25c:	eb00027f 	cmp	x19, x0
    4000a260:	54000100 	b.eq	4000a280 <z_impl_k_mutex_lock+0x118>  // b.none
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    4000a264:	b40000e0 	cbz	x0, 4000a280 <z_impl_k_mutex_lock+0x118>
    4000a268:	39c06800 	ldrsb	w0, [x0, #26]
    4000a26c:	6b01001f 	cmp	w0, w1
    4000a270:	1a81d001 	csel	w1, w0, w1, le
    4000a274:	12800fc0 	mov	w0, #0xffffff81            	// #-127
    4000a278:	3101fc3f 	cmn	w1, #0x7f
    4000a27c:	1a80a021 	csel	w1, w1, w0, ge  // ge = tcont
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    4000a280:	f9400a60 	ldr	x0, [x19, #16]
    4000a284:	97ffffae 	bl	4000a13c <adjust_owner_prio.isra.0>
    4000a288:	72001c1f 	tst	w0, #0xff
    4000a28c:	54000041 	b.ne	4000a294 <z_impl_k_mutex_lock+0x12c>  // b.any
	if (resched) {
    4000a290:	34000116 	cbz	w22, 4000a2b0 <z_impl_k_mutex_lock+0x148>
		z_reschedule(&lock, key);
    4000a294:	2a1403e1 	mov	w1, w20
    4000a298:	aa1503e0 	mov	x0, x21
    4000a29c:	940000e0 	bl	4000a61c <z_reschedule>
	return -EAGAIN;
    4000a2a0:	12800140 	mov	w0, #0xfffffff5            	// #-11
    4000a2a4:	17ffffd0 	b	4000a1e4 <z_impl_k_mutex_lock+0x7c>
	bool resched = false;
    4000a2a8:	52800016 	mov	w22, #0x0                   	// #0
    4000a2ac:	17ffffe0 	b	4000a22c <z_impl_k_mutex_lock+0xc4>
MAKE_REG_HELPER(daif)
    4000a2b0:	92407e94 	and	x20, x20, #0xffffffff
    4000a2b4:	d51b4234 	msr	daif, x20
    4000a2b8:	17fffffa 	b	4000a2a0 <z_impl_k_mutex_lock+0x138>

000000004000a2bc <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    4000a2bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a2c0:	910003fd 	mov	x29, sp
    4000a2c4:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a2c8:	aa0003f3 	mov	x19, x0

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
    4000a2cc:	f9400800 	ldr	x0, [x0, #16]
    4000a2d0:	b4000500 	cbz	x0, 4000a370 <z_impl_k_mutex_unlock+0xb4>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    4000a2d4:	90000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000a2d8:	f9413021 	ldr	x1, [x1, #608]
    4000a2dc:	eb01001f 	cmp	x0, x1
    4000a2e0:	540004c1 	b.ne	4000a378 <z_impl_k_mutex_unlock+0xbc>  // b.any
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    4000a2e4:	39406c01 	ldrb	w1, [x0, #27]
    4000a2e8:	51000421 	sub	w1, w1, #0x1
    4000a2ec:	39006c01 	strb	w1, [x0, #27]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
    4000a2f0:	b9401a60 	ldr	w0, [x19, #24]
    4000a2f4:	7100041f 	cmp	w0, #0x1
    4000a2f8:	54000109 	b.ls	4000a318 <z_impl_k_mutex_unlock+0x5c>  // b.plast
		mutex->lock_count--;
    4000a2fc:	51000400 	sub	w0, w0, #0x1
    4000a300:	b9001a60 	str	w0, [x19, #24]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
    4000a304:	9400026b 	bl	4000acb0 <k_sched_unlock>

	return 0;
    4000a308:	52800000 	mov	w0, #0x0                   	// #0
}
    4000a30c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a310:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a314:	d65f03c0 	ret
    4000a318:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a31c:	d50342df 	msr	daifset, #0x2
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    4000a320:	b9401e61 	ldr	w1, [x19, #28]
    4000a324:	f9400a60 	ldr	x0, [x19, #16]
    4000a328:	97ffff85 	bl	4000a13c <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    4000a32c:	aa1303e0 	mov	x0, x19
    4000a330:	94000271 	bl	4000acf4 <z_unpend_first_thread>
	mutex->owner = new_owner;
    4000a334:	f9000a60 	str	x0, [x19, #16]
	if (new_owner != NULL) {
    4000a338:	b4000140 	cbz	x0, 4000a360 <z_impl_k_mutex_unlock+0xa4>
		mutex->owner_orig_prio = new_owner->base.prio;
    4000a33c:	39c06801 	ldrsb	w1, [x0, #26]
    4000a340:	b9001e61 	str	w1, [x19, #28]
 * z_swap() is in use it's a simple inline provided by the kernel.
 */
static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->swap_retval = value;
    4000a344:	b901381f 	str	wzr, [x0, #312]
		z_ready_thread(new_owner);
    4000a348:	94000184 	bl	4000a958 <z_ready_thread>
		z_reschedule(&lock, key);
    4000a34c:	2a1403e1 	mov	w1, w20
    4000a350:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000a354:	91108000 	add	x0, x0, #0x420
    4000a358:	940000b1 	bl	4000a61c <z_reschedule>
    4000a35c:	17ffffea 	b	4000a304 <z_impl_k_mutex_unlock+0x48>
MAKE_REG_HELPER(daif)
    4000a360:	92407e94 	and	x20, x20, #0xffffffff
		mutex->lock_count = 0U;
    4000a364:	b9001a7f 	str	wzr, [x19, #24]
    4000a368:	d51b4234 	msr	daif, x20
    4000a36c:	17ffffe6 	b	4000a304 <z_impl_k_mutex_unlock+0x48>
		return -EINVAL;
    4000a370:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4000a374:	17ffffe6 	b	4000a30c <z_impl_k_mutex_unlock+0x50>
		return -EPERM;
    4000a378:	12800000 	mov	w0, #0xffffffff            	// #-1
    4000a37c:	17ffffe4 	b	4000a30c <z_impl_k_mutex_unlock+0x50>

000000004000a380 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    4000a380:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a384:	910003fd 	mov	x29, sp
    4000a388:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a38c:	aa0003f3 	mov	x19, x0
    4000a390:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a394:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    4000a398:	94000257 	bl	4000acf4 <z_unpend_first_thread>

	if (thread != NULL) {
    4000a39c:	b4000120 	cbz	x0, 4000a3c0 <z_impl_k_sem_give+0x40>
    4000a3a0:	b901381f 	str	wzr, [x0, #312]
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    4000a3a4:	9400016d 	bl	4000a958 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    4000a3a8:	2a1403e1 	mov	w1, w20
    4000a3ac:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000a3b0:	91108000 	add	x0, x0, #0x420

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    4000a3b4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a3b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule(&lock, key);
    4000a3bc:	14000098 	b	4000a61c <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    4000a3c0:	29420660 	ldp	w0, w1, [x19, #16]
    4000a3c4:	6b00003f 	cmp	w1, w0
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    4000a3c8:	52800041 	mov	w1, #0x2                   	// #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    4000a3cc:	1a800400 	cinc	w0, w0, ne  // ne = any
    4000a3d0:	b9001260 	str	w0, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    4000a3d4:	91006260 	add	x0, x19, #0x18
    4000a3d8:	94000600 	bl	4000bbd8 <z_handle_obj_poll_events>
}
    4000a3dc:	17fffff3 	b	4000a3a8 <z_impl_k_sem_give+0x28>

000000004000a3e0 <sys_dlist_remove>:
	sys_dnode_t *const prev = node->prev;
    4000a3e0:	a9400801 	ldp	x1, x2, [x0]
	prev->next = next;
    4000a3e4:	f9000041 	str	x1, [x2]
	next->prev = prev;
    4000a3e8:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
    4000a3ec:	a9007c1f 	stp	xzr, xzr, [x0]
	sys_dnode_init(node);
}
    4000a3f0:	d65f03c0 	ret

000000004000a3f4 <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
    4000a3f4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000a3f8:	aa0003e3 	mov	x3, x0
    4000a3fc:	910003fd 	mov	x29, sp

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    4000a400:	97fffff8 	bl	4000a3e0 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    4000a404:	39406400 	ldrb	w0, [x0, #25]
    4000a408:	121e7800 	and	w0, w0, #0xfffffffd
    4000a40c:	39006460 	strb	w0, [x3, #25]
}
    4000a410:	a8c17bfd 	ldp	x29, x30, [sp], #16
	thread->base.pended_on = NULL;
    4000a414:	f900087f 	str	xzr, [x3, #16]
}
    4000a418:	d65f03c0 	ret

000000004000a41c <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
    4000a41c:	39c06802 	ldrsb	w2, [x0, #26]
	int32_t b2 = thread_2->base.prio;
    4000a420:	39c06821 	ldrsb	w1, [x1, #26]
		return b2 - b1;
    4000a424:	4b020020 	sub	w0, w1, w2
    4000a428:	6b01005f 	cmp	w2, w1
}
    4000a42c:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
    4000a430:	d65f03c0 	ret

000000004000a434 <z_reset_time_slice>:
{
    4000a434:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a438:	910003fd 	mov	x29, sp
    4000a43c:	f9000bf3 	str	x19, [sp, #16]
	if (slice_time != 0) {
    4000a440:	90000093 	adrp	x19, 4001a000 <shell_uart_ctx+0x1c8>
    4000a444:	b942e660 	ldr	w0, [x19, #740]
    4000a448:	34000160 	cbz	w0, 4000a474 <z_reset_time_slice+0x40>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    4000a44c:	97fffcf3 	bl	40009818 <sys_clock_elapsed>
    4000a450:	2a0003e1 	mov	w1, w0
    4000a454:	b942e660 	ldr	w0, [x19, #740]
    4000a458:	90000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
}
    4000a45c:	f9400bf3 	ldr	x19, [sp, #16]
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    4000a460:	0b010001 	add	w1, w0, w1
}
    4000a464:	a8c27bfd 	ldp	x29, x30, [sp], #32
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    4000a468:	b9027041 	str	w1, [x2, #624]
		z_set_timeout_expiry(slice_time, false);
    4000a46c:	52800001 	mov	w1, #0x0                   	// #0
    4000a470:	14000369 	b	4000b214 <z_set_timeout_expiry>
}
    4000a474:	f9400bf3 	ldr	x19, [sp, #16]
    4000a478:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a47c:	d65f03c0 	ret

000000004000a480 <z_swap_irqlock>:
{
    4000a480:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000a484:	910003fd 	mov	x29, sp
    4000a488:	a90153f3 	stp	x19, x20, [sp, #16]
	old_thread = _current;
    4000a48c:	90000093 	adrp	x19, 4001a000 <shell_uart_ctx+0x1c8>
    4000a490:	91094273 	add	x19, x19, #0x250
{
    4000a494:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000a498:	2a0003f4 	mov	w20, w0
	old_thread->swap_retval = -EAGAIN;
    4000a49c:	12800140 	mov	w0, #0xfffffff5            	// #-11
	old_thread = _current;
    4000a4a0:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    4000a4a4:	b9013ac0 	str	w0, [x22, #312]
MAKE_REG_HELPER(daif)
    4000a4a8:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a4ac:	d50342df 	msr	daifset, #0x2
	return _kernel.ready_q.cache;
    4000a4b0:	f9401a75 	ldr	x21, [x19, #48]
	if (new_thread != old_thread) {
    4000a4b4:	eb1502df 	cmp	x22, x21
    4000a4b8:	540000c0 	b.eq	4000a4d0 <z_swap_irqlock+0x50>  // b.none
		z_reset_time_slice();
    4000a4bc:	97ffffde 	bl	4000a434 <z_reset_time_slice>
		_current_cpu->current = new_thread;
    4000a4c0:	f9000a75 	str	x21, [x19, #16]
    4000a4c4:	f940a2a0 	ldr	x0, [x21, #320]
    4000a4c8:	910502c1 	add	x1, x22, #0x140
    4000a4cc:	97fff6a6 	bl	40007f64 <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    4000a4d0:	d51b4234 	msr	daif, x20
	return _current->swap_retval;
    4000a4d4:	f9400a60 	ldr	x0, [x19, #16]
}
    4000a4d8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a4dc:	b9413800 	ldr	w0, [x0, #312]
    4000a4e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a4e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000a4e8:	d65f03c0 	ret

000000004000a4ec <z_swap>:
{
    4000a4ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000a4f0:	910003fd 	mov	x29, sp
    4000a4f4:	a90153f3 	stp	x19, x20, [sp, #16]
	old_thread = _current;
    4000a4f8:	90000093 	adrp	x19, 4001a000 <shell_uart_ctx+0x1c8>
    4000a4fc:	91094273 	add	x19, x19, #0x250
{
    4000a500:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000a504:	2a0103f4 	mov	w20, w1
	old_thread->swap_retval = -EAGAIN;
    4000a508:	12800141 	mov	w1, #0xfffffff5            	// #-11
	old_thread = _current;
    4000a50c:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    4000a510:	b9013ac1 	str	w1, [x22, #312]
	if (!is_spinlock || lock != &sched_spinlock) {
    4000a514:	90000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000a518:	91108021 	add	x1, x1, #0x420
    4000a51c:	eb00003f 	cmp	x1, x0
    4000a520:	54000060 	b.eq	4000a52c <z_swap+0x40>  // b.none
    4000a524:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a528:	d50342df 	msr	daifset, #0x2
    4000a52c:	f9401a75 	ldr	x21, [x19, #48]
	if (new_thread != old_thread) {
    4000a530:	eb1502df 	cmp	x22, x21
    4000a534:	540000c0 	b.eq	4000a54c <z_swap+0x60>  // b.none
		z_reset_time_slice();
    4000a538:	97ffffbf 	bl	4000a434 <z_reset_time_slice>
		_current_cpu->current = new_thread;
    4000a53c:	f9000a75 	str	x21, [x19, #16]
    4000a540:	f940a2a0 	ldr	x0, [x21, #320]
    4000a544:	910502c1 	add	x1, x22, #0x140
    4000a548:	97fff687 	bl	40007f64 <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    4000a54c:	d51b4234 	msr	daif, x20
	return _current->swap_retval;
    4000a550:	f9400a60 	ldr	x0, [x19, #16]
}
    4000a554:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a558:	b9413800 	ldr	w0, [x0, #312]
    4000a55c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a560:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000a564:	d65f03c0 	ret

000000004000a568 <k_sched_time_slice_set>:
{
    4000a568:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a56c:	910003fd 	mov	x29, sp
    4000a570:	f9000bf3 	str	x19, [sp, #16]
    4000a574:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a578:	d50342df 	msr	daifset, #0x2
		_current_cpu->slice_ticks = 0;
    4000a57c:	90000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
		if (result32 && (t < BIT64(32))) {
    4000a580:	b2407fe3 	mov	x3, #0xffffffff            	// #4294967295
    4000a584:	b902705f 	str	wzr, [x2, #624]
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
    4000a588:	2a0003e2 	mov	w2, w0
		t += off;
    4000a58c:	91002442 	add	x2, x2, #0x9
		if (result32 && (t < BIT64(32))) {
    4000a590:	eb03005f 	cmp	x2, x3
    4000a594:	54000208 	b.hi	4000a5d4 <k_sched_time_slice_set+0x6c>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    4000a598:	11002402 	add	w2, w0, #0x9
    4000a59c:	52800143 	mov	w3, #0xa                   	// #10
    4000a5a0:	1ac30842 	udiv	w2, w2, w3
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    4000a5a4:	7100001f 	cmp	w0, #0x0
    4000a5a8:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000a5ac:	540001ac 	b.gt	4000a5e0 <k_sched_time_slice_set+0x78>
			slice_time = MAX(2, slice_time);
    4000a5b0:	b902e402 	str	w2, [x0, #740]
		slice_max_prio = prio;
    4000a5b4:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
MAKE_REG_HELPER(daif)
    4000a5b8:	92407e73 	and	x19, x19, #0xffffffff
    4000a5bc:	b902e001 	str	w1, [x0, #736]
		z_reset_time_slice();
    4000a5c0:	97ffff9d 	bl	4000a434 <z_reset_time_slice>
    4000a5c4:	d51b4233 	msr	daif, x19
}
    4000a5c8:	f9400bf3 	ldr	x19, [sp, #16]
    4000a5cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a5d0:	d65f03c0 	ret
			return t / ((uint64_t)from_hz / to_hz);
    4000a5d4:	d2800143 	mov	x3, #0xa                   	// #10
    4000a5d8:	9ac30842 	udiv	x2, x2, x3
    4000a5dc:	17fffff2 	b	4000a5a4 <k_sched_time_slice_set+0x3c>
			slice_time = MAX(2, slice_time);
    4000a5e0:	7100085f 	cmp	w2, #0x2
    4000a5e4:	52800043 	mov	w3, #0x2                   	// #2
    4000a5e8:	1a83a042 	csel	w2, w2, w3, ge  // ge = tcont
    4000a5ec:	17fffff1 	b	4000a5b0 <k_sched_time_slice_set+0x48>

000000004000a5f0 <z_unpend_thread>:
{
    4000a5f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000a5f4:	aa0003e4 	mov	x4, x0
    4000a5f8:	910003fd 	mov	x29, sp
    4000a5fc:	d53b4225 	mrs	x5, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a600:	d50342df 	msr	daifset, #0x2
		unpend_thread_no_timeout(thread);
    4000a604:	97ffff7c 	bl	4000a3f4 <unpend_thread_no_timeout>
MAKE_REG_HELPER(daif)
    4000a608:	92407ca5 	and	x5, x5, #0xffffffff
    4000a60c:	d51b4225 	msr	daif, x5
}
    4000a610:	a8c17bfd 	ldp	x29, x30, [sp], #16
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    4000a614:	9100a080 	add	x0, x4, #0x28
    4000a618:	140002ef 	b	4000b1d4 <z_abort_timeout>

000000004000a61c <z_reschedule>:
{
    4000a61c:	2a0103e2 	mov	w2, w1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    4000a620:	36380062 	tbz	w2, #7, 4000a62c <z_reschedule+0x10>
    4000a624:	d51b4222 	msr	daif, x2
}
    4000a628:	d65f03c0 	ret
MAKE_REG_HELPER(tpidrro_el0);
    4000a62c:	d53bd063 	mrs	x3, tpidrro_el0
    4000a630:	927db063 	and	x3, x3, #0xfffffffffff8
	if (resched(key.key) && need_swap()) {
    4000a634:	b9400063 	ldr	w3, [x3]
    4000a638:	35ffff63 	cbnz	w3, 4000a624 <z_reschedule+0x8>
	new_thread = _kernel.ready_q.cache;
    4000a63c:	90000083 	adrp	x3, 4001a000 <shell_uart_ctx+0x1c8>
    4000a640:	91094063 	add	x3, x3, #0x250
	if (resched(key.key) && need_swap()) {
    4000a644:	f9401864 	ldr	x4, [x3, #48]
    4000a648:	f9400863 	ldr	x3, [x3, #16]
    4000a64c:	eb03009f 	cmp	x4, x3
    4000a650:	54fffea0 	b.eq	4000a624 <z_reschedule+0x8>  // b.none
		z_swap(lock, key);
    4000a654:	17ffffa6 	b	4000a4ec <z_swap>

000000004000a658 <z_reschedule_irqlock>:
{
    4000a658:	2a0003e1 	mov	w1, w0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    4000a65c:	36380061 	tbz	w1, #7, 4000a668 <z_reschedule_irqlock+0x10>
MAKE_REG_HELPER(daif)
    4000a660:	d51b4221 	msr	daif, x1
}
    4000a664:	d65f03c0 	ret
MAKE_REG_HELPER(tpidrro_el0);
    4000a668:	d53bd062 	mrs	x2, tpidrro_el0
    4000a66c:	927db042 	and	x2, x2, #0xfffffffffff8
	if (resched(key)) {
    4000a670:	b9400042 	ldr	w2, [x2]
    4000a674:	35ffff62 	cbnz	w2, 4000a660 <z_reschedule_irqlock+0x8>
		z_swap_irqlock(key);
    4000a678:	17ffff82 	b	4000a480 <z_swap_irqlock>

000000004000a67c <z_reschedule_unlocked>:
MAKE_REG_HELPER(daif)
    4000a67c:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a680:	d50342df 	msr	daifset, #0x2
	(void) z_reschedule_irqlock(arch_irq_lock());
    4000a684:	17fffff5 	b	4000a658 <z_reschedule_irqlock>

000000004000a688 <k_sched_lock>:
MAKE_REG_HELPER(daif)
    4000a688:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a68c:	d50342df 	msr	daifset, #0x2
	--_current->base.sched_locked;
    4000a690:	90000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000a694:	f9413022 	ldr	x2, [x1, #608]
    4000a698:	39406c41 	ldrb	w1, [x2, #27]
    4000a69c:	51000421 	sub	w1, w1, #0x1
    4000a6a0:	39006c41 	strb	w1, [x2, #27]
MAKE_REG_HELPER(daif)
    4000a6a4:	92407c00 	and	x0, x0, #0xffffffff
    4000a6a8:	d51b4220 	msr	daif, x0
}
    4000a6ac:	d65f03c0 	ret

000000004000a6b0 <z_swap_next_thread>:
}
    4000a6b0:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000a6b4:	f9414000 	ldr	x0, [x0, #640]
    4000a6b8:	d65f03c0 	ret

000000004000a6bc <z_get_next_switch_handle>:
	z_sched_usage_switch(_kernel.ready_q.cache);
    4000a6bc:	90000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000a6c0:	91094021 	add	x1, x1, #0x250
	_current->switch_handle = interrupted;
    4000a6c4:	f9400823 	ldr	x3, [x1, #16]
	z_sched_usage_switch(_kernel.ready_q.cache);
    4000a6c8:	f9401822 	ldr	x2, [x1, #48]
	_current_cpu->current = new_thread;
    4000a6cc:	f9000822 	str	x2, [x1, #16]
	_current->switch_handle = interrupted;
    4000a6d0:	f900a060 	str	x0, [x3, #320]
}
    4000a6d4:	f940a040 	ldr	x0, [x2, #320]
    4000a6d8:	d65f03c0 	ret

000000004000a6dc <z_priq_dumb_best>:
	return list->head == list;
    4000a6dc:	f9400001 	ldr	x1, [x0]
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *thread = NULL;
    4000a6e0:	eb01001f 	cmp	x0, x1

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    4000a6e4:	9a9f1020 	csel	x0, x1, xzr, ne  // ne = any
    4000a6e8:	d65f03c0 	ret

000000004000a6ec <update_cache>:
{
    4000a6ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a6f0:	2a0003e2 	mov	w2, w0
	return _priq_run_best(curr_cpu_runq());
    4000a6f4:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000a6f8:	910a2000 	add	x0, x0, #0x288
{
    4000a6fc:	910003fd 	mov	x29, sp
    4000a700:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a704:	90000093 	adrp	x19, 4001a000 <shell_uart_ctx+0x1c8>
    4000a708:	91094273 	add	x19, x19, #0x250
	return _priq_run_best(curr_cpu_runq());
    4000a70c:	97fffff4 	bl	4000a6dc <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    4000a710:	b50001c0 	cbnz	x0, 4000a748 <update_cache+0x5c>
    4000a714:	f9400e74 	ldr	x20, [x19, #24]
	if (z_is_thread_prevented_from_running(_current)) {
    4000a718:	f9400a61 	ldr	x1, [x19, #16]
	if (preempt_ok != 0) {
    4000a71c:	350001a2 	cbnz	w2, 4000a750 <update_cache+0x64>
	if (z_is_thread_prevented_from_running(_current)) {
    4000a720:	39406420 	ldrb	w0, [x1, #25]
    4000a724:	f240101f 	tst	x0, #0x1f
    4000a728:	54000141 	b.ne	4000a750 <update_cache+0x64>  // b.any
	if (is_preempt(_current) || is_metairq(thread)) {
    4000a72c:	79403420 	ldrh	w0, [x1, #26]
    4000a730:	7101fc1f 	cmp	w0, #0x7f
    4000a734:	540000e9 	b.ls	4000a750 <update_cache+0x64>  // b.plast
		_kernel.ready_q.cache = _current;
    4000a738:	f9001a61 	str	x1, [x19, #48]
}
    4000a73c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a740:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a744:	d65f03c0 	ret
    4000a748:	aa0003f4 	mov	x20, x0
    4000a74c:	17fffff3 	b	4000a718 <update_cache+0x2c>
		if (thread != _current) {
    4000a750:	eb01029f 	cmp	x20, x1
    4000a754:	54000040 	b.eq	4000a75c <update_cache+0x70>  // b.none
			z_reset_time_slice();
    4000a758:	97ffff37 	bl	4000a434 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    4000a75c:	f9001a74 	str	x20, [x19, #48]
}
    4000a760:	17fffff7 	b	4000a73c <update_cache+0x50>

000000004000a764 <move_thread_to_end_of_prio_q>:
{
    4000a764:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000a768:	aa0003e3 	mov	x3, x0
    4000a76c:	910003fd 	mov	x29, sp
	if (z_is_thread_queued(thread)) {
    4000a770:	39c06402 	ldrsb	w2, [x0, #25]
	return (thread->base.thread_state & state) != 0U;
    4000a774:	39406401 	ldrb	w1, [x0, #25]
    4000a778:	36f80082 	tbz	w2, #31, 4000a788 <move_thread_to_end_of_prio_q+0x24>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000a77c:	12001821 	and	w1, w1, #0x7f
    4000a780:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000a784:	97ffff17 	bl	4000a3e0 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    4000a788:	39406460 	ldrb	w0, [x3, #25]
    4000a78c:	90000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000a790:	91094021 	add	x1, x1, #0x250
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000a794:	90000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    4000a798:	910a2042 	add	x2, x2, #0x288
    4000a79c:	32196000 	orr	w0, w0, #0xffffff80
    4000a7a0:	39006460 	strb	w0, [x3, #25]
	return (node == list->tail) ? NULL : node->next;
    4000a7a4:	a9439420 	ldp	x0, x5, [x1, #56]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000a7a8:	eb02001f 	cmp	x0, x2
    4000a7ac:	540002c0 	b.eq	4000a804 <move_thread_to_end_of_prio_q+0xa0>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000a7b0:	b40002a0 	cbz	x0, 4000a804 <move_thread_to_end_of_prio_q+0xa0>
	int32_t b1 = thread_1->base.prio;
    4000a7b4:	39c06866 	ldrsb	w6, [x3, #26]
	int32_t b2 = thread_2->base.prio;
    4000a7b8:	39c06804 	ldrsb	w4, [x0, #26]
	if (b1 != b2) {
    4000a7bc:	6b0400df 	cmp	w6, w4
    4000a7c0:	540001a0 	b.eq	4000a7f4 <move_thread_to_end_of_prio_q+0x90>  // b.none
		return b2 - b1;
    4000a7c4:	4b060084 	sub	w4, w4, w6
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000a7c8:	7100009f 	cmp	w4, #0x0
    4000a7cc:	5400014d 	b.le	4000a7f4 <move_thread_to_end_of_prio_q+0x90>
	sys_dnode_t *const prev = successor->prev;
    4000a7d0:	f9400402 	ldr	x2, [x0, #8]
	node->prev = prev;
    4000a7d4:	a9000860 	stp	x0, x2, [x3]
	prev->next = node;
    4000a7d8:	f9000043 	str	x3, [x2]
	successor->prev = node;
    4000a7dc:	f9000403 	str	x3, [x0, #8]
}
    4000a7e0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	update_cache(thread == _current);
    4000a7e4:	f9400820 	ldr	x0, [x1, #16]
    4000a7e8:	eb03001f 	cmp	x0, x3
    4000a7ec:	1a9f17e0 	cset	w0, eq  // eq = none
    4000a7f0:	17ffffbf 	b	4000a6ec <update_cache>
	return (node == list->tail) ? NULL : node->next;
    4000a7f4:	eb05001f 	cmp	x0, x5
    4000a7f8:	54000060 	b.eq	4000a804 <move_thread_to_end_of_prio_q+0xa0>  // b.none
    4000a7fc:	f9400000 	ldr	x0, [x0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000a800:	b5fffdc0 	cbnz	x0, 4000a7b8 <move_thread_to_end_of_prio_q+0x54>
	node->prev = tail;
    4000a804:	a9001462 	stp	x2, x5, [x3]
	tail->next = node;
    4000a808:	f90000a3 	str	x3, [x5]
	list->tail = node;
    4000a80c:	f9002023 	str	x3, [x1, #64]
}
    4000a810:	17fffff4 	b	4000a7e0 <move_thread_to_end_of_prio_q+0x7c>

000000004000a814 <z_time_slice>:
{
    4000a814:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a818:	2a0003e3 	mov	w3, w0
    4000a81c:	910003fd 	mov	x29, sp
    4000a820:	f9000bf3 	str	x19, [sp, #16]
    4000a824:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a828:	d50342df 	msr	daifset, #0x2
	if (slice_time && sliceable(_current)) {
    4000a82c:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000a830:	b942e400 	ldr	w0, [x0, #740]
    4000a834:	90000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000a838:	91094021 	add	x1, x1, #0x250
    4000a83c:	340003c0 	cbz	w0, 4000a8b4 <z_time_slice+0xa0>
    4000a840:	f9400820 	ldr	x0, [x1, #16]
		&& !z_is_idle_thread_object(thread);
    4000a844:	79403402 	ldrh	w2, [x0, #26]
    4000a848:	7101fc5f 	cmp	w2, #0x7f
    4000a84c:	54000348 	b.hi	4000a8b4 <z_time_slice+0xa0>  // b.pmore
		&& !z_is_thread_prevented_from_running(thread)
    4000a850:	39406402 	ldrb	w2, [x0, #25]
    4000a854:	f240105f 	tst	x2, #0x1f
    4000a858:	540002e1 	b.ne	4000a8b4 <z_time_slice+0xa0>  // b.any
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    4000a85c:	39c06804 	ldrsb	w4, [x0, #26]
    4000a860:	90000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    4000a864:	b942e042 	ldr	w2, [x2, #736]
    4000a868:	6b02009f 	cmp	w4, w2
    4000a86c:	5400024b 	b.lt	4000a8b4 <z_time_slice+0xa0>  // b.tstop
		&& !z_is_idle_thread_object(thread);
    4000a870:	f0000062 	adrp	x2, 40019000 <shell_uart_thread>
    4000a874:	910dc042 	add	x2, x2, #0x370
    4000a878:	eb02001f 	cmp	x0, x2
    4000a87c:	540001c0 	b.eq	4000a8b4 <z_time_slice+0xa0>  // b.none
		if (ticks >= _current_cpu->slice_ticks) {
    4000a880:	b9402022 	ldr	w2, [x1, #32]
    4000a884:	6b03005f 	cmp	w2, w3
    4000a888:	5400010c 	b.gt	4000a8a8 <z_time_slice+0x94>
			move_thread_to_end_of_prio_q(_current);
    4000a88c:	97ffffb6 	bl	4000a764 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    4000a890:	97fffee9 	bl	4000a434 <z_reset_time_slice>
MAKE_REG_HELPER(daif)
    4000a894:	92407e73 	and	x19, x19, #0xffffffff
    4000a898:	d51b4233 	msr	daif, x19
}
    4000a89c:	f9400bf3 	ldr	x19, [sp, #16]
    4000a8a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a8a4:	d65f03c0 	ret
			_current_cpu->slice_ticks -= ticks;
    4000a8a8:	4b030042 	sub	w2, w2, w3
    4000a8ac:	b9002022 	str	w2, [x1, #32]
    4000a8b0:	17fffff9 	b	4000a894 <z_time_slice+0x80>
		_current_cpu->slice_ticks = 0;
    4000a8b4:	b900203f 	str	wzr, [x1, #32]
    4000a8b8:	17fffff7 	b	4000a894 <z_time_slice+0x80>

000000004000a8bc <ready_thread>:
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    4000a8bc:	39c06402 	ldrsb	w2, [x0, #25]
    4000a8c0:	39406401 	ldrb	w1, [x0, #25]
    4000a8c4:	37f80482 	tbnz	w2, #31, 4000a954 <ready_thread+0x98>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    4000a8c8:	f240103f 	tst	x1, #0x1f
    4000a8cc:	54000441 	b.ne	4000a954 <ready_thread+0x98>  // b.any
    4000a8d0:	f9401402 	ldr	x2, [x0, #40]
    4000a8d4:	b5000402 	cbnz	x2, 4000a954 <ready_thread+0x98>
	return list->head == list;
    4000a8d8:	90000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    4000a8dc:	91094042 	add	x2, x2, #0x250
	thread->base.thread_state |= _THREAD_QUEUED;
    4000a8e0:	32196021 	orr	w1, w1, #0xffffff80
    4000a8e4:	39006401 	strb	w1, [x0, #25]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000a8e8:	90000083 	adrp	x3, 4001a000 <shell_uart_ctx+0x1c8>
    4000a8ec:	910a2063 	add	x3, x3, #0x288
	return (node == list->tail) ? NULL : node->next;
    4000a8f0:	a9439441 	ldp	x1, x5, [x2, #56]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000a8f4:	eb03003f 	cmp	x1, x3
    4000a8f8:	54000260 	b.eq	4000a944 <ready_thread+0x88>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000a8fc:	b4000241 	cbz	x1, 4000a944 <ready_thread+0x88>
	int32_t b1 = thread_1->base.prio;
    4000a900:	39c06806 	ldrsb	w6, [x0, #26]
	int32_t b2 = thread_2->base.prio;
    4000a904:	39c06824 	ldrsb	w4, [x1, #26]
	if (b1 != b2) {
    4000a908:	6b0400df 	cmp	w6, w4
    4000a90c:	54000140 	b.eq	4000a934 <ready_thread+0x78>  // b.none
		return b2 - b1;
    4000a910:	4b060084 	sub	w4, w4, w6
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000a914:	7100009f 	cmp	w4, #0x0
    4000a918:	540000ed 	b.le	4000a934 <ready_thread+0x78>
	sys_dnode_t *const prev = successor->prev;
    4000a91c:	f9400422 	ldr	x2, [x1, #8]
	node->prev = prev;
    4000a920:	a9000801 	stp	x1, x2, [x0]
	prev->next = node;
    4000a924:	f9000040 	str	x0, [x2]
	successor->prev = node;
    4000a928:	f9000420 	str	x0, [x1, #8]
		update_cache(0);
    4000a92c:	52800000 	mov	w0, #0x0                   	// #0
    4000a930:	17ffff6f 	b	4000a6ec <update_cache>
	return (node == list->tail) ? NULL : node->next;
    4000a934:	eb05003f 	cmp	x1, x5
    4000a938:	54000060 	b.eq	4000a944 <ready_thread+0x88>  // b.none
    4000a93c:	f9400021 	ldr	x1, [x1]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000a940:	b5fffe21 	cbnz	x1, 4000a904 <ready_thread+0x48>
	node->prev = tail;
    4000a944:	a9001403 	stp	x3, x5, [x0]
	tail->next = node;
    4000a948:	f90000a0 	str	x0, [x5]
	list->tail = node;
    4000a94c:	f9002040 	str	x0, [x2, #64]
}
    4000a950:	17fffff7 	b	4000a92c <ready_thread+0x70>
}
    4000a954:	d65f03c0 	ret

000000004000a958 <z_ready_thread>:
{
    4000a958:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a95c:	910003fd 	mov	x29, sp
    4000a960:	f9000bf3 	str	x19, [sp, #16]
    4000a964:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a968:	d50342df 	msr	daifset, #0x2
			ready_thread(thread);
    4000a96c:	97ffffd4 	bl	4000a8bc <ready_thread>
MAKE_REG_HELPER(daif)
    4000a970:	92407e73 	and	x19, x19, #0xffffffff
    4000a974:	d51b4233 	msr	daif, x19
}
    4000a978:	f9400bf3 	ldr	x19, [sp, #16]
    4000a97c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a980:	d65f03c0 	ret

000000004000a984 <z_sched_start>:
{
    4000a984:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a988:	910003fd 	mov	x29, sp
    4000a98c:	f9000bf3 	str	x19, [sp, #16]
    4000a990:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a994:	d50342df 	msr	daifset, #0x2
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    4000a998:	39406402 	ldrb	w2, [x0, #25]
	if (z_has_thread_started(thread)) {
    4000a99c:	371000c2 	tbnz	w2, #2, 4000a9b4 <z_sched_start+0x30>
MAKE_REG_HELPER(daif)
    4000a9a0:	92407e73 	and	x19, x19, #0xffffffff
    4000a9a4:	d51b4233 	msr	daif, x19
}
    4000a9a8:	f9400bf3 	ldr	x19, [sp, #16]
    4000a9ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a9b0:	d65f03c0 	ret
	thread->base.thread_state &= ~_THREAD_PRESTART;
    4000a9b4:	121d7842 	and	w2, w2, #0xfffffffb
    4000a9b8:	39006402 	strb	w2, [x0, #25]
	ready_thread(thread);
    4000a9bc:	97ffffc0 	bl	4000a8bc <ready_thread>
	z_reschedule(&sched_spinlock, key);
    4000a9c0:	2a1303e1 	mov	w1, w19
    4000a9c4:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000a9c8:	91108000 	add	x0, x0, #0x420
}
    4000a9cc:	f9400bf3 	ldr	x19, [sp, #16]
    4000a9d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule(&sched_spinlock, key);
    4000a9d4:	17ffff12 	b	4000a61c <z_reschedule>

000000004000a9d8 <z_thread_timeout>:
{
    4000a9d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a9dc:	910003fd 	mov	x29, sp
    4000a9e0:	f9000bf3 	str	x19, [sp, #16]
    4000a9e4:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000a9e8:	d50342df 	msr	daifset, #0x2
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
    4000a9ec:	d100a004 	sub	x4, x0, #0x28
		if (!killed) {
    4000a9f0:	52800501 	mov	w1, #0x28                  	// #40
    4000a9f4:	39406480 	ldrb	w0, [x4, #25]
    4000a9f8:	6a00003f 	tst	w1, w0
    4000a9fc:	54000161 	b.ne	4000aa28 <z_thread_timeout+0x50>  // b.any
			if (thread->base.pended_on != NULL) {
    4000aa00:	f9400880 	ldr	x0, [x4, #16]
    4000aa04:	b4000060 	cbz	x0, 4000aa10 <z_thread_timeout+0x38>
				unpend_thread_no_timeout(thread);
    4000aa08:	aa0403e0 	mov	x0, x4
    4000aa0c:	97fffe7a 	bl	4000a3f4 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    4000aa10:	39406480 	ldrb	w0, [x4, #25]
    4000aa14:	12800281 	mov	w1, #0xffffffeb            	// #-21
    4000aa18:	0a010000 	and	w0, w0, w1
    4000aa1c:	39006480 	strb	w0, [x4, #25]
			ready_thread(thread);
    4000aa20:	aa0403e0 	mov	x0, x4
    4000aa24:	97ffffa6 	bl	4000a8bc <ready_thread>
MAKE_REG_HELPER(daif)
    4000aa28:	92407e73 	and	x19, x19, #0xffffffff
    4000aa2c:	d51b4233 	msr	daif, x19
}
    4000aa30:	f9400bf3 	ldr	x19, [sp, #16]
    4000aa34:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000aa38:	d65f03c0 	ret

000000004000aa3c <unready_thread>:
	if (z_is_thread_queued(thread)) {
    4000aa3c:	39c06402 	ldrsb	w2, [x0, #25]
{
    4000aa40:	aa0003e3 	mov	x3, x0
	return (thread->base.thread_state & state) != 0U;
    4000aa44:	39406401 	ldrb	w1, [x0, #25]
	if (z_is_thread_queued(thread)) {
    4000aa48:	36f80182 	tbz	w2, #31, 4000aa78 <unready_thread+0x3c>
{
    4000aa4c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000aa50:	12001821 	and	w1, w1, #0x7f
{
    4000aa54:	910003fd 	mov	x29, sp
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000aa58:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000aa5c:	97fffe61 	bl	4000a3e0 <sys_dlist_remove>
	update_cache(thread == _current);
    4000aa60:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000aa64:	f9413000 	ldr	x0, [x0, #608]
}
    4000aa68:	a8c17bfd 	ldp	x29, x30, [sp], #16
	update_cache(thread == _current);
    4000aa6c:	eb03001f 	cmp	x0, x3
    4000aa70:	1a9f17e0 	cset	w0, eq  // eq = none
    4000aa74:	17ffff1e 	b	4000a6ec <update_cache>
    4000aa78:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000aa7c:	f9413000 	ldr	x0, [x0, #608]
    4000aa80:	eb03001f 	cmp	x0, x3
    4000aa84:	1a9f17e0 	cset	w0, eq  // eq = none
    4000aa88:	17fffffb 	b	4000aa74 <unready_thread+0x38>

000000004000aa8c <add_to_waitq_locked>:
{
    4000aa8c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000aa90:	910003fd 	mov	x29, sp
    4000aa94:	a90153f3 	stp	x19, x20, [sp, #16]
    4000aa98:	aa0003f3 	mov	x19, x0
    4000aa9c:	aa0103f4 	mov	x20, x1
	unready_thread(thread);
    4000aaa0:	97ffffe7 	bl	4000aa3c <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    4000aaa4:	39406660 	ldrb	w0, [x19, #25]
    4000aaa8:	321f0000 	orr	w0, w0, #0x2
    4000aaac:	39006660 	strb	w0, [x19, #25]
	if (wait_q != NULL) {
    4000aab0:	b4000234 	cbz	x20, 4000aaf4 <add_to_waitq_locked+0x68>
	return list->head == list;
    4000aab4:	f9400280 	ldr	x0, [x20]
		thread->base.pended_on = wait_q;
    4000aab8:	f9000a74 	str	x20, [x19, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000aabc:	eb00029f 	cmp	x20, x0
    4000aac0:	540002a0 	b.eq	4000ab14 <add_to_waitq_locked+0x88>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000aac4:	b4000280 	cbz	x0, 4000ab14 <add_to_waitq_locked+0x88>
	int32_t b1 = thread_1->base.prio;
    4000aac8:	39c06a62 	ldrsb	w2, [x19, #26]
	int32_t b2 = thread_2->base.prio;
    4000aacc:	39c06801 	ldrsb	w1, [x0, #26]
	if (b1 != b2) {
    4000aad0:	6b01005f 	cmp	w2, w1
    4000aad4:	54000160 	b.eq	4000ab00 <add_to_waitq_locked+0x74>  // b.none
		return b2 - b1;
    4000aad8:	4b020021 	sub	w1, w1, w2
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000aadc:	7100003f 	cmp	w1, #0x0
    4000aae0:	5400010d 	b.le	4000ab00 <add_to_waitq_locked+0x74>
	sys_dnode_t *const prev = successor->prev;
    4000aae4:	f9400401 	ldr	x1, [x0, #8]
	node->prev = prev;
    4000aae8:	a9000660 	stp	x0, x1, [x19]
	prev->next = node;
    4000aaec:	f9000033 	str	x19, [x1]
	successor->prev = node;
    4000aaf0:	f9000413 	str	x19, [x0, #8]
}
    4000aaf4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000aaf8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000aafc:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
    4000ab00:	f9400681 	ldr	x1, [x20, #8]
    4000ab04:	eb01001f 	cmp	x0, x1
    4000ab08:	54000060 	b.eq	4000ab14 <add_to_waitq_locked+0x88>  // b.none
    4000ab0c:	f9400000 	ldr	x0, [x0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000ab10:	b5fffde0 	cbnz	x0, 4000aacc <add_to_waitq_locked+0x40>
	sys_dnode_t *const tail = list->tail;
    4000ab14:	f9400680 	ldr	x0, [x20, #8]
	node->prev = tail;
    4000ab18:	a9000274 	stp	x20, x0, [x19]
	tail->next = node;
    4000ab1c:	f9000013 	str	x19, [x0]
	list->tail = node;
    4000ab20:	f9000693 	str	x19, [x20, #8]
}
    4000ab24:	17fffff4 	b	4000aaf4 <add_to_waitq_locked+0x68>

000000004000ab28 <pend>:
{
    4000ab28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000ab2c:	910003fd 	mov	x29, sp
    4000ab30:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ab34:	aa0003f4 	mov	x20, x0
    4000ab38:	aa0203f3 	mov	x19, x2
    4000ab3c:	f90013f5 	str	x21, [sp, #32]
    4000ab40:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ab44:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(daif)
    4000ab48:	92407eb5 	and	x21, x21, #0xffffffff
		add_to_waitq_locked(thread, wait_q);
    4000ab4c:	97ffffd0 	bl	4000aa8c <add_to_waitq_locked>
    4000ab50:	d51b4235 	msr	daif, x21
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    4000ab54:	b100067f 	cmn	x19, #0x1
    4000ab58:	54000120 	b.eq	4000ab7c <pend+0x54>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    4000ab5c:	aa1303e2 	mov	x2, x19
    4000ab60:	9100a280 	add	x0, x20, #0x28
}
    4000ab64:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ab68:	90000001 	adrp	x1, 4000a000 <z_impl_k_thread_create+0x5c>
    4000ab6c:	91276021 	add	x1, x1, #0x9d8
    4000ab70:	f94013f5 	ldr	x21, [sp, #32]
    4000ab74:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000ab78:	14000150 	b	4000b0b8 <z_add_timeout>
    4000ab7c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ab80:	f94013f5 	ldr	x21, [sp, #32]
    4000ab84:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000ab88:	d65f03c0 	ret

000000004000ab8c <z_pend_curr>:
{
    4000ab8c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000ab90:	910003fd 	mov	x29, sp
    4000ab94:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ab98:	aa0003f3 	mov	x19, x0
	pend(_current, wait_q, timeout);
    4000ab9c:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000aba0:	f9413000 	ldr	x0, [x0, #608]
{
    4000aba4:	2a0103f4 	mov	w20, w1
    4000aba8:	aa0203e1 	mov	x1, x2
    4000abac:	aa0303e2 	mov	x2, x3
	pend(_current, wait_q, timeout);
    4000abb0:	97ffffde 	bl	4000ab28 <pend>
	return z_swap(lock, key);
    4000abb4:	2a1403e1 	mov	w1, w20
    4000abb8:	aa1303e0 	mov	x0, x19
}
    4000abbc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000abc0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return z_swap(lock, key);
    4000abc4:	17fffe4a 	b	4000a4ec <z_swap>

000000004000abc8 <z_set_prio>:
{
    4000abc8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000abcc:	aa0003e3 	mov	x3, x0
    4000abd0:	910003fd 	mov	x29, sp
    4000abd4:	f9000bf3 	str	x19, [sp, #16]
    4000abd8:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000abdc:	d50342df 	msr	daifset, #0x2
	uint8_t state = thread->base.thread_state;
    4000abe0:	39406402 	ldrb	w2, [x0, #25]
				thread->base.prio = prio;
    4000abe4:	13001c24 	sxtb	w4, w1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    4000abe8:	f240105f 	tst	x2, #0x1f
    4000abec:	540005c1 	b.ne	4000aca4 <z_set_prio+0xdc>  // b.any
		if (need_sched) {
    4000abf0:	f9401401 	ldr	x1, [x0, #40]
    4000abf4:	b5000581 	cbnz	x1, 4000aca4 <z_set_prio+0xdc>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000abf8:	12001842 	and	w2, w2, #0x7f
    4000abfc:	39006402 	strb	w2, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000ac00:	97fffdf8 	bl	4000a3e0 <sys_dlist_remove>
				thread->base.prio = prio;
    4000ac04:	39006804 	strb	w4, [x0, #26]
	thread->base.thread_state |= _THREAD_QUEUED;
    4000ac08:	39406400 	ldrb	w0, [x0, #25]
	return list->head == list;
    4000ac0c:	90000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000ac10:	91094021 	add	x1, x1, #0x250
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000ac14:	90000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    4000ac18:	910a2042 	add	x2, x2, #0x288
    4000ac1c:	32196000 	orr	w0, w0, #0xffffff80
    4000ac20:	39006460 	strb	w0, [x3, #25]
	return list->head == list;
    4000ac24:	f9401c20 	ldr	x0, [x1, #56]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000ac28:	eb02001f 	cmp	x0, x2
    4000ac2c:	54000320 	b.eq	4000ac90 <z_set_prio+0xc8>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000ac30:	b4000300 	cbz	x0, 4000ac90 <z_set_prio+0xc8>
	return (node == list->tail) ? NULL : node->next;
    4000ac34:	f9402026 	ldr	x6, [x1, #64]
	int32_t b2 = thread_2->base.prio;
    4000ac38:	39c06805 	ldrsb	w5, [x0, #26]
	if (b1 != b2) {
    4000ac3c:	6b05009f 	cmp	w4, w5
    4000ac40:	54000200 	b.eq	4000ac80 <z_set_prio+0xb8>  // b.none
		return b2 - b1;
    4000ac44:	4b0400a5 	sub	w5, w5, w4
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000ac48:	710000bf 	cmp	w5, #0x0
    4000ac4c:	540001ad 	b.le	4000ac80 <z_set_prio+0xb8>
	sys_dnode_t *const prev = successor->prev;
    4000ac50:	f9400401 	ldr	x1, [x0, #8]
	node->prev = prev;
    4000ac54:	a9000460 	stp	x0, x1, [x3]
	prev->next = node;
    4000ac58:	f9000023 	str	x3, [x1]
	successor->prev = node;
    4000ac5c:	f9000403 	str	x3, [x0, #8]
			update_cache(1);
    4000ac60:	52800020 	mov	w0, #0x1                   	// #1
    4000ac64:	97fffea2 	bl	4000a6ec <update_cache>
    4000ac68:	52800020 	mov	w0, #0x1                   	// #1
MAKE_REG_HELPER(daif)
    4000ac6c:	92407e73 	and	x19, x19, #0xffffffff
    4000ac70:	d51b4233 	msr	daif, x19
}
    4000ac74:	f9400bf3 	ldr	x19, [sp, #16]
    4000ac78:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000ac7c:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
    4000ac80:	eb06001f 	cmp	x0, x6
    4000ac84:	54000060 	b.eq	4000ac90 <z_set_prio+0xc8>  // b.none
    4000ac88:	f9400000 	ldr	x0, [x0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000ac8c:	b5fffd60 	cbnz	x0, 4000ac38 <z_set_prio+0x70>
	sys_dnode_t *const tail = list->tail;
    4000ac90:	f9402020 	ldr	x0, [x1, #64]
	node->prev = tail;
    4000ac94:	a9000062 	stp	x2, x0, [x3]
	tail->next = node;
    4000ac98:	f9000003 	str	x3, [x0]
	list->tail = node;
    4000ac9c:	f9002023 	str	x3, [x1, #64]
}
    4000aca0:	17fffff0 	b	4000ac60 <z_set_prio+0x98>
			thread->base.prio = prio;
    4000aca4:	52800000 	mov	w0, #0x0                   	// #0
    4000aca8:	39006864 	strb	w4, [x3, #26]
    4000acac:	17fffff0 	b	4000ac6c <z_set_prio+0xa4>

000000004000acb0 <k_sched_unlock>:
{
    4000acb0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000acb4:	910003fd 	mov	x29, sp
    4000acb8:	f9000bf3 	str	x19, [sp, #16]
    4000acbc:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000acc0:	d50342df 	msr	daifset, #0x2
		++_current->base.sched_locked;
    4000acc4:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000acc8:	f9413001 	ldr	x1, [x0, #608]
MAKE_REG_HELPER(daif)
    4000accc:	92407e73 	and	x19, x19, #0xffffffff
    4000acd0:	39406c20 	ldrb	w0, [x1, #27]
    4000acd4:	11000400 	add	w0, w0, #0x1
    4000acd8:	39006c20 	strb	w0, [x1, #27]
		update_cache(0);
    4000acdc:	52800000 	mov	w0, #0x0                   	// #0
    4000ace0:	97fffe83 	bl	4000a6ec <update_cache>
    4000ace4:	d51b4233 	msr	daif, x19
}
    4000ace8:	f9400bf3 	ldr	x19, [sp, #16]
    4000acec:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule_unlocked();
    4000acf0:	17fffe63 	b	4000a67c <z_reschedule_unlocked>

000000004000acf4 <z_unpend_first_thread>:
{
    4000acf4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000acf8:	910003fd 	mov	x29, sp
    4000acfc:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ad00:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ad04:	d50342df 	msr	daifset, #0x2
		thread = _priq_wait_best(&wait_q->waitq);
    4000ad08:	97fffe75 	bl	4000a6dc <z_priq_dumb_best>
    4000ad0c:	aa0003f3 	mov	x19, x0
		if (thread != NULL) {
    4000ad10:	b4000080 	cbz	x0, 4000ad20 <z_unpend_first_thread+0x2c>
			unpend_thread_no_timeout(thread);
    4000ad14:	97fffdb8 	bl	4000a3f4 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
    4000ad18:	9100a260 	add	x0, x19, #0x28
    4000ad1c:	9400012e 	bl	4000b1d4 <z_abort_timeout>
MAKE_REG_HELPER(daif)
    4000ad20:	92407e94 	and	x20, x20, #0xffffffff
    4000ad24:	d51b4234 	msr	daif, x20
}
    4000ad28:	aa1303e0 	mov	x0, x19
    4000ad2c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ad30:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000ad34:	d65f03c0 	ret

000000004000ad38 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    4000ad38:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000ad3c:	91094000 	add	x0, x0, #0x250
    4000ad40:	90000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000ad44:	910a2021 	add	x1, x1, #0x288
	list->tail = (sys_dnode_t *)list;
    4000ad48:	a9038401 	stp	x1, x1, [x0, #56]
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    4000ad4c:	52800001 	mov	w1, #0x0                   	// #0
    4000ad50:	52800000 	mov	w0, #0x0                   	// #0
    4000ad54:	17fffe05 	b	4000a568 <k_sched_time_slice_set>

000000004000ad58 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
    4000ad58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000ad5c:	910003fd 	mov	x29, sp
    4000ad60:	f9000bf3 	str	x19, [sp, #16]
    4000ad64:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ad68:	d50342df 	msr	daifset, #0x2

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
    4000ad6c:	90000083 	adrp	x3, 4001a000 <shell_uart_ctx+0x1c8>
    4000ad70:	91094063 	add	x3, x3, #0x250
    4000ad74:	f9400860 	ldr	x0, [x3, #16]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000ad78:	39406401 	ldrb	w1, [x0, #25]
    4000ad7c:	12001821 	and	w1, w1, #0x7f
    4000ad80:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000ad84:	97fffd97 	bl	4000a3e0 <sys_dlist_remove>
	}
	queue_thread(_current);
    4000ad88:	f9400860 	ldr	x0, [x3, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000ad8c:	90000082 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    4000ad90:	910a2042 	add	x2, x2, #0x288
	thread->base.thread_state |= _THREAD_QUEUED;
    4000ad94:	39406401 	ldrb	w1, [x0, #25]
    4000ad98:	32196021 	orr	w1, w1, #0xffffff80
    4000ad9c:	39006401 	strb	w1, [x0, #25]
	return list->head == list;
    4000ada0:	f9401c61 	ldr	x1, [x3, #56]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000ada4:	eb02003f 	cmp	x1, x2
    4000ada8:	54000340 	b.eq	4000ae10 <z_impl_k_yield+0xb8>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000adac:	b4000321 	cbz	x1, 4000ae10 <z_impl_k_yield+0xb8>
	int32_t b1 = thread_1->base.prio;
    4000adb0:	39c06805 	ldrsb	w5, [x0, #26]
	return (node == list->tail) ? NULL : node->next;
    4000adb4:	f9402066 	ldr	x6, [x3, #64]
	int32_t b2 = thread_2->base.prio;
    4000adb8:	39c06824 	ldrsb	w4, [x1, #26]
	if (b1 != b2) {
    4000adbc:	6b0400bf 	cmp	w5, w4
    4000adc0:	54000200 	b.eq	4000ae00 <z_impl_k_yield+0xa8>  // b.none
		return b2 - b1;
    4000adc4:	4b050084 	sub	w4, w4, w5
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000adc8:	7100009f 	cmp	w4, #0x0
    4000adcc:	540001ad 	b.le	4000ae00 <z_impl_k_yield+0xa8>
	sys_dnode_t *const prev = successor->prev;
    4000add0:	f9400422 	ldr	x2, [x1, #8]
	node->prev = prev;
    4000add4:	a9000801 	stp	x1, x2, [x0]
	prev->next = node;
    4000add8:	f9000040 	str	x0, [x2]
	successor->prev = node;
    4000addc:	f9000420 	str	x0, [x1, #8]
	update_cache(1);
    4000ade0:	52800020 	mov	w0, #0x1                   	// #1
    4000ade4:	97fffe42 	bl	4000a6ec <update_cache>
	z_swap(&sched_spinlock, key);
    4000ade8:	2a1303e1 	mov	w1, w19
    4000adec:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000adf0:	91108000 	add	x0, x0, #0x420
}
    4000adf4:	f9400bf3 	ldr	x19, [sp, #16]
    4000adf8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_swap(&sched_spinlock, key);
    4000adfc:	17fffdbc 	b	4000a4ec <z_swap>
	return (node == list->tail) ? NULL : node->next;
    4000ae00:	eb06003f 	cmp	x1, x6
    4000ae04:	54000060 	b.eq	4000ae10 <z_impl_k_yield+0xb8>  // b.none
    4000ae08:	f9400021 	ldr	x1, [x1]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000ae0c:	b5fffd61 	cbnz	x1, 4000adb8 <z_impl_k_yield+0x60>
	sys_dnode_t *const tail = list->tail;
    4000ae10:	f9402061 	ldr	x1, [x3, #64]
	node->prev = tail;
    4000ae14:	a9000402 	stp	x2, x1, [x0]
	tail->next = node;
    4000ae18:	f9000020 	str	x0, [x1]
	list->tail = node;
    4000ae1c:	f9002060 	str	x0, [x3, #64]
}
    4000ae20:	17fffff0 	b	4000ade0 <z_impl_k_yield+0x88>

000000004000ae24 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    4000ae24:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000ae28:	f9413000 	ldr	x0, [x0, #608]
    4000ae2c:	d65f03c0 	ret

000000004000ae30 <z_impl_k_is_preempt_thread>:
MAKE_REG_HELPER(tpidrro_el0);
    4000ae30:	d53bd060 	mrs	x0, tpidrro_el0
    4000ae34:	927db000 	and	x0, x0, #0xfffffffffff8
#include <syscalls/z_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
	return !arch_is_in_isr() && is_preempt(_current);
    4000ae38:	b9400000 	ldr	w0, [x0]
    4000ae3c:	350000e0 	cbnz	w0, 4000ae58 <z_impl_k_is_preempt_thread+0x28>
    4000ae40:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    4000ae44:	f9413000 	ldr	x0, [x0, #608]
	return !arch_is_in_isr() && is_preempt(_current);
    4000ae48:	79403400 	ldrh	w0, [x0, #26]
    4000ae4c:	7101fc1f 	cmp	w0, #0x7f
    4000ae50:	1a9f87e0 	cset	w0, ls  // ls = plast
}
    4000ae54:	d65f03c0 	ret
	return !arch_is_in_isr() && is_preempt(_current);
    4000ae58:	52800000 	mov	w0, #0x0                   	// #0
    4000ae5c:	17fffffe 	b	4000ae54 <z_impl_k_is_preempt_thread+0x24>

000000004000ae60 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    4000ae60:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000ae64:	910003fd 	mov	x29, sp
    4000ae68:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ae6c:	a9025bf5 	stp	x21, x22, [sp, #32]
MAKE_REG_HELPER(daif)
    4000ae70:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ae74:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    4000ae78:	39406401 	ldrb	w1, [x0, #25]
    4000ae7c:	361800e1 	tbz	w1, #3, 4000ae98 <z_thread_abort+0x38>
MAKE_REG_HELPER(daif)
    4000ae80:	92407e94 	and	x20, x20, #0xffffffff
    4000ae84:	d51b4234 	msr	daif, x20
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    4000ae88:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ae8c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000ae90:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000ae94:	d65f03c0 	ret
		thread->base.thread_state &= ~_THREAD_ABORTING;
    4000ae98:	121a7822 	and	w2, w1, #0xffffffdf
    4000ae9c:	aa0003f3 	mov	x19, x0
    4000aea0:	321d0043 	orr	w3, w2, #0x8
		if (z_is_thread_queued(thread)) {
    4000aea4:	373803c2 	tbnz	w2, #7, 4000af1c <z_thread_abort+0xbc>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    4000aea8:	39006403 	strb	w3, [x0, #25]
		if (thread->base.pended_on != NULL) {
    4000aeac:	f9400a60 	ldr	x0, [x19, #16]
    4000aeb0:	b4000060 	cbz	x0, 4000aebc <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
    4000aeb4:	aa1303e0 	mov	x0, x19
    4000aeb8:	97fffd4f 	bl	4000a3f4 <unpend_thread_no_timeout>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    4000aebc:	9102e276 	add	x22, x19, #0xb8
    4000aec0:	9100a260 	add	x0, x19, #0x28
    4000aec4:	940000c4 	bl	4000b1d4 <z_abort_timeout>
	return list->head == list;
    4000aec8:	f9405e75 	ldr	x21, [x19, #184]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000aecc:	eb1602bf 	cmp	x21, x22
    4000aed0:	54000040 	b.eq	4000aed8 <z_thread_abort+0x78>  // b.none
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    4000aed4:	b5000315 	cbnz	x21, 4000af34 <z_thread_abort+0xd4>
		update_cache(1);
    4000aed8:	52800020 	mov	w0, #0x1                   	// #1
    4000aedc:	97fffe04 	bl	4000a6ec <update_cache>
		z_thread_monitor_exit(thread);
    4000aee0:	aa1303e0 	mov	x0, x19
    4000aee4:	97fffb97 	bl	40009d40 <z_thread_monitor_exit>
	if (thread == _current && !arch_is_in_isr()) {
    4000aee8:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000aeec:	f9413000 	ldr	x0, [x0, #608]
    4000aef0:	eb13001f 	cmp	x0, x19
    4000aef4:	54fffc61 	b.ne	4000ae80 <z_thread_abort+0x20>  // b.any
MAKE_REG_HELPER(tpidrro_el0);
    4000aef8:	d53bd060 	mrs	x0, tpidrro_el0
    4000aefc:	927db000 	and	x0, x0, #0xfffffffffff8
    4000af00:	b9400000 	ldr	w0, [x0]
    4000af04:	35fffbe0 	cbnz	w0, 4000ae80 <z_thread_abort+0x20>
		z_swap(&sched_spinlock, key);
    4000af08:	2a1403e1 	mov	w1, w20
    4000af0c:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000af10:	91108000 	add	x0, x0, #0x420
    4000af14:	97fffd76 	bl	4000a4ec <z_swap>
    4000af18:	17ffffda 	b	4000ae80 <z_thread_abort+0x20>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000af1c:	52800be2 	mov	w2, #0x5f                  	// #95
    4000af20:	0a020021 	and	w1, w1, w2
    4000af24:	321d0021 	orr	w1, w1, #0x8
    4000af28:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000af2c:	97fffd2d 	bl	4000a3e0 <sys_dlist_remove>
}
    4000af30:	17ffffdf 	b	4000aeac <z_thread_abort+0x4c>
		unpend_thread_no_timeout(thread);
    4000af34:	aa1503e0 	mov	x0, x21
    4000af38:	97fffd2f 	bl	4000a3f4 <unpend_thread_no_timeout>
    4000af3c:	9100a2a0 	add	x0, x21, #0x28
    4000af40:	940000a5 	bl	4000b1d4 <z_abort_timeout>
    4000af44:	b9013abf 	str	wzr, [x21, #312]
		ready_thread(thread);
    4000af48:	aa1503e0 	mov	x0, x21
    4000af4c:	97fffe5c 	bl	4000a8bc <ready_thread>
    4000af50:	17ffffde 	b	4000aec8 <z_thread_abort+0x68>

000000004000af54 <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
    4000af54:	17ffffc3 	b	4000ae60 <z_thread_abort>

000000004000af58 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
    4000af58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000af5c:	2a0103e3 	mov	w3, w1
    4000af60:	910003fd 	mov	x29, sp
    4000af64:	a90153f3 	stp	x19, x20, [sp, #16]
MAKE_REG_HELPER(daif)
    4000af68:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000af6c:	d50342df 	msr	daifset, #0x2
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
    4000af70:	97fffddb 	bl	4000a6dc <z_priq_dumb_best>

		if (thread != NULL) {
    4000af74:	b40001e0 	cbz	x0, 4000afb0 <z_sched_wake+0x58>
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    4000af78:	f9001002 	str	x2, [x0, #32]
    4000af7c:	aa0003f3 	mov	x19, x0
	thread->swap_retval = value;
    4000af80:	b9013803 	str	w3, [x0, #312]
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
    4000af84:	97fffd1c 	bl	4000a3f4 <unpend_thread_no_timeout>
    4000af88:	9100a260 	add	x0, x19, #0x28
    4000af8c:	94000092 	bl	4000b1d4 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
    4000af90:	aa1303e0 	mov	x0, x19
    4000af94:	97fffe4a 	bl	4000a8bc <ready_thread>
			ret = true;
    4000af98:	52800020 	mov	w0, #0x1                   	// #1
MAKE_REG_HELPER(daif)
    4000af9c:	92407e94 	and	x20, x20, #0xffffffff
    4000afa0:	d51b4234 	msr	daif, x20
		}
	}

	return ret;
}
    4000afa4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000afa8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000afac:	d65f03c0 	ret
	bool ret = false;
    4000afb0:	52800000 	mov	w0, #0x0                   	// #0
    4000afb4:	17fffffa 	b	4000af9c <z_sched_wake+0x44>

000000004000afb8 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
    4000afb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000afbc:	910003fd 	mov	x29, sp
    4000afc0:	f9000bf3 	str	x19, [sp, #16]
    4000afc4:	aa0403f3 	mov	x19, x4
	int ret = z_pend_curr(lock, key, wait_q, timeout);
    4000afc8:	97fffef1 	bl	4000ab8c <z_pend_curr>

	if (data != NULL) {
    4000afcc:	b40000b3 	cbz	x19, 4000afe0 <z_sched_wait+0x28>
		*data = _current->base.swap_data;
    4000afd0:	90000081 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000afd4:	f9413021 	ldr	x1, [x1, #608]
    4000afd8:	f9401021 	ldr	x1, [x1, #32]
    4000afdc:	f9000261 	str	x1, [x19]
	}
	return ret;
}
    4000afe0:	f9400bf3 	ldr	x19, [sp, #16]
    4000afe4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000afe8:	d65f03c0 	ret

000000004000afec <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    4000afec:	90000080 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000aff0:	b942e800 	ldr	w0, [x0, #744]
    4000aff4:	35000040 	cbnz	w0, 4000affc <elapsed+0x10>
    4000aff8:	17fffa08 	b	40009818 <sys_clock_elapsed>
}
    4000affc:	52800000 	mov	w0, #0x0                   	// #0
    4000b000:	d65f03c0 	ret

000000004000b004 <next_timeout>:

static int32_t next_timeout(void)
{
    4000b004:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return list->head == list;
    4000b008:	f00002c0 	adrp	x0, 40066000 <sys_work_q_stack+0x3d0>
    4000b00c:	913dc001 	add	x1, x0, #0xf70
    4000b010:	910003fd 	mov	x29, sp
    4000b014:	f9000bf3 	str	x19, [sp, #16]
    4000b018:	f947b813 	ldr	x19, [x0, #3952]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000b01c:	eb01027f 	cmp	x19, x1
    4000b020:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    4000b024:	97fffff2 	bl	4000afec <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
    4000b028:	b4000213 	cbz	x19, 4000b068 <next_timeout+0x64>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    4000b02c:	f9400e61 	ldr	x1, [x19, #24]
    4000b030:	cb20c020 	sub	x0, x1, w0, sxtw
	int32_t ret = to == NULL ? MAX_WAIT
    4000b034:	f100001f 	cmp	x0, #0x0
    4000b038:	540001cd 	b.le	4000b070 <next_timeout+0x6c>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    4000b03c:	b2407be1 	mov	x1, #0x7fffffff            	// #2147483647
    4000b040:	eb01001f 	cmp	x0, x1
	int32_t ret = to == NULL ? MAX_WAIT
    4000b044:	9a81d000 	csel	x0, x0, x1, le

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    4000b048:	f0000061 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000b04c:	b9427021 	ldr	w1, [x1, #624]
    4000b050:	34000061 	cbz	w1, 4000b05c <next_timeout+0x58>
    4000b054:	6b01001f 	cmp	w0, w1
    4000b058:	1a81d000 	csel	w0, w0, w1, le
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    4000b05c:	f9400bf3 	ldr	x19, [sp, #16]
    4000b060:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000b064:	d65f03c0 	ret
	int32_t ret = to == NULL ? MAX_WAIT
    4000b068:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    4000b06c:	17fffff7 	b	4000b048 <next_timeout+0x44>
    4000b070:	52800000 	mov	w0, #0x0                   	// #0
    4000b074:	17fffff5 	b	4000b048 <next_timeout+0x44>

000000004000b078 <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
    4000b078:	f9400001 	ldr	x1, [x0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    4000b07c:	b4000140 	cbz	x0, 4000b0a4 <remove_timeout+0x2c>
	return (node == list->tail) ? NULL : node->next;
    4000b080:	f00002c2 	adrp	x2, 40066000 <sys_work_q_stack+0x3d0>
    4000b084:	f947bc42 	ldr	x2, [x2, #3960]
    4000b088:	eb02001f 	cmp	x0, x2
    4000b08c:	540000c0 	b.eq	4000b0a4 <remove_timeout+0x2c>  // b.none
	if (next(t) != NULL) {
    4000b090:	b40000a1 	cbz	x1, 4000b0a4 <remove_timeout+0x2c>
		next(t)->dticks += t->dticks;
    4000b094:	f9400c03 	ldr	x3, [x0, #24]
    4000b098:	f9400c22 	ldr	x2, [x1, #24]
    4000b09c:	8b030042 	add	x2, x2, x3
    4000b0a0:	f9000c22 	str	x2, [x1, #24]
	sys_dnode_t *const prev = node->prev;
    4000b0a4:	f9400402 	ldr	x2, [x0, #8]
	prev->next = next;
    4000b0a8:	f9000041 	str	x1, [x2]
	next->prev = prev;
    4000b0ac:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
    4000b0b0:	a9007c1f 	stp	xzr, xzr, [x0]
}
    4000b0b4:	d65f03c0 	ret

000000004000b0b8 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    4000b0b8:	b100045f 	cmn	x2, #0x1
    4000b0bc:	540008a0 	b.eq	4000b1d0 <z_add_timeout+0x118>  // b.none
{
    4000b0c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000b0c4:	910003fd 	mov	x29, sp
    4000b0c8:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b0cc:	aa0003f3 	mov	x19, x0
    4000b0d0:	aa0203f4 	mov	x20, x2
    4000b0d4:	f90013f5 	str	x21, [sp, #32]
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    4000b0d8:	f9000801 	str	x1, [x0, #16]
    4000b0dc:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000b0e0:	d50342df 	msr	daifset, #0x2

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    4000b0e4:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    4000b0e8:	eb02001f 	cmp	x0, x2
    4000b0ec:	54000244 	b.mi	4000b134 <z_add_timeout+0x7c>  // b.first
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    4000b0f0:	f0000061 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000b0f4:	f9415422 	ldr	x2, [x1, #680]
    4000b0f8:	cb020000 	sub	x0, x0, x2
    4000b0fc:	cb140002 	sub	x2, x0, x20

			to->dticks = MAX(1, ticks);
    4000b100:	f100005f 	cmp	x2, #0x0
    4000b104:	9a9fc442 	csinc	x2, x2, xzr, gt
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    4000b108:	f9000e62 	str	x2, [x19, #24]
	return list->head == list;
    4000b10c:	f00002c2 	adrp	x2, 40066000 <sys_work_q_stack+0x3d0>
    4000b110:	913dc041 	add	x1, x2, #0xf70
    4000b114:	f947b840 	ldr	x0, [x2, #3952]
	sys_dnode_t *const tail = list->tail;
    4000b118:	f9400425 	ldr	x5, [x1, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000b11c:	eb01001f 	cmp	x0, x1
    4000b120:	540001c1 	b.ne	4000b158 <z_add_timeout+0xa0>  // b.any
	node->prev = tail;
    4000b124:	a9001661 	stp	x1, x5, [x19]
	tail->next = node;
    4000b128:	f90000b3 	str	x19, [x5]
	list->tail = node;
    4000b12c:	f9000433 	str	x19, [x1, #8]
}
    4000b130:	14000015 	b	4000b184 <z_add_timeout+0xcc>
    4000b134:	97ffffae 	bl	4000afec <elapsed>
    4000b138:	91000682 	add	x2, x20, #0x1
    4000b13c:	8b20c042 	add	x2, x2, w0, sxtw
    4000b140:	17fffff2 	b	4000b108 <z_add_timeout+0x50>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
    4000b144:	cb040063 	sub	x3, x3, x4
    4000b148:	f9000e63 	str	x3, [x19, #24]
	return (node == list->tail) ? NULL : node->next;
    4000b14c:	eb0000bf 	cmp	x5, x0
    4000b150:	54fffea0 	b.eq	4000b124 <z_add_timeout+0x6c>  // b.none
    4000b154:	f9400000 	ldr	x0, [x0]
		for (t = first(); t != NULL; t = next(t)) {
    4000b158:	b4fffe60 	cbz	x0, 4000b124 <z_add_timeout+0x6c>
			if (t->dticks > to->dticks) {
    4000b15c:	f9400c04 	ldr	x4, [x0, #24]
    4000b160:	f9400e63 	ldr	x3, [x19, #24]
    4000b164:	eb03009f 	cmp	x4, x3
    4000b168:	54fffeed 	b.le	4000b144 <z_add_timeout+0x8c>
				t->dticks -= to->dticks;
    4000b16c:	cb030083 	sub	x3, x4, x3
    4000b170:	f9000c03 	str	x3, [x0, #24]
	sys_dnode_t *const prev = successor->prev;
    4000b174:	f9400403 	ldr	x3, [x0, #8]
	node->prev = prev;
    4000b178:	a9000e60 	stp	x0, x3, [x19]
	prev->next = node;
    4000b17c:	f9000073 	str	x19, [x3]
	successor->prev = node;
    4000b180:	f9000413 	str	x19, [x0, #8]
	return list->head == list;
    4000b184:	f947b840 	ldr	x0, [x2, #3952]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000b188:	eb01001f 	cmp	x0, x1
    4000b18c:	54000160 	b.eq	4000b1b8 <z_add_timeout+0x100>  // b.none

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    4000b190:	eb00027f 	cmp	x19, x0
    4000b194:	54000121 	b.ne	4000b1b8 <z_add_timeout+0x100>  // b.any
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    4000b198:	97ffff9b 	bl	4000b004 <next_timeout>

			if (next_time == 0 ||
    4000b19c:	340000a0 	cbz	w0, 4000b1b0 <z_add_timeout+0xf8>
			    _current_cpu->slice_ticks != next_time) {
    4000b1a0:	f0000061 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
			if (next_time == 0 ||
    4000b1a4:	b9427021 	ldr	w1, [x1, #624]
    4000b1a8:	6b00003f 	cmp	w1, w0
    4000b1ac:	54000060 	b.eq	4000b1b8 <z_add_timeout+0x100>  // b.none
				sys_clock_set_timeout(next_time, false);
    4000b1b0:	52800001 	mov	w1, #0x0                   	// #0
    4000b1b4:	97fff973 	bl	40009780 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    4000b1b8:	92407eb5 	and	x21, x21, #0xffffffff
    4000b1bc:	d51b4235 	msr	daif, x21
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    4000b1c0:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b1c4:	f94013f5 	ldr	x21, [sp, #32]
    4000b1c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000b1cc:	d65f03c0 	ret
    4000b1d0:	d65f03c0 	ret

000000004000b1d4 <z_abort_timeout>:
    4000b1d4:	d53b4224 	mrs	x4, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000b1d8:	d50342df 	msr	daifset, #0x2
int z_abort_timeout(struct _timeout *to)
{
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    4000b1dc:	f9400001 	ldr	x1, [x0]
    4000b1e0:	b4000121 	cbz	x1, 4000b204 <z_abort_timeout+0x30>
{
    4000b1e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER(daif)
    4000b1e8:	92407c84 	and	x4, x4, #0xffffffff
    4000b1ec:	910003fd 	mov	x29, sp
			remove_timeout(to);
    4000b1f0:	97ffffa2 	bl	4000b078 <remove_timeout>
			ret = 0;
    4000b1f4:	52800000 	mov	w0, #0x0                   	// #0
    4000b1f8:	d51b4224 	msr	daif, x4
		}
	}

	return ret;
}
    4000b1fc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b200:	d65f03c0 	ret
	int ret = -EINVAL;
    4000b204:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4000b208:	92407c84 	and	x4, x4, #0xffffffff
    4000b20c:	d51b4224 	msr	daif, x4
}
    4000b210:	d65f03c0 	ret

000000004000b214 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    4000b214:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000b218:	910003fd 	mov	x29, sp
    4000b21c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b220:	2a0003f3 	mov	w19, w0
    4000b224:	f90013f5 	str	x21, [sp, #32]
    4000b228:	12001c35 	and	w21, w1, #0xff
    4000b22c:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000b230:	d50342df 	msr	daifset, #0x2
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    4000b234:	97ffff74 	bl	4000b004 <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    4000b238:	6b13001f 	cmp	w0, w19
    4000b23c:	3a41b804 	ccmn	w0, #0x1, #0x4, lt  // lt = tstop
    4000b240:	7a410804 	ccmp	w0, #0x1, #0x4, eq  // eq = none
    4000b244:	540000ad 	b.le	4000b258 <z_set_timeout_expiry+0x44>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    4000b248:	6b13001f 	cmp	w0, w19
    4000b24c:	2a1503e1 	mov	w1, w21
    4000b250:	1a93d000 	csel	w0, w0, w19, le
    4000b254:	97fff94b 	bl	40009780 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    4000b258:	92407e94 	and	x20, x20, #0xffffffff
    4000b25c:	d51b4234 	msr	daif, x20
		}
	}
}
    4000b260:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b264:	f94013f5 	ldr	x21, [sp, #32]
    4000b268:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000b26c:	d65f03c0 	ret

000000004000b270 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    4000b270:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000b274:	910003fd 	mov	x29, sp
    4000b278:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b27c:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000b280:	2a0003f5 	mov	w21, w0
    4000b284:	a90363f7 	stp	x23, x24, [sp, #48]
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    4000b288:	97fffd63 	bl	4000a814 <z_time_slice>
    4000b28c:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000b290:	d50342df 	msr	daifset, #0x2
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    4000b294:	f0000074 	adrp	x20, 4001a000 <shell_uart_ctx+0x1c8>

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    4000b298:	f0000076 	adrp	x22, 4001a000 <shell_uart_ctx+0x1c8>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    4000b29c:	910ba297 	add	x23, x20, #0x2e8
    4000b2a0:	aa1603f8 	mov	x24, x22
	announce_remaining = ticks;
    4000b2a4:	b902ea95 	str	w21, [x20, #744]
	return list->head == list;
    4000b2a8:	f00002d5 	adrp	x21, 40066000 <sys_work_q_stack+0x3d0>
    4000b2ac:	913dc2b5 	add	x21, x21, #0xf70
	while (first() != NULL && first()->dticks <= announce_remaining) {
    4000b2b0:	b94002e4 	ldr	w4, [x23]
	return key;
}

static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	write_daif(key);
    4000b2b4:	2a1303f3 	mov	w19, w19
    4000b2b8:	f94002a0 	ldr	x0, [x21]
		curr_tick += dt;
    4000b2bc:	f94156c3 	ldr	x3, [x22, #680]
    4000b2c0:	93407c82 	sxtw	x2, w4
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000b2c4:	eb15001f 	cmp	x0, x21
    4000b2c8:	540000e0 	b.eq	4000b2e4 <sys_clock_announce+0x74>  // b.none
	while (first() != NULL && first()->dticks <= announce_remaining) {
    4000b2cc:	b40000c0 	cbz	x0, 4000b2e4 <sys_clock_announce+0x74>
    4000b2d0:	f9400c01 	ldr	x1, [x0, #24]
    4000b2d4:	eb02003f 	cmp	x1, x2
    4000b2d8:	540001ed 	b.le	4000b314 <sys_clock_announce+0xa4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    4000b2dc:	cb020021 	sub	x1, x1, x2
    4000b2e0:	f9000c01 	str	x1, [x0, #24]
	}

	curr_tick += announce_remaining;
    4000b2e4:	8b030042 	add	x2, x2, x3
	announce_remaining = 0;
    4000b2e8:	b902ea9f 	str	wzr, [x20, #744]
	curr_tick += announce_remaining;
    4000b2ec:	f9015702 	str	x2, [x24, #680]

	sys_clock_set_timeout(next_timeout(), false);
    4000b2f0:	97ffff45 	bl	4000b004 <next_timeout>
    4000b2f4:	52800001 	mov	w1, #0x0                   	// #0
    4000b2f8:	97fff922 	bl	40009780 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    4000b2fc:	d51b4233 	msr	daif, x19

	k_spin_unlock(&timeout_lock, key);
}
    4000b300:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b304:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b308:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000b30c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000b310:	d65f03c0 	ret
		curr_tick += dt;
    4000b314:	8b21c062 	add	x2, x3, w1, sxtw
		announce_remaining -= dt;
    4000b318:	4b010081 	sub	w1, w4, w1
		t->dticks = 0;
    4000b31c:	f9000c1f 	str	xzr, [x0, #24]
		curr_tick += dt;
    4000b320:	f90156c2 	str	x2, [x22, #680]
		announce_remaining -= dt;
    4000b324:	b90002e1 	str	w1, [x23]
		remove_timeout(t);
    4000b328:	97ffff54 	bl	4000b078 <remove_timeout>
    4000b32c:	d51b4233 	msr	daif, x19
		t->fn(t);
    4000b330:	f9400801 	ldr	x1, [x0, #16]
    4000b334:	d63f0020 	blr	x1
    4000b338:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000b33c:	d50342df 	msr	daifset, #0x2
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    4000b340:	17ffffdc 	b	4000b2b0 <sys_clock_announce+0x40>

000000004000b344 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    4000b344:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000b348:	910003fd 	mov	x29, sp
    4000b34c:	f9000bf3 	str	x19, [sp, #16]
MAKE_REG_HELPER(daif)
    4000b350:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000b354:	d50342df 	msr	daifset, #0x2
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
    4000b358:	97fff930 	bl	40009818 <sys_clock_elapsed>
MAKE_REG_HELPER(daif)
    4000b35c:	92407e73 	and	x19, x19, #0xffffffff
    4000b360:	f0000061 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000b364:	f9415421 	ldr	x1, [x1, #680]
    4000b368:	8b204020 	add	x0, x1, w0, uxtw
    4000b36c:	d51b4233 	msr	daif, x19
	}
	return t;
}
    4000b370:	f9400bf3 	ldr	x19, [sp, #16]
    4000b374:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000b378:	d65f03c0 	ret

000000004000b37c <z_impl_k_uptime_ticks>:
#endif
}

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
    4000b37c:	17fffff2 	b	4000b344 <sys_clock_tick_get>

000000004000b380 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    4000b380:	34000040 	cbz	w0, 4000b388 <z_impl_k_busy_wait+0x8>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    4000b384:	17fff933 	b	40009850 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    4000b388:	d65f03c0 	ret

000000004000b38c <virt_region_free>:

	virt_region_inited = true;
}

static void virt_region_free(void *vaddr, size_t size)
{
    4000b38c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000b390:	910003fd 	mov	x29, sp
    4000b394:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b398:	aa0003f4 	mov	x20, x0
    4000b39c:	aa0103f3 	mov	x19, x1
    4000b3a0:	a9025bf5 	stp	x21, x22, [sp, #32]
	size_t offset, num_bits;
	uint8_t *vaddr_u8 = (uint8_t *)vaddr;

	if (unlikely(!virt_region_inited)) {
    4000b3a4:	f0000076 	adrp	x22, 4001a000 <shell_uart_ctx+0x1c8>
    4000b3a8:	395082c0 	ldrb	w0, [x22, #1056]
    4000b3ac:	900002f5 	adrp	x21, 40067000 <_end>
    4000b3b0:	910002b5 	add	x21, x21, #0x0
    4000b3b4:	35000180 	cbnz	w0, 4000b3e4 <virt_region_free+0x58>
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    4000b3b8:	b26287e1 	mov	x1, #0xffffffffc0000000    	// #-1073741824
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    4000b3bc:	d2a81002 	mov	x2, #0x40800000            	// #1082130432
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    4000b3c0:	8b0102a1 	add	x1, x21, x1
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    4000b3c4:	cb150042 	sub	x2, x2, x21
	(void)sys_bitarray_set_region(&virt_region_bitmap,
    4000b3c8:	f00002c0 	adrp	x0, 40066000 <sys_work_q_stack+0x3d0>
    4000b3cc:	913e0000 	add	x0, x0, #0xf80
    4000b3d0:	d34cfc42 	lsr	x2, x2, #12
    4000b3d4:	d34cfc21 	lsr	x1, x1, #12
    4000b3d8:	97ffd940 	bl	400018d8 <sys_bitarray_set_region>
	virt_region_inited = true;
    4000b3dc:	52800020 	mov	w0, #0x1                   	// #1
    4000b3e0:	391082c0 	strb	w0, [x22, #1056]
	}

	__ASSERT((vaddr_u8 >= Z_VIRT_REGION_START_ADDR)
		 && ((vaddr_u8 + size) < Z_VIRT_REGION_END_ADDR),
		 "invalid virtual address region %p (%zu)", vaddr_u8, size);
	if (!((vaddr_u8 >= Z_VIRT_REGION_START_ADDR)
    4000b3e4:	eb15029f 	cmp	x20, x21
    4000b3e8:	54000203 	b.cc	4000b428 <virt_region_free+0x9c>  // b.lo, b.ul, b.last
	      && ((vaddr_u8 + size) < Z_VIRT_REGION_END_ADDR))) {
    4000b3ec:	8b130281 	add	x1, x20, x19
	if (!((vaddr_u8 >= Z_VIRT_REGION_START_ADDR)
    4000b3f0:	12b7f000 	mov	w0, #0x407fffff            	// #1082130431
    4000b3f4:	eb00003f 	cmp	x1, x0
    4000b3f8:	54000188 	b.hi	4000b428 <virt_region_free+0x9c>  // b.pmore
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    4000b3fc:	d2a81002 	mov	x2, #0x40800000            	// #1082130432
    4000b400:	cb130042 	sub	x2, x2, x19
    4000b404:	cb140042 	sub	x2, x2, x20
		return;
	}

	offset = virt_to_bitmap_offset(vaddr, size);
	num_bits = size / CONFIG_MMU_PAGE_SIZE;
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    4000b408:	d34cfe61 	lsr	x1, x19, #12
}
    4000b40c:	a94153f3 	ldp	x19, x20, [sp, #16]
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    4000b410:	d34cfc42 	lsr	x2, x2, #12
}
    4000b414:	a9425bf5 	ldp	x21, x22, [sp, #32]
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    4000b418:	f00002c0 	adrp	x0, 40066000 <sys_work_q_stack+0x3d0>
    4000b41c:	913e0000 	add	x0, x0, #0xf80
}
    4000b420:	a8c37bfd 	ldp	x29, x30, [sp], #48
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    4000b424:	17ffd903 	b	40001830 <sys_bitarray_free>
}
    4000b428:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b42c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b430:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000b434:	d65f03c0 	ret

000000004000b438 <free_page_frame_list_put>:
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
    4000b438:	f0000063 	adrp	x3, 4001a000 <shell_uart_ctx+0x1c8>
    4000b43c:	910ac061 	add	x1, x3, #0x2b0
    4000b440:	f9400422 	ldr	x2, [x1, #8]
	parent->next = child;
    4000b444:	f900001f 	str	xzr, [x0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    4000b448:	b5000102 	cbnz	x2, 4000b468 <free_page_frame_list_put+0x30>
	list->head = node;
    4000b44c:	f9015860 	str	x0, [x3, #688]
	list->tail = node;
    4000b450:	f9000420 	str	x0, [x1, #8]
static void free_page_frame_list_put(struct z_page_frame *pf)
{
	PF_ASSERT(pf, z_page_frame_is_available(pf),
		 "unavailable page put on free list");
	sys_slist_append(&free_page_frame_list, &pf->node);
	z_free_page_count++;
    4000b454:	f0000061 	adrp	x1, 4001a000 <shell_uart_ctx+0x1c8>
    4000b458:	f9416020 	ldr	x0, [x1, #704]
    4000b45c:	91000400 	add	x0, x0, #0x1
    4000b460:	f9016020 	str	x0, [x1, #704]
}
    4000b464:	d65f03c0 	ret
	parent->next = child;
    4000b468:	f9000040 	str	x0, [x2]
	list->tail = node;
    4000b46c:	f9000420 	str	x0, [x1, #8]
}
    4000b470:	17fffff9 	b	4000b454 <free_page_frame_list_put+0x1c>

000000004000b474 <virt_region_alloc>:
{
    4000b474:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000b478:	910003fd 	mov	x29, sp
    4000b47c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b480:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000b484:	aa0003f6 	mov	x22, x0
	if (unlikely(!virt_region_inited)) {
    4000b488:	f0000073 	adrp	x19, 4001a000 <shell_uart_ctx+0x1c8>
    4000b48c:	39508260 	ldrb	w0, [x19, #1056]
{
    4000b490:	aa0103f5 	mov	x21, x1
    4000b494:	a90363f7 	stp	x23, x24, [sp, #48]
    4000b498:	f00002d7 	adrp	x23, 40066000 <sys_work_q_stack+0x3d0>
    4000b49c:	913e02f7 	add	x23, x23, #0xf80
	if (unlikely(!virt_region_inited)) {
    4000b4a0:	350001a0 	cbnz	w0, 4000b4d4 <virt_region_alloc+0x60>
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    4000b4a4:	900002e2 	adrp	x2, 40067000 <_end>
    4000b4a8:	91000042 	add	x2, x2, #0x0
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    4000b4ac:	d2a81000 	mov	x0, #0x40800000            	// #1082130432
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    4000b4b0:	b26287e1 	mov	x1, #0xffffffffc0000000    	// #-1073741824
    4000b4b4:	8b010041 	add	x1, x2, x1
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    4000b4b8:	cb020002 	sub	x2, x0, x2
	(void)sys_bitarray_set_region(&virt_region_bitmap,
    4000b4bc:	aa1703e0 	mov	x0, x23
    4000b4c0:	d34cfc42 	lsr	x2, x2, #12
    4000b4c4:	d34cfc21 	lsr	x1, x1, #12
    4000b4c8:	97ffd904 	bl	400018d8 <sys_bitarray_set_region>
	virt_region_inited = true;
    4000b4cc:	52800020 	mov	w0, #0x1                   	// #1
    4000b4d0:	39108260 	strb	w0, [x19, #1056]
	num_bits = (size + align - CONFIG_MMU_PAGE_SIZE) / CONFIG_MMU_PAGE_SIZE;
    4000b4d4:	d14006a1 	sub	x1, x21, #0x1, lsl #12
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
    4000b4d8:	910123e2 	add	x2, sp, #0x48
	num_bits = (size + align - CONFIG_MMU_PAGE_SIZE) / CONFIG_MMU_PAGE_SIZE;
    4000b4dc:	8b160021 	add	x1, x1, x22
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
    4000b4e0:	aa1703e0 	mov	x0, x23
	alloc_size = num_bits * CONFIG_MMU_PAGE_SIZE;
    4000b4e4:	9274cc38 	and	x24, x1, #0xfffffffffffff000
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
    4000b4e8:	d34cfc21 	lsr	x1, x1, #12
    4000b4ec:	97ffd88c 	bl	4000171c <sys_bitarray_alloc>
	if (ret != 0) {
    4000b4f0:	350003c0 	cbnz	w0, 4000b568 <virt_region_alloc+0xf4>
	       - (offset * CONFIG_MMU_PAGE_SIZE) - size;
    4000b4f4:	f94027e0 	ldr	x0, [sp, #72]
    4000b4f8:	d2810014 	mov	x20, #0x800                 	// #2048
    4000b4fc:	f2a00094 	movk	x20, #0x4, lsl #16
	if (alloc_size > size) {
    4000b500:	eb1802df 	cmp	x22, x24
	       - (offset * CONFIG_MMU_PAGE_SIZE) - size;
    4000b504:	cb000294 	sub	x20, x20, x0
    4000b508:	d374ce94 	lsl	x20, x20, #12
    4000b50c:	cb180280 	sub	x0, x20, x24
	if (alloc_size > size) {
    4000b510:	54000382 	b.cs	4000b580 <virt_region_alloc+0x10c>  // b.hs, b.nlast
		uintptr_t aligned_dest_addr = ROUND_UP(dest_addr, align);
    4000b514:	d10006b3 	sub	x19, x21, #0x1
    4000b518:	cb1503f5 	neg	x21, x21
    4000b51c:	8b000273 	add	x19, x19, x0
		virt_region_free(UINT_TO_POINTER(dest_addr),
    4000b520:	cb140301 	sub	x1, x24, x20
		uintptr_t aligned_dest_addr = ROUND_UP(dest_addr, align);
    4000b524:	8a150273 	and	x19, x19, x21
		virt_region_free(UINT_TO_POINTER(dest_addr),
    4000b528:	8b130021 	add	x1, x1, x19
    4000b52c:	97ffff98 	bl	4000b38c <virt_region_free>
		if (((dest_addr + alloc_size) - (aligned_dest_addr + size)) > 0) {
    4000b530:	8b160260 	add	x0, x19, x22
    4000b534:	eb00029f 	cmp	x20, x0
    4000b538:	54000060 	b.eq	4000b544 <virt_region_alloc+0xd0>  // b.none
			virt_region_free(UINT_TO_POINTER(aligned_dest_addr + size),
    4000b53c:	cb000281 	sub	x1, x20, x0
    4000b540:	97ffff93 	bl	4000b38c <virt_region_free>
	if (dest_addr < POINTER_TO_UINT(Z_VIRT_REGION_START_ADDR)) {
    4000b544:	900002e1 	adrp	x1, 40067000 <_end>
    4000b548:	91000021 	add	x1, x1, #0x0
	return UINT_TO_POINTER(dest_addr);
    4000b54c:	aa1303e0 	mov	x0, x19
	if (dest_addr < POINTER_TO_UINT(Z_VIRT_REGION_START_ADDR)) {
    4000b550:	eb01027f 	cmp	x19, x1
    4000b554:	540000c2 	b.cs	4000b56c <virt_region_alloc+0xf8>  // b.hs, b.nlast
		(void)sys_bitarray_free(&virt_region_bitmap, size, offset);
    4000b558:	f94027e2 	ldr	x2, [sp, #72]
    4000b55c:	aa1603e1 	mov	x1, x22
    4000b560:	aa1703e0 	mov	x0, x23
    4000b564:	97ffd8b3 	bl	40001830 <sys_bitarray_free>
		return NULL;
    4000b568:	d2800000 	mov	x0, #0x0                   	// #0
}
    4000b56c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b570:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b574:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000b578:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4000b57c:	d65f03c0 	ret
	dest_addr = virt_from_bitmap_offset(offset, alloc_size);
    4000b580:	aa0003f3 	mov	x19, x0
    4000b584:	17fffff0 	b	4000b544 <virt_region_alloc+0xd0>

000000004000b588 <z_phys_map>:
/* This may be called from arch early boot code before z_cstart() is invoked.
 * Data will be copied and BSS zeroed, but this must not rely on any
 * initialization functions being called prior to work correctly.
 */
void z_phys_map(uint8_t **virt_ptr, uintptr_t phys, size_t size, uint32_t flags)
{
    4000b588:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000b58c:	910003fd 	mov	x29, sp
    4000b590:	a90153f3 	stp	x19, x20, [sp, #16]

	/* The actual mapped region must be page-aligned. Round down the
	 * physical address and pad the region size appropriately
	 */
	*aligned_addr = ROUND_DOWN(addr, align);
	addr_offset = addr - *aligned_addr;
    4000b594:	92402c34 	and	x20, x1, #0xfff
	*aligned_size = ROUND_UP(size + addr_offset, align);
    4000b598:	913ffc53 	add	x19, x2, #0xfff
    4000b59c:	8b140273 	add	x19, x19, x20
{
    4000b5a0:	f90023f9 	str	x25, [sp, #64]
	*aligned_size = ROUND_UP(size + addr_offset, align);
    4000b5a4:	9274ce73 	and	x19, x19, #0xfffffffffffff000
	*aligned_addr = ROUND_DOWN(addr, align);
    4000b5a8:	9274cc39 	and	x25, x1, #0xfffffffffffff000
	align_boundary = arch_virt_region_align(aligned_phys, aligned_size);
    4000b5ac:	aa1303e1 	mov	x1, x19
{
    4000b5b0:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000b5b4:	aa0003f6 	mov	x22, x0
	align_boundary = arch_virt_region_align(aligned_phys, aligned_size);
    4000b5b8:	aa1903e0 	mov	x0, x25
{
    4000b5bc:	a90363f7 	stp	x23, x24, [sp, #48]
    4000b5c0:	2a0303f8 	mov	w24, w3
	align_boundary = arch_virt_region_align(aligned_phys, aligned_size);
    4000b5c4:	97fff453 	bl	40008710 <arch_virt_region_align>
    4000b5c8:	aa0003e1 	mov	x1, x0
    4000b5cc:	d53b4237 	mrs	x23, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000b5d0:	d50342df 	msr	daifset, #0x2
	dest_addr = virt_region_alloc(aligned_size, align_boundary);
    4000b5d4:	aa1303e0 	mov	x0, x19
    4000b5d8:	97ffffa7 	bl	4000b474 <virt_region_alloc>
	if (!dest_addr) {
    4000b5dc:	b5000120 	cbnz	x0, 4000b600 <z_phys_map+0x78>
	k_panic();
    4000b5e0:	d2800088 	mov	x8, #0x4                   	// #4
    4000b5e4:	d4000041 	svc	#0x2
}
    4000b5e8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b5ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b5f0:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000b5f4:	f94023f9 	ldr	x25, [sp, #64]
    4000b5f8:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4000b5fc:	d65f03c0 	ret
    4000b600:	aa0003f5 	mov	x21, x0
	arch_mem_map(dest_addr, aligned_phys, aligned_size, flags);
    4000b604:	2a1803e3 	mov	w3, w24
    4000b608:	aa1303e2 	mov	x2, x19
    4000b60c:	aa1903e1 	mov	x1, x25
MAKE_REG_HELPER(daif)
    4000b610:	92407ef7 	and	x23, x23, #0xffffffff
    4000b614:	97fff41b 	bl	40008680 <arch_mem_map>
    4000b618:	d51b4237 	msr	daif, x23
	*virt_ptr = dest_addr + addr_offset;
    4000b61c:	8b1402b4 	add	x20, x21, x20
    4000b620:	f90002d4 	str	x20, [x22]
	return;
    4000b624:	17fffff1 	b	4000b5e8 <z_phys_map+0x60>

000000004000b628 <z_mem_manage_init>:
    4000b628:	d53b4225 	mrs	x5, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000b62c:	d50342df 	msr	daifset, #0x2
	list->head = NULL;
    4000b630:	f0000060 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000b634:	910ac001 	add	x1, x0, #0x2b0

#ifdef CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT
	/* All pages composing the Zephyr image are mapped at boot in a
	 * predictable way. This can change at runtime.
	 */
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    4000b638:	900002e2 	adrp	x2, 40067000 <_end>
    4000b63c:	91000042 	add	x2, x2, #0x0
    4000b640:	f901581f 	str	xzr, [x0, #688]
	list->tail = NULL;
    4000b644:	f0000064 	adrp	x4, 4001a000 <shell_uart_ctx+0x1c8>
    4000b648:	91108484 	add	x4, x4, #0x421
    4000b64c:	b0ffffa0 	adrp	x0, 40000000 <__text_region_start>
    4000b650:	91000000 	add	x0, x0, #0x0
static inline struct z_page_frame *z_phys_to_page_frame(uintptr_t phys)
{
	__ASSERT(z_is_page_frame(phys),
		 "0x%lx not an SRAM physical address", phys);

	return &z_page_frames[(phys - Z_PHYS_RAM_START) /
    4000b654:	b26287e7 	mov	x7, #0xffffffffc0000000    	// #-1073741824
		 * code/data pages which are pinned in memory and
		 * may not be evicted. This will contain critical CPU data
		 * structures, and any code used to perform page fault
		 * handling, page-ins, etc.
		 */
		pf->flags |= Z_PAGE_FRAME_PINNED;
    4000b658:	528000a8 	mov	w8, #0x5                   	// #5
    4000b65c:	f900043f 	str	xzr, [x1, #8]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    4000b660:	eb02001f 	cmp	x0, x2
    4000b664:	54000183 	b.cc	4000b694 <z_mem_manage_init+0x6c>  // b.lo, b.ul, b.last
#endif

	/* Any remaining pages that aren't mapped, reserved, or pinned get
	 * added to the free pages list
	 */
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    4000b668:	d2a80006 	mov	x6, #0x40000000            	// #1073741824
    4000b66c:	d2a90007 	mov	x7, #0x48000000            	// #1207959552
		if (z_page_frame_is_available(pf)) {
    4000b670:	39402080 	ldrb	w0, [x4, #8]
    4000b674:	340003c0 	cbz	w0, 4000b6ec <z_mem_manage_init+0xc4>
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    4000b678:	914004c6 	add	x6, x6, #0x1, lsl #12
    4000b67c:	91002484 	add	x4, x4, #0x9
    4000b680:	eb0700df 	cmp	x6, x7
    4000b684:	54ffff61 	b.ne	4000b670 <z_mem_manage_init+0x48>  // b.any
MAKE_REG_HELPER(daif)
    4000b688:	92407ca5 	and	x5, x5, #0xffffffff
    4000b68c:	d51b4225 	msr	daif, x5
    4000b690:	d65f03c0 	ret
    4000b694:	8b070001 	add	x1, x0, x7
    4000b698:	d34cfc21 	lsr	x1, x1, #12
	pf->flags |= Z_PAGE_FRAME_MAPPED;
    4000b69c:	8b010c21 	add	x1, x1, x1, lsl #3
    4000b6a0:	8b010086 	add	x6, x4, x1
	pf->addr = addr;
    4000b6a4:	f8216880 	str	x0, [x4, x1]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    4000b6a8:	91400400 	add	x0, x0, #0x1, lsl #12
	pf->flags |= Z_PAGE_FRAME_MAPPED;
    4000b6ac:	394020c3 	ldrb	w3, [x6, #8]
		pf->flags |= Z_PAGE_FRAME_PINNED;
    4000b6b0:	2a080061 	orr	w1, w3, w8
    4000b6b4:	390020c1 	strb	w1, [x6, #8]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    4000b6b8:	17ffffea 	b	4000b660 <z_mem_manage_init+0x38>
		if (z_page_frame_is_available(pf)) {
    4000b6bc:	39402080 	ldrb	w0, [x4, #8]
    4000b6c0:	35000060 	cbnz	w0, 4000b6cc <z_mem_manage_init+0xa4>
			free_page_frame_list_put(pf);
    4000b6c4:	aa0403e0 	mov	x0, x4
    4000b6c8:	97ffff5c 	bl	4000b438 <free_page_frame_list_put>
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    4000b6cc:	914004c6 	add	x6, x6, #0x1, lsl #12
    4000b6d0:	91002484 	add	x4, x4, #0x9
    4000b6d4:	eb0700df 	cmp	x6, x7
    4000b6d8:	54ffff21 	b.ne	4000b6bc <z_mem_manage_init+0x94>  // b.any
    4000b6dc:	92407ca5 	and	x5, x5, #0xffffffff
    4000b6e0:	d51b4225 	msr	daif, x5
	 * and the BSS pages can be brought into physical
	 * memory to be cleared.
	 */
	z_bss_zero();
#endif
}
    4000b6e4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b6e8:	d65f03c0 	ret
{
    4000b6ec:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000b6f0:	910003fd 	mov	x29, sp
    4000b6f4:	17fffff4 	b	4000b6c4 <z_mem_manage_init+0x9c>

000000004000b6f8 <z_mem_manage_boot_finish>:
	/* At the end of boot process, unpin the boot sections
	 * as they don't need to be in memory all the time anymore.
	 */
	mark_linker_section_pinned(lnkr_boot_start, lnkr_boot_end, false);
#endif
}
    4000b6f8:	d65f03c0 	ret

000000004000b6fc <add_event>:
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
}

static inline void add_event(sys_dlist_t *events, struct k_poll_event *event,
			     struct z_poller *poller)
{
    4000b6fc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000b700:	910003fd 	mov	x29, sp
    4000b704:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b708:	aa0003f3 	mov	x19, x0
    4000b70c:	aa0103f4 	mov	x20, x1
    4000b710:	a9025bf5 	stp	x21, x22, [sp, #32]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    4000b714:	f9400261 	ldr	x1, [x19]
    4000b718:	f9400400 	ldr	x0, [x0, #8]
    4000b71c:	eb01027f 	cmp	x19, x1
    4000b720:	54000121 	b.ne	4000b744 <add_event+0x48>  // b.any
	sys_dnode_t *const tail = list->tail;
    4000b724:	f9400660 	ldr	x0, [x19, #8]
	node->prev = tail;
    4000b728:	a9000293 	stp	x19, x0, [x20]
	tail->next = node;
    4000b72c:	f9000014 	str	x20, [x0]
	list->tail = node;
    4000b730:	f9000674 	str	x20, [x19, #8]
			return;
		}
	}

	sys_dlist_append(events, &event->_node);
}
    4000b734:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b738:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b73c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000b740:	d65f03c0 	ret
	if ((pending == NULL) ||
    4000b744:	b4ffff00 	cbz	x0, 4000b724 <add_event+0x28>
		(z_sched_prio_cmp(poller_thread(pending->poller),
    4000b748:	f9400800 	ldr	x0, [x0, #16]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
    4000b74c:	aa0203f6 	mov	x22, x2
    4000b750:	b4000040 	cbz	x0, 4000b758 <add_event+0x5c>
    4000b754:	d1032000 	sub	x0, x0, #0xc8
    4000b758:	b4000056 	cbz	x22, 4000b760 <add_event+0x64>
    4000b75c:	d10322d6 	sub	x22, x22, #0xc8
		(z_sched_prio_cmp(poller_thread(pending->poller),
    4000b760:	aa1603e1 	mov	x1, x22
    4000b764:	97fffb2e 	bl	4000a41c <z_sched_prio_cmp>
	if ((pending == NULL) ||
    4000b768:	7100001f 	cmp	w0, #0x0
    4000b76c:	54fffdcc 	b.gt	4000b724 <add_event+0x28>
	return list->head == list;
    4000b770:	f9400275 	ldr	x21, [x19]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000b774:	eb15027f 	cmp	x19, x21
    4000b778:	54fffd60 	b.eq	4000b724 <add_event+0x28>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    4000b77c:	b4fffd55 	cbz	x21, 4000b724 <add_event+0x28>
		if (z_sched_prio_cmp(poller_thread(poller),
    4000b780:	f9400aa1 	ldr	x1, [x21, #16]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
    4000b784:	b4000041 	cbz	x1, 4000b78c <add_event+0x90>
    4000b788:	d1032021 	sub	x1, x1, #0xc8
		if (z_sched_prio_cmp(poller_thread(poller),
    4000b78c:	aa1603e0 	mov	x0, x22
    4000b790:	97fffb23 	bl	4000a41c <z_sched_prio_cmp>
    4000b794:	7100001f 	cmp	w0, #0x0
    4000b798:	540000cd 	b.le	4000b7b0 <add_event+0xb4>
	sys_dnode_t *const prev = successor->prev;
    4000b79c:	f94006a0 	ldr	x0, [x21, #8]
	node->prev = prev;
    4000b7a0:	a9000295 	stp	x21, x0, [x20]
	prev->next = node;
    4000b7a4:	f9000014 	str	x20, [x0]
	successor->prev = node;
    4000b7a8:	f90006b4 	str	x20, [x21, #8]
			return;
    4000b7ac:	17ffffe2 	b	4000b734 <add_event+0x38>
	return (node == list->tail) ? NULL : node->next;
    4000b7b0:	f9400660 	ldr	x0, [x19, #8]
    4000b7b4:	eb15001f 	cmp	x0, x21
    4000b7b8:	54fffb60 	b.eq	4000b724 <add_event+0x28>  // b.none
    4000b7bc:	f94002b5 	ldr	x21, [x21]
    4000b7c0:	17ffffef 	b	4000b77c <add_event+0x80>

000000004000b7c4 <register_events>:

static inline int register_events(struct k_poll_event *events,
				  int num_events,
				  struct z_poller *poller,
				  bool just_check)
{
    4000b7c4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4000b7c8:	910003fd 	mov	x29, sp
    4000b7cc:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b7d0:	aa0203f4 	mov	x20, x2
    4000b7d4:	aa0003f3 	mov	x19, x0
    4000b7d8:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000b7dc:	2a0103f6 	mov	w22, w1
	int events_registered = 0;
    4000b7e0:	52800015 	mov	w21, #0x0                   	// #0
{
    4000b7e4:	a90363f7 	stp	x23, x24, [sp, #48]
	switch (event->type) {
    4000b7e8:	f0000018 	adrp	x24, 4000e000 <mmu_regions+0x38>
    4000b7ec:	912b9318 	add	x24, x24, #0xae4
{
    4000b7f0:	a9046bf9 	stp	x25, x26, [sp, #64]
	switch (event->type) {
    4000b7f4:	f0000019 	adrp	x25, 4000e000 <mmu_regions+0x38>
    4000b7f8:	912b7339 	add	x25, x25, #0xadc
{
    4000b7fc:	f9002bfb 	str	x27, [sp, #80]
    4000b800:	12001c7b 	and	w27, w3, #0xff

	for (int ii = 0; ii < num_events; ii++) {
    4000b804:	52800017 	mov	w23, #0x0                   	// #0
    4000b808:	6b1602ff 	cmp	w23, w22
    4000b80c:	5400012b 	b.lt	4000b830 <register_events+0x6c>  // b.tstop
		}
		k_spin_unlock(&lock, key);
	}

	return events_registered;
}
    4000b810:	2a1503e0 	mov	w0, w21
    4000b814:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b818:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b81c:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000b820:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000b824:	f9402bfb 	ldr	x27, [sp, #80]
    4000b828:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000b82c:	d65f03c0 	ret
    4000b830:	d53b423a 	mrs	x26, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000b834:	d50342df 	msr	daifset, #0x2
	switch (event->type) {
    4000b838:	f9400e60 	ldr	x0, [x19, #24]
    4000b83c:	53083000 	ubfx	w0, w0, #8, #5
    4000b840:	51000400 	sub	w0, w0, #0x1
    4000b844:	71001c1f 	cmp	w0, #0x7
    4000b848:	540001a8 	b.hi	4000b87c <register_events+0xb8>  // b.pmore
    4000b84c:	38604b20 	ldrb	w0, [x25, w0, uxtw]
    4000b850:	10000061 	adr	x1, 4000b85c <register_events+0x98>
    4000b854:	8b208820 	add	x0, x1, w0, sxtb #2
    4000b858:	d61f0000 	br	x0
		if (k_sem_count_get(event->sem) > 0U) {
    4000b85c:	f9401260 	ldr	x0, [x19, #32]
    4000b860:	b9401000 	ldr	w0, [x0, #16]
    4000b864:	340000c0 	cbz	w0, 4000b87c <register_events+0xb8>
			*state = K_POLL_STATE_SEM_AVAILABLE;
    4000b868:	52800040 	mov	w0, #0x2                   	// #2
    4000b86c:	14000019 	b	4000b8d0 <register_events+0x10c>
		if (!k_queue_is_empty(event->queue)) {
    4000b870:	f9401260 	ldr	x0, [x19, #32]
    4000b874:	f9400000 	ldr	x0, [x0]
    4000b878:	b5000460 	cbnz	x0, 4000b904 <register_events+0x140>
		} else if (!just_check && poller->is_polling) {
    4000b87c:	350003bb 	cbnz	w27, 4000b8f0 <register_events+0x12c>
    4000b880:	39400280 	ldrb	w0, [x20]
    4000b884:	34000360 	cbz	w0, 4000b8f0 <register_events+0x12c>
	switch (event->type) {
    4000b888:	f9400e60 	ldr	x0, [x19, #24]
    4000b88c:	53083000 	ubfx	w0, w0, #8, #5
    4000b890:	51000400 	sub	w0, w0, #0x1
    4000b894:	71001c1f 	cmp	w0, #0x7
    4000b898:	54000448 	b.hi	4000b920 <register_events+0x15c>  // b.pmore
    4000b89c:	38604b00 	ldrb	w0, [x24, w0, uxtw]
    4000b8a0:	10000061 	adr	x1, 4000b8ac <register_events+0xe8>
    4000b8a4:	8b208820 	add	x0, x1, w0, sxtb #2
    4000b8a8:	d61f0000 	br	x0
		if (event->signal->signaled != 0U) {
    4000b8ac:	f9401260 	ldr	x0, [x19, #32]
    4000b8b0:	b9401000 	ldr	w0, [x0, #16]
    4000b8b4:	34fffe40 	cbz	w0, 4000b87c <register_events+0xb8>
			*state = K_POLL_STATE_SIGNALED;
    4000b8b8:	52800020 	mov	w0, #0x1                   	// #1
    4000b8bc:	14000005 	b	4000b8d0 <register_events+0x10c>
		if (event->msgq->used_msgs > 0) {
    4000b8c0:	f9401260 	ldr	x0, [x19, #32]
    4000b8c4:	b9404000 	ldr	w0, [x0, #64]
    4000b8c8:	34fffda0 	cbz	w0, 4000b87c <register_events+0xb8>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
    4000b8cc:	52800200 	mov	w0, #0x10                  	// #16
	event->state |= state;
    4000b8d0:	f9400e61 	ldr	x1, [x19, #24]
	event->poller = NULL;
    4000b8d4:	f9000a7f 	str	xzr, [x19, #16]
	event->state |= state;
    4000b8d8:	d34d4821 	ubfx	x1, x1, #13, #6
    4000b8dc:	2a010000 	orr	w0, w0, w1
    4000b8e0:	b9401a61 	ldr	w1, [x19, #24]
    4000b8e4:	33131401 	bfi	w1, w0, #13, #6
    4000b8e8:	b9001a61 	str	w1, [x19, #24]
			poller->is_polling = false;
    4000b8ec:	3900029f 	strb	wzr, [x20]
MAKE_REG_HELPER(daif)
    4000b8f0:	92407f5a 	and	x26, x26, #0xffffffff
    4000b8f4:	d51b423a 	msr	daif, x26
	for (int ii = 0; ii < num_events; ii++) {
    4000b8f8:	110006f7 	add	w23, w23, #0x1
    4000b8fc:	9100a273 	add	x19, x19, #0x28
    4000b900:	17ffffc2 	b	4000b808 <register_events+0x44>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
    4000b904:	52800080 	mov	w0, #0x4                   	// #4
    4000b908:	17fffff2 	b	4000b8d0 <register_events+0x10c>
		add_event(&event->sem->poll_events, event, poller);
    4000b90c:	f9401260 	ldr	x0, [x19, #32]
    4000b910:	aa1403e2 	mov	x2, x20
    4000b914:	aa1303e1 	mov	x1, x19
    4000b918:	91006000 	add	x0, x0, #0x18
		add_event(&event->msgq->poll_events, event, poller);
    4000b91c:	97ffff78 	bl	4000b6fc <add_event>
			events_registered += 1;
    4000b920:	110006b5 	add	w21, w21, #0x1
	event->poller = poller;
    4000b924:	f9000a74 	str	x20, [x19, #16]
			events_registered += 1;
    4000b928:	17fffff2 	b	4000b8f0 <register_events+0x12c>
		add_event(&event->queue->poll_events, event, poller);
    4000b92c:	f9401260 	ldr	x0, [x19, #32]
    4000b930:	aa1403e2 	mov	x2, x20
    4000b934:	aa1303e1 	mov	x1, x19
    4000b938:	91008000 	add	x0, x0, #0x20
    4000b93c:	17fffff8 	b	4000b91c <register_events+0x158>
		add_event(&event->signal->poll_events, event, poller);
    4000b940:	aa1403e2 	mov	x2, x20
    4000b944:	aa1303e1 	mov	x1, x19
    4000b948:	f9401260 	ldr	x0, [x19, #32]
    4000b94c:	17fffff4 	b	4000b91c <register_events+0x158>
		add_event(&event->msgq->poll_events, event, poller);
    4000b950:	f9401260 	ldr	x0, [x19, #32]
    4000b954:	aa1403e2 	mov	x2, x20
    4000b958:	aa1303e1 	mov	x1, x19
    4000b95c:	91012000 	add	x0, x0, #0x48
    4000b960:	17ffffef 	b	4000b91c <register_events+0x158>

000000004000b964 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
    4000b964:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000b968:	910003fd 	mov	x29, sp
    4000b96c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b970:	aa0003f4 	mov	x20, x0
	struct z_poller *poller = event->poller;
    4000b974:	f9400813 	ldr	x19, [x0, #16]
{
    4000b978:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000b97c:	2a0103f5 	mov	w21, w1
    4000b980:	f9001bf7 	str	x23, [sp, #48]
	int retcode = 0;

	if (poller != NULL) {
    4000b984:	b4000113 	cbz	x19, 4000b9a4 <signal_poll_event+0x40>
		if (poller->mode == MODE_POLL) {
    4000b988:	39400660 	ldrb	w0, [x19, #1]
    4000b98c:	7100041f 	cmp	w0, #0x1
    4000b990:	540004c1 	b.ne	4000ba28 <signal_poll_event+0xc4>  // b.any
	if (!z_is_thread_pending(thread)) {
    4000b994:	38551260 	ldurb	w0, [x19, #-175]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
    4000b998:	d1032276 	sub	x22, x19, #0xc8
    4000b99c:	37080160 	tbnz	w0, #1, 4000b9c8 <signal_poll_event+0x64>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
    4000b9a0:	3900027f 	strb	wzr, [x19]
	event->state |= state;
    4000b9a4:	f9400e81 	ldr	x1, [x20, #24]
	event->poller = NULL;
    4000b9a8:	f9000a9f 	str	xzr, [x20, #16]
	event->state |= state;
    4000b9ac:	b9401a80 	ldr	w0, [x20, #24]
    4000b9b0:	d34d4821 	ubfx	x1, x1, #13, #6
    4000b9b4:	2a0102b5 	orr	w21, w21, w1
    4000b9b8:	331316a0 	bfi	w0, w21, #13, #6
    4000b9bc:	b9001a80 	str	w0, [x20, #24]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
    4000b9c0:	52800000 	mov	w0, #0x0                   	// #0
    4000b9c4:	14000006 	b	4000b9dc <signal_poll_event+0x78>
	if (z_is_thread_timeout_expired(thread)) {
    4000b9c8:	f94022c0 	ldr	x0, [x22, #64]
    4000b9cc:	b100081f 	cmn	x0, #0x2
    4000b9d0:	54000101 	b.ne	4000b9f0 <signal_poll_event+0x8c>  // b.any
		return -EAGAIN;
    4000b9d4:	12800140 	mov	w0, #0xfffffff5            	// #-11
		poller->is_polling = false;
    4000b9d8:	3900027f 	strb	wzr, [x19]
}
    4000b9dc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b9e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b9e4:	f9401bf7 	ldr	x23, [sp, #48]
    4000b9e8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000b9ec:	d65f03c0 	ret
	z_unpend_thread(thread);
    4000b9f0:	aa1603e0 	mov	x0, x22
    4000b9f4:	97fffaff 	bl	4000a5f0 <z_unpend_thread>
	arch_thread_return_value_set(thread,
    4000b9f8:	710022bf 	cmp	w21, #0x8
    4000b9fc:	12800060 	mov	w0, #0xfffffffc            	// #-4
    4000ba00:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
    4000ba04:	b9013ac0 	str	w0, [x22, #312]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    4000ba08:	394066c0 	ldrb	w0, [x22, #25]
    4000ba0c:	f240101f 	tst	x0, #0x1f
    4000ba10:	54fffc81 	b.ne	4000b9a0 <signal_poll_event+0x3c>  // b.any
	if (!z_is_thread_ready(thread)) {
    4000ba14:	f8560260 	ldur	x0, [x19, #-160]
    4000ba18:	b5fffc40 	cbnz	x0, 4000b9a0 <signal_poll_event+0x3c>
	z_ready_thread(thread);
    4000ba1c:	aa1603e0 	mov	x0, x22
    4000ba20:	97fffbce 	bl	4000a958 <z_ready_thread>
		poller->is_polling = false;
    4000ba24:	17ffffdf 	b	4000b9a0 <signal_poll_event+0x3c>
		} else if (poller->mode == MODE_TRIGGERED) {
    4000ba28:	7100081f 	cmp	w0, #0x2
    4000ba2c:	54fffba1 	b.ne	4000b9a0 <signal_poll_event+0x3c>  // b.any
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
    4000ba30:	39400260 	ldrb	w0, [x19]
    4000ba34:	34fffb80 	cbz	w0, 4000b9a4 <signal_poll_event+0x40>
    4000ba38:	f85f8277 	ldur	x23, [x19, #-8]
    4000ba3c:	d100a276 	sub	x22, x19, #0x28
    4000ba40:	b4fffb17 	cbz	x23, 4000b9a0 <signal_poll_event+0x3c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
    4000ba44:	91008260 	add	x0, x19, #0x20
    4000ba48:	97fffde3 	bl	4000b1d4 <z_abort_timeout>
		twork->poll_result = 0;
    4000ba4c:	b900427f 	str	wzr, [x19, #64]
		k_work_submit_to_queue(work_q, &twork->work);
    4000ba50:	aa1603e1 	mov	x1, x22
    4000ba54:	aa1703e0 	mov	x0, x23
    4000ba58:	94000165 	bl	4000bfec <k_work_submit_to_queue>
		poller->is_polling = false;
    4000ba5c:	17ffffd1 	b	4000b9a0 <signal_poll_event+0x3c>

000000004000ba60 <clear_event_registrations>:
	while (num_events--) {
    4000ba60:	51000421 	sub	w1, w1, #0x1
		clear_event_registration(&events[num_events]);
    4000ba64:	52800507 	mov	w7, #0x28                  	// #40
    4000ba68:	d2800028 	mov	x8, #0x1                   	// #1
    4000ba6c:	d28022c9 	mov	x9, #0x116                 	// #278
	while (num_events--) {
    4000ba70:	3100043f 	cmn	w1, #0x1
    4000ba74:	54000041 	b.ne	4000ba7c <clear_event_registrations+0x1c>  // b.any
}
    4000ba78:	d65f03c0 	ret
		clear_event_registration(&events[num_events]);
    4000ba7c:	9b277c25 	smull	x5, w1, w7
    4000ba80:	8b050003 	add	x3, x0, x5
	switch (event->type) {
    4000ba84:	f9400c64 	ldr	x4, [x3, #24]
	event->poller = NULL;
    4000ba88:	f900087f 	str	xzr, [x3, #16]
	switch (event->type) {
    4000ba8c:	d3483086 	ubfx	x6, x4, #8, #5
    4000ba90:	53083084 	ubfx	w4, w4, #8, #5
    4000ba94:	7100209f 	cmp	w4, #0x8
    4000ba98:	54000168 	b.hi	4000bac4 <clear_event_registrations+0x64>  // b.pmore
    4000ba9c:	9ac62104 	lsl	x4, x8, x6
    4000baa0:	ea09009f 	tst	x4, x9
    4000baa4:	54000100 	b.eq	4000bac4 <clear_event_registrations+0x64>  // b.none
	return node->next != NULL;
    4000baa8:	f8656804 	ldr	x4, [x0, x5]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
    4000baac:	b40000c4 	cbz	x4, 4000bac4 <clear_event_registrations+0x64>
	sys_dnode_t *const prev = node->prev;
    4000bab0:	f9400466 	ldr	x6, [x3, #8]
	prev->next = next;
    4000bab4:	f90000c4 	str	x4, [x6]
	next->prev = prev;
    4000bab8:	f9000486 	str	x6, [x4, #8]
	node->next = NULL;
    4000babc:	f825681f 	str	xzr, [x0, x5]
	node->prev = NULL;
    4000bac0:	f900047f 	str	xzr, [x3, #8]
    4000bac4:	2a0203e2 	mov	w2, w2
    4000bac8:	d51b4222 	msr	daif, x2
    4000bacc:	d53b4222 	mrs	x2, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000bad0:	d50342df 	msr	daifset, #0x2
    4000bad4:	51000421 	sub	w1, w1, #0x1
    4000bad8:	17ffffe6 	b	4000ba70 <clear_event_registrations+0x10>

000000004000badc <k_poll_event_init>:
	event->type = type;
    4000badc:	53181021 	ubfiz	w1, w1, #8, #5
    4000bae0:	530d0042 	ubfiz	w2, w2, #19, #1
    4000bae4:	2a010042 	orr	w2, w2, w1
    4000bae8:	39406001 	ldrb	w1, [x0, #24]
	event->poller = NULL;
    4000baec:	f900081f 	str	xzr, [x0, #16]
	event->type = type;
    4000baf0:	2a010042 	orr	w2, w2, w1
    4000baf4:	b9001802 	str	w2, [x0, #24]
	event->obj = obj;
    4000baf8:	f9001003 	str	x3, [x0, #32]
}
    4000bafc:	d65f03c0 	ret

000000004000bb00 <z_impl_k_poll>:
{
    4000bb00:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	poller->is_polling = true;
    4000bb04:	52802023 	mov	w3, #0x101                 	// #257
{
    4000bb08:	910003fd 	mov	x29, sp
    4000bb0c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000bb10:	aa0203f3 	mov	x19, x2
	events_registered = register_events(events, num_events, poller,
    4000bb14:	f100027f 	cmp	x19, #0x0
{
    4000bb18:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct z_poller *poller = &_current->poller;
    4000bb1c:	f0000062 	adrp	x2, 4001a000 <shell_uart_ctx+0x1c8>
    4000bb20:	f9413056 	ldr	x22, [x2, #608]
{
    4000bb24:	aa0003f4 	mov	x20, x0
	poller->is_polling = true;
    4000bb28:	aa1603e2 	mov	x2, x22
    4000bb2c:	780c8c43 	strh	w3, [x2, #200]!
	events_registered = register_events(events, num_events, poller,
    4000bb30:	1a9f17e3 	cset	w3, eq  // eq = none
    4000bb34:	97ffff24 	bl	4000b7c4 <register_events>
    4000bb38:	2a0003f5 	mov	w21, w0
MAKE_REG_HELPER(daif)
    4000bb3c:	d53b422a 	mrs	x10, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000bb40:	d50342df 	msr	daifset, #0x2
	if (!poller->is_polling) {
    4000bb44:	394322c0 	ldrb	w0, [x22, #200]
    4000bb48:	350001a0 	cbnz	w0, 4000bb7c <z_impl_k_poll+0x7c>
		clear_event_registrations(events, events_registered, key);
    4000bb4c:	2a0a03e2 	mov	w2, w10
    4000bb50:	2a1503e1 	mov	w1, w21
    4000bb54:	aa1403e0 	mov	x0, x20
MAKE_REG_HELPER(daif)
    4000bb58:	92407d4a 	and	x10, x10, #0xffffffff
    4000bb5c:	97ffffc1 	bl	4000ba60 <clear_event_registrations>
    4000bb60:	d51b422a 	msr	daif, x10
		return 0;
    4000bb64:	5280000a 	mov	w10, #0x0                   	// #0
}
    4000bb68:	2a0a03e0 	mov	w0, w10
    4000bb6c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000bb70:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000bb74:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000bb78:	d65f03c0 	ret
	poller->is_polling = false;
    4000bb7c:	390322df 	strb	wzr, [x22, #200]
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    4000bb80:	b50000b3 	cbnz	x19, 4000bb94 <z_impl_k_poll+0x94>
    4000bb84:	92407d4a 	and	x10, x10, #0xffffffff
    4000bb88:	d51b422a 	msr	daif, x10
		return -EAGAIN;
    4000bb8c:	1280014a 	mov	w10, #0xfffffff5            	// #-11
    4000bb90:	17fffff6 	b	4000bb68 <z_impl_k_poll+0x68>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
    4000bb94:	2a0a03e1 	mov	w1, w10
    4000bb98:	aa1303e3 	mov	x3, x19
    4000bb9c:	f00002c2 	adrp	x2, 40066000 <sys_work_q_stack+0x3d0>
    4000bba0:	913e4042 	add	x2, x2, #0xf90
    4000bba4:	f00002a0 	adrp	x0, 40062000 <z_page_frames+0x47bdf>
    4000bba8:	91108400 	add	x0, x0, #0x421
    4000bbac:	97fffbf8 	bl	4000ab8c <z_pend_curr>
    4000bbb0:	2a0003ea 	mov	w10, w0
    4000bbb4:	d53b422b 	mrs	x11, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000bbb8:	d50342df 	msr	daifset, #0x2
	clear_event_registrations(events, events_registered, key);
    4000bbbc:	2a0b03e2 	mov	w2, w11
    4000bbc0:	2a1503e1 	mov	w1, w21
    4000bbc4:	aa1403e0 	mov	x0, x20
MAKE_REG_HELPER(daif)
    4000bbc8:	92407d6b 	and	x11, x11, #0xffffffff
    4000bbcc:	97ffffa5 	bl	4000ba60 <clear_event_registrations>
    4000bbd0:	d51b422b 	msr	daif, x11
	return swap_rc;
    4000bbd4:	17ffffe5 	b	4000bb68 <z_impl_k_poll+0x68>

000000004000bbd8 <z_handle_obj_poll_events>:
{
    4000bbd8:	aa0003e2 	mov	x2, x0
	return list->head == list;
    4000bbdc:	f9400000 	ldr	x0, [x0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
    4000bbe0:	eb00005f 	cmp	x2, x0
    4000bbe4:	540000c0 	b.eq	4000bbfc <z_handle_obj_poll_events+0x24>  // b.none
	sys_dnode_t *const prev = node->prev;
    4000bbe8:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
    4000bbec:	f9000062 	str	x2, [x3]
	next->prev = prev;
    4000bbf0:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
    4000bbf4:	a9007c1f 	stp	xzr, xzr, [x0]
		(void) signal_poll_event(poll_event, state);
    4000bbf8:	17ffff5b 	b	4000b964 <signal_poll_event>
}
    4000bbfc:	d65f03c0 	ret

000000004000bc00 <z_impl_k_poll_signal_init>:
	list->tail = (sys_dnode_t *)list;
    4000bc00:	a9000000 	stp	x0, x0, [x0]
	sig->signaled = 0U;
    4000bc04:	b900101f 	str	wzr, [x0, #16]
}
    4000bc08:	d65f03c0 	ret

000000004000bc0c <z_impl_k_poll_signal_reset>:
	sig->signaled = 0U;
    4000bc0c:	b900101f 	str	wzr, [x0, #16]
}
    4000bc10:	d65f03c0 	ret

000000004000bc14 <z_impl_k_poll_signal_check>:
	*signaled = sig->signaled;
    4000bc14:	b9401003 	ldr	w3, [x0, #16]
    4000bc18:	b9000023 	str	w3, [x1]
	*result = sig->result;
    4000bc1c:	b9401400 	ldr	w0, [x0, #20]
    4000bc20:	b9000040 	str	w0, [x2]
}
    4000bc24:	d65f03c0 	ret

000000004000bc28 <z_impl_k_poll_signal_raise>:
{
    4000bc28:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000bc2c:	aa0003e2 	mov	x2, x0
    4000bc30:	910003fd 	mov	x29, sp
    4000bc34:	a90153f3 	stp	x19, x20, [sp, #16]
    4000bc38:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000bc3c:	d50342df 	msr	daifset, #0x2
	sig->result = result;
    4000bc40:	b9001401 	str	w1, [x0, #20]
	sig->signaled = 1U;
    4000bc44:	52800021 	mov	w1, #0x1                   	// #1
    4000bc48:	b9001001 	str	w1, [x0, #16]
	return list->head == list;
    4000bc4c:	f9400000 	ldr	x0, [x0]
	if (!sys_dlist_is_empty(list)) {
    4000bc50:	eb00005f 	cmp	x2, x0
    4000bc54:	54000101 	b.ne	4000bc74 <z_impl_k_poll_signal_raise+0x4c>  // b.any
MAKE_REG_HELPER(daif)
    4000bc58:	92407e94 	and	x20, x20, #0xffffffff
    4000bc5c:	d51b4234 	msr	daif, x20
		return 0;
    4000bc60:	52800013 	mov	w19, #0x0                   	// #0
}
    4000bc64:	2a1303e0 	mov	w0, w19
    4000bc68:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000bc6c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000bc70:	d65f03c0 	ret
	sys_dnode_t *const prev = node->prev;
    4000bc74:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
    4000bc78:	f9000062 	str	x2, [x3]
	next->prev = prev;
    4000bc7c:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
    4000bc80:	a9007c1f 	stp	xzr, xzr, [x0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
    4000bc84:	97ffff38 	bl	4000b964 <signal_poll_event>
    4000bc88:	2a0003f3 	mov	w19, w0
	z_reschedule(&lock, key);
    4000bc8c:	2a1403e1 	mov	w1, w20
    4000bc90:	f00002a0 	adrp	x0, 40062000 <z_page_frames+0x47bdf>
    4000bc94:	91108400 	add	x0, x0, #0x421
    4000bc98:	97fffa61 	bl	4000a61c <z_reschedule>
	return rc;
    4000bc9c:	17fffff2 	b	4000bc64 <z_impl_k_poll_signal_raise+0x3c>

000000004000bca0 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    4000bca0:	f0000002 	adrp	x2, 4000e000 <mmu_regions+0x38>
    4000bca4:	91317842 	add	x2, x2, #0xc5e
    4000bca8:	90000021 	adrp	x1, 4000f000 <cfg_flags.0+0x5ac>
    4000bcac:	91256821 	add	x1, x1, #0x95a
    4000bcb0:	90000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    4000bcb4:	91259c00 	add	x0, x0, #0x967
    4000bcb8:	17ffd576 	b	40001290 <printk>

000000004000bcbc <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
    4000bcbc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
    4000bcc0:	90000020 	adrp	x0, 4000f000 <cfg_flags.0+0x5ac>
    4000bcc4:	91263800 	add	x0, x0, #0x98e
{
    4000bcc8:	910003fd 	mov	x29, sp
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
    4000bccc:	910043e4 	add	x4, sp, #0x10
    4000bcd0:	12800003 	mov	w3, #0xffffffff            	// #-1
    4000bcd4:	d2820002 	mov	x2, #0x1000                	// #4096
    4000bcd8:	d00002c1 	adrp	x1, 40065000 <z_interrupt_stacks+0x3d0>
    4000bcdc:	9130c021 	add	x1, x1, #0xc30
	struct k_work_queue_config cfg = {
    4000bce0:	f9000be0 	str	x0, [sp, #16]
	k_work_queue_start(&k_sys_work_q,
    4000bce4:	d0000060 	adrp	x0, 40019000 <shell_uart_thread>
    4000bce8:	91294000 	add	x0, x0, #0xa50
	struct k_work_queue_config cfg = {
    4000bcec:	390063ff 	strb	wzr, [sp, #24]
	k_work_queue_start(&k_sys_work_q,
    4000bcf0:	940000d4 	bl	4000c040 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
    4000bcf4:	52800000 	mov	w0, #0x0                   	// #0
    4000bcf8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000bcfc:	d65f03c0 	ret

000000004000bd00 <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
    4000bd00:	b9400002 	ldr	w2, [x0]
	*flagp &= ~BIT(bit);
    4000bd04:	d2800023 	mov	x3, #0x1                   	// #1
    4000bd08:	9ac12063 	lsl	x3, x3, x1
    4000bd0c:	0a230043 	bic	w3, w2, w3
	return (*flagp & BIT(bit)) != 0U;
    4000bd10:	2a0203e2 	mov	w2, w2
	*flagp &= ~BIT(bit);
    4000bd14:	b9000003 	str	w3, [x0]
	return (*flagp & BIT(bit)) != 0U;
    4000bd18:	9ac12440 	lsr	x0, x2, x1
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
    4000bd1c:	12000000 	and	w0, w0, #0x1
    4000bd20:	d65f03c0 	ret

000000004000bd24 <notify_queue_locked.isra.0>:
 */
static inline bool notify_queue_locked(struct k_work_q *queue)
{
	bool rv = false;

	if (queue != NULL) {
    4000bd24:	b40000a0 	cbz	x0, 4000bd38 <notify_queue_locked.isra.0+0x14>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
    4000bd28:	910e0000 	add	x0, x0, #0x380
    4000bd2c:	d2800002 	mov	x2, #0x0                   	// #0
    4000bd30:	52800001 	mov	w1, #0x0                   	// #0
    4000bd34:	17fffc89 	b	4000af58 <z_sched_wake>
	}

	return rv;
}
    4000bd38:	d65f03c0 	ret

000000004000bd3c <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
    4000bd3c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000bd40:	910003fd 	mov	x29, sp
    4000bd44:	a90153f3 	stp	x19, x20, [sp, #16]
    4000bd48:	aa0003f4 	mov	x20, x0
    4000bd4c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return list->head;
    4000bd50:	f0000075 	adrp	x21, 4001a000 <shell_uart_ctx+0x1c8>
    4000bd54:	910b22b5 	add	x21, x21, #0x2c8
			 * the lock, and we didn't find work nor got asked to
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
    4000bd58:	f00002b6 	adrp	x22, 40062000 <z_page_frames+0x47bdf>
    4000bd5c:	911086d6 	add	x22, x22, #0x421
{
    4000bd60:	a90363f7 	stp	x23, x24, [sp, #48]
    4000bd64:	f90023f9 	str	x25, [sp, #64]
    4000bd68:	d53b4237 	mrs	x23, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000bd6c:	d50342df 	msr	daifset, #0x2
    4000bd70:	f941ba93 	ldr	x19, [x20, #880]
    4000bd74:	91100280 	add	x0, x20, #0x400
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    4000bd78:	b50001b3 	cbnz	x19, 4000bdac <work_queue_main+0x70>
		} else if (flag_test_and_clear(&queue->flags,
    4000bd7c:	910e8280 	add	x0, x20, #0x3a0
    4000bd80:	52800041 	mov	w1, #0x2                   	// #2
    4000bd84:	97ffffdf 	bl	4000bd00 <flag_test_and_clear>
    4000bd88:	72001c1f 	tst	w0, #0xff
    4000bd8c:	54000421 	b.ne	4000be10 <work_queue_main+0xd4>  // b.any
			(void)z_sched_wait(&lock, key, &queue->notifyq,
    4000bd90:	910e0282 	add	x2, x20, #0x380
    4000bd94:	2a1703e1 	mov	w1, w23
    4000bd98:	aa1603e0 	mov	x0, x22
    4000bd9c:	d2800004 	mov	x4, #0x0                   	// #0
    4000bda0:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    4000bda4:	97fffc85 	bl	4000afb8 <z_sched_wait>
					   K_FOREVER, NULL);
			continue;
    4000bda8:	17fffff0 	b	4000bd68 <work_queue_main+0x2c>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    4000bdac:	f8578002 	ldur	x2, [x0, #-136]
	return node->next;
    4000bdb0:	f9400261 	ldr	x1, [x19]
	list->head = node;
    4000bdb4:	f8170001 	stur	x1, [x0, #-144]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    4000bdb8:	eb02027f 	cmp	x19, x2
    4000bdbc:	54000041 	b.ne	4000bdc4 <work_queue_main+0x88>  // b.any
	list->tail = node;
    4000bdc0:	f8178001 	stur	x1, [x0, #-136]
	*flagp |= BIT(bit);
    4000bdc4:	b943a280 	ldr	w0, [x20, #928]
MAKE_REG_HELPER(daif)
    4000bdc8:	92407ef7 	and	x23, x23, #0xffffffff
			handler = work->handler;
    4000bdcc:	f9400661 	ldr	x1, [x19, #8]
	*flagp |= BIT(bit);
    4000bdd0:	321f0000 	orr	w0, w0, #0x2
    4000bdd4:	b903a280 	str	w0, [x20, #928]
	*flagp &= ~BIT(bit);
    4000bdd8:	b9401a62 	ldr	w2, [x19, #24]
    4000bddc:	121d7842 	and	w2, w2, #0xfffffffb
    4000bde0:	32000042 	orr	w2, w2, #0x1
    4000bde4:	b9001a62 	str	w2, [x19, #24]
    4000bde8:	d51b4237 	msr	daif, x23

		if (work != NULL) {
			bool yield;

			__ASSERT_NO_MSG(handler != NULL);
			handler(work);
    4000bdec:	aa1303e0 	mov	x0, x19
    4000bdf0:	d63f0020 	blr	x1
    4000bdf4:	d53b4239 	mrs	x25, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000bdf8:	d50342df 	msr	daifset, #0x2
	*flagp &= ~BIT(bit);
    4000bdfc:	b9401a61 	ldr	w1, [x19, #24]
    4000be00:	121f7820 	and	w0, w1, #0xfffffffe
			 * starving other threads.
			 */
			key = k_spin_lock(&lock);

			flag_clear(&work->flags, K_WORK_RUNNING_BIT);
			if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    4000be04:	37080161 	tbnz	w1, #1, 4000be30 <work_queue_main+0xf4>
	*flagp &= ~BIT(bit);
    4000be08:	b9001a60 	str	w0, [x19, #24]
    4000be0c:	1400000d 	b	4000be40 <work_queue_main+0x104>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
    4000be10:	910e4293 	add	x19, x20, #0x390
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
    4000be14:	aa1303e0 	mov	x0, x19
    4000be18:	d2800002 	mov	x2, #0x0                   	// #0
    4000be1c:	52800021 	mov	w1, #0x1                   	// #1
    4000be20:	97fffc4e 	bl	4000af58 <z_sched_wake>
    4000be24:	72001c1f 	tst	w0, #0xff
    4000be28:	54ffff61 	b.ne	4000be14 <work_queue_main+0xd8>  // b.any
    4000be2c:	17ffffd9 	b	4000bd90 <work_queue_main+0x54>
	return list->head;
    4000be30:	f94002a0 	ldr	x0, [x21]
	*flagp &= ~BIT(bit);
    4000be34:	121e7421 	and	w1, w1, #0xfffffffc
    4000be38:	b9001a61 	str	w1, [x19, #24]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    4000be3c:	b5000120 	cbnz	x0, 4000be60 <work_queue_main+0x124>
	*flagp &= ~BIT(bit);
    4000be40:	b943a280 	ldr	w0, [x20, #928]
MAKE_REG_HELPER(daif)
    4000be44:	92407f39 	and	x25, x25, #0xffffffff
    4000be48:	121e7800 	and	w0, w0, #0xfffffffd
    4000be4c:	b903a280 	str	w0, [x20, #928]
    4000be50:	d51b4239 	msr	daif, x25
			k_spin_unlock(&lock, key);

			/* Optionally yield to prevent the work queue from
			 * starving other threads.
			 */
			if (yield) {
    4000be54:	3747f8a0 	tbnz	w0, #8, 4000bd68 <work_queue_main+0x2c>
	z_impl_k_yield();
    4000be58:	97fffbc0 	bl	4000ad58 <z_impl_k_yield>
}
    4000be5c:	17ffffc3 	b	4000bd68 <work_queue_main+0x2c>
	return node->next;
    4000be60:	f9400018 	ldr	x24, [x0]
    4000be64:	d2800017 	mov	x23, #0x0                   	// #0
		if (wc->work == work) {
    4000be68:	f9400402 	ldr	x2, [x0, #8]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
    4000be6c:	aa0003e1 	mov	x1, x0
		if (wc->work == work) {
    4000be70:	eb02027f 	cmp	x19, x2
    4000be74:	54000161 	b.ne	4000bea0 <work_queue_main+0x164>  // b.any
    4000be78:	f9400001 	ldr	x1, [x0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
    4000be7c:	b50001d7 	cbnz	x23, 4000beb4 <work_queue_main+0x178>
    4000be80:	f94006a2 	ldr	x2, [x21, #8]
	list->head = node;
    4000be84:	f90002a1 	str	x1, [x21]
Z_GENLIST_REMOVE(slist, snode)
    4000be88:	eb02001f 	cmp	x0, x2
    4000be8c:	54000041 	b.ne	4000be94 <work_queue_main+0x158>  // b.any
	list->tail = node;
    4000be90:	f90006a1 	str	x1, [x21, #8]
	parent->next = child;
    4000be94:	f801041f 	str	xzr, [x0], #16
	z_impl_k_sem_give(sem);
    4000be98:	97fff93a 	bl	4000a380 <z_impl_k_sem_give>
}
    4000be9c:	aa1703e1 	mov	x1, x23
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    4000bea0:	b4fffd18 	cbz	x24, 4000be40 <work_queue_main+0x104>
	return node->next;
    4000bea4:	aa1803e0 	mov	x0, x24
    4000bea8:	aa0103f7 	mov	x23, x1
    4000beac:	f9400318 	ldr	x24, [x24]
    4000beb0:	17ffffee 	b	4000be68 <work_queue_main+0x12c>
	return list->tail;
    4000beb4:	f94006a2 	ldr	x2, [x21, #8]
	parent->next = child;
    4000beb8:	f90002e1 	str	x1, [x23]
Z_GENLIST_REMOVE(slist, snode)
    4000bebc:	eb00005f 	cmp	x2, x0
    4000bec0:	54fffea1 	b.ne	4000be94 <work_queue_main+0x158>  // b.any
	list->tail = node;
    4000bec4:	f90006b7 	str	x23, [x21, #8]
}
    4000bec8:	17fffff3 	b	4000be94 <work_queue_main+0x158>

000000004000becc <submit_to_queue_locked>:
{
    4000becc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000bed0:	910003fd 	mov	x29, sp
    4000bed4:	a90153f3 	stp	x19, x20, [sp, #16]
    4000bed8:	aa0003f3 	mov	x19, x0
	return (*flagp & BIT(bit)) != 0U;
    4000bedc:	b9401800 	ldr	w0, [x0, #24]
{
    4000bee0:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000bee4:	aa0103f4 	mov	x20, x1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    4000bee8:	37080700 	tbnz	w0, #1, 4000bfc8 <submit_to_queue_locked+0xfc>
    4000beec:	2a0003e1 	mov	w1, w0
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
    4000bef0:	721e003f 	tst	w1, #0x4
    4000bef4:	54000701 	b.ne	4000bfd4 <submit_to_queue_locked+0x108>  // b.any
		if (*queuep == NULL) {
    4000bef8:	f9400281 	ldr	x1, [x20]
    4000befc:	b5000061 	cbnz	x1, 4000bf08 <submit_to_queue_locked+0x3c>
			*queuep = work->queue;
    4000bf00:	f9400a61 	ldr	x1, [x19, #16]
    4000bf04:	f9000281 	str	x1, [x20]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
    4000bf08:	36000520 	tbz	w0, #0, 4000bfac <submit_to_queue_locked+0xe0>
			*queuep = work->queue;
    4000bf0c:	f9400a60 	ldr	x0, [x19, #16]
			ret = 2;
    4000bf10:	52800055 	mov	w21, #0x2                   	// #2
			*queuep = work->queue;
    4000bf14:	f9000280 	str	x0, [x20]
		int rc = queue_submit_locked(*queuep, work);
    4000bf18:	f9400296 	ldr	x22, [x20]
	if (queue == NULL) {
    4000bf1c:	b4000616 	cbz	x22, 4000bfdc <submit_to_queue_locked+0x110>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    4000bf20:	f0000060 	adrp	x0, 4001a000 <shell_uart_ctx+0x1c8>
    4000bf24:	f9413000 	ldr	x0, [x0, #608]
    4000bf28:	eb16001f 	cmp	x0, x22
    4000bf2c:	54000441 	b.ne	4000bfb4 <submit_to_queue_locked+0xe8>  // b.any
    4000bf30:	97fff77e 	bl	40009d28 <k_is_in_isr>
    4000bf34:	12001c00 	and	w0, w0, #0xff
    4000bf38:	52000000 	eor	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
    4000bf3c:	b943a2c2 	ldr	w2, [x22, #928]
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    4000bf40:	12000000 	and	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
    4000bf44:	d3420841 	ubfx	x1, x2, #2, #1
    4000bf48:	d3430c43 	ubfx	x3, x2, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
    4000bf4c:	360004c2 	tbz	w2, #0, 4000bfe4 <submit_to_queue_locked+0x118>
	} else if (draining && !chained) {
    4000bf50:	52000000 	eor	w0, w0, #0x1
    4000bf54:	6a00003f 	tst	w1, w0
    4000bf58:	54000381 	b.ne	4000bfc8 <submit_to_queue_locked+0xfc>  // b.any
	} else if (plugged && !draining) {
    4000bf5c:	52000021 	eor	w1, w1, #0x1
    4000bf60:	6a01007f 	tst	w3, w1
    4000bf64:	54000321 	b.ne	4000bfc8 <submit_to_queue_locked+0xfc>  // b.any
	return list->tail;
    4000bf68:	f941bec1 	ldr	x1, [x22, #888]
	parent->next = child;
    4000bf6c:	f900027f 	str	xzr, [x19]
	return list->tail;
    4000bf70:	911002c0 	add	x0, x22, #0x400
Z_GENLIST_APPEND(slist, snode)
    4000bf74:	b5000241 	cbnz	x1, 4000bfbc <submit_to_queue_locked+0xf0>
	list->tail = node;
    4000bf78:	a9374c13 	stp	x19, x19, [x0, #-144]
		(void)notify_queue_locked(queue);
    4000bf7c:	aa1603e0 	mov	x0, x22
    4000bf80:	97ffff69 	bl	4000bd24 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
    4000bf84:	b9401a60 	ldr	w0, [x19, #24]
    4000bf88:	321e0000 	orr	w0, w0, #0x4
    4000bf8c:	b9001a60 	str	w0, [x19, #24]
			work->queue = *queuep;
    4000bf90:	f9400280 	ldr	x0, [x20]
    4000bf94:	f9000a60 	str	x0, [x19, #16]
}
    4000bf98:	2a1503e0 	mov	w0, w21
    4000bf9c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000bfa0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000bfa4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000bfa8:	d65f03c0 	ret
		ret = 1;
    4000bfac:	52800035 	mov	w21, #0x1                   	// #1
    4000bfb0:	17ffffda 	b	4000bf18 <submit_to_queue_locked+0x4c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    4000bfb4:	52800000 	mov	w0, #0x0                   	// #0
    4000bfb8:	17ffffe1 	b	4000bf3c <submit_to_queue_locked+0x70>
	parent->next = child;
    4000bfbc:	f9000033 	str	x19, [x1]
	list->tail = node;
    4000bfc0:	f8178013 	stur	x19, [x0, #-136]
}
    4000bfc4:	17ffffee 	b	4000bf7c <submit_to_queue_locked+0xb0>
		ret = -EBUSY;
    4000bfc8:	128001f5 	mov	w21, #0xfffffff0            	// #-16
		*queuep = NULL;
    4000bfcc:	f900029f 	str	xzr, [x20]
	return ret;
    4000bfd0:	17fffff2 	b	4000bf98 <submit_to_queue_locked+0xcc>
	int ret = 0;
    4000bfd4:	52800015 	mov	w21, #0x0                   	// #0
    4000bfd8:	17fffffd 	b	4000bfcc <submit_to_queue_locked+0x100>
		return -EINVAL;
    4000bfdc:	128002b5 	mov	w21, #0xffffffea            	// #-22
    4000bfe0:	17fffffb 	b	4000bfcc <submit_to_queue_locked+0x100>
		ret = -ENODEV;
    4000bfe4:	12800255 	mov	w21, #0xffffffed            	// #-19
    4000bfe8:	17fffff9 	b	4000bfcc <submit_to_queue_locked+0x100>

000000004000bfec <k_work_submit_to_queue>:
{
    4000bfec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000bff0:	910003fd 	mov	x29, sp
    4000bff4:	a90153f3 	stp	x19, x20, [sp, #16]
    4000bff8:	f90017e0 	str	x0, [sp, #40]
    4000bffc:	aa0103e0 	mov	x0, x1
    4000c000:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000c004:	d50342df 	msr	daifset, #0x2
	int ret = submit_to_queue_locked(work, &queue);
    4000c008:	9100a3e1 	add	x1, sp, #0x28
MAKE_REG_HELPER(daif)
    4000c00c:	92407e94 	and	x20, x20, #0xffffffff
    4000c010:	97ffffaf 	bl	4000becc <submit_to_queue_locked>
    4000c014:	2a0003f3 	mov	w19, w0
    4000c018:	d51b4234 	msr	daif, x20
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
    4000c01c:	7100001f 	cmp	w0, #0x0
    4000c020:	5400008d 	b.le	4000c030 <k_work_submit_to_queue+0x44>
	return z_impl_k_is_preempt_thread();
    4000c024:	97fffb83 	bl	4000ae30 <z_impl_k_is_preempt_thread>
    4000c028:	34000040 	cbz	w0, 4000c030 <k_work_submit_to_queue+0x44>
	z_impl_k_yield();
    4000c02c:	97fffb4b 	bl	4000ad58 <z_impl_k_yield>
}
    4000c030:	2a1303e0 	mov	w0, w19
    4000c034:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000c038:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000c03c:	d65f03c0 	ret

000000004000c040 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
    4000c040:	d100c3ff 	sub	sp, sp, #0x30
    4000c044:	2a0303e7 	mov	w7, w3
	sys_dlist_init(&w->waitq);
    4000c048:	910e0003 	add	x3, x0, #0x380
    4000c04c:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000c050:	910043fd 	add	x29, sp, #0x10
    4000c054:	a90253f3 	stp	x19, x20, [sp, #32]
    4000c058:	aa0003f3 	mov	x19, x0
	list->tail = (sys_dnode_t *)list;
    4000c05c:	910dc000 	add	x0, x0, #0x370
    4000c060:	aa0403f4 	mov	x20, x4
    4000c064:	a9007c1f 	stp	xzr, xzr, [x0]
    4000c068:	a9010c03 	stp	x3, x3, [x0, #16]
    4000c06c:	910e4263 	add	x3, x19, #0x390
	list->head = (sys_dnode_t *)list;
    4000c070:	f901ca63 	str	x3, [x19, #912]
	list->tail = (sys_dnode_t *)list;
    4000c074:	f901ce63 	str	x3, [x19, #920]

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
    4000c078:	b4000344 	cbz	x4, 4000c0e0 <k_work_queue_start+0xa0>
    4000c07c:	39402080 	ldrb	w0, [x4, #8]
		flags |= K_WORK_QUEUE_NO_YIELD;
    4000c080:	7100001f 	cmp	w0, #0x0
    4000c084:	52802020 	mov	w0, #0x101                 	// #257
    4000c088:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
	*flagp = flags;
    4000c08c:	b903a260 	str	w0, [x19, #928]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    4000c090:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4000c094:	b90003ff 	str	wzr, [sp]
    4000c098:	f90007e0 	str	x0, [sp, #8]
    4000c09c:	f0ffffe3 	adrp	x3, 4000b000 <elapsed+0x14>
    4000c0a0:	9134f063 	add	x3, x3, #0xd3c
    4000c0a4:	aa1303e4 	mov	x4, x19
    4000c0a8:	aa1303e0 	mov	x0, x19
    4000c0ac:	d2800006 	mov	x6, #0x0                   	// #0
    4000c0b0:	d2800005 	mov	x5, #0x0                   	// #0
    4000c0b4:	97fff7bc 	bl	40009fa4 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
    4000c0b8:	b40000b4 	cbz	x20, 4000c0cc <k_work_queue_start+0x8c>
    4000c0bc:	f9400281 	ldr	x1, [x20]
    4000c0c0:	b4000061 	cbz	x1, 4000c0cc <k_work_queue_start+0x8c>
	return z_impl_k_thread_name_set(thread, str);
    4000c0c4:	aa1303e0 	mov	x0, x19
    4000c0c8:	97fff732 	bl	40009d90 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
    4000c0cc:	aa1303e0 	mov	x0, x19
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
    4000c0d0:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000c0d4:	a94253f3 	ldp	x19, x20, [sp, #32]
    4000c0d8:	9100c3ff 	add	sp, sp, #0x30
    4000c0dc:	17fff769 	b	40009e80 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
    4000c0e0:	52800020 	mov	w0, #0x1                   	// #1
    4000c0e4:	17ffffea 	b	4000c08c <k_work_queue_start+0x4c>
	...
