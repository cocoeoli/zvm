
zephyr.elf:     file format elf64-littleaarch64


Disassembly of section text:

0000000040000000 <__text_region_start>:
#define HEADER_FLAGS	(HEADER_PGSIZE << 1)

_ASM_FILE_PROLOGUE

SECTION_SUBSEC_FUNC(image_header,_image_header_section,_image_header)
	b	__start				// branch to kernel start
    40000000:	14000431 	b	400010c4 <__reset>
	...
    40000010:	4006fae0 	.word	0x4006fae0
    40000014:	00000000 	.word	0x00000000
    40000018:	00000002 	.word	0x00000002
	...
    40000038:	644d5241 	.word	0x644d5241
    4000003c:	00000000 	.word	0x00000000

0000000040000040 <_vector_start>:
	...

0000000040000800 <_vector_table>:
	/* The whole table must be 2K aligned */
	.align 11

	/* Current EL with SP0 / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000800:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000810:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000820:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000830:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000840:	927ff800 8b010000 d51bd060 9400298b     ........`....)..
	b	z_arm64_sync_exc
    40000850:	14002942 d503201f d503201f d503201f     B)... ... ... ..
    40000860:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000870:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SP0 / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000880:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000890:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    400008a0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    400008b0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    400008c0:	927ff800 8b010000 d51bd060 9400296b     ........`...k)..
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    400008d0:	1400021e d503201f d503201f d503201f     ..... ... ... ..
    400008e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    400008f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Current EL with SP0 / FIQ */
	.align 7
	b 	.
    40000900:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000910:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000920:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000930:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000940:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000950:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000960:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000970:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SP0 / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000980:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000990:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    400009a0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    400009b0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    400009c0:	927ff800 8b010000 d51bd060 9400292b     ........`...+)..
	b	z_arm64_serror
    400009d0:	1400290f d503201f d503201f d503201f     .)... ... ... ..
    400009e0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    400009f0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000a00:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000a10:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000a20:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000a30:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000a40:	927ff800 8b010000 d51bd060 9400290b     ........`....)..
	b	z_arm64_sync_exc
    40000a50:	140028c2 d503201f d503201f d503201f     .(... ... ... ..
    40000a60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000a70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000a80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000a90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000aa0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000ab0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000ac0:	927ff800 8b010000 d51bd060 940028eb     ........`....(..
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    40000ad0:	1400019e d503201f d503201f d503201f     ..... ... ... ..
    40000ae0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000af0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Current EL with SPx / FIQ */
	.align 7
	b	.
    40000b00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000b10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000b70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Current EL with SPx / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000b80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000b90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000ba0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000bb0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000bc0:	927ff800 8b010000 d51bd060 940028ab     ........`....(..
	b	z_arm64_serror
    40000bd0:	1400288f d503201f d503201f d503201f     .(... ... ... ..
    40000be0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000bf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / Synchronous */
	.align 7
	z_arm64_enter_exc x0, x1
    40000c00:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000c10:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000c20:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000c30:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000c40:	927ff800 8b010000 d51bd060 9400288b     ........`....(..
	b	z_arm64_sync_exc
    40000c50:	14002842 d503201f d503201f d503201f     B(... ... ... ..
    40000c60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000c70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / IRQ */
	.align 7
	z_arm64_enter_exc x0, x1
    40000c80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000c90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000ca0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000cb0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000cc0:	927ff800 8b010000 d51bd060 9400286b     ........`...k(..
#ifdef CONFIG_GEN_SW_ISR_TABLE
	b 	_isr_wrapper
    40000cd0:	1400011e d503201f d503201f d503201f     ..... ... ... ..
    40000ce0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000cf0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
	b	z_irq_spurious
#endif

	/* Lower EL using AArch64 / FIQ */
	.align 7
	b	.
    40000d00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000d10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000d70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch64 / SError */
	.align 7
	z_arm64_enter_exc x0, x1
    40000d80:	d102c3ff a90007e0 a9010fe2 a90217e4     ................
    40000d90:	a9031fe6 a90427e8 a9052fea a90637ec     .....'.../...7..
    40000da0:	a9073fee a90847f0 a9097bf2 d5384000     .?...G...{...@8.
    40000db0:	d5384021 a90a07e0 d53bd060 d2e02001     !@8.....`.;.. ..
    40000dc0:	927ff800 8b010000 d51bd060 9400282b     ........`...+(..
	b	z_arm64_serror
    40000dd0:	1400280f d503201f d503201f d503201f     .(... ... ... ..
    40000de0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000df0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / Synchronous */
	.align 7
	b	.
    40000e00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000e10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000e70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / IRQ */
	.align 7
	b	.
    40000e80:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000e90:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ea0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000eb0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ec0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ed0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ee0:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000ef0:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / FIQ */
	.align 7
	b	.
    40000f00:	14000000 d503201f d503201f d503201f     ..... ... ... ..
    40000f10:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f20:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f30:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f40:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f50:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f60:	d503201f d503201f d503201f d503201f     . ... ... ... ..
    40000f70:	d503201f d503201f d503201f d503201f     . ... ... ... ..

	/* Lower EL using AArch32 / SError */
	.align 7
	b	.
    40000f80:	14000000                                ....

0000000040000f84 <_vector_end>:
	...

0000000040000f90 <__aarch64_swp8_acq_rel>:
    40000f90:	d503245f 	bti	c
    40000f94:	f00000b0 	adrp	x16, 40017000 <__aarch64_have_lse_atomics>
    40000f98:	39400210 	ldrb	w16, [x16]
    40000f9c:	34000070 	cbz	w16, 40000fa8 <__aarch64_swp8_acq_rel+0x18>
    40000fa0:	f8e08020 	swpal	x0, x0, [x1]
    40000fa4:	d65f03c0 	ret
    40000fa8:	aa0003f0 	mov	x16, x0
    40000fac:	c85ffc20 	ldaxr	x0, [x1]
    40000fb0:	c811fc30 	stlxr	w17, x16, [x1]
    40000fb4:	35ffffd1 	cbnz	w17, 40000fac <__aarch64_swp8_acq_rel+0x1c>
    40000fb8:	d65f03c0 	ret
    40000fbc:	00000000 	udf	#0

0000000040000fc0 <__aarch64_ldadd8_acq_rel>:
    40000fc0:	d503245f 	bti	c
    40000fc4:	f00000b0 	adrp	x16, 40017000 <__aarch64_have_lse_atomics>
    40000fc8:	39400210 	ldrb	w16, [x16]
    40000fcc:	34000070 	cbz	w16, 40000fd8 <__aarch64_ldadd8_acq_rel+0x18>
    40000fd0:	f8e00020 	ldaddal	x0, x0, [x1]
    40000fd4:	d65f03c0 	ret
    40000fd8:	aa0003f0 	mov	x16, x0
    40000fdc:	c85ffc20 	ldaxr	x0, [x1]
    40000fe0:	8b100011 	add	x17, x0, x16
    40000fe4:	c80ffc31 	stlxr	w15, x17, [x1]
    40000fe8:	35ffffaf 	cbnz	w15, 40000fdc <__aarch64_ldadd8_acq_rel+0x1c>
    40000fec:	d65f03c0 	ret

0000000040000ff0 <__aarch64_ldclr8_acq_rel>:
    40000ff0:	d503245f 	bti	c
    40000ff4:	f00000b0 	adrp	x16, 40017000 <__aarch64_have_lse_atomics>
    40000ff8:	39400210 	ldrb	w16, [x16]
    40000ffc:	34000070 	cbz	w16, 40001008 <__aarch64_ldclr8_acq_rel+0x18>
    40001000:	f8e01020 	ldclral	x0, x0, [x1]
    40001004:	d65f03c0 	ret
    40001008:	aa0003f0 	mov	x16, x0
    4000100c:	c85ffc20 	ldaxr	x0, [x1]
    40001010:	8a300011 	bic	x17, x0, x16
    40001014:	c80ffc31 	stlxr	w15, x17, [x1]
    40001018:	35ffffaf 	cbnz	w15, 4000100c <__aarch64_ldclr8_acq_rel+0x1c>
    4000101c:	d65f03c0 	ret

0000000040001020 <__aarch64_ldset8_acq_rel>:
    40001020:	d503245f 	bti	c
    40001024:	d00000b0 	adrp	x16, 40017000 <__aarch64_have_lse_atomics>
    40001028:	39400210 	ldrb	w16, [x16]
    4000102c:	34000070 	cbz	w16, 40001038 <__aarch64_ldset8_acq_rel+0x18>
    40001030:	f8e03020 	ldsetal	x0, x0, [x1]
    40001034:	d65f03c0 	ret
    40001038:	aa0003f0 	mov	x16, x0
    4000103c:	c85ffc20 	ldaxr	x0, [x1]
    40001040:	aa100011 	orr	x17, x0, x16
    40001044:	c80ffc31 	stlxr	w15, x17, [x1]
    40001048:	35ffffaf 	cbnz	w15, 4000103c <__aarch64_ldset8_acq_rel+0x1c>
    4000104c:	d65f03c0 	ret

0000000040001050 <__reset_prep_c>:
 */

GTEXT(__reset_prep_c)
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__reset_prep_c)
	/* return address: x23 */
	mov	x23, x30
    40001050:	aa1e03f7 	mov	x23, x30

	switch_el x0, 3f, 2f, 1f
    40001054:	d5384240 	mrs	x0, currentel
    40001058:	f100301f 	cmp	x0, #0xc
    4000105c:	540000a0 	b.eq	40001070 <__reset_prep_c+0x20>  // b.none
    40001060:	f100201f 	cmp	x0, #0x8
    40001064:	54000100 	b.eq	40001084 <__reset_prep_c+0x34>  // b.none
    40001068:	f100101f 	cmp	x0, #0x4
    4000106c:	54000180 	b.eq	4000109c <__reset_prep_c+0x4c>  // b.none
3:
	/* Reinitialize SCTLR from scratch in EL3 */
	ldr	w0, =(SCTLR_EL3_RES1 | SCTLR_I_BIT | SCTLR_SA_BIT)
    40001070:	18000600 	ldr	w0, 40001130 <switch_el+0x58>
	msr	sctlr_el3, x0
    40001074:	d51e1000 	msr	sctlr_el3, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el3_plat_prep_c
    40001078:	940026b5 	bl	4000ab4c <z_arm64_el3_plat_prep_c>

	/* Set SP_EL1 */
	msr     sp_el1, x24
    4000107c:	d51c4118 	msr	sp_el1, x24

	b	out
    40001080:	1400000d 	b	400010b4 <out>
2:
	/* Disable alignment fault checking */
	mrs	x0, sctlr_el2
    40001084:	d53c1000 	mrs	x0, sctlr_el2
	bic	x0, x0, SCTLR_A_BIT
    40001088:	927ef800 	and	x0, x0, #0xfffffffffffffffd
	msr	sctlr_el2, x0
    4000108c:	d51c1000 	msr	sctlr_el2, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el2_plat_prep_c
    40001090:	940026b0 	bl	4000ab50 <z_arm64_el2_plat_prep_c>

	/* Set SP_EL1 */
	msr     sp_el1, x24
    40001094:	d51c4118 	msr	sp_el1, x24

	b	out
    40001098:	14000007 	b	400010b4 <out>
1:
	/* Disable alignment fault checking */
	mrs	x0, sctlr_el1
    4000109c:	d5381000 	mrs	x0, sctlr_el1
	bic	x0, x0, SCTLR_A_BIT
    400010a0:	927ef800 	and	x0, x0, #0xfffffffffffffffd
	msr	sctlr_el1, x0
    400010a4:	d5181000 	msr	sctlr_el1, x0

	/* Custom plat prep_c init */
	bl	z_arm64_el1_plat_prep_c
    400010a8:	940026ab 	bl	4000ab54 <z_arm64_el1_plat_prep_c>

	/* Set SP_EL1. We cannot use sp_el1 at EL1 */
	msr     SPSel, #1
    400010ac:	d50041bf 	msr	spsel, #0x1
	mov     sp, x24
    400010b0:	9100031f 	mov	sp, x24

00000000400010b4 <out>:
out:
	isb
    400010b4:	d5033fdf 	isb

	/* Select SP_EL0 */
	msr	SPSel, #0
    400010b8:	d50040bf 	msr	spsel, #0x0

	/* Initialize stack */
	mov	sp, x24
    400010bc:	9100031f 	mov	sp, x24

	ret	x23
    400010c0:	d65f02e0 	ret	x23

00000000400010c4 <__reset>:
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__reset)

GTEXT(__start)
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)
	/* Mask all exceptions */
	msr	DAIFSet, #0xf
    400010c4:	d5034fdf 	msr	daifset, #0xf
primary_core:
	/* advertise ourself */
	str	x1, [x0, #BOOT_PARAM_MPID_OFFSET]
#endif
	/* load primary stack and entry point */
	ldr	x24, =(z_interrupt_stacks + CONFIG_ISR_STACK_SIZE)
    400010c8:	58000398 	ldr	x24, 40001138 <switch_el+0x60>
	ldr	x25, =z_arm64_prep_c
    400010cc:	580003b9 	ldr	x25, 40001140 <switch_el+0x68>
2:
	/* Prepare for calling C code */
	bl	__reset_prep_c
    400010d0:	97ffffe0 	bl	40001050 <__reset_prep_c>

	/* Platform hook for highest EL */
	bl	z_arm64_el_highest_init
    400010d4:	940026ae 	bl	4000ab8c <z_arm64_el_highest_init>

00000000400010d8 <switch_el>:

switch_el:
	switch_el x0, 3f, 2f, 1f
    400010d8:	d5384240 	mrs	x0, currentel
    400010dc:	f100301f 	cmp	x0, #0xc
    400010e0:	540000a0 	b.eq	400010f4 <switch_el+0x1c>  // b.none
    400010e4:	f100201f 	cmp	x0, #0x8
    400010e8:	540000e0 	b.eq	40001104 <switch_el+0x2c>  // b.none
    400010ec:	f100101f 	cmp	x0, #0x4
    400010f0:	54000180 	b.eq	40001120 <switch_el+0x48>  // b.none
3:
	/* EL3 init */
	bl	z_arm64_el3_init
    400010f4:	940026cb 	bl	4000ac20 <z_arm64_el3_init>

	/* Get next EL */
	adr	x0, switch_el
    400010f8:	10ffff00 	adr	x0, 400010d8 <switch_el>
	bl	z_arm64_el3_get_next_el
    400010fc:	940026f2 	bl	4000acc4 <z_arm64_el3_get_next_el>
	eret
    40001100:	d69f03e0 	eret

2:
	/* EL2 init */
	bl	z_arm64_el2_init
    40001104:	940026b4 	bl	4000abd4 <z_arm64_el2_init>

	/* Move to EL1 with all exceptions masked */
	mov_imm	x0, (SPSR_DAIF_MASK | SPSR_MODE_EL1T)
    40001108:	d2a00000 	movz	x0, #0x0, lsl #16
    4000110c:	f2807880 	movk	x0, #0x3c4
	msr	spsr_el2, x0
    40001110:	d51c4000 	msr	spsr_el2, x0

	adr	x0, 1f
    40001114:	10000060 	adr	x0, 40001120 <switch_el+0x48>
	msr	elr_el2, x0
    40001118:	d51c4020 	msr	elr_el2, x0
	eret
    4000111c:	d69f03e0 	eret

1:
	/* EL1 init */
	bl	z_arm64_el1_init
    40001120:	940026d6 	bl	4000ac78 <z_arm64_el1_init>

	/* Enable SError interrupts */
	msr	DAIFClr, #(DAIFCLR_ABT_BIT)
    40001124:	d50344ff 	msr	daifclr, #0x4
	isb
    40001128:	d5033fdf 	isb

	ret	x25  /* either z_arm64_prep_c or z_arm64_secondary_prep_c */
    4000112c:	d65f0320 	ret	x25
    40001130:	30c51838 	.word	0x30c51838
    40001134:	00000000 	udf	#0
    40001138:	4006e0e0 	.word	0x4006e0e0
    4000113c:	00000000 	.word	0x00000000
    40001140:	4000ab08 	.word	0x4000ab08
    40001144:	00000000 	.word	0x00000000

0000000040001148 <_isr_wrapper>:

GTEXT(_isr_wrapper)
SECTION_FUNC(TEXT, _isr_wrapper)

	/* ++(_kernel->nested) to be checked by arch_is_in_isr() */
	inc_nest_counter x0, x1
    40001148:	d53bd060 	mrs	x0, tpidrro_el0
    4000114c:	927db000 	and	x0, x0, #0xfffffffffff8
    40001150:	f9400001 	ldr	x1, [x0]
    40001154:	91000421 	add	x1, x1, #0x1
    40001158:	f9000001 	str	x1, [x0]
	bl	sys_trace_isr_enter
#endif

	/* Get active IRQ number from the interrupt controller */
#if !defined(CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER)
	bl	arm_gic_get_active
    4000115c:	94003260 	bl	4000dadc <arm_gic_get_active>
#if CONFIG_GIC_VER >= 3
	/*
	 * Ignore Special INTIDs 1020..1023 see 2.2.1 of Arm Generic Interrupt Controller
	 * Architecture Specification GIC architecture version 3 and version 4
	 */
	cmp	x0, 1019
    40001160:	f10fec1f 	cmp	x0, #0x3fb
	b.le	oob
    40001164:	5400008d 	b.le	40001174 <oob>
	cmp	x0, 1023
    40001168:	f10ffc1f 	cmp	x0, #0x3ff
	b.gt	oob
    4000116c:	5400004c 	b.gt	40001174 <oob>
	b	spurious_continue
    40001170:	1400000c 	b	400011a0 <spurious_continue>

0000000040001174 <oob>:

oob:
#endif
	/* IRQ out of bounds */
	mov	x1, #(CONFIG_NUM_IRQS - 1)
    40001174:	d2801b61 	mov	x1, #0xdb                  	// #219
	cmp	x0, x1
    40001178:	eb01001f 	cmp	x0, x1
	b.hi	spurious_continue
    4000117c:	54000128 	b.hi	400011a0 <spurious_continue>  // b.pmore

	stp	x0, xzr, [sp, #-16]!
    40001180:	a9bf7fe0 	stp	x0, xzr, [sp, #-16]!

	/* Retrieve the interrupt service routine */
	ldr	x1, =_sw_isr_table
    40001184:	580002e1 	ldr	x1, 400011e0 <exit+0x8>
	add	x1, x1, x0, lsl #4	/* table is 16-byte wide */
    40001188:	8b001021 	add	x1, x1, x0, lsl #4
	ldp	x0, x3, [x1] /* arg in x0, ISR in x3 */
    4000118c:	a9400c20 	ldp	x0, x3, [x1]

	/*
	 * Call the ISR. Unmask and mask again the IRQs to support nested
	 * exception handlers
	 */
	msr	daifclr, #(DAIFCLR_IRQ_BIT)
    40001190:	d50342ff 	msr	daifclr, #0x2
	blr	x3
    40001194:	d63f0060 	blr	x3
	msr	daifset, #(DAIFSET_IRQ_BIT)
    40001198:	d50342df 	msr	daifset, #0x2

	/* Signal end-of-interrupt */
	ldp	x0, xzr, [sp], #16
    4000119c:	a8c17fe0 	ldp	x0, xzr, [sp], #16

00000000400011a0 <spurious_continue>:

spurious_continue:
#if !defined(CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER)
	bl	arm_gic_eoi
    400011a0:	94003251 	bl	4000dae4 <arm_gic_eoi>
#ifdef CONFIG_TRACING
	bl	sys_trace_isr_exit
#endif

	/* if (--(_kernel->nested) != 0) exit */
	dec_nest_counter x0, x1
    400011a4:	d53bd060 	mrs	x0, tpidrro_el0
    400011a8:	927db000 	and	x0, x0, #0xfffffffffff8
    400011ac:	f9400001 	ldr	x1, [x0]
    400011b0:	f1000421 	subs	x1, x1, #0x1
    400011b4:	f9000001 	str	x1, [x0]

	bne	exit
    400011b8:	54000101 	b.ne	400011d8 <exit>  // b.any
	 * - The next thread to schedule in x0
	 * - The current thread in x1. This value is returned using the
	 *   **old_thread parameter, so we need to make space on the stack for
	 *   that.
	 */
	sub	sp, sp, #16
    400011bc:	d10043ff 	sub	sp, sp, #0x10
	mov	x0, sp
    400011c0:	910003e0 	mov	x0, sp
	bl	z_arch_get_next_switch_handle
    400011c4:	9400270d 	bl	4000adf8 <z_arch_get_next_switch_handle>
	ldp	x1, xzr, [sp], #16
    400011c8:	a8c17fe1 	ldp	x1, xzr, [sp], #16

	/*
	 * x0: 1st thread in the ready queue
	 * x1: _current thread
	 */
	cmp	x0, x1
    400011cc:	eb01001f 	cmp	x0, x1
	beq	exit
    400011d0:	54000040 	b.eq	400011d8 <exit>  // b.none

	/* Switch thread */
	bl	z_arm64_context_switch
    400011d4:	940026c7 	bl	4000acf0 <z_arm64_context_switch>

00000000400011d8 <exit>:

exit:
#ifdef CONFIG_STACK_SENTINEL
	bl	z_check_stack_sentinel
#endif
	b	z_arm64_exit_exc
    400011d8:	14002711 	b	4000ae1c <z_arm64_exit_exc>
    400011dc:	00000000 	udf	#0
    400011e0:	40012100 	.word	0x40012100
    400011e4:	00000000 	.word	0x00000000

00000000400011e8 <_OffsetAbsSyms>:
GEN_NAMED_OFFSET_SYM(arm_smccc_res_t, a4, a4_a5);
GEN_NAMED_OFFSET_SYM(arm_smccc_res_t, a6, a6_a7);

#endif /* CONFIG_HAS_ARM_SMCCC */

GEN_ABS_SYM_END
    400011e8:	d65f03c0 	ret

00000000400011ec <main>:
#include <logging/log.h>
LOG_MODULE_REGISTER(app);

void main(void)
{
}
    400011ec:	d65f03c0 	ret

00000000400011f0 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
    400011f0:	52800000 	mov	w0, #0x0                   	// #0
    400011f4:	d65f03c0 	ret

00000000400011f8 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    400011f8:	b9400022 	ldr	w2, [x1]
    400011fc:	11000442 	add	w2, w2, #0x1
    40001200:	b9000022 	str	w2, [x1]
	return _char_out(c);
    40001204:	d0000361 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
    40001208:	f9444421 	ldr	x1, [x1, #2184]
    4000120c:	aa0103f0 	mov	x16, x1
    40001210:	d61f0200 	br	x16

0000000040001214 <str_out>:
	int count;
};

static int str_out(int c, struct str_context *ctx)
{
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    40001214:	f9400024 	ldr	x4, [x1]
    40001218:	b9400c22 	ldr	w2, [x1, #12]
		ctx->count++;
		return c;
	}

	if (ctx->count == ctx->max - 1) {
		ctx->str[ctx->count++] = '\0';
    4000121c:	11000445 	add	w5, w2, #0x1
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    40001220:	b4000084 	cbz	x4, 40001230 <str_out+0x1c>
    40001224:	b9400823 	ldr	w3, [x1, #8]
    40001228:	6b02007f 	cmp	w3, w2
    4000122c:	5400006c 	b.gt	40001238 <str_out+0x24>
		ctx->count++;
    40001230:	b9000c25 	str	w5, [x1, #12]
	} else {
		ctx->str[ctx->count++] = c;
	}

	return c;
}
    40001234:	d65f03c0 	ret
		ctx->str[ctx->count++] = '\0';
    40001238:	b9000c25 	str	w5, [x1, #12]
	if (ctx->count == ctx->max - 1) {
    4000123c:	51000463 	sub	w3, w3, #0x1
		ctx->str[ctx->count++] = '\0';
    40001240:	93407c46 	sxtw	x6, w2
	if (ctx->count == ctx->max - 1) {
    40001244:	6b02007f 	cmp	w3, w2
    40001248:	54000061 	b.ne	40001254 <str_out+0x40>  // b.any
		ctx->str[ctx->count++] = '\0';
    4000124c:	3826689f 	strb	wzr, [x4, x6]
    40001250:	17fffff9 	b	40001234 <str_out+0x20>
		ctx->str[ctx->count++] = c;
    40001254:	38266880 	strb	w0, [x4, x6]
    40001258:	17fffff7 	b	40001234 <str_out+0x20>

000000004000125c <__printk_hook_install>:
	_char_out = fn;
    4000125c:	d0000361 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
    40001260:	f9044420 	str	x0, [x1, #2184]
}
    40001264:	d65f03c0 	ret

0000000040001268 <vprintk>:
{
    40001268:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000126c:	910003fd 	mov	x29, sp
	cbvprintf(char_out, &ctx, fmt, ap);
    40001270:	a9400c22 	ldp	x2, x3, [x1]
    40001274:	a9010fe2 	stp	x2, x3, [sp, #16]
    40001278:	a9410c22 	ldp	x2, x3, [x1, #16]
    4000127c:	9100e3e1 	add	x1, sp, #0x38
    40001280:	a9020fe2 	stp	x2, x3, [sp, #32]
    40001284:	910043e3 	add	x3, sp, #0x10
    40001288:	aa0003e2 	mov	x2, x0
    4000128c:	90000000 	adrp	x0, 40001000 <__aarch64_ldclr8_acq_rel+0x10>
    40001290:	9107e000 	add	x0, x0, #0x1f8
	struct out_context ctx = { 0 };
    40001294:	b9003bff 	str	wzr, [sp, #56]
	cbvprintf(char_out, &ctx, fmt, ap);
    40001298:	94000245 	bl	40001bac <cbvprintf>
}
    4000129c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400012a0:	d65f03c0 	ret

00000000400012a4 <printk>:
{
    400012a4:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
    400012a8:	910003fd 	mov	x29, sp
    400012ac:	a90d8be1 	stp	x1, x2, [sp, #216]
	va_start(ap, fmt);
    400012b0:	910443e1 	add	x1, sp, #0x110
    400012b4:	a90307e1 	stp	x1, x1, [sp, #48]
    400012b8:	910343e1 	add	x1, sp, #0xd0
    400012bc:	f90023e1 	str	x1, [sp, #64]
    400012c0:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    400012c4:	b9004be1 	str	w1, [sp, #72]
    400012c8:	12800fe1 	mov	w1, #0xffffff80            	// #-128
    400012cc:	b9004fe1 	str	w1, [sp, #76]
		vprintk(fmt, ap);
    400012d0:	910043e1 	add	x1, sp, #0x10
{
    400012d4:	a90e93e3 	stp	x3, x4, [sp, #232]
		vprintk(fmt, ap);
    400012d8:	a9430fe2 	ldp	x2, x3, [sp, #48]
    400012dc:	a9010fe2 	stp	x2, x3, [sp, #16]
    400012e0:	a9440fe2 	ldp	x2, x3, [sp, #64]
    400012e4:	a9020fe2 	stp	x2, x3, [sp, #32]
{
    400012e8:	3d8017e0 	str	q0, [sp, #80]
    400012ec:	3d801be1 	str	q1, [sp, #96]
    400012f0:	3d801fe2 	str	q2, [sp, #112]
    400012f4:	3d8023e3 	str	q3, [sp, #128]
    400012f8:	3d8027e4 	str	q4, [sp, #144]
    400012fc:	3d802be5 	str	q5, [sp, #160]
    40001300:	3d802fe6 	str	q6, [sp, #176]
    40001304:	3d8033e7 	str	q7, [sp, #192]
    40001308:	a90f9be5 	stp	x5, x6, [sp, #248]
    4000130c:	f90087e7 	str	x7, [sp, #264]
		vprintk(fmt, ap);
    40001310:	97ffffd6 	bl	40001268 <vprintk>
}
    40001314:	a8d17bfd 	ldp	x29, x30, [sp], #272
    40001318:	d65f03c0 	ret

000000004000131c <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    4000131c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40001320:	910003fd 	mov	x29, sp
    40001324:	f9000bf3 	str	x19, [sp, #16]
    40001328:	aa0003f3 	mov	x19, x0
	struct str_context ctx = { str, size, 0 };
    4000132c:	f90023e0 	str	x0, [sp, #64]
    40001330:	29097fe1 	stp	w1, wzr, [sp, #72]

	cbvprintf(str_out, &ctx, fmt, ap);
    40001334:	a9400460 	ldp	x0, x1, [x3]
    40001338:	a90207e0 	stp	x0, x1, [sp, #32]
    4000133c:	a9410460 	ldp	x0, x1, [x3, #16]
    40001340:	910083e3 	add	x3, sp, #0x20
    40001344:	a90307e0 	stp	x0, x1, [sp, #48]
    40001348:	910103e1 	add	x1, sp, #0x40
    4000134c:	90000000 	adrp	x0, 40001000 <__aarch64_ldclr8_acq_rel+0x10>
    40001350:	91085000 	add	x0, x0, #0x214
    40001354:	94000216 	bl	40001bac <cbvprintf>

	if (ctx.count < ctx.max) {
    40001358:	294903e1 	ldp	w1, w0, [sp, #72]
    4000135c:	6b01001f 	cmp	w0, w1
    40001360:	5400004a 	b.ge	40001368 <vsnprintk+0x4c>  // b.tcont
		str[ctx.count] = '\0';
    40001364:	3820ca7f 	strb	wzr, [x19, w0, sxtw]
	}

	return ctx.count;
}
    40001368:	f9400bf3 	ldr	x19, [sp, #16]
    4000136c:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40001370:	d65f03c0 	ret

0000000040001374 <snprintk>:
{
    40001374:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40001378:	910003fd 	mov	x29, sp
    4000137c:	a90d93e3 	stp	x3, x4, [sp, #216]
	va_start(ap, fmt);
    40001380:	910403e3 	add	x3, sp, #0x100
    40001384:	a9030fe3 	stp	x3, x3, [sp, #48]
    40001388:	910343e3 	add	x3, sp, #0xd0
    4000138c:	f90023e3 	str	x3, [sp, #64]
    40001390:	128004e3 	mov	w3, #0xffffffd8            	// #-40
    40001394:	b9004be3 	str	w3, [sp, #72]
    40001398:	12800fe3 	mov	w3, #0xffffff80            	// #-128
    4000139c:	b9004fe3 	str	w3, [sp, #76]
	ret = vsnprintk(str, size, fmt, ap);
    400013a0:	910043e3 	add	x3, sp, #0x10
{
    400013a4:	a90e9be5 	stp	x5, x6, [sp, #232]
	ret = vsnprintk(str, size, fmt, ap);
    400013a8:	a94317e4 	ldp	x4, x5, [sp, #48]
    400013ac:	a90117e4 	stp	x4, x5, [sp, #16]
    400013b0:	a94417e4 	ldp	x4, x5, [sp, #64]
    400013b4:	a90217e4 	stp	x4, x5, [sp, #32]
{
    400013b8:	3d8017e0 	str	q0, [sp, #80]
    400013bc:	3d801be1 	str	q1, [sp, #96]
    400013c0:	3d801fe2 	str	q2, [sp, #112]
    400013c4:	3d8023e3 	str	q3, [sp, #128]
    400013c8:	3d8027e4 	str	q4, [sp, #144]
    400013cc:	3d802be5 	str	q5, [sp, #160]
    400013d0:	3d802fe6 	str	q6, [sp, #176]
    400013d4:	3d8033e7 	str	q7, [sp, #192]
    400013d8:	f9007fe7 	str	x7, [sp, #248]
	ret = vsnprintk(str, size, fmt, ap);
    400013dc:	97ffffd0 	bl	4000131c <vsnprintk>
}
    400013e0:	a8d07bfd 	ldp	x29, x30, [sp], #256
    400013e4:	d65f03c0 	ret

00000000400013e8 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    400013e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400013ec:	aa0003e4 	mov	x4, x0
    400013f0:	aa0103e0 	mov	x0, x1
    400013f4:	910003fd 	mov	x29, sp
    400013f8:	aa0203e1 	mov	x1, x2
    400013fc:	aa0303e2 	mov	x2, x3
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    40001400:	d63f0080 	blr	x4
		/* coverity[OVERRUN] */
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
    40001404:	94003a97 	bl	4000fe60 <z_impl_z_current_get>
		arch_syscall_invoke1(*(uintptr_t *)&thread, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
    40001408:	94003ae2 	bl	4000ff90 <z_impl_k_thread_abort>

000000004000140c <chunk_size>:
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
    4000140c:	8b214c01 	add	x1, x0, w1, uxtw #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
    40001410:	b9400420 	ldr	w0, [x1, #4]
}
    40001414:	53017c00 	lsr	w0, w0, #1
    40001418:	d65f03c0 	ret

000000004000141c <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
    4000141c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40001420:	aa0003e2 	mov	x2, x0
    40001424:	2a0103e3 	mov	w3, w1
    40001428:	910003fd 	mov	x29, sp
	chunk_set(h, c, LEFT_SIZE, size);
}

static inline bool solo_free_header(struct z_heap *h, chunkid_t c)
{
	return big_heap(h) && chunk_size(h, c) == 1U;
    4000142c:	97fffff8 	bl	4000140c <chunk_size>
	if (!solo_free_header(h, c)) {
    40001430:	7100041f 	cmp	w0, #0x1
    40001434:	54000260 	b.eq	40001480 <free_list_add+0x64>  // b.none
	return chunksz_in * CHUNK_UNIT - chunk_header_bytes(h);
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    40001438:	51000400 	sub	w0, w0, #0x1
	return 31 - __builtin_clz(usable_sz);
    4000143c:	528003e1 	mov	w1, #0x1f                  	// #31
    40001440:	5ac01000 	clz	w0, w0
    40001444:	4b000020 	sub	w0, w1, w0
	if (b->next == 0U) {
    40001448:	d37d7c61 	ubfiz	x1, x3, #3, #32
    4000144c:	91002026 	add	x6, x1, #0x8
		((uint32_t *)cmem)[f] = val;
    40001450:	91003021 	add	x1, x1, #0xc
    40001454:	8b20c847 	add	x7, x2, w0, sxtw #2
    40001458:	b94010e5 	ldr	w5, [x7, #16]
    4000145c:	35000165 	cbnz	w5, 40001488 <free_list_add+0x6c>
		h->avail_buckets |= (1 << bidx);
    40001460:	52800024 	mov	w4, #0x1                   	// #1
    40001464:	1ac02084 	lsl	w4, w4, w0
    40001468:	b9400c40 	ldr	w0, [x2, #12]
    4000146c:	2a040000 	orr	w0, w0, w4
    40001470:	b9000c40 	str	w0, [x2, #12]
		b->next = c;
    40001474:	b90010e3 	str	w3, [x7, #16]
    40001478:	b8266843 	str	w3, [x2, x6]
    4000147c:	b8216843 	str	w3, [x2, x1]
		int bidx = bucket_idx(h, chunk_size(h, c));
		free_list_add_bidx(h, c, bidx);
	}
}
    40001480:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40001484:	d65f03c0 	ret
		return ((uint32_t *)cmem)[f];
    40001488:	d37d7ca0 	ubfiz	x0, x5, #3, #32
    4000148c:	91002000 	add	x0, x0, #0x8
    40001490:	b8606844 	ldr	w4, [x2, x0]
		((uint32_t *)cmem)[f] = val;
    40001494:	b8266844 	str	w4, [x2, x6]
    40001498:	b8216845 	str	w5, [x2, x1]
    4000149c:	8b244c44 	add	x4, x2, w4, uxtw #3
    400014a0:	b9000c83 	str	w3, [x4, #12]
    400014a4:	b8206843 	str	w3, [x2, x0]
    400014a8:	17fffff6 	b	40001480 <free_list_add+0x64>

00000000400014ac <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
    400014ac:	d1002042 	sub	x2, x2, #0x8

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    400014b0:	91001c23 	add	x3, x1, #0x7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    400014b4:	8b020022 	add	x2, x1, x2
{
    400014b8:	aa0003e4 	mov	x4, x0
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
    400014bc:	927df042 	and	x2, x2, #0xfffffffffffffff8
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
    400014c0:	927df060 	and	x0, x3, #0xfffffffffffffff8
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    400014c4:	cb000042 	sub	x2, x2, x0
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
    400014c8:	91004005 	add	x5, x0, #0x10
	heap->heap = h;
    400014cc:	f9000080 	str	x0, [x4]
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    400014d0:	52800404 	mov	w4, #0x20                  	// #32
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
    400014d4:	d343fc42 	lsr	x2, x2, #3
	h->avail_buckets = 0;
    400014d8:	29017c02 	stp	w2, wzr, [x0, #8]
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
    400014dc:	51000441 	sub	w1, w2, #0x1
	return 31 - __builtin_clz(usable_sz);
    400014e0:	5ac01023 	clz	w3, w1
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
    400014e4:	52800481 	mov	w1, #0x24                  	// #36
    400014e8:	4b030021 	sub	w1, w1, w3
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
    400014ec:	4b030084 	sub	w4, w4, w3
    400014f0:	d28000e3 	mov	x3, #0x7                   	// #7
    400014f4:	8b21c861 	add	x1, x3, w1, sxtw #2
	for (int i = 0; i < nb_buckets; i++) {
    400014f8:	d2800003 	mov	x3, #0x0                   	// #0
    400014fc:	d343fc21 	lsr	x1, x1, #3
    40001500:	6b03009f 	cmp	w4, w3
    40001504:	5400020c 	b.gt	40001544 <sys_heap_init+0x98>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    40001508:	531f7823 	lsl	w3, w1, #1
		((uint32_t *)cmem)[f] = val;
    4000150c:	8b010c05 	add	x5, x0, x1, lsl #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    40001510:	32000063 	orr	w3, w3, #0x1
	void *cmem = &buf[c];
    40001514:	d37df024 	lsl	x4, x1, #3
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    40001518:	29000c1f 	stp	wzr, w3, [x0]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
    4000151c:	4b010043 	sub	w3, w2, w1
	void *cmem = &buf[c];
    40001520:	d37d7c42 	ubfiz	x2, x2, #3, #32
	chunk_set(h, c, SIZE_AND_USED, size << 1);
    40001524:	531f7866 	lsl	w6, w3, #1
		((uint32_t *)cmem)[f] = val;
    40001528:	b90004a6 	str	w6, [x5, #4]
    4000152c:	b8246801 	str	w1, [x0, x4]
    40001530:	8b020004 	add	x4, x0, x2
    40001534:	b8226803 	str	w3, [x0, x2]
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
    40001538:	52800022 	mov	w2, #0x1                   	// #1
    4000153c:	b9000482 	str	w2, [x4, #4]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
    40001540:	17ffffb7 	b	4000141c <free_list_add>
		h->buckets[i].next = 0;
    40001544:	b82378bf 	str	wzr, [x5, x3, lsl #2]
	for (int i = 0; i < nb_buckets; i++) {
    40001548:	91000463 	add	x3, x3, #0x1
    4000154c:	17ffffed 	b	40001500 <sys_heap_init+0x54>

0000000040001550 <setup_bundle_data.constprop.0>:
			      size_t offset, size_t num_bits)
{
	bd->sidx = offset / bundle_bitness(bitarray);
	bd->soff = offset % bundle_bitness(bitarray);

	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    40001550:	d1000442 	sub	x2, x2, #0x1
	bd->sidx = offset / bundle_bitness(bitarray);
    40001554:	d345fc25 	lsr	x5, x1, #5
	bd->soff = offset % bundle_bitness(bitarray);
    40001558:	92401023 	and	x3, x1, #0x1f
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    4000155c:	8b010041 	add	x1, x2, x1
	bd->eoff = (offset + num_bits - 1) % bundle_bitness(bitarray);

	bd->smask = ~(BIT(bd->soff) - 1);
    40001560:	d2800022 	mov	x2, #0x1                   	// #1
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    40001564:	d345fc24 	lsr	x4, x1, #5
	bd->eoff = (offset + num_bits - 1) % bundle_bitness(bitarray);
    40001568:	92401021 	and	x1, x1, #0x1f
    4000156c:	a9010403 	stp	x3, x1, [x0, #16]
	bd->smask = ~(BIT(bd->soff) - 1);
    40001570:	9ac32043 	lsl	x3, x2, x3
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
    40001574:	9ac12042 	lsl	x2, x2, x1
    40001578:	51000441 	sub	w1, w2, #0x1
	bd->smask = ~(BIT(bd->soff) - 1);
    4000157c:	4b0303e3 	neg	w3, w3
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
    40001580:	2a020021 	orr	w1, w1, w2

	if (bd->sidx == bd->eidx) {
		/* The region lies within the same bundle. So combine the masks. */
		bd->smask &= bd->emask;
    40001584:	eb0400bf 	cmp	x5, x4
	bd->emask = (BIT(bd->eoff) - 1) | BIT(bd->eoff);
    40001588:	b9002401 	str	w1, [x0, #36]
		bd->smask &= bd->emask;
    4000158c:	0a010061 	and	w1, w3, w1
    40001590:	1a830021 	csel	w1, w1, w3, eq  // eq = none
	bd->eidx = (offset + num_bits - 1) / bundle_bitness(bitarray);
    40001594:	a9001005 	stp	x5, x4, [x0]
		bd->smask &= bd->emask;
    40001598:	b9002001 	str	w1, [x0, #32]
	}
}
    4000159c:	d65f03c0 	ret

00000000400015a0 <set_region>:
 *                 prior call to match_region().
 */
static void set_region(sys_bitarray_t *bitarray, size_t offset,
		       size_t num_bits, bool to_set,
		       struct bundle_data *bd)
{
    400015a0:	aa0003e7 	mov	x7, x0
    400015a4:	12001c69 	and	w9, w3, #0xff
	int idx;
	struct bundle_data bdata;

	if (bd == NULL) {
    400015a8:	b50005e4 	cbnz	x4, 40001664 <set_region+0xc4>
{
    400015ac:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
		bd = &bdata;
		setup_bundle_data(bitarray, bd, offset, num_bits);
    400015b0:	910063e0 	add	x0, sp, #0x18
{
    400015b4:	910003fd 	mov	x29, sp
		setup_bundle_data(bitarray, bd, offset, num_bits);
    400015b8:	97ffffe6 	bl	40001550 <setup_bundle_data.constprop.0>
	}

	if (bd->sidx == bd->eidx) {
		/* Start/end at same bundle */
		if (to_set) {
			bitarray->bundles[bd->sidx] |= bd->smask;
    400015bc:	f94004e2 	ldr	x2, [x7, #8]
	if (bd->sidx == bd->eidx) {
    400015c0:	a9401801 	ldp	x1, x6, [x0]
			bitarray->bundles[bd->sidx] |= bd->smask;
    400015c4:	b9402004 	ldr	w4, [x0, #32]
    400015c8:	d37ef428 	lsl	x8, x1, #2
	if (bd->sidx == bd->eidx) {
    400015cc:	eb06003f 	cmp	x1, x6
			bitarray->bundles[bd->sidx] |= bd->smask;
    400015d0:	b8686845 	ldr	w5, [x2, x8]
	if (bd->sidx == bd->eidx) {
    400015d4:	54000101 	b.ne	400015f4 <set_region+0x54>  // b.any
			bitarray->bundles[bd->sidx] |= bd->smask;
    400015d8:	0a2400a0 	bic	w0, w5, w4
    400015dc:	7100013f 	cmp	w9, #0x0
    400015e0:	2a0400a5 	orr	w5, w5, w4
    400015e4:	1a8010a5 	csel	w5, w5, w0, ne  // ne = any
    400015e8:	b8286845 	str	w5, [x2, x8]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
				bitarray->bundles[idx] = 0U;
			}
		}
	}
}
    400015ec:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400015f0:	d65f03c0 	ret
			bitarray->bundles[bd->eidx] |= bd->emask;
    400015f4:	d37ef4c7 	lsl	x7, x6, #2
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400015f8:	11000421 	add	w1, w1, #0x1
		if (to_set) {
    400015fc:	340001c9 	cbz	w9, 40001634 <set_region+0x94>
			bitarray->bundles[bd->sidx] |= bd->smask;
    40001600:	2a0400a5 	orr	w5, w5, w4
    40001604:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] |= bd->emask;
    40001608:	b8676843 	ldr	w3, [x2, x7]
    4000160c:	b9402400 	ldr	w0, [x0, #36]
    40001610:	2a000063 	orr	w3, w3, w0
    40001614:	b8276843 	str	w3, [x2, x7]
				bitarray->bundles[idx] = ~0U;
    40001618:	12800003 	mov	w3, #0xffffffff            	// #-1
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    4000161c:	93407c20 	sxtw	x0, w1
    40001620:	eb21c0df 	cmp	x6, w1, sxtw
    40001624:	54fffe49 	b.ls	400015ec <set_region+0x4c>  // b.plast
    40001628:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = ~0U;
    4000162c:	b8207843 	str	w3, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40001630:	17fffffb 	b	4000161c <set_region+0x7c>
			bitarray->bundles[bd->sidx] &= ~bd->smask;
    40001634:	0a2400a5 	bic	w5, w5, w4
    40001638:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] &= ~bd->emask;
    4000163c:	b8676843 	ldr	w3, [x2, x7]
    40001640:	b9402400 	ldr	w0, [x0, #36]
    40001644:	0a200060 	bic	w0, w3, w0
    40001648:	b8276840 	str	w0, [x2, x7]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    4000164c:	93407c20 	sxtw	x0, w1
    40001650:	eb21c0df 	cmp	x6, w1, sxtw
    40001654:	54fffcc9 	b.ls	400015ec <set_region+0x4c>  // b.plast
    40001658:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = 0U;
    4000165c:	b820785f 	str	wzr, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40001660:	17fffffb 	b	4000164c <set_region+0xac>
    40001664:	aa0403e0 	mov	x0, x4
			bitarray->bundles[bd->sidx] |= bd->smask;
    40001668:	b9402084 	ldr	w4, [x4, #32]
    4000166c:	f94004e2 	ldr	x2, [x7, #8]
	if (bd->sidx == bd->eidx) {
    40001670:	a9401801 	ldp	x1, x6, [x0]
			bitarray->bundles[bd->sidx] |= bd->smask;
    40001674:	d37ef428 	lsl	x8, x1, #2
	if (bd->sidx == bd->eidx) {
    40001678:	eb06003f 	cmp	x1, x6
			bitarray->bundles[bd->sidx] |= bd->smask;
    4000167c:	b8686845 	ldr	w5, [x2, x8]
	if (bd->sidx == bd->eidx) {
    40001680:	540000e1 	b.ne	4000169c <set_region+0xfc>  // b.any
			bitarray->bundles[bd->sidx] |= bd->smask;
    40001684:	0a2400a0 	bic	w0, w5, w4
    40001688:	7100013f 	cmp	w9, #0x0
    4000168c:	2a0400a5 	orr	w5, w5, w4
    40001690:	1a8010a5 	csel	w5, w5, w0, ne  // ne = any
    40001694:	b8286845 	str	w5, [x2, x8]
    40001698:	d65f03c0 	ret
			bitarray->bundles[bd->eidx] |= bd->emask;
    4000169c:	d37ef4c7 	lsl	x7, x6, #2
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400016a0:	11000421 	add	w1, w1, #0x1
		if (to_set) {
    400016a4:	340001e9 	cbz	w9, 400016e0 <set_region+0x140>
			bitarray->bundles[bd->sidx] |= bd->smask;
    400016a8:	2a0400a5 	orr	w5, w5, w4
    400016ac:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] |= bd->emask;
    400016b0:	b8676843 	ldr	w3, [x2, x7]
    400016b4:	b9402400 	ldr	w0, [x0, #36]
    400016b8:	2a000063 	orr	w3, w3, w0
    400016bc:	b8276843 	str	w3, [x2, x7]
				bitarray->bundles[idx] = ~0U;
    400016c0:	12800003 	mov	w3, #0xffffffff            	// #-1
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400016c4:	93407c20 	sxtw	x0, w1
    400016c8:	eb21c0df 	cmp	x6, w1, sxtw
    400016cc:	54000048 	b.hi	400016d4 <set_region+0x134>  // b.pmore
    400016d0:	d65f03c0 	ret
    400016d4:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = ~0U;
    400016d8:	b8207843 	str	w3, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400016dc:	17fffffa 	b	400016c4 <set_region+0x124>
			bitarray->bundles[bd->sidx] &= ~bd->smask;
    400016e0:	0a2400a5 	bic	w5, w5, w4
    400016e4:	b8286845 	str	w5, [x2, x8]
			bitarray->bundles[bd->eidx] &= ~bd->emask;
    400016e8:	b8676843 	ldr	w3, [x2, x7]
    400016ec:	b9402400 	ldr	w0, [x0, #36]
    400016f0:	0a200060 	bic	w0, w3, w0
    400016f4:	b8276840 	str	w0, [x2, x7]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    400016f8:	93407c20 	sxtw	x0, w1
    400016fc:	eb21c0df 	cmp	x6, w1, sxtw
    40001700:	54000048 	b.hi	40001708 <set_region+0x168>  // b.pmore
    40001704:	d65f03c0 	ret
    40001708:	11000421 	add	w1, w1, #0x1
				bitarray->bundles[idx] = 0U;
    4000170c:	b820785f 	str	wzr, [x2, x0, lsl #2]
			for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40001710:	17fffffa 	b	400016f8 <set_region+0x158>

0000000040001714 <set_clear_region>:
	return is_region_set_clear(bitarray, num_bits, offset, false);
}

static int set_clear_region(sys_bitarray_t *bitarray, size_t num_bits,
			    size_t offset, bool to_set)
{
    40001714:	aa0103e5 	mov	x5, x1
    40001718:	aa0203e1 	mov	x1, x2
	int ret;
	size_t off_end = offset + num_bits - 1;
    4000171c:	d10004a2 	sub	x2, x5, #0x1
    40001720:	8b010042 	add	x2, x2, x1
MAKE_REG_HELPER(cntv_ctl_el0)
MAKE_REG_HELPER(cntv_cval_el0)
MAKE_REG_HELPER(cntvct_el0);
MAKE_REG_HELPER(cntvoff_el2);
MAKE_REG_HELPER(currentel);
MAKE_REG_HELPER(daif)
    40001724:	d53b422a 	mrs	x10, daif
			  :: "i" (DAIFCLR_IRQ_BIT) : "memory");
}

static ALWAYS_INLINE void disable_irq(void)
{
	__asm__ volatile ("msr DAIFSet, %0"
    40001728:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&bitarray->lock);

	__ASSERT_NO_MSG(bitarray->num_bits > 0);

	if ((num_bits == 0)
    4000172c:	b4000265 	cbz	x5, 40001778 <set_clear_region+0x64>
	    || (num_bits > bitarray->num_bits)
    40001730:	b9400004 	ldr	w4, [x0]
    40001734:	eb05009f 	cmp	x4, x5
    40001738:	54000203 	b.cc	40001778 <set_clear_region+0x64>  // b.lo, b.ul, b.last
	    || (offset >= bitarray->num_bits)
    4000173c:	eb01009f 	cmp	x4, x1
    40001740:	540001c9 	b.ls	40001778 <set_clear_region+0x64>  // b.plast
	    || (off_end >= bitarray->num_bits)) {
    40001744:	eb02009f 	cmp	x4, x2
    40001748:	54000189 	b.ls	40001778 <set_clear_region+0x64>  // b.plast
{
    4000174c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40001750:	12001c63 	and	w3, w3, #0xff
		ret = -EINVAL;
		goto out;
	}

	set_region(bitarray, offset, num_bits, to_set, NULL);
    40001754:	aa0503e2 	mov	x2, x5
{
    40001758:	910003fd 	mov	x29, sp
	set_region(bitarray, offset, num_bits, to_set, NULL);
    4000175c:	d2800004 	mov	x4, #0x0                   	// #0
    40001760:	97ffff90 	bl	400015a0 <set_region>
	ret = 0;
    40001764:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    40001768:	92407d4a 	and	x10, x10, #0xffffffff
    4000176c:	d51b422a 	msr	daif, x10

out:
	k_spin_unlock(&bitarray->lock, key);
	return ret;
}
    40001770:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40001774:	d65f03c0 	ret
		ret = -EINVAL;
    40001778:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4000177c:	92407d4a 	and	x10, x10, #0xffffffff
    40001780:	d51b422a 	msr	daif, x10
}
    40001784:	d65f03c0 	ret

0000000040001788 <match_region>:
{
    40001788:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000178c:	aa0003e8 	mov	x8, x0
    40001790:	aa0403e0 	mov	x0, x4
    40001794:	910003fd 	mov	x29, sp
    40001798:	12001c67 	and	w7, w3, #0xff
    4000179c:	aa0503e6 	mov	x6, x5
	setup_bundle_data(bitarray, bd, offset, num_bits);
    400017a0:	97ffff6c 	bl	40001550 <setup_bundle_data.constprop.0>
	if (bd->sidx == bd->eidx) {
    400017a4:	a9401002 	ldp	x2, x4, [x0]
    400017a8:	b9402001 	ldr	w1, [x0, #32]
    400017ac:	f9400503 	ldr	x3, [x8, #8]
    400017b0:	eb04005f 	cmp	x2, x4
    400017b4:	54000221 	b.ne	400017f8 <match_region+0x70>  // b.any
		bundle = bitarray->bundles[bd->sidx];
    400017b8:	b8627860 	ldr	w0, [x3, x2, lsl #2]
		if (!match_set) {
    400017bc:	35000047 	cbnz	w7, 400017c4 <match_region+0x3c>
			bundle = ~bundle;
    400017c0:	2a2003e0 	mvn	w0, w0
		if ((bundle & bd->smask) != bd->smask) {
    400017c4:	6a20003f 	bics	wzr, w1, w0
    400017c8:	54000400 	b.eq	40001848 <match_region+0xc0>  // b.none
			mismatch_bundle = ~bundle & bd->smask;
    400017cc:	0a200020 	bic	w0, w1, w0
	if (mismatch != NULL) {
    400017d0:	b4000106 	cbz	x6, 400017f0 <match_region+0x68>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
    400017d4:	7100001f 	cmp	w0, #0x0
    400017d8:	5ac00000 	rbit	w0, w0
    400017dc:	5ac01000 	clz	w0, w0
    400017e0:	1a8007e0 	csinc	w0, wzr, w0, eq  // eq = none
		mismatch_bit_off = find_lsb_set(mismatch_bundle) - 1;
    400017e4:	51000400 	sub	w0, w0, #0x1
		*mismatch = (uint32_t)mismatch_bit_off;
    400017e8:	0b021400 	add	w0, w0, w2, lsl #5
    400017ec:	f90000c0 	str	x0, [x6]
	return false;
    400017f0:	52800000 	mov	w0, #0x0                   	// #0
    400017f4:	14000016 	b	4000184c <match_region+0xc4>
	bundle = bitarray->bundles[bd->sidx];
    400017f8:	b8627865 	ldr	w5, [x3, x2, lsl #2]
	if (!match_set) {
    400017fc:	35000047 	cbnz	w7, 40001804 <match_region+0x7c>
		bundle = ~bundle;
    40001800:	2a2503e5 	mvn	w5, w5
	if ((bundle & bd->smask) != bd->smask) {
    40001804:	6a25003f 	bics	wzr, w1, w5
    40001808:	54000060 	b.eq	40001814 <match_region+0x8c>  // b.none
		mismatch_bundle = ~bundle & bd->smask;
    4000180c:	0a250020 	bic	w0, w1, w5
		goto mismatch;
    40001810:	17fffff0 	b	400017d0 <match_region+0x48>
	bundle = bitarray->bundles[bd->eidx];
    40001814:	b8647861 	ldr	w1, [x3, x4, lsl #2]
	if (!match_set) {
    40001818:	35000047 	cbnz	w7, 40001820 <match_region+0x98>
		bundle = ~bundle;
    4000181c:	2a2103e1 	mvn	w1, w1
	if ((bundle & bd->emask) != bd->emask) {
    40001820:	b9402400 	ldr	w0, [x0, #36]
    40001824:	6a21001f 	bics	wzr, w0, w1
    40001828:	54000080 	b.eq	40001838 <match_region+0xb0>  // b.none
		mismatch_bundle = ~bundle & bd->emask;
    4000182c:	0a210000 	bic	w0, w0, w1
		goto mismatch;
    40001830:	aa0403e2 	mov	x2, x4
    40001834:	17ffffe7 	b	400017d0 <match_region+0x48>
	for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    40001838:	11000441 	add	w1, w2, #0x1
    4000183c:	93407c22 	sxtw	x2, w1
    40001840:	eb21c09f 	cmp	x4, w1, sxtw
    40001844:	54000088 	b.hi	40001854 <match_region+0xcc>  // b.pmore
	return true;
    40001848:	52800020 	mov	w0, #0x1                   	// #1
}
    4000184c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40001850:	d65f03c0 	ret
		bundle = bitarray->bundles[idx];
    40001854:	b8627860 	ldr	w0, [x3, x2, lsl #2]
		if (match_set) {
    40001858:	34000047 	cbz	w7, 40001860 <match_region+0xd8>
			bundle = ~bundle;
    4000185c:	2a2003e0 	mvn	w0, w0
		if (bundle != 0U) {
    40001860:	34000060 	cbz	w0, 4000186c <match_region+0xe4>
			mismatch_bundle = ~bundle;
    40001864:	2a2003e0 	mvn	w0, w0
			goto mismatch;
    40001868:	17ffffda 	b	400017d0 <match_region+0x48>
	for (idx = bd->sidx + 1; idx < bd->eidx; idx++) {
    4000186c:	11000421 	add	w1, w1, #0x1
    40001870:	17fffff3 	b	4000183c <match_region+0xb4>

0000000040001874 <sys_bitarray_alloc>:
    40001874:	d53b422d 	mrs	x13, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40001878:	d50342df 	msr	daifset, #0x2
	CHECKIF(offset == NULL) {
    4000187c:	b4000502 	cbz	x2, 4000191c <sys_bitarray_alloc+0xa8>
    40001880:	aa0103ea 	mov	x10, x1
	if ((num_bits == 0) || (num_bits > bitarray->num_bits)) {
    40001884:	b40004c1 	cbz	x1, 4000191c <sys_bitarray_alloc+0xa8>
    40001888:	b9400001 	ldr	w1, [x0]
    4000188c:	aa0003e9 	mov	x9, x0
    40001890:	eb0a003f 	cmp	x1, x10
    40001894:	54000443 	b.cc	4000191c <sys_bitarray_alloc+0xa8>  // b.lo, b.ul, b.last
    40001898:	aa0203ec 	mov	x12, x2
    4000189c:	b9400522 	ldr	w2, [x9, #4]
	for (ret = 0; ret < bitarray->num_bundles; ret++) {
    400018a0:	52800000 	mov	w0, #0x0                   	// #0
    400018a4:	531b6804 	lsl	w4, w0, #5
    400018a8:	6b02001f 	cmp	w0, w2
    400018ac:	540001e0 	b.eq	400018e8 <sys_bitarray_alloc+0x74>  // b.none
		if (~bitarray->bundles[ret] == 0U) {
    400018b0:	f9400523 	ldr	x3, [x9, #8]
    400018b4:	b860d863 	ldr	w3, [x3, w0, sxtw #2]
    400018b8:	3100047f 	cmn	w3, #0x1
    400018bc:	54000061 	b.ne	400018c8 <sys_bitarray_alloc+0x54>  // b.any
	for (ret = 0; ret < bitarray->num_bundles; ret++) {
    400018c0:	11000400 	add	w0, w0, #0x1
    400018c4:	17fffff8 	b	400018a4 <sys_bitarray_alloc+0x30>
		if (bitarray->bundles[ret] != 0U) {
    400018c8:	34000103 	cbz	w3, 400018e8 <sys_bitarray_alloc+0x74>
			off_start = find_lsb_set(~bitarray->bundles[ret]) - 1;
    400018cc:	2a2303e3 	mvn	w3, w3
			bit_idx += off_start;
    400018d0:	51000484 	sub	w4, w4, #0x1
    400018d4:	7100007f 	cmp	w3, #0x0
    400018d8:	5ac00063 	rbit	w3, w3
    400018dc:	5ac01063 	clz	w3, w3
    400018e0:	1a8307e3 	csinc	w3, wzr, w3, eq  // eq = none
    400018e4:	0b030084 	add	w4, w4, w3
	off_end = bitarray->num_bits - num_bits;
    400018e8:	cb0a002b 	sub	x11, x1, x10
	while (bit_idx <= off_end) {
    400018ec:	2a0403ee 	mov	w14, w4
    400018f0:	eb24417f 	cmp	x11, w4, uxtw
    400018f4:	540001c2 	b.cs	4000192c <sys_bitarray_alloc+0xb8>  // b.hs, b.nlast
	ret = -ENOSPC;
    400018f8:	12800360 	mov	w0, #0xffffffe4            	// #-28
    400018fc:	14000009 	b	40001920 <sys_bitarray_alloc+0xac>
		bit_idx = mismatch + 1;
    40001900:	f9400be4 	ldr	x4, [sp, #16]
    40001904:	11000484 	add	w4, w4, #0x1
	while (bit_idx <= off_end) {
    40001908:	2a0403ee 	mov	w14, w4
    4000190c:	eb24417f 	cmp	x11, w4, uxtw
    40001910:	54000122 	b.cs	40001934 <sys_bitarray_alloc+0xc0>  // b.hs, b.nlast
	ret = -ENOSPC;
    40001914:	12800360 	mov	w0, #0xffffffe4            	// #-28
out:
    40001918:	14000018 	b	40001978 <sys_bitarray_alloc+0x104>
		ret = -EINVAL;
    4000191c:	128002a0 	mov	w0, #0xffffffea            	// #-22
MAKE_REG_HELPER(daif)
    40001920:	92407dad 	and	x13, x13, #0xffffffff
    40001924:	d51b422d 	msr	daif, x13
}
    40001928:	d65f03c0 	ret
{
    4000192c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40001930:	910003fd 	mov	x29, sp
		if (match_region(bitarray, bit_idx, num_bits, false,
    40001934:	910043e5 	add	x5, sp, #0x10
    40001938:	910063e4 	add	x4, sp, #0x18
    4000193c:	aa0a03e2 	mov	x2, x10
    40001940:	aa0e03e1 	mov	x1, x14
    40001944:	aa0903e0 	mov	x0, x9
    40001948:	52800003 	mov	w3, #0x0                   	// #0
    4000194c:	97ffff8f 	bl	40001788 <match_region>
    40001950:	72001c1f 	tst	w0, #0xff
    40001954:	54fffd60 	b.eq	40001900 <sys_bitarray_alloc+0x8c>  // b.none
			set_region(bitarray, bit_idx, num_bits, true, &bd);
    40001958:	aa0903e0 	mov	x0, x9
    4000195c:	910063e4 	add	x4, sp, #0x18
    40001960:	aa0a03e2 	mov	x2, x10
    40001964:	aa0e03e1 	mov	x1, x14
    40001968:	52800023 	mov	w3, #0x1                   	// #1
    4000196c:	97ffff0d 	bl	400015a0 <set_region>
			ret = 0;
    40001970:	52800000 	mov	w0, #0x0                   	// #0
			*offset = bit_idx;
    40001974:	f900018e 	str	x14, [x12]
    40001978:	92407dad 	and	x13, x13, #0xffffffff
    4000197c:	d51b422d 	msr	daif, x13
}
    40001980:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40001984:	d65f03c0 	ret

0000000040001988 <sys_bitarray_free>:
{
    40001988:	aa0103e9 	mov	x9, x1
	size_t off_end = offset + num_bits - 1;
    4000198c:	d1000421 	sub	x1, x1, #0x1
    40001990:	8b020021 	add	x1, x1, x2
    40001994:	d53b422c 	mrs	x12, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40001998:	d50342df 	msr	daifset, #0x2
	if ((num_bits == 0)
    4000199c:	b40003e9 	cbz	x9, 40001a18 <sys_bitarray_free+0x90>
    400019a0:	aa0203ea 	mov	x10, x2
	    || (num_bits > bitarray->num_bits)
    400019a4:	b9400002 	ldr	w2, [x0]
    400019a8:	aa0003eb 	mov	x11, x0
    400019ac:	eb09005f 	cmp	x2, x9
    400019b0:	54000343 	b.cc	40001a18 <sys_bitarray_free+0x90>  // b.lo, b.ul, b.last
	    || (offset >= bitarray->num_bits)
    400019b4:	eb0a005f 	cmp	x2, x10
    400019b8:	54000309 	b.ls	40001a18 <sys_bitarray_free+0x90>  // b.plast
	    || (off_end >= bitarray->num_bits)) {
    400019bc:	eb01005f 	cmp	x2, x1
    400019c0:	540002c9 	b.ls	40001a18 <sys_bitarray_free+0x90>  // b.plast
{
    400019c4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	if (match_region(bitarray, offset, num_bits, true, &bd, NULL)) {
    400019c8:	aa0903e2 	mov	x2, x9
    400019cc:	aa0a03e1 	mov	x1, x10
{
    400019d0:	910003fd 	mov	x29, sp
	if (match_region(bitarray, offset, num_bits, true, &bd, NULL)) {
    400019d4:	910063e4 	add	x4, sp, #0x18
    400019d8:	d2800005 	mov	x5, #0x0                   	// #0
    400019dc:	52800023 	mov	w3, #0x1                   	// #1
    400019e0:	97ffff6a 	bl	40001788 <match_region>
    400019e4:	72001c1f 	tst	w0, #0xff
    400019e8:	54000200 	b.eq	40001a28 <sys_bitarray_free+0xa0>  // b.none
		set_region(bitarray, offset, num_bits, false, &bd);
    400019ec:	aa0b03e0 	mov	x0, x11
    400019f0:	910063e4 	add	x4, sp, #0x18
    400019f4:	aa0903e2 	mov	x2, x9
    400019f8:	aa0a03e1 	mov	x1, x10
    400019fc:	52800003 	mov	w3, #0x0                   	// #0
    40001a00:	97fffee8 	bl	400015a0 <set_region>
		ret = 0;
    40001a04:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    40001a08:	92407d8c 	and	x12, x12, #0xffffffff
    40001a0c:	d51b422c 	msr	daif, x12
}
    40001a10:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40001a14:	d65f03c0 	ret
		ret = -EINVAL;
    40001a18:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40001a1c:	92407d8c 	and	x12, x12, #0xffffffff
    40001a20:	d51b422c 	msr	daif, x12
}
    40001a24:	d65f03c0 	ret
		ret = -EFAULT;
    40001a28:	128001a0 	mov	w0, #0xfffffff2            	// #-14
    40001a2c:	17fffff7 	b	40001a08 <sys_bitarray_free+0x80>

0000000040001a30 <sys_bitarray_set_region>:

int sys_bitarray_set_region(sys_bitarray_t *bitarray, size_t num_bits,
			    size_t offset)
{
	return set_clear_region(bitarray, num_bits, offset, true);
    40001a30:	52800023 	mov	w3, #0x1                   	// #1
    40001a34:	17ffff38 	b	40001714 <set_clear_region>

0000000040001a38 <_get_digit>:

/* Extract the next decimal character in the converted representation of a
 * fractional component.
 */
static char _get_digit(uint64_t *fr, int *digit_count)
{
    40001a38:	aa0003e3 	mov	x3, x0
	char rval;

	if (*digit_count > 0) {
    40001a3c:	b9400020 	ldr	w0, [x1]
    40001a40:	7100001f 	cmp	w0, #0x0
    40001a44:	5400016d 	b.le	40001a70 <_get_digit+0x38>
		--*digit_count;
    40001a48:	51000400 	sub	w0, w0, #0x1
    40001a4c:	b9000020 	str	w0, [x1]
		*fr *= 10U;
    40001a50:	f9400061 	ldr	x1, [x3]
    40001a54:	d2800140 	mov	x0, #0xa                   	// #10
    40001a58:	9b007c21 	mul	x1, x1, x0
		rval = ((*fr >> 60) & 0xF) + '0';
    40001a5c:	d37cfc22 	lsr	x2, x1, #60
		*fr &= (BIT64(60) - 1U);
    40001a60:	9240ec21 	and	x1, x1, #0xfffffffffffffff
		rval = ((*fr >> 60) & 0xF) + '0';
    40001a64:	1100c040 	add	w0, w2, #0x30
		*fr &= (BIT64(60) - 1U);
    40001a68:	f9000061 	str	x1, [x3]
	} else {
		rval = '0';
	}

	return rval;
}
    40001a6c:	d65f03c0 	ret
		rval = '0';
    40001a70:	52800600 	mov	w0, #0x30                  	// #48
    40001a74:	17fffffe 	b	40001a6c <_get_digit+0x34>

0000000040001a78 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
    40001a78:	aa0003e5 	mov	x5, x0
    40001a7c:	aa0303e0 	mov	x0, x3
	bool upcase = isupper((int)conv->specifier);
    40001a80:	39400c23 	ldrb	w3, [x1, #3]
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    40001a84:	51010468 	sub	w8, w3, #0x41
	switch (specifier) {
    40001a88:	7101bc7f 	cmp	w3, #0x6f
    40001a8c:	54000380 	b.eq	40001afc <encode_uint+0x84>  // b.none
    40001a90:	54000308 	b.hi	40001af0 <encode_uint+0x78>  // b.pmore
		return 16;
    40001a94:	7101607f 	cmp	w3, #0x58
    40001a98:	d2800144 	mov	x4, #0xa                   	// #10
    40001a9c:	d2800203 	mov	x3, #0x10                  	// #16
    40001aa0:	9a831084 	csel	x4, x4, x3, ne  // ne = any
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
    40001aa4:	9ac408a7 	udiv	x7, x5, x4
    40001aa8:	9b0494e6 	msub	x6, x7, x4, x5

		*--bp = (lsv <= 9) ? ('0' + lsv)
    40001aac:	12001cc3 	and	w3, w6, #0xff
    40001ab0:	f10024df 	cmp	x6, #0x9
    40001ab4:	540002c8 	b.hi	40001b0c <encode_uint+0x94>  // b.pmore
    40001ab8:	1100c063 	add	w3, w3, #0x30
    40001abc:	12001c63 	and	w3, w3, #0xff
    40001ac0:	381ffc03 	strb	w3, [x0, #-1]!
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
	} while ((value != 0) && (bps < bp));
    40001ac4:	eb0400bf 	cmp	x5, x4
    40001ac8:	fa422000 	ccmp	x0, x2, #0x0, cs  // cs = hs, nlast
    40001acc:	540001c8 	b.hi	40001b04 <encode_uint+0x8c>  // b.pmore

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
    40001ad0:	79400022 	ldrh	w2, [x1]
    40001ad4:	362800c2 	tbz	w2, #5, 40001aec <encode_uint+0x74>
		if (radix == 8) {
    40001ad8:	f100209f 	cmp	x4, #0x8
    40001adc:	54000261 	b.ne	40001b28 <encode_uint+0xb0>  // b.any
			conv->altform_0 = true;
    40001ae0:	39400822 	ldrb	w2, [x1, #2]
    40001ae4:	321d0042 	orr	w2, w2, #0x8
		} else if (radix == 16) {
			conv->altform_0c = true;
    40001ae8:	39000822 	strb	w2, [x1, #2]
			;
		}
	}

	return bp;
}
    40001aec:	d65f03c0 	ret
	switch (specifier) {
    40001af0:	121c7863 	and	w3, w3, #0xfffffff7
		return 16;
    40001af4:	7101c07f 	cmp	w3, #0x70
    40001af8:	17ffffe8 	b	40001a98 <encode_uint+0x20>
	switch (specifier) {
    40001afc:	d2800104 	mov	x4, #0x8                   	// #8
	char *bp = bps + (bpe - bps);
    40001b00:	17ffffe9 	b	40001aa4 <encode_uint+0x2c>
		value /= radix;
    40001b04:	aa0703e5 	mov	x5, x7
    40001b08:	17ffffe7 	b	40001aa4 <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    40001b0c:	1100dc66 	add	w6, w3, #0x37
    40001b10:	11015c63 	add	w3, w3, #0x57
    40001b14:	12001cc6 	and	w6, w6, #0xff
    40001b18:	12001c63 	and	w3, w3, #0xff
    40001b1c:	7100651f 	cmp	w8, #0x19
    40001b20:	1a868063 	csel	w3, w3, w6, hi  // hi = pmore
    40001b24:	17ffffe7 	b	40001ac0 <encode_uint+0x48>
		} else if (radix == 16) {
    40001b28:	f100409f 	cmp	x4, #0x10
    40001b2c:	54fffe01 	b.ne	40001aec <encode_uint+0x74>  // b.any
			conv->altform_0c = true;
    40001b30:	39400822 	ldrb	w2, [x1, #2]
    40001b34:	321c0042 	orr	w2, w2, #0x10
    40001b38:	17ffffec 	b	40001ae8 <encode_uint+0x70>

0000000040001b3c <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
    40001b3c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40001b40:	910003fd 	mov	x29, sp
    40001b44:	a90153f3 	stp	x19, x20, [sp, #16]
    40001b48:	aa0203f4 	mov	x20, x2
	size_t count = 0;
    40001b4c:	d2800013 	mov	x19, #0x0                   	// #0
{
    40001b50:	a9025bf5 	stp	x21, x22, [sp, #32]
    40001b54:	aa0003f6 	mov	x22, x0
    40001b58:	aa0303f5 	mov	x21, x3
    40001b5c:	f9001bf7 	str	x23, [sp, #48]
    40001b60:	aa0103f7 	mov	x23, x1

	while ((sp < ep) || ((ep == NULL) && *sp)) {
    40001b64:	8b130280 	add	x0, x20, x19
    40001b68:	eb0002bf 	cmp	x21, x0
    40001b6c:	54000148 	b.hi	40001b94 <outs+0x58>  // b.pmore
    40001b70:	b40000f5 	cbz	x21, 40001b8c <outs+0x50>
			return rc;
		}
		++count;
	}

	return (int)count;
    40001b74:	2a1303e0 	mov	w0, w19
}
    40001b78:	a94153f3 	ldp	x19, x20, [sp, #16]
    40001b7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40001b80:	f9401bf7 	ldr	x23, [sp, #48]
    40001b84:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40001b88:	d65f03c0 	ret
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    40001b8c:	38736a80 	ldrb	w0, [x20, x19]
    40001b90:	34ffff20 	cbz	w0, 40001b74 <outs+0x38>
		int rc = out((int)*sp++, ctx);
    40001b94:	38736a80 	ldrb	w0, [x20, x19]
    40001b98:	aa1703e1 	mov	x1, x23
    40001b9c:	d63f02c0 	blr	x22
		if (rc < 0) {
    40001ba0:	37fffec0 	tbnz	w0, #31, 40001b78 <outs+0x3c>
		++count;
    40001ba4:	91000673 	add	x19, x19, #0x1
    40001ba8:	17ffffef 	b	40001b64 <outs+0x28>

0000000040001bac <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    40001bac:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
    40001bb0:	910003fd 	mov	x29, sp
    40001bb4:	a90153f3 	stp	x19, x20, [sp, #16]
    40001bb8:	aa0003f4 	mov	x20, x0
    40001bbc:	a90363f7 	stp	x23, x24, [sp, #48]
    40001bc0:	a9406073 	ldp	x19, x24, [x3]
    40001bc4:	a90573fb 	stp	x27, x28, [sp, #80]
    40001bc8:	b940187c 	ldr	w28, [x3, #24]
    40001bcc:	f9400860 	ldr	x0, [x3, #16]
    40001bd0:	a9025bf5 	stp	x21, x22, [sp, #32]
    40001bd4:	aa0103f5 	mov	x21, x1
    40001bd8:	f90037e0 	str	x0, [sp, #104]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    40001bdc:	d280001b 	mov	x27, #0x0                   	// #0
    40001be0:	b9401c60 	ldr	w0, [x3, #28]
{
    40001be4:	a9046bf9 	stp	x25, x26, [sp, #64]
    40001be8:	b9007be0 	str	w0, [sp, #120]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    40001bec:	39400040 	ldrb	w0, [x2]
    40001bf0:	35000060 	cbnz	w0, 40001bfc <cbvprintf+0x50>
			OUTC(' ');
			--width;
		}
	}

	return count;
    40001bf4:	2a1b03e0 	mov	w0, w27
    40001bf8:	14000425 	b	40002c8c <cbvprintf+0x10e0>
			OUTC(*fp++);
    40001bfc:	91000456 	add	x22, x2, #0x1
		if (*fp != '%') {
    40001c00:	7100941f 	cmp	w0, #0x25
    40001c04:	540000c0 	b.eq	40001c1c <cbvprintf+0x70>  // b.none
			OUTC(*fp++);
    40001c08:	aa1503e1 	mov	x1, x21
			OUTC('%');
    40001c0c:	d63f0280 	blr	x20
    40001c10:	37f883e0 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40001c14:	9100077b 	add	x27, x27, #0x1
		if (bps == NULL) {
    40001c18:	14000195 	b	4000226c <cbvprintf+0x6c0>
	if (*sp == '%') {
    40001c1c:	39400440 	ldrb	w0, [x2, #1]
		} state = {
    40001c20:	a90b7fff 	stp	xzr, xzr, [sp, #176]
	if (*sp == '%') {
    40001c24:	7100941f 	cmp	w0, #0x25
		} state = {
    40001c28:	a90c7fff 	stp	xzr, xzr, [sp, #192]
	if (*sp == '%') {
    40001c2c:	540006a1 	b.ne	40001d00 <cbvprintf+0x154>  // b.any
		conv->specifier = *sp++;
    40001c30:	91000856 	add	x22, x2, #0x2
    40001c34:	39030fe0 	strb	w0, [sp, #195]
		if (conv->width_star) {
    40001c38:	794183e0 	ldrh	w0, [sp, #192]
    40001c3c:	36402900 	tbz	w0, #8, 4000215c <cbvprintf+0x5b0>
			width = va_arg(ap, int);
    40001c40:	37f8279c 	tbnz	w28, #31, 40002130 <cbvprintf+0x584>
    40001c44:	91002e61 	add	x1, x19, #0xb
    40001c48:	aa1303e0 	mov	x0, x19
    40001c4c:	927df033 	and	x19, x1, #0xfffffffffffffff8
    40001c50:	b9400017 	ldr	w23, [x0]
			if (width < 0) {
    40001c54:	36f800b7 	tbz	w23, #31, 40001c68 <cbvprintf+0xbc>
				conv->flag_dash = true;
    40001c58:	794183e0 	ldrh	w0, [sp, #192]
				width = -width;
    40001c5c:	4b1703f7 	neg	w23, w23
				conv->flag_dash = true;
    40001c60:	321e0000 	orr	w0, w0, #0x4
    40001c64:	790183e0 	strh	w0, [sp, #192]
		if (conv->prec_star) {
    40001c68:	794183e0 	ldrh	w0, [sp, #192]
    40001c6c:	36502960 	tbz	w0, #10, 40002198 <cbvprintf+0x5ec>
			int arg = va_arg(ap, int);
    40001c70:	37f827fc 	tbnz	w28, #31, 4000216c <cbvprintf+0x5c0>
    40001c74:	91002e61 	add	x1, x19, #0xb
    40001c78:	aa1303e0 	mov	x0, x19
    40001c7c:	927df033 	and	x19, x1, #0xfffffffffffffff8
    40001c80:	b9400009 	ldr	w9, [x0]
			if (arg < 0) {
    40001c84:	36f800a9 	tbz	w9, #31, 40001c98 <cbvprintf+0xec>
				conv->prec_present = false;
    40001c88:	794183e0 	ldrh	w0, [sp, #192]
		int precision = -1;
    40001c8c:	12800009 	mov	w9, #0xffffffff            	// #-1
				conv->prec_present = false;
    40001c90:	12167800 	and	w0, w0, #0xfffffdff
    40001c94:	790183e0 	strh	w0, [sp, #192]
		    && (conv->specifier_cat == SPECIFIER_FP)
    40001c98:	39430be0 	ldrb	w0, [sp, #194]
		conv->pad0_value = 0;
    40001c9c:	f80c43ff 	stur	xzr, [sp, #196]
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT)
    40001ca0:	12000800 	and	w0, w0, #0x7
    40001ca4:	7100101f 	cmp	w0, #0x4
    40001ca8:	f94063e3 	ldr	x3, [sp, #192]
    40001cac:	54000101 	b.ne	40001ccc <cbvprintf+0x120>  // b.any
		    && !conv->prec_present) {
    40001cb0:	7217007f 	tst	w3, #0x200
    40001cb4:	540000c1 	b.ne	40001ccc <cbvprintf+0x120>  // b.any
			if (conv->specifier_a) {
    40001cb8:	79c183e0 	ldrsh	w0, [sp, #192]
				precision = 6;
    40001cbc:	528001a9 	mov	w9, #0xd                   	// #13
    40001cc0:	7100001f 	cmp	w0, #0x0
    40001cc4:	528000c0 	mov	w0, #0x6                   	// #6
    40001cc8:	1a80b129 	csel	w9, w9, w0, lt  // lt = tstop
		enum specifier_cat_enum specifier_cat
    40001ccc:	53104860 	ubfx	w0, w3, #16, #3
			= (enum length_mod_enum)conv->length_mod;
    40001cd0:	530b3861 	ubfx	w1, w3, #11, #4
		if (specifier_cat == SPECIFIER_SINT) {
    40001cd4:	7100041f 	cmp	w0, #0x1
    40001cd8:	54002ce1 	b.ne	40002274 <cbvprintf+0x6c8>  // b.any
			switch (length_mod) {
    40001cdc:	51000c24 	sub	w4, w1, #0x3
    40001ce0:	7100109f 	cmp	w4, #0x4
    40001ce4:	54002628 	b.hi	400021a8 <cbvprintf+0x5fc>  // b.pmore
    40001ce8:	d0000080 	adrp	x0, 40013000 <shell_cmd_kernel>
    40001cec:	913e6000 	add	x0, x0, #0xf98
    40001cf0:	78645800 	ldrh	w0, [x0, w4, uxtw #1]
    40001cf4:	10000064 	adr	x4, 40001d00 <cbvprintf+0x154>
    40001cf8:	8b20a880 	add	x0, x4, w0, sxth #2
    40001cfc:	d61f0000 	br	x0
    40001d00:	52800003 	mov	w3, #0x0                   	// #0
    40001d04:	52800005 	mov	w5, #0x0                   	// #0
    40001d08:	52800004 	mov	w4, #0x0                   	// #0
    40001d0c:	52800006 	mov	w6, #0x0                   	// #0
    40001d10:	52800001 	mov	w1, #0x0                   	// #0
		switch (*sp) {
    40001d14:	394002c0 	ldrb	w0, [x22]
    40001d18:	7100ac1f 	cmp	w0, #0x2b
    40001d1c:	540009a0 	b.eq	40001e50 <cbvprintf+0x2a4>  // b.none
    40001d20:	540008c8 	b.hi	40001e38 <cbvprintf+0x28c>  // b.pmore
    40001d24:	7100801f 	cmp	w0, #0x20
    40001d28:	540009a0 	b.eq	40001e5c <cbvprintf+0x2b0>  // b.none
    40001d2c:	71008c1f 	cmp	w0, #0x23
    40001d30:	540009a0 	b.eq	40001e64 <cbvprintf+0x2b8>  // b.none
    40001d34:	34000081 	cbz	w1, 40001d44 <cbvprintf+0x198>
    40001d38:	794183e1 	ldrh	w1, [sp, #192]
    40001d3c:	321e0021 	orr	w1, w1, #0x4
    40001d40:	790183e1 	strh	w1, [sp, #192]
    40001d44:	34000086 	cbz	w6, 40001d54 <cbvprintf+0x1a8>
    40001d48:	794183e1 	ldrh	w1, [sp, #192]
    40001d4c:	321d0021 	orr	w1, w1, #0x8
    40001d50:	790183e1 	strh	w1, [sp, #192]
    40001d54:	34000084 	cbz	w4, 40001d64 <cbvprintf+0x1b8>
    40001d58:	794183e1 	ldrh	w1, [sp, #192]
    40001d5c:	321c0021 	orr	w1, w1, #0x10
    40001d60:	790183e1 	strh	w1, [sp, #192]
    40001d64:	34000085 	cbz	w5, 40001d74 <cbvprintf+0x1c8>
    40001d68:	794183e1 	ldrh	w1, [sp, #192]
    40001d6c:	321b0021 	orr	w1, w1, #0x20
    40001d70:	790183e1 	strh	w1, [sp, #192]
    40001d74:	34000083 	cbz	w3, 40001d84 <cbvprintf+0x1d8>
    40001d78:	794183e1 	ldrh	w1, [sp, #192]
    40001d7c:	321a0021 	orr	w1, w1, #0x40
    40001d80:	790183e1 	strh	w1, [sp, #192]
	if (conv->flag_zero && conv->flag_dash) {
    40001d84:	b940c3e1 	ldr	w1, [sp, #192]
    40001d88:	52800883 	mov	w3, #0x44                  	// #68
    40001d8c:	0a030021 	and	w1, w1, w3
    40001d90:	6b03003f 	cmp	w1, w3
    40001d94:	54000081 	b.ne	40001da4 <cbvprintf+0x1f8>  // b.any
		conv->flag_zero = false;
    40001d98:	794183e1 	ldrh	w1, [sp, #192]
    40001d9c:	12197821 	and	w1, w1, #0xffffffbf
    40001da0:	790183e1 	strh	w1, [sp, #192]
	conv->width_present = true;
    40001da4:	794183e3 	ldrh	w3, [sp, #192]
	if (*sp == '*') {
    40001da8:	7100a81f 	cmp	w0, #0x2a
	conv->width_present = true;
    40001dac:	32190061 	orr	w1, w3, #0x80
    40001db0:	790183e1 	strh	w1, [sp, #192]
	if (*sp == '*') {
    40001db4:	54000861 	b.ne	40001ec0 <cbvprintf+0x314>  // b.any
			++sp;
    40001db8:	910006c1 	add	x1, x22, #0x1
		conv->width_star = true;
    40001dbc:	32190463 	orr	w3, w3, #0x180
    40001dc0:	790183e3 	strh	w3, [sp, #192]
	conv->prec_present = (*sp == '.');
    40001dc4:	39400020 	ldrb	w0, [x1]
    40001dc8:	7100b81f 	cmp	w0, #0x2e
    40001dcc:	794183e0 	ldrh	w0, [sp, #192]
    40001dd0:	1a9f17e3 	cset	w3, eq  // eq = none
    40001dd4:	33170060 	bfi	w0, w3, #9, #1
    40001dd8:	790183e0 	strh	w0, [sp, #192]
	if (!conv->prec_present) {
    40001ddc:	54000841 	b.ne	40001ee4 <cbvprintf+0x338>  // b.any
	if (*sp == '*') {
    40001de0:	39400423 	ldrb	w3, [x1, #1]
    40001de4:	7100a87f 	cmp	w3, #0x2a
    40001de8:	54000780 	b.eq	40001ed8 <cbvprintf+0x32c>  // b.none
	++sp;
    40001dec:	91000421 	add	x1, x1, #0x1
	size_t val = 0;
    40001df0:	d2800000 	mov	x0, #0x0                   	// #0
		val = 10U * val + *sp++ - '0';
    40001df4:	d2800146 	mov	x6, #0xa                   	// #10
	while (isdigit((int)(unsigned char)*sp)) {
    40001df8:	aa0103e3 	mov	x3, x1
    40001dfc:	38401464 	ldrb	w4, [x3], #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    40001e00:	5100c085 	sub	w5, w4, #0x30
    40001e04:	710024bf 	cmp	w5, #0x9
    40001e08:	54000c49 	b.ls	40001f90 <cbvprintf+0x3e4>  // b.plast
	conv->unsupported |= ((conv->prec_value < 0)
    40001e0c:	f94063e3 	ldr	x3, [sp, #192]
	conv->prec_value = prec;
    40001e10:	b900cbe0 	str	w0, [sp, #200]
	conv->unsupported |= ((conv->prec_value < 0)
    40001e14:	53010463 	ubfx	w3, w3, #1, #1
			      || (prec != (size_t)conv->prec_value));
    40001e18:	37f80c60 	tbnz	w0, #31, 40001fa4 <cbvprintf+0x3f8>
    40001e1c:	eb20c01f 	cmp	x0, w0, sxtw
    40001e20:	1a9f07e0 	cset	w0, ne  // ne = any
	conv->unsupported |= ((conv->prec_value < 0)
    40001e24:	2a000060 	orr	w0, w3, w0
    40001e28:	794183e3 	ldrh	w3, [sp, #192]
    40001e2c:	331f0003 	bfi	w3, w0, #1, #1
    40001e30:	790183e3 	strh	w3, [sp, #192]
	return sp;
    40001e34:	1400002c 	b	40001ee4 <cbvprintf+0x338>
		switch (*sp) {
    40001e38:	7100b41f 	cmp	w0, #0x2d
    40001e3c:	54000180 	b.eq	40001e6c <cbvprintf+0x2c0>  // b.none
    40001e40:	7100c01f 	cmp	w0, #0x30
    40001e44:	54fff781 	b.ne	40001d34 <cbvprintf+0x188>  // b.any
			conv->flag_zero = true;
    40001e48:	52800023 	mov	w3, #0x1                   	// #1
    40001e4c:	14000002 	b	40001e54 <cbvprintf+0x2a8>
			conv->flag_plus = true;
    40001e50:	52800026 	mov	w6, #0x1                   	// #1
			++sp;
    40001e54:	910006d6 	add	x22, x22, #0x1
	} while (loop);
    40001e58:	17ffffaf 	b	40001d14 <cbvprintf+0x168>
			conv->flag_space = true;
    40001e5c:	52800024 	mov	w4, #0x1                   	// #1
    40001e60:	17fffffd 	b	40001e54 <cbvprintf+0x2a8>
			conv->flag_hash = true;
    40001e64:	52800025 	mov	w5, #0x1                   	// #1
    40001e68:	17fffffb 	b	40001e54 <cbvprintf+0x2a8>
		switch (*sp) {
    40001e6c:	52800021 	mov	w1, #0x1                   	// #1
    40001e70:	17fffff9 	b	40001e54 <cbvprintf+0x2a8>
		val = 10U * val + *sp++ - '0';
    40001e74:	9b067c00 	mul	x0, x0, x6
    40001e78:	aa0303e1 	mov	x1, x3
    40001e7c:	d100c000 	sub	x0, x0, #0x30
    40001e80:	8b240000 	add	x0, x0, w4, uxtb
	while (isdigit((int)(unsigned char)*sp)) {
    40001e84:	aa0103e3 	mov	x3, x1
    40001e88:	38401464 	ldrb	w4, [x3], #1
    40001e8c:	5100c085 	sub	w5, w4, #0x30
    40001e90:	710024bf 	cmp	w5, #0x9
    40001e94:	54ffff09 	b.ls	40001e74 <cbvprintf+0x2c8>  // b.plast
	if (sp != wp) {
    40001e98:	eb0102df 	cmp	x22, x1
    40001e9c:	54fff940 	b.eq	40001dc4 <cbvprintf+0x218>  // b.none
		conv->width_value = width;
    40001ea0:	b900c7e0 	str	w0, [sp, #196]
				      || (width != (size_t)conv->width_value));
    40001ea4:	37f80160 	tbnz	w0, #31, 40001ed0 <cbvprintf+0x324>
    40001ea8:	eb20c01f 	cmp	x0, w0, sxtw
    40001eac:	1a9f07e3 	cset	w3, ne  // ne = any
		conv->unsupported |= ((conv->width_value < 0)
    40001eb0:	794183e0 	ldrh	w0, [sp, #192]
    40001eb4:	331f0060 	bfi	w0, w3, #1, #1
    40001eb8:	790183e0 	strh	w0, [sp, #192]
    40001ebc:	17ffffc2 	b	40001dc4 <cbvprintf+0x218>
    40001ec0:	aa1603e1 	mov	x1, x22
	size_t val = 0;
    40001ec4:	d2800000 	mov	x0, #0x0                   	// #0
		val = 10U * val + *sp++ - '0';
    40001ec8:	d2800146 	mov	x6, #0xa                   	// #10
    40001ecc:	17ffffee 	b	40001e84 <cbvprintf+0x2d8>
				      || (width != (size_t)conv->width_value));
    40001ed0:	52800023 	mov	w3, #0x1                   	// #1
    40001ed4:	17fffff7 	b	40001eb0 <cbvprintf+0x304>
		return ++sp;
    40001ed8:	91000821 	add	x1, x1, #0x2
		conv->prec_star = true;
    40001edc:	32160000 	orr	w0, w0, #0x400
    40001ee0:	790183e0 	strh	w0, [sp, #192]
	switch (*sp) {
    40001ee4:	aa0103f6 	mov	x22, x1
    40001ee8:	384016c0 	ldrb	w0, [x22], #1
    40001eec:	7101b01f 	cmp	w0, #0x6c
    40001ef0:	54000860 	b.eq	40001ffc <cbvprintf+0x450>  // b.none
    40001ef4:	540005c8 	b.hi	40001fac <cbvprintf+0x400>  // b.pmore
    40001ef8:	7101a01f 	cmp	w0, #0x68
    40001efc:	54000660 	b.eq	40001fc8 <cbvprintf+0x41c>  // b.none
    40001f00:	7101a81f 	cmp	w0, #0x6a
    40001f04:	540008c0 	b.eq	4000201c <cbvprintf+0x470>  // b.none
    40001f08:	7101301f 	cmp	w0, #0x4c
    40001f0c:	54000940 	b.eq	40002034 <cbvprintf+0x488>  // b.none
    40001f10:	aa0103f6 	mov	x22, x1
	conv->specifier = *sp++;
    40001f14:	384016c0 	ldrb	w0, [x22], #1
    40001f18:	39030fe0 	strb	w0, [sp, #195]
	switch (conv->specifier) {
    40001f1c:	7101e01f 	cmp	w0, #0x78
    40001f20:	54001008 	b.hi	40002120 <cbvprintf+0x574>  // b.pmore
    40001f24:	71015c1f 	cmp	w0, #0x57
    40001f28:	54000928 	b.hi	4000204c <cbvprintf+0x4a0>  // b.pmore
    40001f2c:	7101041f 	cmp	w0, #0x41
    40001f30:	540000a0 	b.eq	40001f44 <cbvprintf+0x398>  // b.none
    40001f34:	51011401 	sub	w1, w0, #0x45
    40001f38:	12001c21 	and	w1, w1, #0xff
    40001f3c:	7100083f 	cmp	w1, #0x2
    40001f40:	54000f08 	b.hi	40002120 <cbvprintf+0x574>  // b.pmore
			|| (conv->specifier == 'A');
    40001f44:	121a7800 	and	w0, w0, #0xffffffdf
		conv->specifier_a = (conv->specifier == 'a')
    40001f48:	784c13e1 	ldurh	w1, [sp, #193]
			|| (conv->specifier == 'A');
    40001f4c:	7101041f 	cmp	w0, #0x41
    40001f50:	1a9f17e0 	cset	w0, eq  // eq = none
		conv->specifier_a = (conv->specifier == 'a')
    40001f54:	12156c21 	and	w1, w1, #0xfffff87f
    40001f58:	53196000 	lsl	w0, w0, #7
    40001f5c:	32160000 	orr	w0, w0, #0x400
    40001f60:	2a010000 	orr	w0, w0, w1
    40001f64:	780c13e0 	sturh	w0, [sp, #193]
		if (conv->specifier_a
    40001f68:	79c183e1 	ldrsh	w1, [sp, #192]
    40001f6c:	794183e0 	ldrh	w0, [sp, #192]
    40001f70:	37f80dc1 	tbnz	w1, #31, 40002128 <cbvprintf+0x57c>
		if (conv->length_mod == LENGTH_L) {
    40001f74:	12150c03 	and	w3, w0, #0x7800
    40001f78:	52830001 	mov	w1, #0x1800                	// #6144
    40001f7c:	6b01007f 	cmp	w3, w1
    40001f80:	54000a61 	b.ne	400020cc <cbvprintf+0x520>  // b.any
			conv->length_mod = LENGTH_NONE;
    40001f84:	12116c00 	and	w0, w0, #0xffff87ff
    40001f88:	790183e0 	strh	w0, [sp, #192]
    40001f8c:	14000045 	b	400020a0 <cbvprintf+0x4f4>
		val = 10U * val + *sp++ - '0';
    40001f90:	9b067c00 	mul	x0, x0, x6
    40001f94:	aa0303e1 	mov	x1, x3
    40001f98:	d100c000 	sub	x0, x0, #0x30
    40001f9c:	8b240000 	add	x0, x0, w4, uxtb
    40001fa0:	17ffff96 	b	40001df8 <cbvprintf+0x24c>
			      || (prec != (size_t)conv->prec_value));
    40001fa4:	52800020 	mov	w0, #0x1                   	// #1
    40001fa8:	17ffff9f 	b	40001e24 <cbvprintf+0x278>
	switch (*sp) {
    40001fac:	7101d01f 	cmp	w0, #0x74
    40001fb0:	540003c0 	b.eq	40002028 <cbvprintf+0x47c>  // b.none
    40001fb4:	7101e81f 	cmp	w0, #0x7a
    40001fb8:	54fffac1 	b.ne	40001f10 <cbvprintf+0x364>  // b.any
		conv->length_mod = LENGTH_Z;
    40001fbc:	794183e0 	ldrh	w0, [sp, #192]
    40001fc0:	528000c1 	mov	w1, #0x6                   	// #6
    40001fc4:	1400000b 	b	40001ff0 <cbvprintf+0x444>
		if (*++sp == 'h') {
    40001fc8:	39400420 	ldrb	w0, [x1, #1]
    40001fcc:	7101a01f 	cmp	w0, #0x68
    40001fd0:	794183e0 	ldrh	w0, [sp, #192]
    40001fd4:	540000c1 	b.ne	40001fec <cbvprintf+0x440>  // b.any
			conv->length_mod = LENGTH_HH;
    40001fd8:	52800023 	mov	w3, #0x1                   	// #1
			conv->length_mod = LENGTH_LL;
    40001fdc:	33150c60 	bfi	w0, w3, #11, #4
			++sp;
    40001fe0:	91000836 	add	x22, x1, #0x2
			conv->length_mod = LENGTH_LL;
    40001fe4:	790183e0 	strh	w0, [sp, #192]
			++sp;
    40001fe8:	17ffffcb 	b	40001f14 <cbvprintf+0x368>
			conv->length_mod = LENGTH_H;
    40001fec:	52800041 	mov	w1, #0x2                   	// #2
		conv->length_mod = LENGTH_T;
    40001ff0:	33150c20 	bfi	w0, w1, #11, #4
		conv->unsupported = true;
    40001ff4:	790183e0 	strh	w0, [sp, #192]
		break;
    40001ff8:	17ffffc7 	b	40001f14 <cbvprintf+0x368>
		if (*++sp == 'l') {
    40001ffc:	39400420 	ldrb	w0, [x1, #1]
    40002000:	7101b01f 	cmp	w0, #0x6c
    40002004:	794183e0 	ldrh	w0, [sp, #192]
    40002008:	54000061 	b.ne	40002014 <cbvprintf+0x468>  // b.any
			conv->length_mod = LENGTH_LL;
    4000200c:	52800083 	mov	w3, #0x4                   	// #4
    40002010:	17fffff3 	b	40001fdc <cbvprintf+0x430>
			conv->length_mod = LENGTH_L;
    40002014:	52800061 	mov	w1, #0x3                   	// #3
    40002018:	17fffff6 	b	40001ff0 <cbvprintf+0x444>
		conv->length_mod = LENGTH_J;
    4000201c:	794183e0 	ldrh	w0, [sp, #192]
    40002020:	528000a1 	mov	w1, #0x5                   	// #5
    40002024:	17fffff3 	b	40001ff0 <cbvprintf+0x444>
		conv->length_mod = LENGTH_T;
    40002028:	794183e0 	ldrh	w0, [sp, #192]
    4000202c:	528000e1 	mov	w1, #0x7                   	// #7
    40002030:	17fffff0 	b	40001ff0 <cbvprintf+0x444>
		conv->unsupported = true;
    40002034:	794183e0 	ldrh	w0, [sp, #192]
    40002038:	128f0041 	mov	w1, #0xffff87fd            	// #-30723
    4000203c:	0a010000 	and	w0, w0, w1
    40002040:	52880041 	mov	w1, #0x4002                	// #16386
    40002044:	2a010000 	orr	w0, w0, w1
    40002048:	17ffffeb 	b	40001ff4 <cbvprintf+0x448>
	switch (conv->specifier) {
    4000204c:	51016003 	sub	w3, w0, #0x58
    40002050:	7100807f 	cmp	w3, #0x20
    40002054:	54000668 	b.hi	40002120 <cbvprintf+0x574>  // b.pmore
    40002058:	b0000081 	adrp	x1, 40013000 <shell_cmd_kernel>
    4000205c:	913e9021 	add	x1, x1, #0xfa4
    40002060:	38634821 	ldrb	w1, [x1, w3, uxtw]
    40002064:	10000063 	adr	x3, 40002070 <cbvprintf+0x4c4>
    40002068:	8b218861 	add	x1, x3, w1, sxtb #2
    4000206c:	d61f0020 	br	x1
		conv->specifier_cat = SPECIFIER_SINT;
    40002070:	39430be1 	ldrb	w1, [sp, #194]
    40002074:	52800023 	mov	w3, #0x1                   	// #1
		conv->specifier_cat = SPECIFIER_UINT;
    40002078:	33000861 	bfxil	w1, w3, #0, #3
    4000207c:	39030be1 	strb	w1, [sp, #194]
		if (conv->length_mod == LENGTH_UPPER_L) {
    40002080:	794183e1 	ldrh	w1, [sp, #192]
    40002084:	12150c23 	and	w3, w1, #0x7800
    40002088:	7140107f 	cmp	w3, #0x4, lsl #12
    4000208c:	54000061 	b.ne	40002098 <cbvprintf+0x4ec>  // b.any
			conv->invalid = true;
    40002090:	32000021 	orr	w1, w1, #0x1
    40002094:	790183e1 	strh	w1, [sp, #192]
		if (conv->specifier == 'c') {
    40002098:	71018c1f 	cmp	w0, #0x63
    4000209c:	540003a0 	b.eq	40002110 <cbvprintf+0x564>  // b.none
	bool unsupported = false;
    400020a0:	52800000 	mov	w0, #0x0                   	// #0
	conv->unsupported |= unsupported;
    400020a4:	f94063e1 	ldr	x1, [sp, #192]
    400020a8:	d3410421 	ubfx	x1, x1, #1, #1
    400020ac:	2a010000 	orr	w0, w0, w1
    400020b0:	794183e1 	ldrh	w1, [sp, #192]
    400020b4:	331f0001 	bfi	w1, w0, #1, #1
    400020b8:	790183e1 	strh	w1, [sp, #192]
	return sp;
    400020bc:	17fffedf 	b	40001c38 <cbvprintf+0x8c>
		conv->specifier_cat = SPECIFIER_UINT;
    400020c0:	39430be1 	ldrb	w1, [sp, #194]
    400020c4:	52800043 	mov	w3, #0x2                   	// #2
    400020c8:	17ffffec 	b	40002078 <cbvprintf+0x4cc>
		} else if ((conv->length_mod != LENGTH_NONE)
    400020cc:	7215081f 	tst	w0, #0x3800
    400020d0:	54fffe80 	b.eq	400020a0 <cbvprintf+0x4f4>  // b.none
		conv->invalid = true;
    400020d4:	32000000 	orr	w0, w0, #0x1
    400020d8:	17ffffac 	b	40001f88 <cbvprintf+0x3dc>
		conv->specifier_cat = SPECIFIER_PTR;
    400020dc:	39430be0 	ldrb	w0, [sp, #194]
    400020e0:	52800061 	mov	w1, #0x3                   	// #3
    400020e4:	33000820 	bfxil	w0, w1, #0, #3
    400020e8:	39030be0 	strb	w0, [sp, #194]
		if (conv->length_mod == LENGTH_UPPER_L) {
    400020ec:	794183e0 	ldrh	w0, [sp, #192]
    400020f0:	12150c00 	and	w0, w0, #0x7800
    400020f4:	7140101f 	cmp	w0, #0x4, lsl #12
    400020f8:	1a9f17e0 	cset	w0, eq  // eq = none
    400020fc:	17ffffea 	b	400020a4 <cbvprintf+0x4f8>
		conv->specifier_cat = SPECIFIER_PTR;
    40002100:	39430be0 	ldrb	w0, [sp, #194]
    40002104:	52800061 	mov	w1, #0x3                   	// #3
    40002108:	33000820 	bfxil	w0, w1, #0, #3
    4000210c:	39030be0 	strb	w0, [sp, #194]
		if (conv->length_mod != LENGTH_NONE) {
    40002110:	794183e0 	ldrh	w0, [sp, #192]
    40002114:	72150c1f 	tst	w0, #0x7800
    40002118:	1a9f07e0 	cset	w0, ne  // ne = any
    4000211c:	17ffffe2 	b	400020a4 <cbvprintf+0x4f8>
		conv->invalid = true;
    40002120:	794183e0 	ldrh	w0, [sp, #192]
    40002124:	17ffffec 	b	400020d4 <cbvprintf+0x528>
			unsupported = true;
    40002128:	52800020 	mov	w0, #0x1                   	// #1
    4000212c:	17ffffde 	b	400020a4 <cbvprintf+0x4f8>
			width = va_arg(ap, int);
    40002130:	11002381 	add	w1, w28, #0x8
    40002134:	7100003f 	cmp	w1, #0x0
    40002138:	540000cd 	b.le	40002150 <cbvprintf+0x5a4>
    4000213c:	91002e63 	add	x3, x19, #0xb
    40002140:	aa1303e0 	mov	x0, x19
    40002144:	2a0103fc 	mov	w28, w1
    40002148:	927df073 	and	x19, x3, #0xfffffffffffffff8
    4000214c:	17fffec1 	b	40001c50 <cbvprintf+0xa4>
    40002150:	8b3cc300 	add	x0, x24, w28, sxtw
    40002154:	2a0103fc 	mov	w28, w1
    40002158:	17fffebe 	b	40001c50 <cbvprintf+0xa4>
			width = conv->width_value;
    4000215c:	b940c7f7 	ldr	w23, [sp, #196]
    40002160:	f279001f 	tst	x0, #0x80
    40002164:	5a9f12f7 	csinv	w23, w23, wzr, ne  // ne = any
    40002168:	17fffec0 	b	40001c68 <cbvprintf+0xbc>
			int arg = va_arg(ap, int);
    4000216c:	11002381 	add	w1, w28, #0x8
    40002170:	7100003f 	cmp	w1, #0x0
    40002174:	540000cd 	b.le	4000218c <cbvprintf+0x5e0>
    40002178:	91002e63 	add	x3, x19, #0xb
    4000217c:	aa1303e0 	mov	x0, x19
    40002180:	2a0103fc 	mov	w28, w1
    40002184:	927df073 	and	x19, x3, #0xfffffffffffffff8
    40002188:	17fffebe 	b	40001c80 <cbvprintf+0xd4>
    4000218c:	8b3cc300 	add	x0, x24, w28, sxtw
    40002190:	2a0103fc 	mov	w28, w1
    40002194:	17fffebb 	b	40001c80 <cbvprintf+0xd4>
			precision = conv->prec_value;
    40002198:	b940cbe9 	ldr	w9, [sp, #200]
    4000219c:	f277001f 	tst	x0, #0x200
    400021a0:	5a9f1129 	csinv	w9, w9, wzr, ne  // ne = any
    400021a4:	17fffebd 	b	40001c98 <cbvprintf+0xec>
				value->sint = va_arg(ap, int);
    400021a8:	37f8019c 	tbnz	w28, #31, 400021d8 <cbvprintf+0x62c>
    400021ac:	91002e60 	add	x0, x19, #0xb
    400021b0:	2a1c03e4 	mov	w4, w28
    400021b4:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400021b8:	b9800265 	ldrsw	x5, [x19]
				value->sint =
    400021bc:	f9005be5 	str	x5, [sp, #176]
				break;
    400021c0:	2a0403fc 	mov	w28, w4
    400021c4:	aa0003f3 	mov	x19, x0
			if (length_mod == LENGTH_HH) {
    400021c8:	7100043f 	cmp	w1, #0x1
    400021cc:	54000361 	b.ne	40002238 <cbvprintf+0x68c>  // b.any
				value->uint = (unsigned char)value->uint;
    400021d0:	3942c3e0 	ldrb	w0, [sp, #176]
    400021d4:	1400001c 	b	40002244 <cbvprintf+0x698>
				value->sint = va_arg(ap, int);
    400021d8:	11002384 	add	w4, w28, #0x8
    400021dc:	7100009f 	cmp	w4, #0x0
    400021e0:	5400008d 	b.le	400021f0 <cbvprintf+0x644>
    400021e4:	91002e60 	add	x0, x19, #0xb
    400021e8:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400021ec:	17fffff3 	b	400021b8 <cbvprintf+0x60c>
    400021f0:	aa1303e0 	mov	x0, x19
    400021f4:	8b3cc313 	add	x19, x24, w28, sxtw
    400021f8:	17fffff0 	b	400021b8 <cbvprintf+0x60c>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    400021fc:	37f800dc 	tbnz	w28, #31, 40002214 <cbvprintf+0x668>
    40002200:	91003e60 	add	x0, x19, #0xf
    40002204:	2a1c03e4 	mov	w4, w28
    40002208:	927df000 	and	x0, x0, #0xfffffffffffffff8
				value->sint =
    4000220c:	f9400265 	ldr	x5, [x19]
    40002210:	17ffffeb 	b	400021bc <cbvprintf+0x610>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    40002214:	11002384 	add	w4, w28, #0x8
    40002218:	7100009f 	cmp	w4, #0x0
    4000221c:	5400008d 	b.le	4000222c <cbvprintf+0x680>
    40002220:	91003e60 	add	x0, x19, #0xf
    40002224:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002228:	17fffff9 	b	4000220c <cbvprintf+0x660>
    4000222c:	aa1303e0 	mov	x0, x19
    40002230:	8b3cc313 	add	x19, x24, w28, sxtw
    40002234:	17fffff6 	b	4000220c <cbvprintf+0x660>
			} else if (length_mod == LENGTH_H) {
    40002238:	7100083f 	cmp	w1, #0x2
    4000223c:	54000061 	b.ne	40002248 <cbvprintf+0x69c>  // b.any
				value->sint = (short)value->sint;
    40002240:	798163e0 	ldrsh	x0, [sp, #176]
				value->uint = (unsigned short)value->uint;
    40002244:	f9005be0 	str	x0, [sp, #176]
		if (conv->invalid || conv->unsupported) {
    40002248:	b940c3e0 	ldr	w0, [sp, #192]
    4000224c:	f240041f 	tst	x0, #0x3
    40002250:	540011c0 	b.eq	40002488 <cbvprintf+0x8dc>  // b.none
			OUTS(sp, fp);
    40002254:	aa1603e3 	mov	x3, x22
    40002258:	aa1503e1 	mov	x1, x21
    4000225c:	aa1403e0 	mov	x0, x20
    40002260:	97fffe37 	bl	40001b3c <outs>
    40002264:	37f85140 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002268:	8b20c37b 	add	x27, x27, w0, sxtw
			while (pad_len-- > 0) {
    4000226c:	aa1603e2 	mov	x2, x22
    40002270:	17fffe5f 	b	40001bec <cbvprintf+0x40>
		} else if (specifier_cat == SPECIFIER_UINT) {
    40002274:	7100081f 	cmp	w0, #0x2
    40002278:	54000881 	b.ne	40002388 <cbvprintf+0x7dc>  // b.any
			switch (length_mod) {
    4000227c:	51000c24 	sub	w4, w1, #0x3
    40002280:	7100109f 	cmp	w4, #0x4
    40002284:	540000e8 	b.hi	400022a0 <cbvprintf+0x6f4>  // b.pmore
    40002288:	b0000080 	adrp	x0, 40013000 <shell_cmd_kernel>
    4000228c:	913f2000 	add	x0, x0, #0xfc8
    40002290:	38644800 	ldrb	w0, [x0, w4, uxtw]
    40002294:	10000064 	adr	x4, 400022a0 <cbvprintf+0x6f4>
    40002298:	8b208880 	add	x0, x4, w0, sxtb #2
    4000229c:	d61f0000 	br	x0
				value->uint = va_arg(ap, unsigned int);
    400022a0:	37f801dc 	tbnz	w28, #31, 400022d8 <cbvprintf+0x72c>
    400022a4:	91002e60 	add	x0, x19, #0xb
    400022a8:	2a1c03e4 	mov	w4, w28
    400022ac:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400022b0:	b9400265 	ldr	w5, [x19]
				value->uint =
    400022b4:	f9005be5 	str	x5, [sp, #176]
				break;
    400022b8:	2a0403fc 	mov	w28, w4
    400022bc:	aa0003f3 	mov	x19, x0
			if (length_mod == LENGTH_HH) {
    400022c0:	7100043f 	cmp	w1, #0x1
    400022c4:	54fff860 	b.eq	400021d0 <cbvprintf+0x624>  // b.none
			} else if (length_mod == LENGTH_H) {
    400022c8:	7100083f 	cmp	w1, #0x2
    400022cc:	54fffbe1 	b.ne	40002248 <cbvprintf+0x69c>  // b.any
				value->uint = (unsigned short)value->uint;
    400022d0:	794163e0 	ldrh	w0, [sp, #176]
    400022d4:	17ffffdc 	b	40002244 <cbvprintf+0x698>
				value->uint = va_arg(ap, unsigned int);
    400022d8:	11002384 	add	w4, w28, #0x8
    400022dc:	7100009f 	cmp	w4, #0x0
    400022e0:	5400008d 	b.le	400022f0 <cbvprintf+0x744>
    400022e4:	91002e60 	add	x0, x19, #0xb
    400022e8:	927df000 	and	x0, x0, #0xfffffffffffffff8
    400022ec:	17fffff1 	b	400022b0 <cbvprintf+0x704>
    400022f0:	aa1303e0 	mov	x0, x19
    400022f4:	8b3cc313 	add	x19, x24, w28, sxtw
    400022f8:	17ffffee 	b	400022b0 <cbvprintf+0x704>
				if ((!WCHAR_IS_SIGNED)
    400022fc:	39430fe0 	ldrb	w0, [sp, #195]
    40002300:	71018c1f 	cmp	w0, #0x63
    40002304:	54000a41 	b.ne	4000244c <cbvprintf+0x8a0>  // b.any
					value->uint = (wchar_t)va_arg(ap,
    40002308:	37f8011c 	tbnz	w28, #31, 40002328 <cbvprintf+0x77c>
    4000230c:	91002e60 	add	x0, x19, #0xb
    40002310:	2a1c03e4 	mov	w4, w28
    40002314:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002318:	b9400265 	ldr	w5, [x19]
			value->ptr = va_arg(ap, void *);
    4000231c:	2a0403fc 	mov	w28, w4
    40002320:	f9005be5 	str	x5, [sp, #176]
    40002324:	1400003a 	b	4000240c <cbvprintf+0x860>
					value->uint = (wchar_t)va_arg(ap,
    40002328:	11002384 	add	w4, w28, #0x8
    4000232c:	7100009f 	cmp	w4, #0x0
    40002330:	5400008d 	b.le	40002340 <cbvprintf+0x794>
    40002334:	91002e60 	add	x0, x19, #0xb
    40002338:	927df000 	and	x0, x0, #0xfffffffffffffff8
    4000233c:	17fffff7 	b	40002318 <cbvprintf+0x76c>
    40002340:	aa1303e0 	mov	x0, x19
    40002344:	8b3cc313 	add	x19, x24, w28, sxtw
    40002348:	17fffff4 	b	40002318 <cbvprintf+0x76c>
					(uint_value_type)va_arg(ap, size_t);
    4000234c:	37f800dc 	tbnz	w28, #31, 40002364 <cbvprintf+0x7b8>
    40002350:	91003e60 	add	x0, x19, #0xf
    40002354:	2a1c03e4 	mov	w4, w28
    40002358:	927df000 	and	x0, x0, #0xfffffffffffffff8
				value->uint =
    4000235c:	f9400265 	ldr	x5, [x19]
    40002360:	17ffffd5 	b	400022b4 <cbvprintf+0x708>
					(uint_value_type)va_arg(ap, size_t);
    40002364:	11002384 	add	w4, w28, #0x8
    40002368:	7100009f 	cmp	w4, #0x0
    4000236c:	5400008d 	b.le	4000237c <cbvprintf+0x7d0>
    40002370:	91003e60 	add	x0, x19, #0xf
    40002374:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002378:	17fffff9 	b	4000235c <cbvprintf+0x7b0>
    4000237c:	aa1303e0 	mov	x0, x19
    40002380:	8b3cc313 	add	x19, x24, w28, sxtw
    40002384:	17fffff6 	b	4000235c <cbvprintf+0x7b0>
		} else if (specifier_cat == SPECIFIER_FP) {
    40002388:	7100101f 	cmp	w0, #0x4
    4000238c:	540005c1 	b.ne	40002444 <cbvprintf+0x898>  // b.any
				value->ldbl = va_arg(ap, long double);
    40002390:	b9407be0 	ldr	w0, [sp, #120]
			if (length_mod == LENGTH_UPPER_L) {
    40002394:	7100203f 	cmp	w1, #0x8
    40002398:	540002c1 	b.ne	400023f0 <cbvprintf+0x844>  // b.any
				value->ldbl = va_arg(ap, long double);
    4000239c:	37f80120 	tbnz	w0, #31, 400023c0 <cbvprintf+0x814>
    400023a0:	91003e60 	add	x0, x19, #0xf
    400023a4:	b9407be4 	ldr	w4, [sp, #120]
    400023a8:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    400023ac:	91004013 	add	x19, x0, #0x10
    400023b0:	3dc00000 	ldr	q0, [x0]
    400023b4:	b9007be4 	str	w4, [sp, #120]
    400023b8:	3d802fe0 	str	q0, [sp, #176]
    400023bc:	17ffffa3 	b	40002248 <cbvprintf+0x69c>
    400023c0:	b9407be0 	ldr	w0, [sp, #120]
    400023c4:	11004004 	add	w4, w0, #0x10
    400023c8:	7100009f 	cmp	w4, #0x0
    400023cc:	540000ad 	b.le	400023e0 <cbvprintf+0x834>
    400023d0:	91003e60 	add	x0, x19, #0xf
    400023d4:	927cec00 	and	x0, x0, #0xfffffffffffffff0
    400023d8:	91004013 	add	x19, x0, #0x10
    400023dc:	17fffff5 	b	400023b0 <cbvprintf+0x804>
    400023e0:	f94037e5 	ldr	x5, [sp, #104]
    400023e4:	b9407be0 	ldr	w0, [sp, #120]
    400023e8:	8b20c0a0 	add	x0, x5, w0, sxtw
    400023ec:	17fffff1 	b	400023b0 <cbvprintf+0x804>
				value->dbl = va_arg(ap, double);
    400023f0:	37f80120 	tbnz	w0, #31, 40002414 <cbvprintf+0x868>
    400023f4:	91003e60 	add	x0, x19, #0xf
    400023f8:	b9407be4 	ldr	w4, [sp, #120]
    400023fc:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002400:	fd400260 	ldr	d0, [x19]
    40002404:	b9007be4 	str	w4, [sp, #120]
    40002408:	fd005be0 	str	d0, [sp, #176]
			value->ptr = va_arg(ap, void *);
    4000240c:	aa0003f3 	mov	x19, x0
    40002410:	17ffff8e 	b	40002248 <cbvprintf+0x69c>
				value->dbl = va_arg(ap, double);
    40002414:	b9407be0 	ldr	w0, [sp, #120]
    40002418:	11004004 	add	w4, w0, #0x10
    4000241c:	7100009f 	cmp	w4, #0x0
    40002420:	5400008d 	b.le	40002430 <cbvprintf+0x884>
    40002424:	91003e60 	add	x0, x19, #0xf
    40002428:	927df000 	and	x0, x0, #0xfffffffffffffff8
    4000242c:	17fffff5 	b	40002400 <cbvprintf+0x854>
    40002430:	f94037e6 	ldr	x6, [sp, #104]
    40002434:	aa1303e0 	mov	x0, x19
    40002438:	b9407be5 	ldr	w5, [sp, #120]
    4000243c:	8b25c0d3 	add	x19, x6, w5, sxtw
    40002440:	17fffff0 	b	40002400 <cbvprintf+0x854>
		} else if (specifier_cat == SPECIFIER_PTR) {
    40002444:	71000c1f 	cmp	w0, #0x3
    40002448:	54fff001 	b.ne	40002248 <cbvprintf+0x69c>  // b.any
			value->ptr = va_arg(ap, void *);
    4000244c:	37f800dc 	tbnz	w28, #31, 40002464 <cbvprintf+0x8b8>
    40002450:	91003e60 	add	x0, x19, #0xf
    40002454:	2a1c03e4 	mov	w4, w28
    40002458:	927df000 	and	x0, x0, #0xfffffffffffffff8
    4000245c:	f9400265 	ldr	x5, [x19]
    40002460:	17ffffaf 	b	4000231c <cbvprintf+0x770>
    40002464:	11002384 	add	w4, w28, #0x8
    40002468:	7100009f 	cmp	w4, #0x0
    4000246c:	5400008d 	b.le	4000247c <cbvprintf+0x8d0>
    40002470:	91003e60 	add	x0, x19, #0xf
    40002474:	927df000 	and	x0, x0, #0xfffffffffffffff8
    40002478:	17fffff9 	b	4000245c <cbvprintf+0x8b0>
    4000247c:	aa1303e0 	mov	x0, x19
    40002480:	8b3cc313 	add	x19, x24, w28, sxtw
    40002484:	17fffff6 	b	4000245c <cbvprintf+0x8b0>
		switch (conv->specifier) {
    40002488:	39430fe5 	ldrb	w5, [sp, #195]
    4000248c:	7101e0bf 	cmp	w5, #0x78
    40002490:	54ffeee8 	b.hi	4000226c <cbvprintf+0x6c0>  // b.pmore
    40002494:	71015cbf 	cmp	w5, #0x57
    40002498:	54000468 	b.hi	40002524 <cbvprintf+0x978>  // b.pmore
    4000249c:	710094bf 	cmp	w5, #0x25
    400024a0:	54000540 	b.eq	40002548 <cbvprintf+0x99c>  // b.none
    400024a4:	710090bf 	cmp	w5, #0x24
    400024a8:	54ffee29 	b.ls	4000226c <cbvprintf+0x6c0>  // b.plast
    400024ac:	710104bf 	cmp	w5, #0x41
    400024b0:	540000a0 	b.eq	400024c4 <cbvprintf+0x918>  // b.none
    400024b4:	510114a0 	sub	w0, w5, #0x45
    400024b8:	12001c00 	and	w0, w0, #0xff
    400024bc:	7100081f 	cmp	w0, #0x2
    400024c0:	54ffed68 	b.hi	4000226c <cbvprintf+0x6c0>  // b.pmore
	} u = {
    400024c4:	f9405be0 	ldr	x0, [sp, #176]
	if ((u.u64 & SIGN_MASK) != 0U) {
    400024c8:	b7f81240 	tbnz	x0, #63, 40002710 <cbvprintf+0xb64>
	} else if (conv->flag_plus) {
    400024cc:	794183e4 	ldrh	w4, [sp, #192]
    400024d0:	37181244 	tbnz	w4, #3, 40002718 <cbvprintf+0xb6c>
		*sign = ' ';
    400024d4:	d3441084 	ubfx	x4, x4, #4, #1
    400024d8:	531b6884 	lsl	w4, w4, #5
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    400024dc:	d374f801 	ubfx	x1, x0, #52, #11
	uint64_t fract = u.u64 & BIT64_MASK(FRACTION_BITS);
    400024e0:	9240cc00 	and	x0, x0, #0xfffffffffffff
    400024e4:	f90047e0 	str	x0, [sp, #136]
	if (expo == BIT_MASK(EXPONENT_BITS)) {
    400024e8:	711ffc3f 	cmp	w1, #0x7ff
    400024ec:	54001341 	b.ne	40002754 <cbvprintf+0xba8>  // b.any
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    400024f0:	510104a5 	sub	w5, w5, #0x41
			if (isupper((int)c)) {
    400024f4:	710064bf 	cmp	w5, #0x19
		if (fract == 0) {
    400024f8:	b50011c0 	cbnz	x0, 40002730 <cbvprintf+0xb84>
			if (isupper((int)c)) {
    400024fc:	54001128 	b.hi	40002720 <cbvprintf+0xb74>  // b.pmore
				*buf++ = 'I';
    40002500:	5289c920 	mov	w0, #0x4e49                	// #20041
    40002504:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'F';
    40002508:	528008c0 	mov	w0, #0x46                  	// #70
				*buf++ = 'n';
    4000250c:	39024be0 	strb	w0, [sp, #146]
		*bpe = buf;
    40002510:	91024ff9 	add	x25, sp, #0x93
		conv->flag_zero = false;
    40002514:	794183e0 	ldrh	w0, [sp, #192]
    40002518:	12197800 	and	w0, w0, #0xffffffbf
    4000251c:	790183e0 	strh	w0, [sp, #192]
		return bps;
    40002520:	1400001d 	b	40002594 <cbvprintf+0x9e8>
		switch (conv->specifier) {
    40002524:	510160a2 	sub	w2, w5, #0x58
    40002528:	7100805f 	cmp	w2, #0x20
    4000252c:	54ffea08 	b.hi	4000226c <cbvprintf+0x6c0>  // b.pmore
    40002530:	b0000080 	adrp	x0, 40013000 <shell_cmd_kernel>
    40002534:	913f4000 	add	x0, x0, #0xfd0
    40002538:	78625800 	ldrh	w0, [x0, w2, uxtw #1]
    4000253c:	10000062 	adr	x2, 40002548 <cbvprintf+0x99c>
    40002540:	8b20a840 	add	x0, x2, w0, sxth #2
    40002544:	d61f0000 	br	x0
			OUTC('%');
    40002548:	aa1503e1 	mov	x1, x21
    4000254c:	2a0503e0 	mov	w0, w5
    40002550:	17fffdaf 	b	40001c0c <cbvprintf+0x60>
			bps = (const char *)value->ptr;
    40002554:	f9405bfa 	ldr	x26, [sp, #176]
			if (precision >= 0) {
    40002558:	37f80109 	tbnz	w9, #31, 40002578 <cbvprintf+0x9cc>
				len = strnlen(bps, precision);
    4000255c:	93407d21 	sxtw	x1, w9
    40002560:	aa1a03e0 	mov	x0, x26
    40002564:	9400259a 	bl	4000bbcc <strnlen>
			bpe = bps + len;
    40002568:	8b000359 	add	x25, x26, x0
		char sign = 0;
    4000256c:	52800004 	mov	w4, #0x0                   	// #0
		if (bps == NULL) {
    40002570:	b500015a 	cbnz	x26, 40002598 <cbvprintf+0x9ec>
    40002574:	17ffff3e 	b	4000226c <cbvprintf+0x6c0>
				len = strlen(bps);
    40002578:	aa1a03e0 	mov	x0, x26
    4000257c:	9400258d 	bl	4000bbb0 <strlen>
    40002580:	17fffffa 	b	40002568 <cbvprintf+0x9bc>
			bpe = buf + 1;
    40002584:	910247f9 	add	x25, sp, #0x91
		char sign = 0;
    40002588:	52800004 	mov	w4, #0x0                   	// #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    4000258c:	f9405be0 	ldr	x0, [sp, #176]
    40002590:	390243e0 	strb	w0, [sp, #144]
				bps = encode_float(value->dbl, conv, precision,
    40002594:	910243fa 	add	x26, sp, #0x90
		size_t nj_len = (bpe - bps);
    40002598:	cb1a0320 	sub	x0, x25, x26
		if (sign != 0) {
    4000259c:	34000044 	cbz	w4, 400025a4 <cbvprintf+0x9f8>
			nj_len += 1U;
    400025a0:	91000400 	add	x0, x0, #0x1
		if (conv->altform_0c) {
    400025a4:	39430be5 	ldrb	w5, [sp, #194]
    400025a8:	36202b85 	tbz	w5, #4, 40002b18 <cbvprintf+0xf6c>
			nj_len += 2U;
    400025ac:	91000800 	add	x0, x0, #0x2
		nj_len += conv->pad0_value;
    400025b0:	b980c7e1 	ldrsw	x1, [sp, #196]
    400025b4:	8b000020 	add	x0, x1, x0
		if (conv->pad_fp) {
    400025b8:	36300065 	tbz	w5, #6, 400025c4 <cbvprintf+0xa18>
			nj_len += conv->pad0_pre_exp;
    400025bc:	b980cbe1 	ldrsw	x1, [sp, #200]
    400025c0:	8b010000 	add	x0, x0, x1
		if (width > 0) {
    400025c4:	710002ff 	cmp	w23, #0x0
    400025c8:	54002c8d 	b.le	40002b58 <cbvprintf+0xfac>
			width -= (int)nj_len;
    400025cc:	4b0002f7 	sub	w23, w23, w0
			if (!conv->flag_dash) {
    400025d0:	f94063e0 	ldr	x0, [sp, #192]
    400025d4:	721e001f 	tst	w0, #0x4
    400025d8:	54002c01 	b.ne	40002b58 <cbvprintf+0xfac>  // b.any
				if (conv->flag_zero) {
    400025dc:	794183e0 	ldrh	w0, [sp, #192]
    400025e0:	36303080 	tbz	w0, #6, 40002bf0 <cbvprintf+0x1044>
					if (sign != 0) {
    400025e4:	340000e4 	cbz	w4, 40002600 <cbvprintf+0xa54>
						OUTC(sign);
    400025e8:	aa1503e1 	mov	x1, x21
    400025ec:	2a0403e0 	mov	w0, w4
    400025f0:	d63f0280 	blr	x20
    400025f4:	37f834c0 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    400025f8:	9100077b 	add	x27, x27, #0x1
						sign = 0;
    400025fc:	52800004 	mov	w4, #0x0                   	// #0
					pad = '0';
    40002600:	52800605 	mov	w5, #0x30                  	// #48
    40002604:	1400017c 	b	40002bf4 <cbvprintf+0x1048>
			if (conv->flag_plus) {
    40002608:	794183e4 	ldrh	w4, [sp, #192]
    4000260c:	37180384 	tbnz	w4, #3, 4000267c <cbvprintf+0xad0>
				sign = ' ';
    40002610:	d3441084 	ubfx	x4, x4, #4, #1
    40002614:	531b6884 	lsl	w4, w4, #5
			sint = value->sint;
    40002618:	f9405be0 	ldr	x0, [sp, #176]
			if (sint < 0) {
    4000261c:	b6f80080 	tbz	x0, #63, 4000262c <cbvprintf+0xa80>
				value->uint = (uint_value_type)-sint;
    40002620:	cb0003e0 	neg	x0, x0
				sign = '-';
    40002624:	528005a4 	mov	w4, #0x2d                  	// #45
				value->uint = (uint_value_type)-sint;
    40002628:	f9005be0 	str	x0, [sp, #176]
			bps = encode_uint(value->uint, conv, buf, bpe);
    4000262c:	f9405be0 	ldr	x0, [sp, #176]
    40002630:	9102a7e3 	add	x3, sp, #0xa9
    40002634:	910243e2 	add	x2, sp, #0x90
    40002638:	910303e1 	add	x1, sp, #0xc0
    4000263c:	b90073e4 	str	w4, [sp, #112]
    40002640:	97fffd0e 	bl	40001a78 <encode_uint>
    40002644:	aa0003fa 	mov	x26, x0
    40002648:	b94073e4 	ldr	w4, [sp, #112]
			if (precision >= 0) {
    4000264c:	9102a7e3 	add	x3, sp, #0xa9
    40002650:	37f80129 	tbnz	w9, #31, 40002674 <cbvprintf+0xac8>
				conv->flag_zero = false;
    40002654:	794183e1 	ldrh	w1, [sp, #192]
				size_t len = bpe - bps;
    40002658:	cb1a0060 	sub	x0, x3, x26
				if (len < (size_t)precision) {
    4000265c:	eb29c01f 	cmp	x0, w9, sxtw
				conv->flag_zero = false;
    40002660:	12197821 	and	w1, w1, #0xffffffbf
    40002664:	790183e1 	strh	w1, [sp, #192]
				if (len < (size_t)precision) {
    40002668:	54000062 	b.cs	40002674 <cbvprintf+0xac8>  // b.hs, b.nlast
					conv->pad0_value = precision - (int)len;
    4000266c:	4b000120 	sub	w0, w9, w0
    40002670:	b900c7e0 	str	w0, [sp, #196]
		const char *bpe = buf + sizeof(buf);
    40002674:	aa0303f9 	mov	x25, x3
    40002678:	17ffffbe 	b	40002570 <cbvprintf+0x9c4>
				sign = '+';
    4000267c:	52800564 	mov	w4, #0x2b                  	// #43
    40002680:	17ffffe6 	b	40002618 <cbvprintf+0xa6c>
		switch (conv->specifier) {
    40002684:	52800004 	mov	w4, #0x0                   	// #0
    40002688:	17ffffe9 	b	4000262c <cbvprintf+0xa80>
			if (value->ptr != NULL) {
    4000268c:	f9405be0 	ldr	x0, [sp, #176]
    40002690:	b4002380 	cbz	x0, 40002b00 <cbvprintf+0xf54>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    40002694:	910303e1 	add	x1, sp, #0xc0
    40002698:	9102a7e3 	add	x3, sp, #0xa9
    4000269c:	910243e2 	add	x2, sp, #0x90
    400026a0:	97fffcf6 	bl	40001a78 <encode_uint>
    400026a4:	aa0003fa 	mov	x26, x0
				conv->altform_0c = true;
    400026a8:	794187e0 	ldrh	w0, [sp, #194]
    400026ac:	52801de1 	mov	w1, #0xef                  	// #239
		char sign = 0;
    400026b0:	52800004 	mov	w4, #0x0                   	// #0
				conv->altform_0c = true;
    400026b4:	0a010000 	and	w0, w0, w1
    400026b8:	528f0201 	mov	w1, #0x7810                	// #30736
    400026bc:	2a010000 	orr	w0, w0, w1
    400026c0:	790187e0 	strh	w0, [sp, #194]
				goto prec_int_pad0;
    400026c4:	17ffffe2 	b	4000264c <cbvprintf+0xaa0>
				store_count(conv, value->ptr, count);
    400026c8:	93407f60 	sxtw	x0, w27
	switch ((enum length_mod_enum)conv->length_mod) {
    400026cc:	71001c3f 	cmp	w1, #0x7
				store_count(conv, value->ptr, count);
    400026d0:	f9405be2 	ldr	x2, [sp, #176]
	switch ((enum length_mod_enum)conv->length_mod) {
    400026d4:	54ffdcc8 	b.hi	4000226c <cbvprintf+0x6c0>  // b.pmore
    400026d8:	d0000083 	adrp	x3, 40014000 <CSWTCH.135+0x90>
    400026dc:	91005063 	add	x3, x3, #0x14
    400026e0:	38614861 	ldrb	w1, [x3, w1, uxtw]
    400026e4:	10000063 	adr	x3, 400026f0 <cbvprintf+0xb44>
    400026e8:	8b218861 	add	x1, x3, w1, sxtb #2
    400026ec:	d61f0020 	br	x1
		*(int *)dp = count;
    400026f0:	b9000040 	str	w0, [x2]
		break;
    400026f4:	17fffede 	b	4000226c <cbvprintf+0x6c0>
		*(signed char *)dp = (signed char)count;
    400026f8:	3900005b 	strb	w27, [x2]
		break;
    400026fc:	17fffedc 	b	4000226c <cbvprintf+0x6c0>
		*(short *)dp = (short)count;
    40002700:	7900005b 	strh	w27, [x2]
		break;
    40002704:	17fffeda 	b	4000226c <cbvprintf+0x6c0>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    40002708:	f9000040 	str	x0, [x2]
		break;
    4000270c:	17fffed8 	b	4000226c <cbvprintf+0x6c0>
		*sign = '-';
    40002710:	528005a4 	mov	w4, #0x2d                  	// #45
    40002714:	17ffff72 	b	400024dc <cbvprintf+0x930>
		*sign = '+';
    40002718:	52800564 	mov	w4, #0x2b                  	// #43
    4000271c:	17ffff70 	b	400024dc <cbvprintf+0x930>
				*buf++ = 'i';
    40002720:	528dcd20 	mov	w0, #0x6e69                	// #28265
    40002724:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'f';
    40002728:	52800cc0 	mov	w0, #0x66                  	// #102
    4000272c:	17ffff78 	b	4000250c <cbvprintf+0x960>
			if (isupper((int)c)) {
    40002730:	540000a8 	b.hi	40002744 <cbvprintf+0xb98>  // b.pmore
				*buf++ = 'N';
    40002734:	528829c0 	mov	w0, #0x414e                	// #16718
    40002738:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'N';
    4000273c:	528009c0 	mov	w0, #0x4e                  	// #78
    40002740:	17ffff73 	b	4000250c <cbvprintf+0x960>
				*buf++ = 'n';
    40002744:	528c2dc0 	mov	w0, #0x616e                	// #24942
    40002748:	790123e0 	strh	w0, [sp, #144]
				*buf++ = 'n';
    4000274c:	52800dc0 	mov	w0, #0x6e                  	// #110
    40002750:	17ffff6f 	b	4000250c <cbvprintf+0x960>
		c = 'f';
    40002754:	52800cc2 	mov	w2, #0x66                  	// #102
    40002758:	710118bf 	cmp	w5, #0x46
    4000275c:	1a8210a5 	csel	w5, w5, w2, ne  // ne = any
	fract <<= EXPONENT_BITS;
    40002760:	d375d002 	lsl	x2, x0, #11
	fract &= ~SIGN_MASK;
    40002764:	f90047e2 	str	x2, [sp, #136]
	if ((expo | fract) != 0) {
    40002768:	93407c26 	sxtw	x6, w1
    4000276c:	aa0200c6 	orr	x6, x6, x2
    40002770:	b4000f66 	cbz	x6, 4000295c <cbvprintf+0xdb0>
	bool is_subnormal = (expo == 0) && (fract != 0);
    40002774:	7100003f 	cmp	w1, #0x0
		if (is_subnormal) {
    40002778:	fa400804 	ccmp	x0, #0x0, #0x4, eq  // eq = none
    4000277c:	54000c61 	b.ne	40002908 <cbvprintf+0xd5c>  // b.any
		fract |= BIT_63;
    40002780:	f94047e2 	ldr	x2, [sp, #136]
		expo -= (1023 - 1);	/* +1 since .1 vs 1. */
    40002784:	510ff821 	sub	w1, w1, #0x3fe
		fract |= BIT_63;
    40002788:	52800000 	mov	w0, #0x0                   	// #0
    4000278c:	52800006 	mov	w6, #0x0                   	// #0
    40002790:	b2410042 	orr	x2, x2, #0x8000000000000000
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    40002794:	3200e7e7 	mov	w7, #0x33333333            	// #858993459
		fract |= BIT_63;
    40002798:	f90047e2 	str	x2, [sp, #136]
	while (expo < -2) {
    4000279c:	3100083f 	cmn	w1, #0x2
    400027a0:	54000b8b 	b.lt	40002910 <cbvprintf+0xd64>  // b.tstop
    400027a4:	34000040 	cbz	w0, 400027ac <cbvprintf+0xc00>
    400027a8:	f90047e2 	str	x2, [sp, #136]
    400027ac:	f94047e0 	ldr	x0, [sp, #136]
		decexp--;
    400027b0:	52800002 	mov	w2, #0x0                   	// #0
	*v /= 5U;
    400027b4:	d28000a7 	mov	x7, #0x5                   	// #5
	while (expo > 0) {
    400027b8:	7100003f 	cmp	w1, #0x0
    400027bc:	54000bec 	b.gt	40002938 <cbvprintf+0xd8c>
    400027c0:	34000042 	cbz	w2, 400027c8 <cbvprintf+0xc1c>
    400027c4:	f90047e0 	str	x0, [sp, #136]
	fract >>= (4 - expo);
    400027c8:	52800080 	mov	w0, #0x4                   	// #4
    400027cc:	4b010000 	sub	w0, w0, w1
    400027d0:	f94047e1 	ldr	x1, [sp, #136]
    400027d4:	9ac02421 	lsr	x1, x1, x0
	if ((c == 'g') || (c == 'G')) {
    400027d8:	121a78a0 	and	w0, w5, #0xffffffdf
    400027dc:	12001c00 	and	w0, w0, #0xff
    400027e0:	71011c1f 	cmp	w0, #0x47
    400027e4:	54000c81 	b.ne	40002974 <cbvprintf+0xdc8>  // b.any
		if (decexp < (-4 + 1) || decexp > precision) {
    400027e8:	6b06013f 	cmp	w9, w6
    400027ec:	3a43a8c1 	ccmn	w6, #0x3, #0x1, ge  // ge = tcont
    400027f0:	54000bca 	b.ge	40002968 <cbvprintf+0xdbc>  // b.tcont
				precision--;
    400027f4:	7100013f 	cmp	w9, #0x0
			c += 'e' - 'g';  /* e or E */
    400027f8:	510008a5 	sub	w5, w5, #0x2
				precision--;
    400027fc:	1a9fd7e0 	cset	w0, gt
			c += 'e' - 'g';  /* e or E */
    40002800:	12001ca5 	and	w5, w5, #0xff
				precision--;
    40002804:	4b000129 	sub	w9, w9, w0
		if (!conv->flag_hash && (precision > 0)) {
    40002808:	721b007f 	tst	w3, #0x20
    4000280c:	54000b41 	b.ne	40002974 <cbvprintf+0xdc8>  // b.any
    40002810:	7100013f 	cmp	w9, #0x0
    40002814:	1a9fd7e7 	cset	w7, gt
	if (c == 'f') {
    40002818:	710198bf 	cmp	w5, #0x66
    4000281c:	54000b01 	b.ne	4000297c <cbvprintf+0xdd0>  // b.any
		if (decimals < 0) {
    40002820:	2b060120 	adds	w0, w9, w6
    40002824:	54000ae5 	b.pl	40002980 <cbvprintf+0xdd4>  // b.nfrst
			decimals = 0;
    40002828:	52800000 	mov	w0, #0x0                   	// #0
    4000282c:	52800202 	mov	w2, #0x10                  	// #16
	*v /= 5U;
    40002830:	d28000a3 	mov	x3, #0x5                   	// #5
    40002834:	b90087e2 	str	w2, [sp, #132]
			decimals = 0;
    40002838:	d2e10002 	mov	x2, #0x800000000000000     	// #576460752303423488
	while (decimals--) {
    4000283c:	51000400 	sub	w0, w0, #0x1
    40002840:	3100041f 	cmn	w0, #0x1
    40002844:	54000a61 	b.ne	40002990 <cbvprintf+0xde4>  // b.any
	fract += round;
    40002848:	8b020021 	add	x1, x1, x2
	if (fract >= BIT64(60)) {
    4000284c:	92fe0000 	mov	x0, #0xfffffffffffffff     	// #1152921504606846975
    40002850:	eb00003f 	cmp	x1, x0
    40002854:	54000a48 	b.hi	4000299c <cbvprintf+0xdf0>  // b.pmore
	fract += round;
    40002858:	f90047e1 	str	x1, [sp, #136]
	if (c == 'f') {
    4000285c:	710198bf 	cmp	w5, #0x66
    40002860:	54000b21 	b.ne	400029c4 <cbvprintf+0xe18>  // b.any
		if (decexp > 0) {
    40002864:	710000df 	cmp	w6, #0x0
    40002868:	54000a6d 	b.le	400029b4 <cbvprintf+0xe08>
	char *buf = bps;
    4000286c:	910243f9 	add	x25, sp, #0x90
				*buf++ = _get_digit(&fract, &digit_count);
    40002870:	910213e1 	add	x1, sp, #0x84
    40002874:	910223e0 	add	x0, sp, #0x88
    40002878:	97fffc70 	bl	40001a38 <_get_digit>
    4000287c:	38001720 	strb	w0, [x25], #1
			while (decexp > 0 && digit_count > 0) {
    40002880:	b94087e0 	ldr	w0, [sp, #132]
				decexp--;
    40002884:	510004c6 	sub	w6, w6, #0x1
			while (decexp > 0 && digit_count > 0) {
    40002888:	7100001f 	cmp	w0, #0x0
    4000288c:	7a40c8c4 	ccmp	w6, #0x0, #0x4, gt
    40002890:	54ffff0c 	b.gt	40002870 <cbvprintf+0xcc4>
			conv->pad0_value = decexp;
    40002894:	b900c7e6 	str	w6, [sp, #196]
			decexp = 0;
    40002898:	52800006 	mov	w6, #0x0                   	// #0
		if (conv->flag_hash || (precision > 0)) {
    4000289c:	794183e0 	ldrh	w0, [sp, #192]
    400028a0:	37280060 	tbnz	w0, #5, 400028ac <cbvprintf+0xd00>
    400028a4:	7100013f 	cmp	w9, #0x0
    400028a8:	54000c2d 	b.le	40002a2c <cbvprintf+0xe80>
			*buf++ = '.';
    400028ac:	aa1903e3 	mov	x3, x25
    400028b0:	528005c0 	mov	w0, #0x2e                  	// #46
		if (decexp < 0 && precision > 0) {
    400028b4:	710000df 	cmp	w6, #0x0
    400028b8:	7a40b924 	ccmp	w9, #0x0, #0x4, lt  // lt = tstop
			*buf++ = '.';
    400028bc:	38001460 	strb	w0, [x3], #1
		if (decexp < 0 && precision > 0) {
    400028c0:	5400016d 	b.le	400028ec <cbvprintf+0xd40>
			conv->pad0_value = -decexp;
    400028c4:	4b0603e1 	neg	w1, w6
			conv->pad_postdp = (conv->pad0_value > 0);
    400028c8:	39430be0 	ldrb	w0, [sp, #194]
			conv->pad0_value = -decexp;
    400028cc:	6b01013f 	cmp	w9, w1
    400028d0:	1a81b121 	csel	w1, w9, w1, lt  // lt = tstop
    400028d4:	b900c7e1 	str	w1, [sp, #196]
			conv->pad_postdp = (conv->pad0_value > 0);
    400028d8:	7100003f 	cmp	w1, #0x0
			precision -= conv->pad0_value;
    400028dc:	4b010129 	sub	w9, w9, w1
			conv->pad_postdp = (conv->pad0_value > 0);
    400028e0:	1a9fd7e1 	cset	w1, gt
    400028e4:	331b0020 	bfi	w0, w1, #5, #1
    400028e8:	39030be0 	strb	w0, [sp, #194]
			*buf++ = '.';
    400028ec:	aa0303f9 	mov	x25, x3
    400028f0:	1400004a 	b	40002a18 <cbvprintf+0xe6c>
				expo--;
    400028f4:	51000421 	sub	w1, w1, #0x1
			while (((fract <<= 1) & BIT_63) == 0) {
    400028f8:	d37ff842 	lsl	x2, x2, #1
    400028fc:	b6ffffc2 	tbz	x2, #63, 400028f4 <cbvprintf+0xd48>
    40002900:	f90047e2 	str	x2, [sp, #136]
    40002904:	17ffff9f 	b	40002780 <cbvprintf+0xbd4>
	int expo = (u.u64 >> FRACTION_BITS) & BIT_MASK(EXPONENT_BITS);
    40002908:	52800001 	mov	w1, #0x0                   	// #0
    4000290c:	17fffffb 	b	400028f8 <cbvprintf+0xd4c>
			expo++;
    40002910:	2a0103e8 	mov	w8, w1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    40002914:	eb4284ff 	cmp	x7, x2, lsr #33
			expo++;
    40002918:	11000421 	add	w1, w1, #0x1
		} while ((uint32_t)(fract >> 32) >= (UINT32_MAX / 5U));
    4000291c:	d341fc42 	lsr	x2, x2, #1
    40002920:	54ffff89 	b.ls	40002910 <cbvprintf+0xd64>  // b.plast
		fract *= 5U;
    40002924:	8b020842 	add	x2, x2, x2, lsl #2
		expo++;
    40002928:	11000901 	add	w1, w8, #0x2
		decexp--;
    4000292c:	510004c6 	sub	w6, w6, #0x1
    40002930:	52800020 	mov	w0, #0x1                   	// #1
    40002934:	17ffff9a 	b	4000279c <cbvprintf+0xbf0>
		fract += 2;
    40002938:	91000800 	add	x0, x0, #0x2
		expo--;
    4000293c:	51000421 	sub	w1, w1, #0x1
		decexp++;
    40002940:	110004c6 	add	w6, w6, #0x1
    40002944:	52800022 	mov	w2, #0x1                   	// #1
	*v /= 5U;
    40002948:	9ac70800 	udiv	x0, x0, x7
			fract <<= 1;
    4000294c:	d37ff800 	lsl	x0, x0, #1
			expo--;
    40002950:	51000421 	sub	w1, w1, #0x1
		} while (!(fract & BIT_63));
    40002954:	b6ffffc0 	tbz	x0, #63, 4000294c <cbvprintf+0xda0>
    40002958:	17ffff98 	b	400027b8 <cbvprintf+0xc0c>
    4000295c:	52800006 	mov	w6, #0x0                   	// #0
    40002960:	52800001 	mov	w1, #0x0                   	// #0
    40002964:	17ffff99 	b	400027c8 <cbvprintf+0xc1c>
			precision -= decexp;
    40002968:	4b060129 	sub	w9, w9, w6
			c = 'f';
    4000296c:	52800cc5 	mov	w5, #0x66                  	// #102
    40002970:	17ffffa6 	b	40002808 <cbvprintf+0xc5c>
	bool prune_zero = false;
    40002974:	52800007 	mov	w7, #0x0                   	// #0
    40002978:	17ffffa8 	b	40002818 <cbvprintf+0xc6c>
		decimals = precision + 1;
    4000297c:	11000520 	add	w0, w9, #0x1
	if (decimals > 16) {
    40002980:	7100401f 	cmp	w0, #0x10
    40002984:	52800202 	mov	w2, #0x10                  	// #16
    40002988:	1a82d000 	csel	w0, w0, w2, le
    4000298c:	17ffffa8 	b	4000282c <cbvprintf+0xc80>
	*v >>= 1;
    40002990:	d341fc42 	lsr	x2, x2, #1
	*v /= 5U;
    40002994:	9ac30842 	udiv	x2, x2, x3
}
    40002998:	17ffffa9 	b	4000283c <cbvprintf+0xc90>
	*v >>= 1;
    4000299c:	d341fc21 	lsr	x1, x1, #1
	*v /= 5U;
    400029a0:	d28000a0 	mov	x0, #0x5                   	// #5
		decexp++;
    400029a4:	110004c6 	add	w6, w6, #0x1
	*v /= 5U;
    400029a8:	9ac00821 	udiv	x1, x1, x0
    400029ac:	f90047e1 	str	x1, [sp, #136]
		decexp++;
    400029b0:	17ffffab 	b	4000285c <cbvprintf+0xcb0>
			*buf++ = '0';
    400029b4:	52800600 	mov	w0, #0x30                  	// #48
    400029b8:	910247f9 	add	x25, sp, #0x91
    400029bc:	390243e0 	strb	w0, [sp, #144]
    400029c0:	17ffffb7 	b	4000289c <cbvprintf+0xcf0>
		*buf = _get_digit(&fract, &digit_count);
    400029c4:	910213e1 	add	x1, sp, #0x84
    400029c8:	910223e0 	add	x0, sp, #0x88
    400029cc:	97fffc1b 	bl	40001a38 <_get_digit>
    400029d0:	12001c01 	and	w1, w0, #0xff
			decexp--;
    400029d4:	7100c03f 	cmp	w1, #0x30
		*buf = _get_digit(&fract, &digit_count);
    400029d8:	390243e0 	strb	w0, [sp, #144]
			decexp--;
    400029dc:	1a9f07e0 	cset	w0, ne  // ne = any
    400029e0:	4b0000c6 	sub	w6, w6, w0
		if (conv->flag_hash || (precision > 0)) {
    400029e4:	794183e0 	ldrh	w0, [sp, #192]
    400029e8:	37280060 	tbnz	w0, #5, 400029f4 <cbvprintf+0xe48>
    400029ec:	7100013f 	cmp	w9, #0x0
    400029f0:	540006cd 	b.le	40002ac8 <cbvprintf+0xf1c>
			*buf++ = '.';
    400029f4:	528005c0 	mov	w0, #0x2e                  	// #46
    400029f8:	91024be3 	add	x3, sp, #0x92
    400029fc:	390247e0 	strb	w0, [sp, #145]
    40002a00:	17ffffbb 	b	400028ec <cbvprintf+0xd40>
		precision--;
    40002a04:	51000529 	sub	w9, w9, #0x1
		*buf++ = _get_digit(&fract, &digit_count);
    40002a08:	910213e1 	add	x1, sp, #0x84
    40002a0c:	910223e0 	add	x0, sp, #0x88
    40002a10:	97fffc0a 	bl	40001a38 <_get_digit>
    40002a14:	38001720 	strb	w0, [x25], #1
	while (precision > 0 && digit_count > 0) {
    40002a18:	7100013f 	cmp	w9, #0x0
    40002a1c:	5400008d 	b.le	40002a2c <cbvprintf+0xe80>
    40002a20:	b94087e0 	ldr	w0, [sp, #132]
    40002a24:	7100001f 	cmp	w0, #0x0
    40002a28:	54fffeec 	b.gt	40002a04 <cbvprintf+0xe58>
	if (prune_zero) {
    40002a2c:	35000527 	cbnz	w7, 40002ad0 <cbvprintf+0xf24>
	conv->pad0_pre_exp = precision;
    40002a30:	b900cbe9 	str	w9, [sp, #200]
	if ((c == 'e') || (c == 'E')) {
    40002a34:	121a78a0 	and	w0, w5, #0xffffffdf
    40002a38:	12001c00 	and	w0, w0, #0xff
    40002a3c:	7101141f 	cmp	w0, #0x45
    40002a40:	540002e1 	b.ne	40002a9c <cbvprintf+0xef0>  // b.any
		*buf++ = c;
    40002a44:	aa1903e1 	mov	x1, x25
    40002a48:	38002425 	strb	w5, [x1], #2
		if (decexp < 0) {
    40002a4c:	36f80526 	tbz	w6, #31, 40002af0 <cbvprintf+0xf44>
			decexp = -decexp;
    40002a50:	4b0603e6 	neg	w6, w6
			*buf++ = '-';
    40002a54:	528005a0 	mov	w0, #0x2d                  	// #45
    40002a58:	39000720 	strb	w0, [x25, #1]
		if (decexp >= 100) {
    40002a5c:	71018cdf 	cmp	w6, #0x63
    40002a60:	540000ed 	b.le	40002a7c <cbvprintf+0xed0>
			*buf++ = (decexp / 100) + '0';
    40002a64:	52800c80 	mov	w0, #0x64                  	// #100
    40002a68:	91000f21 	add	x1, x25, #0x3
    40002a6c:	1ac00cc2 	sdiv	w2, w6, w0
			decexp %= 100;
    40002a70:	1b009846 	msub	w6, w2, w0, w6
			*buf++ = (decexp / 100) + '0';
    40002a74:	1100c045 	add	w5, w2, #0x30
    40002a78:	39000b25 	strb	w5, [x25, #2]
		*buf++ = (decexp / 10) + '0';
    40002a7c:	52800142 	mov	w2, #0xa                   	// #10
    40002a80:	aa0103f9 	mov	x25, x1
    40002a84:	1ac20cc0 	sdiv	w0, w6, w2
    40002a88:	1100c005 	add	w5, w0, #0x30
		*buf++ = (decexp % 10) + '0';
    40002a8c:	1b029800 	msub	w0, w0, w2, w6
		*buf++ = (decexp / 10) + '0';
    40002a90:	38002725 	strb	w5, [x25], #2
		*buf++ = (decexp % 10) + '0';
    40002a94:	1100c000 	add	w0, w0, #0x30
    40002a98:	39000420 	strb	w0, [x1, #1]
		|| (conv->pad0_pre_exp > 0);
    40002a9c:	b940c7e0 	ldr	w0, [sp, #196]
    40002aa0:	7100001f 	cmp	w0, #0x0
    40002aa4:	540002ac 	b.gt	40002af8 <cbvprintf+0xf4c>
    40002aa8:	b940cbe0 	ldr	w0, [sp, #200]
    40002aac:	7100001f 	cmp	w0, #0x0
    40002ab0:	1a9fd7e1 	cset	w1, gt
	conv->pad_fp = (conv->pad0_value > 0)
    40002ab4:	39430be0 	ldrb	w0, [sp, #194]
    40002ab8:	331a0020 	bfi	w0, w1, #6, #1
    40002abc:	39030be0 	strb	w0, [sp, #194]
	*buf = 0;
    40002ac0:	3900033f 	strb	wzr, [x25]
	return bps;
    40002ac4:	17fffeb4 	b	40002594 <cbvprintf+0x9e8>
		if (*buf++ != '0') {
    40002ac8:	910247f9 	add	x25, sp, #0x91
    40002acc:	17ffffd8 	b	40002a2c <cbvprintf+0xe80>
		conv->pad0_pre_exp = 0;
    40002ad0:	b900cbff 	str	wzr, [sp, #200]
		while (*--buf == '0') {
    40002ad4:	aa1903e1 	mov	x1, x25
    40002ad8:	385fff20 	ldrb	w0, [x25, #-1]!
    40002adc:	7100c01f 	cmp	w0, #0x30
    40002ae0:	54ffffa0 	b.eq	40002ad4 <cbvprintf+0xf28>  // b.none
		if (*buf != '.') {
    40002ae4:	7100b81f 	cmp	w0, #0x2e
    40002ae8:	9a810339 	csel	x25, x25, x1, eq  // eq = none
    40002aec:	17ffffd2 	b	40002a34 <cbvprintf+0xe88>
			*buf++ = '+';
    40002af0:	52800560 	mov	w0, #0x2b                  	// #43
    40002af4:	17ffffd9 	b	40002a58 <cbvprintf+0xeac>
		|| (conv->pad0_pre_exp > 0);
    40002af8:	52800021 	mov	w1, #0x1                   	// #1
    40002afc:	17ffffee 	b	40002ab4 <cbvprintf+0xf08>
			bpe = bps + 5;
    40002b00:	d0000083 	adrp	x3, 40014000 <CSWTCH.135+0x90>
    40002b04:	91056479 	add	x25, x3, #0x159
			bps = "(nil)";
    40002b08:	d0000082 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40002b0c:	9105505a 	add	x26, x2, #0x154
		char sign = 0;
    40002b10:	52800004 	mov	w4, #0x0                   	// #0
    40002b14:	17fffea1 	b	40002598 <cbvprintf+0x9ec>
		} else if (conv->altform_0) {
    40002b18:	361fd4c5 	tbz	w5, #3, 400025b0 <cbvprintf+0xa04>
			nj_len += 1U;
    40002b1c:	91000400 	add	x0, x0, #0x1
    40002b20:	17fffea4 	b	400025b0 <cbvprintf+0xa04>
					OUTC(pad);
    40002b24:	b90073e5 	str	w5, [sp, #112]
    40002b28:	aa1503e1 	mov	x1, x21
    40002b2c:	b9007fe4 	str	w4, [sp, #124]
    40002b30:	2a0503e0 	mov	w0, w5
    40002b34:	d63f0280 	blr	x20
    40002b38:	37f80aa0 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002b3c:	b94073e5 	ldr	w5, [sp, #112]
    40002b40:	9100077b 	add	x27, x27, #0x1
    40002b44:	b9407fe4 	ldr	w4, [sp, #124]
				while (width-- > 0) {
    40002b48:	2a1703e0 	mov	w0, w23
    40002b4c:	510006f7 	sub	w23, w23, #0x1
    40002b50:	7100001f 	cmp	w0, #0x0
    40002b54:	54fffe8c 	b.gt	40002b24 <cbvprintf+0xf78>
		if (sign != 0) {
    40002b58:	340000c4 	cbz	w4, 40002b70 <cbvprintf+0xfc4>
			OUTC(sign);
    40002b5c:	aa1503e1 	mov	x1, x21
    40002b60:	2a0403e0 	mov	w0, w4
    40002b64:	d63f0280 	blr	x20
    40002b68:	37f80920 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002b6c:	9100077b 	add	x27, x27, #0x1
		if (IS_ENABLED(CONFIG_CBPRINTF_FP_SUPPORT) && conv->pad_fp) {
    40002b70:	39430be0 	ldrb	w0, [sp, #194]
    40002b74:	36300e00 	tbz	w0, #6, 40002d34 <cbvprintf+0x1188>
			if (conv->specifier_a) {
    40002b78:	79c183e0 	ldrsh	w0, [sp, #192]
    40002b7c:	cb1a037b 	sub	x27, x27, x26
    40002b80:	37f80460 	tbnz	w0, #31, 40002c0c <cbvprintf+0x1060>
				while (isdigit((int)*cp)) {
    40002b84:	39400340 	ldrb	w0, [x26]
    40002b88:	8b1b0344 	add	x4, x26, x27
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    40002b8c:	5100c001 	sub	w1, w0, #0x30
    40002b90:	7100243f 	cmp	w1, #0x9
    40002b94:	54000749 	b.ls	40002c7c <cbvprintf+0x10d0>  // b.plast
				if (!conv->pad_postdp) {
    40002b98:	f94063e0 	ldr	x0, [sp, #192]
				pad_len = conv->pad0_value;
    40002b9c:	b940c7fb 	ldr	w27, [sp, #196]
				if (!conv->pad_postdp) {
    40002ba0:	720b001f 	tst	w0, #0x200000
    40002ba4:	540000a1 	b.ne	40002bb8 <cbvprintf+0x100c>  // b.any
					while (pad_len-- > 0) {
    40002ba8:	51000765 	sub	w5, w27, #0x1
    40002bac:	7100037f 	cmp	w27, #0x0
    40002bb0:	540007cc 	b.gt	40002ca8 <cbvprintf+0x10fc>
    40002bb4:	2a0503fb 	mov	w27, w5
				if (*cp == '.') {
    40002bb8:	39400340 	ldrb	w0, [x26]
    40002bbc:	7100b81f 	cmp	w0, #0x2e
    40002bc0:	54000141 	b.ne	40002be8 <cbvprintf+0x103c>  // b.any
    40002bc4:	f9003be4 	str	x4, [sp, #112]
					OUTC(*cp++);
    40002bc8:	aa1503e1 	mov	x1, x21
    40002bcc:	d63f0280 	blr	x20
						OUTC('0');
    40002bd0:	37f805e0 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002bd4:	f9403be4 	ldr	x4, [sp, #112]
					while (pad_len-- > 0) {
    40002bd8:	7100037f 	cmp	w27, #0x0
						OUTC('0');
    40002bdc:	91000484 	add	x4, x4, #0x1
					while (pad_len-- > 0) {
    40002be0:	540007ac 	b.gt	40002cd4 <cbvprintf+0x1128>
					OUTC(*cp++);
    40002be4:	9100075a 	add	x26, x26, #0x1
    40002be8:	cb1a009b 	sub	x27, x4, x26
    40002bec:	14000044 	b	40002cfc <cbvprintf+0x1150>
				char pad = ' ';
    40002bf0:	52800405 	mov	w5, #0x20                  	// #32
					pad = '0';
    40002bf4:	2a1703e0 	mov	w0, w23
    40002bf8:	17ffffd5 	b	40002b4c <cbvprintf+0xfa0>
					OUTC(*cp++);
    40002bfc:	9100075a 	add	x26, x26, #0x1
    40002c00:	aa1503e1 	mov	x1, x21
    40002c04:	d63f0280 	blr	x20
    40002c08:	37f80420 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
				while (*cp != 'p') {
    40002c0c:	39400340 	ldrb	w0, [x26]
    40002c10:	8b1b0341 	add	x1, x26, x27
    40002c14:	7101c01f 	cmp	w0, #0x70
    40002c18:	54ffff21 	b.ne	40002bfc <cbvprintf+0x1050>  // b.any
			while (pad_len-- > 0) {
    40002c1c:	b940cbe4 	ldr	w4, [sp, #200]
    40002c20:	aa0103fb 	mov	x27, x1
    40002c24:	0b010084 	add	w4, w4, w1
    40002c28:	4b1b0080 	sub	w0, w4, w27
    40002c2c:	7100001f 	cmp	w0, #0x0
    40002c30:	5400072c 	b.gt	40002d14 <cbvprintf+0x1168>
			OUTS(bps, bpe);
    40002c34:	aa1903e3 	mov	x3, x25
    40002c38:	aa1a03e2 	mov	x2, x26
    40002c3c:	aa1503e1 	mov	x1, x21
    40002c40:	aa1403e0 	mov	x0, x20
    40002c44:	97fffbbe 	bl	40001b3c <outs>
    40002c48:	37f80220 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002c4c:	8b20c360 	add	x0, x27, w0, sxtw
			while (pad_len-- > 0) {
    40002c50:	aa0003fb 	mov	x27, x0
    40002c54:	0b0002f7 	add	w23, w23, w0
		while (width > 0) {
    40002c58:	4b1b02e0 	sub	w0, w23, w27
    40002c5c:	7100001f 	cmp	w0, #0x0
    40002c60:	54ffb06d 	b.le	4000226c <cbvprintf+0x6c0>
			OUTC(' ');
    40002c64:	aa1503e1 	mov	x1, x21
    40002c68:	52800400 	mov	w0, #0x20                  	// #32
    40002c6c:	d63f0280 	blr	x20
    40002c70:	37f800e0 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002c74:	9100077b 	add	x27, x27, #0x1
			--width;
    40002c78:	17fffff8 	b	40002c58 <cbvprintf+0x10ac>
					OUTC(*cp++);
    40002c7c:	9100075a 	add	x26, x26, #0x1
    40002c80:	aa1503e1 	mov	x1, x21
    40002c84:	d63f0280 	blr	x20
    40002c88:	36fff7e0 	tbz	w0, #31, 40002b84 <cbvprintf+0xfd8>
#undef OUTS
#undef OUTC
}
    40002c8c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002c90:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40002c94:	a94363f7 	ldp	x23, x24, [sp, #48]
    40002c98:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40002c9c:	a94573fb 	ldp	x27, x28, [sp, #80]
    40002ca0:	a8cd7bfd 	ldp	x29, x30, [sp], #208
    40002ca4:	d65f03c0 	ret
    40002ca8:	f9003be4 	str	x4, [sp, #112]
						OUTC('0');
    40002cac:	aa1503e1 	mov	x1, x21
    40002cb0:	b9007fe5 	str	w5, [sp, #124]
    40002cb4:	52800600 	mov	w0, #0x30                  	// #48
    40002cb8:	d63f0280 	blr	x20
    40002cbc:	37fffe80 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002cc0:	f9403be4 	ldr	x4, [sp, #112]
					while (pad_len-- > 0) {
    40002cc4:	b9407fe5 	ldr	w5, [sp, #124]
						OUTC('0');
    40002cc8:	91000484 	add	x4, x4, #0x1
					while (pad_len-- > 0) {
    40002ccc:	2a0503fb 	mov	w27, w5
    40002cd0:	17ffffb6 	b	40002ba8 <cbvprintf+0xffc>
    40002cd4:	f9003be4 	str	x4, [sp, #112]
						OUTC('0');
    40002cd8:	aa1503e1 	mov	x1, x21
    40002cdc:	5100077b 	sub	w27, w27, #0x1
    40002ce0:	52800600 	mov	w0, #0x30                  	// #48
    40002ce4:	d63f0280 	blr	x20
    40002ce8:	17ffffba 	b	40002bd0 <cbvprintf+0x1024>
					OUTC(*cp++);
    40002cec:	9100075a 	add	x26, x26, #0x1
    40002cf0:	aa1503e1 	mov	x1, x21
    40002cf4:	d63f0280 	blr	x20
    40002cf8:	37fffca0 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
				while (isdigit((int)*cp)) {
    40002cfc:	39400340 	ldrb	w0, [x26]
    40002d00:	8b1b0341 	add	x1, x26, x27
    40002d04:	5100c004 	sub	w4, w0, #0x30
    40002d08:	7100249f 	cmp	w4, #0x9
    40002d0c:	54ffff09 	b.ls	40002cec <cbvprintf+0x1140>  // b.plast
    40002d10:	17ffffc3 	b	40002c1c <cbvprintf+0x1070>
    40002d14:	b90073e4 	str	w4, [sp, #112]
				OUTC('0');
    40002d18:	aa1503e1 	mov	x1, x21
    40002d1c:	52800600 	mov	w0, #0x30                  	// #48
    40002d20:	d63f0280 	blr	x20
    40002d24:	37fffb40 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002d28:	b94073e4 	ldr	w4, [sp, #112]
    40002d2c:	9100077b 	add	x27, x27, #0x1
    40002d30:	17ffffbe 	b	40002c28 <cbvprintf+0x107c>
			if (conv->altform_0c | conv->altform_0) {
    40002d34:	f94063e0 	ldr	x0, [sp, #192]
    40002d38:	d3545001 	ubfx	x1, x0, #20, #1
    40002d3c:	d3534c00 	ubfx	x0, x0, #19, #1
    40002d40:	2a000020 	orr	w0, w1, w0
    40002d44:	360000c0 	tbz	w0, #0, 40002d5c <cbvprintf+0x11b0>
				OUTC('0');
    40002d48:	aa1503e1 	mov	x1, x21
    40002d4c:	52800600 	mov	w0, #0x30                  	// #48
    40002d50:	d63f0280 	blr	x20
    40002d54:	37fff9c0 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002d58:	9100077b 	add	x27, x27, #0x1
			if (conv->altform_0c) {
    40002d5c:	39430be0 	ldrb	w0, [sp, #194]
    40002d60:	362000c0 	tbz	w0, #4, 40002d78 <cbvprintf+0x11cc>
				OUTC(conv->specifier);
    40002d64:	39430fe0 	ldrb	w0, [sp, #195]
    40002d68:	aa1503e1 	mov	x1, x21
    40002d6c:	d63f0280 	blr	x20
    40002d70:	37fff8e0 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002d74:	9100077b 	add	x27, x27, #0x1
			while (pad_len-- > 0) {
    40002d78:	b940c7e4 	ldr	w4, [sp, #196]
    40002d7c:	0b1b0084 	add	w4, w4, w27
    40002d80:	4b1b0080 	sub	w0, w4, w27
    40002d84:	7100001f 	cmp	w0, #0x0
    40002d88:	54fff56d 	b.le	40002c34 <cbvprintf+0x1088>
    40002d8c:	b90073e4 	str	w4, [sp, #112]
				OUTC('0');
    40002d90:	aa1503e1 	mov	x1, x21
    40002d94:	52800600 	mov	w0, #0x30                  	// #48
    40002d98:	d63f0280 	blr	x20
    40002d9c:	37fff780 	tbnz	w0, #31, 40002c8c <cbvprintf+0x10e0>
    40002da0:	b94073e4 	ldr	w4, [sp, #112]
    40002da4:	9100077b 	add	x27, x27, #0x1
    40002da8:	17fffff6 	b	40002d80 <cbvprintf+0x11d4>

0000000040002dac <ring_buf_get_rewind_threshold>:
 * rewinding earlier.
 */
uint32_t __weak ring_buf_get_rewind_threshold(void)
{
	return RING_BUFFER_MAX_SIZE;
}
    40002dac:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
    40002db0:	d65f03c0 	ret

0000000040002db4 <ring_buf_put_claim>:

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
	uint32_t space, trail_size, allocated, tmp_trail_mod;

	tmp_trail_mod = mod(buf, buf->misc.byte_mode.tmp_tail);
    40002db4:	b9402004 	ldr	w4, [x0, #32]
{
    40002db8:	aa0003e5 	mov	x5, x0
	tmp_trail_mod = mod(buf, buf->misc.byte_mode.tmp_tail);
    40002dbc:	b9400806 	ldr	w6, [x0, #8]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40002dc0:	b9401007 	ldr	w7, [x0, #16]
    40002dc4:	34000204 	cbz	w4, 40002e04 <ring_buf_put_claim+0x50>
    40002dc8:	0a0400c4 	and	w4, w6, w4
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
    40002dcc:	b94000a3 	ldr	w3, [x5]
	trail_size = buf->size - tmp_trail_mod;
    40002dd0:	4b0400e0 	sub	w0, w7, w4
	space = (buf->head + buf->size) - buf->misc.byte_mode.tmp_tail;
    40002dd4:	0b0300e3 	add	w3, w7, w3
    40002dd8:	4b060063 	sub	w3, w3, w6

	/* Limit requested size to available size. */
	size = MIN(size, space);
    40002ddc:	6b02007f 	cmp	w3, w2
    40002de0:	1a829062 	csel	w2, w3, w2, ls  // ls = plast

	trail_size = buf->size - (tmp_trail_mod);

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
    40002de4:	6b00005f 	cmp	w2, w0
    40002de8:	1a809040 	csel	w0, w2, w0, ls  // ls = plast
	*data = &buf->buf.buf8[tmp_trail_mod];
    40002dec:	f9400ca2 	ldr	x2, [x5, #24]

	buf->misc.byte_mode.tmp_tail =
		buf->misc.byte_mode.tmp_tail + allocated;
    40002df0:	0b0000c6 	add	w6, w6, w0
	*data = &buf->buf.buf8[tmp_trail_mod];
    40002df4:	8b244044 	add	x4, x2, w4, uxtw
    40002df8:	f9000024 	str	x4, [x1]
	buf->misc.byte_mode.tmp_tail =
    40002dfc:	b90008a6 	str	w6, [x5, #8]

	return allocated;
}
    40002e00:	d65f03c0 	ret
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40002e04:	1ac708c4 	udiv	w4, w6, w7
    40002e08:	1b079884 	msub	w4, w4, w7, w6
    40002e0c:	17fffff0 	b	40002dcc <ring_buf_put_claim+0x18>

0000000040002e10 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
    40002e10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40002e14:	910003fd 	mov	x29, sp
    40002e18:	a90153f3 	stp	x19, x20, [sp, #16]
    40002e1c:	aa0003f4 	mov	x20, x0
    40002e20:	2a0103f3 	mov	w19, w1
	uint32_t rew;
	uint32_t threshold = ring_buf_get_rewind_threshold();
    40002e24:	97ffffe2 	bl	40002dac <ring_buf_get_rewind_threshold>

	if ((buf->tail + size) > (buf->head + buf->size)) {
    40002e28:	29401282 	ldp	w2, w4, [x20]
    40002e2c:	b9401283 	ldr	w3, [x20, #16]
    40002e30:	0b130081 	add	w1, w4, w19
    40002e34:	0b020062 	add	w2, w3, w2
    40002e38:	6b02003f 	cmp	w1, w2
    40002e3c:	540001a8 	b.hi	40002e70 <ring_buf_put_finish+0x60>  // b.pmore
		return -EINVAL;
	}

	/* Check if indexes shall be rewind. */
	if (buf->tail > threshold) {
    40002e40:	6b00009f 	cmp	w4, w0
    40002e44:	54000129 	b.ls	40002e68 <ring_buf_put_finish+0x58>  // b.plast
	return buf_size * (threshold / buf_size);
    40002e48:	1ac30802 	udiv	w2, w0, w3
    40002e4c:	1b037c42 	mul	w2, w2, w3
		rew = get_rewind_value(buf->size, threshold);
	} else {
		rew = 0;
	}

	buf->tail += (size - rew);
    40002e50:	4b020021 	sub	w1, w1, w2
	buf->misc.byte_mode.tmp_tail = buf->tail;

	return 0;
    40002e54:	52800000 	mov	w0, #0x0                   	// #0
	buf->misc.byte_mode.tmp_tail = buf->tail;
    40002e58:	29008681 	stp	w1, w1, [x20, #4]
}
    40002e5c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002e60:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40002e64:	d65f03c0 	ret
		rew = 0;
    40002e68:	52800002 	mov	w2, #0x0                   	// #0
    40002e6c:	17fffff9 	b	40002e50 <ring_buf_put_finish+0x40>
		return -EINVAL;
    40002e70:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40002e74:	17fffffa 	b	40002e5c <ring_buf_put_finish+0x4c>

0000000040002e78 <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
    40002e78:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40002e7c:	910003fd 	mov	x29, sp
    40002e80:	a90153f3 	stp	x19, x20, [sp, #16]
    40002e84:	2a0203f4 	mov	w20, w2
    40002e88:	a9025bf5 	stp	x21, x22, [sp, #32]
    40002e8c:	aa0103f5 	mov	x21, x1
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
    40002e90:	52800016 	mov	w22, #0x0                   	// #0
{
    40002e94:	a90363f7 	stp	x23, x24, [sp, #48]
    40002e98:	aa0003f7 	mov	x23, x0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
    40002e9c:	2a1403e2 	mov	w2, w20
    40002ea0:	910123e1 	add	x1, sp, #0x48
    40002ea4:	aa1703e0 	mov	x0, x23
    40002ea8:	97ffffc3 	bl	40002db4 <ring_buf_put_claim>
    40002eac:	2a0003f8 	mov	w24, w0
		memcpy(dst, data, partial_size);
    40002eb0:	f94027e0 	ldr	x0, [sp, #72]
    40002eb4:	aa1503e1 	mov	x1, x21
    40002eb8:	aa1803e2 	mov	x2, x24
		total_size += partial_size;
    40002ebc:	0b1802d6 	add	w22, w22, w24
		size -= partial_size;
		data += partial_size;
    40002ec0:	8b1802b5 	add	x21, x21, x24
		memcpy(dst, data, partial_size);
    40002ec4:	9400237e 	bl	4000bcbc <memcpy>
	} while (size && partial_size);
    40002ec8:	6b180294 	subs	w20, w20, w24
    40002ecc:	7a401b04 	ccmp	w24, #0x0, #0x4, ne  // ne = any
    40002ed0:	54fffe61 	b.ne	40002e9c <ring_buf_put+0x24>  // b.any

	err = ring_buf_put_finish(buf, total_size);
    40002ed4:	2a1603e1 	mov	w1, w22
    40002ed8:	aa1703e0 	mov	x0, x23
    40002edc:	97ffffcd 	bl	40002e10 <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
    40002ee0:	2a1603e0 	mov	w0, w22
    40002ee4:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002ee8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40002eec:	a94363f7 	ldp	x23, x24, [sp, #48]
    40002ef0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40002ef4:	d65f03c0 	ret

0000000040002ef8 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
    40002ef8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40002efc:	910003fd 	mov	x29, sp
    40002f00:	a90153f3 	stp	x19, x20, [sp, #16]
    40002f04:	aa0003f3 	mov	x19, x0
	uint32_t space, granted_size, trail_size, tmp_head_mod;
	uint32_t tail = buf->tail;
    40002f08:	b9400414 	ldr	w20, [x0, #4]

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
    40002f0c:	b9400c00 	ldr	w0, [x0, #12]
{
    40002f10:	a9025bf5 	stp	x21, x22, [sp, #32]
    40002f14:	aa0103f6 	mov	x22, x1
    40002f18:	2a0203f5 	mov	w21, w2
    40002f1c:	f9001bf7 	str	x23, [sp, #48]
	if (tail < buf->misc.byte_mode.tmp_head) {
    40002f20:	6b14001f 	cmp	w0, w20
    40002f24:	540000a9 	b.ls	40002f38 <ring_buf_get_claim+0x40>  // b.plast
		/* Locally, increment it to pre-rewind value */
		tail += get_rewind_value(buf->size,
    40002f28:	b9401277 	ldr	w23, [x19, #16]
    40002f2c:	97ffffa0 	bl	40002dac <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
    40002f30:	1ad70800 	udiv	w0, w0, w23
		tail += get_rewind_value(buf->size,
    40002f34:	1b175014 	madd	w20, w0, w23, w20
					 ring_buf_get_rewind_threshold());
	}

	tmp_head_mod = mod(buf, buf->misc.byte_mode.tmp_head);
    40002f38:	b9402263 	ldr	w3, [x19, #32]
    40002f3c:	29419265 	ldp	w5, w4, [x19, #12]
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40002f40:	34000243 	cbz	w3, 40002f88 <ring_buf_get_claim+0x90>
    40002f44:	0a0300a3 	and	w3, w5, w3
	space = tail - buf->misc.byte_mode.tmp_head;
    40002f48:	4b050294 	sub	w20, w20, w5
	trail_size = buf->size - tmp_head_mod;
    40002f4c:	4b030084 	sub	w4, w4, w3
	granted_size = MIN(size, space);

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);

	*data = &buf->buf.buf8[tmp_head_mod];
    40002f50:	f9400e61 	ldr	x1, [x19, #24]
	granted_size = MIN(size, space);
    40002f54:	6b15029f 	cmp	w20, w21
    40002f58:	1a959280 	csel	w0, w20, w21, ls  // ls = plast
	granted_size = MIN(trail_size, granted_size);
    40002f5c:	6b00009f 	cmp	w4, w0
    40002f60:	1a809080 	csel	w0, w4, w0, ls  // ls = plast
	*data = &buf->buf.buf8[tmp_head_mod];
    40002f64:	8b234023 	add	x3, x1, w3, uxtw
	buf->misc.byte_mode.tmp_head += granted_size;

	return granted_size;
}
    40002f68:	f9401bf7 	ldr	x23, [sp, #48]
	*data = &buf->buf.buf8[tmp_head_mod];
    40002f6c:	f90002c3 	str	x3, [x22]
	buf->misc.byte_mode.tmp_head += granted_size;
    40002f70:	0b0000a5 	add	w5, w5, w0
}
    40002f74:	a9425bf5 	ldp	x21, x22, [sp, #32]
	buf->misc.byte_mode.tmp_head += granted_size;
    40002f78:	b9000e65 	str	w5, [x19, #12]
}
    40002f7c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002f80:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40002f84:	d65f03c0 	ret
	return likely(buf->mask) ? val & buf->mask : val % buf->size;
    40002f88:	1ac408a3 	udiv	w3, w5, w4
    40002f8c:	1b049463 	msub	w3, w3, w4, w5
    40002f90:	17ffffee 	b	40002f48 <ring_buf_get_claim+0x50>

0000000040002f94 <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
    40002f94:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40002f98:	910003fd 	mov	x29, sp
    40002f9c:	a90153f3 	stp	x19, x20, [sp, #16]
    40002fa0:	aa0003f4 	mov	x20, x0
    40002fa4:	2a0103f3 	mov	w19, w1
    40002fa8:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint32_t tail = buf->tail;
    40002fac:	b9400415 	ldr	w21, [x0, #4]
	uint32_t rew;

	/* Tail is always ahead, if it is not, it's only because it got rewinded. */
	if (tail < buf->misc.byte_mode.tmp_head) {
    40002fb0:	b9400c00 	ldr	w0, [x0, #12]
    40002fb4:	6b15001f 	cmp	w0, w21
    40002fb8:	54000249 	b.ls	40003000 <ring_buf_get_finish+0x6c>  // b.plast
		/* tail was rewinded. Locally, increment it to pre-rewind value */
		rew = get_rewind_value(buf->size,
    40002fbc:	b9401296 	ldr	w22, [x20, #16]
    40002fc0:	97ffff7b 	bl	40002dac <ring_buf_get_rewind_threshold>
	return buf_size * (threshold / buf_size);
    40002fc4:	1ad60800 	udiv	w0, w0, w22
    40002fc8:	1b167c00 	mul	w0, w0, w22
				       ring_buf_get_rewind_threshold());
		tail += rew;
    40002fcc:	0b0002b5 	add	w21, w21, w0
	} else {
		rew = 0;
	}

	if ((buf->head + size) > tail) {
    40002fd0:	b9400281 	ldr	w1, [x20]
    40002fd4:	0b010261 	add	w1, w19, w1
    40002fd8:	6b15003f 	cmp	w1, w21
    40002fdc:	54000168 	b.hi	40003008 <ring_buf_get_finish+0x74>  // b.pmore
		return -EINVAL;
	}

	/* Include potential rewinding. */
	buf->head += (size - rew);
    40002fe0:	4b000021 	sub	w1, w1, w0
	buf->misc.byte_mode.tmp_head = buf->head;

	return 0;
    40002fe4:	52800000 	mov	w0, #0x0                   	// #0
	buf->head += (size - rew);
    40002fe8:	b9000281 	str	w1, [x20]
	buf->misc.byte_mode.tmp_head = buf->head;
    40002fec:	b9000e81 	str	w1, [x20, #12]
}
    40002ff0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40002ff4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40002ff8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40002ffc:	d65f03c0 	ret
		rew = 0;
    40003000:	52800000 	mov	w0, #0x0                   	// #0
    40003004:	17fffff3 	b	40002fd0 <ring_buf_get_finish+0x3c>
		return -EINVAL;
    40003008:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4000300c:	17fffff9 	b	40002ff0 <ring_buf_get_finish+0x5c>

0000000040003010 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
    40003010:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40003014:	910003fd 	mov	x29, sp
    40003018:	a90153f3 	stp	x19, x20, [sp, #16]
    4000301c:	2a0203f4 	mov	w20, w2
    40003020:	a9025bf5 	stp	x21, x22, [sp, #32]
    40003024:	aa0103f5 	mov	x21, x1
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
    40003028:	52800016 	mov	w22, #0x0                   	// #0
{
    4000302c:	a90363f7 	stp	x23, x24, [sp, #48]
    40003030:	aa0003f7 	mov	x23, x0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
    40003034:	2a1403e2 	mov	w2, w20
    40003038:	910123e1 	add	x1, sp, #0x48
    4000303c:	aa1703e0 	mov	x0, x23
    40003040:	97ffffae 	bl	40002ef8 <ring_buf_get_claim>
    40003044:	2a0003f3 	mov	w19, w0
		if (data) {
    40003048:	b40000f5 	cbz	x21, 40003064 <ring_buf_get+0x54>
			memcpy(data, src, partial_size);
    4000304c:	f94027e1 	ldr	x1, [sp, #72]
    40003050:	2a0003f8 	mov	w24, w0
    40003054:	aa1803e2 	mov	x2, x24
    40003058:	aa1503e0 	mov	x0, x21
			data += partial_size;
    4000305c:	8b1802b5 	add	x21, x21, x24
			memcpy(data, src, partial_size);
    40003060:	94002317 	bl	4000bcbc <memcpy>
		}
		total_size += partial_size;
		size -= partial_size;
	} while (size && partial_size);
    40003064:	6b130294 	subs	w20, w20, w19
		total_size += partial_size;
    40003068:	0b1302d6 	add	w22, w22, w19
	} while (size && partial_size);
    4000306c:	7a401a64 	ccmp	w19, #0x0, #0x4, ne  // ne = any
    40003070:	54fffe21 	b.ne	40003034 <ring_buf_get+0x24>  // b.any

	err = ring_buf_get_finish(buf, total_size);
    40003074:	2a1603e1 	mov	w1, w22
    40003078:	aa1703e0 	mov	x0, x23
    4000307c:	97ffffc6 	bl	40002f94 <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
    40003080:	2a1603e0 	mov	w0, w22
    40003084:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003088:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000308c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40003090:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40003094:	d65f03c0 	ret

0000000040003098 <foldcase>:
#define EOS    '\0'

static inline int foldcase(int ch, int flags)
{

    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
    40003098:	361800a1 	tbz	w1, #3, 400030ac <foldcase+0x14>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    4000309c:	51010401 	sub	w1, w0, #0x41
    400030a0:	7100643f 	cmp	w1, #0x19
    400030a4:	54000048 	b.hi	400030ac <foldcase+0x14>  // b.pmore
			((ua | 32U) - (unsigned)'a' < 6U));
}

static inline int tolower(int chr)
{
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
    400030a8:	11008000 	add	w0, w0, #0x20
        return tolower(ch);
    return ch;
}
    400030ac:	d65f03c0 	ret

00000000400030b0 <fnmatchx>:
static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
    const char *stringstart, *r;
    char c, test;

    if ((pattern == NULL) || (string == NULL))
    400030b0:	f100001f 	cmp	x0, #0x0
    400030b4:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
    400030b8:	54000061 	b.ne	400030c4 <fnmatchx+0x14>  // b.any
    {
        return FNM_NOMATCH;
    400030bc:	52800020 	mov	w0, #0x1                   	// #1
                return FNM_NOMATCH;
            break;
        }
    }
    /* NOTREACHED */
}
    400030c0:	d65f03c0 	ret
{
    400030c4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    400030c8:	910003fd 	mov	x29, sp
    400030cc:	a90153f3 	stp	x19, x20, [sp, #16]
    400030d0:	a9025bf5 	stp	x21, x22, [sp, #32]
    400030d4:	a90363f7 	stp	x23, x24, [sp, #48]
    400030d8:	aa0303f7 	mov	x23, x3
    400030dc:	f90023f9 	str	x25, [sp, #64]
    if (recursion-- == 0)
    400030e0:	b40019c3 	cbz	x3, 40003418 <fnmatchx+0x368>
    400030e4:	aa0003e4 	mov	x4, x0
    400030e8:	aa0103f6 	mov	x22, x1
    400030ec:	2a0203f3 	mov	w19, w2
    400030f0:	aa0103f4 	mov	x20, x1
            if (*string == '.' && (flags & FNM_PERIOD) &&
    400030f4:	121e0058 	and	w24, w2, #0x4
            ok = 1;
    400030f8:	52800039 	mov	w25, #0x1                   	// #1
        switch (c = FOLDCASE(*pattern++, flags)) {
    400030fc:	aa0403f5 	mov	x21, x4
    40003100:	2a1303e1 	mov	w1, w19
    40003104:	384016a0 	ldrb	w0, [x21], #1
    40003108:	97ffffe4 	bl	40003098 <foldcase>
    4000310c:	2a0003e1 	mov	w1, w0
    40003110:	12001c02 	and	w2, w0, #0xff
    40003114:	12001c00 	and	w0, w0, #0xff
            if ((flags & FNM_LEADING_DIR) && *string == '/')
    40003118:	39400283 	ldrb	w3, [x20]
        switch (c = FOLDCASE(*pattern++, flags)) {
    4000311c:	7100fc1f 	cmp	w0, #0x3f
    40003120:	540003e0 	b.eq	4000319c <fnmatchx+0xec>  // b.none
    40003124:	721a043f 	tst	w1, #0xc0
    40003128:	54000161 	b.ne	40003154 <fnmatchx+0xa4>  // b.any
    4000312c:	340002c0 	cbz	w0, 40003184 <fnmatchx+0xd4>
    40003130:	7100a81f 	cmp	w0, #0x2a
    40003134:	54000620 	b.eq	400031f8 <fnmatchx+0x148>  // b.none
            if (c != FOLDCASE(*string++, flags))
    40003138:	2a1303e1 	mov	w1, w19
    4000313c:	2a0303e0 	mov	w0, w3
    40003140:	91000694 	add	x20, x20, #0x1
    40003144:	97ffffd5 	bl	40003098 <foldcase>
    40003148:	6b00005f 	cmp	w2, w0
    4000314c:	54000520 	b.eq	400031f0 <fnmatchx+0x140>  // b.none
    40003150:	14000017 	b	400031ac <fnmatchx+0xfc>
        switch (c = FOLDCASE(*pattern++, flags)) {
    40003154:	71016c1f 	cmp	w0, #0x5b
    40003158:	54000be0 	b.eq	400032d4 <fnmatchx+0x224>  // b.none
    4000315c:	7101701f 	cmp	w0, #0x5c
    40003160:	54fffec1 	b.ne	40003138 <fnmatchx+0x88>  // b.any
            if (!(flags & FNM_NOESCAPE)) {
    40003164:	3707feb3 	tbnz	w19, #0, 40003138 <fnmatchx+0x88>
                if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
    40003168:	39400480 	ldrb	w0, [x4, #1]
    4000316c:	2a1303e1 	mov	w1, w19
    40003170:	97ffffca 	bl	40003098 <foldcase>
    40003174:	72001c02 	ands	w2, w0, #0xff
    40003178:	54fffe00 	b.eq	40003138 <fnmatchx+0x88>  // b.none
    4000317c:	91000895 	add	x21, x4, #0x2
    40003180:	17ffffee 	b	40003138 <fnmatchx+0x88>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
    40003184:	36200073 	tbz	w19, #4, 40003190 <fnmatchx+0xe0>
    40003188:	7100bc7f 	cmp	w3, #0x2f
    4000318c:	54000120 	b.eq	400031b0 <fnmatchx+0x100>  // b.none
            return *string == EOS ? 0 : FNM_NOMATCH;
    40003190:	7100007f 	cmp	w3, #0x0
                        0 : FNM_NOMATCH;
    40003194:	1a9f07e0 	cset	w0, ne  // ne = any
    40003198:	14000006 	b	400031b0 <fnmatchx+0x100>
            if (*string == EOS)
    4000319c:	34000083 	cbz	w3, 400031ac <fnmatchx+0xfc>
            if (*string == '/' && (flags & FNM_PATHNAME))
    400031a0:	7100bc7f 	cmp	w3, #0x2f
    400031a4:	54000121 	b.ne	400031c8 <fnmatchx+0x118>  // b.any
    400031a8:	36080233 	tbz	w19, #1, 400031ec <fnmatchx+0x13c>
        return FNM_NOMATCH;
    400031ac:	52800020 	mov	w0, #0x1                   	// #1
}
    400031b0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400031b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400031b8:	a94363f7 	ldp	x23, x24, [sp, #48]
    400031bc:	f94023f9 	ldr	x25, [sp, #64]
    400031c0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    400031c4:	d65f03c0 	ret
            if (*string == '.' && (flags & FNM_PERIOD) &&
    400031c8:	7100b87f 	cmp	w3, #0x2e
    400031cc:	54000101 	b.ne	400031ec <fnmatchx+0x13c>  // b.any
    400031d0:	340000f8 	cbz	w24, 400031ec <fnmatchx+0x13c>
    400031d4:	eb16029f 	cmp	x20, x22
    400031d8:	54fffea0 	b.eq	400031ac <fnmatchx+0xfc>  // b.none
                (string == stringstart ||
    400031dc:	36080093 	tbz	w19, #1, 400031ec <fnmatchx+0x13c>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
    400031e0:	385ff280 	ldurb	w0, [x20, #-1]
    400031e4:	7100bc1f 	cmp	w0, #0x2f
    400031e8:	54fffe20 	b.eq	400031ac <fnmatchx+0xfc>  // b.none
            ++string;
    400031ec:	91000694 	add	x20, x20, #0x1
            break;
    400031f0:	aa1503e4 	mov	x4, x21
    400031f4:	17ffffc2 	b	400030fc <fnmatchx+0x4c>
            c = FOLDCASE(*pattern, flags);
    400031f8:	39400480 	ldrb	w0, [x4, #1]
    400031fc:	2a1303e1 	mov	w1, w19
                c = FOLDCASE(*++pattern, flags);
    40003200:	97ffffa6 	bl	40003098 <foldcase>
    40003204:	12001c01 	and	w1, w0, #0xff
            while (c == '*')
    40003208:	7100a83f 	cmp	w1, #0x2a
    4000320c:	54000260 	b.eq	40003258 <fnmatchx+0x1a8>  // b.none
            if (*string == '.' && (flags & FNM_PERIOD) &&
    40003210:	7100b87f 	cmp	w3, #0x2e
    40003214:	54000101 	b.ne	40003234 <fnmatchx+0x184>  // b.any
    40003218:	340000f8 	cbz	w24, 40003234 <fnmatchx+0x184>
    4000321c:	eb16029f 	cmp	x20, x22
    40003220:	54fffc60 	b.eq	400031ac <fnmatchx+0xfc>  // b.none
                (string == stringstart ||
    40003224:	36080093 	tbz	w19, #1, 40003234 <fnmatchx+0x184>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
    40003228:	385ff280 	ldurb	w0, [x20, #-1]
    4000322c:	7100bc1f 	cmp	w0, #0x2f
    40003230:	54fffbe0 	b.eq	400031ac <fnmatchx+0xfc>  // b.none
            if (c == EOS) {
    40003234:	35000181 	cbnz	w1, 40003264 <fnmatchx+0x1b4>
                if (flags & FNM_PATHNAME)
    40003238:	121f0260 	and	w0, w19, #0x2
    4000323c:	360ffbb3 	tbz	w19, #1, 400031b0 <fnmatchx+0x100>
                        0 : FNM_NOMATCH;
    40003240:	37200f13 	tbnz	w19, #4, 40003420 <fnmatchx+0x370>
                        strchr(string, '/') == NULL ?
    40003244:	aa1403e0 	mov	x0, x20
    40003248:	528005e1 	mov	w1, #0x2f                  	// #47
    4000324c:	94002246 	bl	4000bb64 <strchr>
                        0 : FNM_NOMATCH;
    40003250:	f100001f 	cmp	x0, #0x0
    40003254:	17ffffd0 	b	40003194 <fnmatchx+0xe4>
                c = FOLDCASE(*++pattern, flags);
    40003258:	38401ea0 	ldrb	w0, [x21, #1]!
    4000325c:	2a1303e1 	mov	w1, w19
    40003260:	17ffffe8 	b	40003200 <fnmatchx+0x150>
            } else if (c == '/' && flags & FNM_PATHNAME) {
    40003264:	7100bc3f 	cmp	w1, #0x2f
    40003268:	540002a0 	b.eq	400032bc <fnmatchx+0x20c>  // b.none
    if (recursion-- == 0)
    4000326c:	d10006f7 	sub	x23, x23, #0x1
                switch ((e = fnmatchx(pattern, string,
    40003270:	121d7a78 	and	w24, w19, #0xfffffffb
                if (test == '/' && flags & FNM_PATHNAME)
    40003274:	121f0279 	and	w25, w19, #0x2
            while ((test = FOLDCASE(*string, flags)) != EOS) {
    40003278:	39400280 	ldrb	w0, [x20]
    4000327c:	2a1303e1 	mov	w1, w19
    40003280:	97ffff86 	bl	40003098 <foldcase>
    40003284:	72001c16 	ands	w22, w0, #0xff
    40003288:	54fff920 	b.eq	400031ac <fnmatchx+0xfc>  // b.none
                switch ((e = fnmatchx(pattern, string,
    4000328c:	aa1703e3 	mov	x3, x23
    40003290:	2a1803e2 	mov	w2, w24
    40003294:	aa1403e1 	mov	x1, x20
    40003298:	aa1503e0 	mov	x0, x21
    4000329c:	97ffff85 	bl	400030b0 <fnmatchx>
    400032a0:	7100041f 	cmp	w0, #0x1
    400032a4:	54fff861 	b.ne	400031b0 <fnmatchx+0x100>  // b.any
                if (test == '/' && flags & FNM_PATHNAME)
    400032a8:	7100bedf 	cmp	w22, #0x2f
    400032ac:	54000041 	b.ne	400032b4 <fnmatchx+0x204>  // b.any
    400032b0:	35fff7f9 	cbnz	w25, 400031ac <fnmatchx+0xfc>
                ++string;
    400032b4:	91000694 	add	x20, x20, #0x1
    400032b8:	17fffff0 	b	40003278 <fnmatchx+0x1c8>
            } else if (c == '/' && flags & FNM_PATHNAME) {
    400032bc:	360ffd93 	tbz	w19, #1, 4000326c <fnmatchx+0x1bc>
                if ((string = strchr(string, '/')) == NULL)
    400032c0:	aa1403e0 	mov	x0, x20
    400032c4:	94002228 	bl	4000bb64 <strchr>
    400032c8:	aa0003f4 	mov	x20, x0
    400032cc:	b5fff920 	cbnz	x0, 400031f0 <fnmatchx+0x140>
    400032d0:	17ffffb7 	b	400031ac <fnmatchx+0xfc>
            if (*string == EOS)
    400032d4:	34fff6c3 	cbz	w3, 400031ac <fnmatchx+0xfc>
            if (*string == '/' && flags & FNM_PATHNAME)
    400032d8:	7100bc7f 	cmp	w3, #0x2f
    400032dc:	54000041 	b.ne	400032e4 <fnmatchx+0x234>  // b.any
    400032e0:	370ff673 	tbnz	w19, #1, 400031ac <fnmatchx+0xfc>
            if ((r = rangematch(pattern,
    400032e4:	2a1303e1 	mov	w1, w19
    400032e8:	2a0303e0 	mov	w0, w3
    400032ec:	97ffff6b 	bl	40003098 <foldcase>
    400032f0:	2a0003e7 	mov	w7, w0
    if (pattern == NULL)
    400032f4:	b4fff5d5 	cbz	x21, 400031ac <fnmatchx+0xfc>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    400032f8:	39400480 	ldrb	w0, [x4, #1]
        ++pattern;
    400032fc:	91000884 	add	x4, x4, #0x2
            ok = 1;
    40003300:	52800029 	mov	w9, #0x1                   	// #1
        if (c == '\\' && !(flags & FNM_NOESCAPE))
    40003304:	0a09026a 	and	w10, w19, w9
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    40003308:	7100841f 	cmp	w0, #0x21
            ok = 1;
    4000330c:	52800006 	mov	w6, #0x0                   	// #0
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
    40003310:	1a9f17e8 	cset	w8, eq  // eq = none
    40003314:	7101781f 	cmp	w0, #0x5e
    40003318:	1a9f17e0 	cset	w0, eq  // eq = none
    4000331c:	2a000108 	orr	w8, w8, w0
        ++pattern;
    40003320:	7100011f 	cmp	w8, #0x0
    40003324:	9a951084 	csel	x4, x4, x21, ne  // ne = any
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
    40003328:	aa0403e2 	mov	x2, x4
    4000332c:	2a1303e1 	mov	w1, w19
    40003330:	38401440 	ldrb	w0, [x2], #1
    40003334:	97ffff59 	bl	40003098 <foldcase>
    40003338:	12001c05 	and	w5, w0, #0xff
    4000333c:	710174bf 	cmp	w5, #0x5d
    40003340:	540001a1 	b.ne	40003374 <fnmatchx+0x2c4>  // b.any
    40003344:	350002e9 	cbnz	w9, 400033a0 <fnmatchx+0x2f0>
    return ok == negate ? NULL : pattern;
    40003348:	6b06011f 	cmp	w8, w6
    4000334c:	54fff300 	b.eq	400031ac <fnmatchx+0xfc>  // b.none
            if ((r = rangematch(pattern,
    40003350:	b4fff2e2 	cbz	x2, 400031ac <fnmatchx+0xfc>
            if (r == (void *)-1) {
    40003354:	b100045f 	cmn	x2, #0x1
    40003358:	54000081 	b.ne	40003368 <fnmatchx+0x2b8>  // b.any
                if (*string != '[')
    4000335c:	71016c7f 	cmp	w3, #0x5b
    40003360:	54fff261 	b.ne	400031ac <fnmatchx+0xfc>  // b.any
    40003364:	aa1503e2 	mov	x2, x21
            ++string;
    40003368:	91000694 	add	x20, x20, #0x1
            break;
    4000336c:	aa0203f5 	mov	x21, x2
    40003370:	17ffffa0 	b	400031f0 <fnmatchx+0x140>
        if (c == '/')
    40003374:	7100bcbf 	cmp	w5, #0x2f
    40003378:	54ffff20 	b.eq	4000335c <fnmatchx+0x2ac>  // b.none
        if (c == '\\' && !(flags & FNM_NOESCAPE))
    4000337c:	710170bf 	cmp	w5, #0x5c
    40003380:	540000e1 	b.ne	4000339c <fnmatchx+0x2ec>  // b.any
    40003384:	350000ea 	cbnz	w10, 400033a0 <fnmatchx+0x2f0>
            c = FOLDCASE(*pattern++, flags);
    40003388:	39400480 	ldrb	w0, [x4, #1]
    4000338c:	2a1303e1 	mov	w1, w19
    40003390:	91000882 	add	x2, x4, #0x2
    40003394:	97ffff41 	bl	40003098 <foldcase>
    40003398:	12001c05 	and	w5, w0, #0xff
        if (c == EOS)
    4000339c:	34fff085 	cbz	w5, 400031ac <fnmatchx+0xfc>
        if (*pattern == '-' 
    400033a0:	39400040 	ldrb	w0, [x2]
    400033a4:	7100b41f 	cmp	w0, #0x2d
    400033a8:	54000301 	b.ne	40003408 <fnmatchx+0x358>  // b.any
            && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
    400033ac:	39400440 	ldrb	w0, [x2, #1]
    400033b0:	2a1303e1 	mov	w1, w19
    400033b4:	97ffff39 	bl	40003098 <foldcase>
    400033b8:	72001c01 	ands	w1, w0, #0xff
    400033bc:	54000260 	b.eq	40003408 <fnmatchx+0x358>  // b.none
    400033c0:	7101743f 	cmp	w1, #0x5d
    400033c4:	54000220 	b.eq	40003408 <fnmatchx+0x358>  // b.none
            pattern += 2;
    400033c8:	91000844 	add	x4, x2, #0x2
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
    400033cc:	7101703f 	cmp	w1, #0x5c
    400033d0:	54000101 	b.ne	400033f0 <fnmatchx+0x340>  // b.any
    400033d4:	350000ea 	cbnz	w10, 400033f0 <fnmatchx+0x340>
                c2 = FOLDCASE(*pattern++, flags);
    400033d8:	39400840 	ldrb	w0, [x2, #2]
    400033dc:	2a1303e1 	mov	w1, w19
    400033e0:	91000c44 	add	x4, x2, #0x3
    400033e4:	97ffff2d 	bl	40003098 <foldcase>
            if (c2 == EOS)
    400033e8:	72001c01 	ands	w1, w0, #0xff
    400033ec:	54ffee00 	b.eq	400031ac <fnmatchx+0xfc>  // b.none
            if (c <= test && test <= c2)
    400033f0:	6b0500ff 	cmp	w7, w5
    400033f4:	5400006b 	b.lt	40003400 <fnmatchx+0x350>  // b.tstop
                ok = 1;
    400033f8:	6b0100ff 	cmp	w7, w1
    400033fc:	1a99c0c6 	csel	w6, w6, w25, gt
            ok = 1;
    40003400:	52800009 	mov	w9, #0x0                   	// #0
    40003404:	17ffffc9 	b	40003328 <fnmatchx+0x278>
        } else if (c == test)
    40003408:	6b0500ff 	cmp	w7, w5
    4000340c:	aa0203e4 	mov	x4, x2
    40003410:	1a9910c6 	csel	w6, w6, w25, ne  // ne = any
    40003414:	17fffffb 	b	40003400 <fnmatchx+0x350>
        return FNM_NORES;
    40003418:	52800060 	mov	w0, #0x3                   	// #3
    4000341c:	17ffff65 	b	400031b0 <fnmatchx+0x100>
                return 0;
    40003420:	52800000 	mov	w0, #0x0                   	// #0
    40003424:	17ffff63 	b	400031b0 <fnmatchx+0x100>

0000000040003428 <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
    return fnmatchx(pattern, string, flags, 64);
    40003428:	d2800803 	mov	x3, #0x40                  	// #64
    4000342c:	17ffff21 	b	400030b0 <fnmatchx>

0000000040003430 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    40003430:	d65f03c0 	ret

0000000040003434 <z_arm64_el3_plat_init>:
	uint64_t reg = 0;

	reg = (ICC_SRE_ELx_DFB_BIT | ICC_SRE_ELx_DIB_BIT |
	       ICC_SRE_ELx_SRE_BIT | ICC_SRE_EL3_EN_BIT);

	write_sysreg(reg, ICC_SRE_EL3);
    40003434:	d28001e0 	mov	x0, #0xf                   	// #15
    40003438:	d51ecca0 	msr	s3_6_c12_c12_5, x0
}
    4000343c:	d65f03c0 	ret

0000000040003440 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
    40003440:	a9007c1f 	stp	xzr, xzr, [x0]
	list->head = NULL;
}
    40003444:	d65f03c0 	ret

0000000040003448 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
    40003448:	f9400002 	ldr	x2, [x0]
    4000344c:	b50000a2 	cbnz	x2, 40003460 <log_list_add_tail+0x18>
		list->head = msg;
    40003450:	f9000001 	str	x1, [x0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
    40003454:	f9000401 	str	x1, [x0, #8]
	msg->next = NULL;
    40003458:	f900003f 	str	xzr, [x1]
}
    4000345c:	d65f03c0 	ret
		list->tail->next = msg;
    40003460:	f9400402 	ldr	x2, [x0, #8]
    40003464:	f9000041 	str	x1, [x2]
    40003468:	17fffffb 	b	40003454 <log_list_add_tail+0xc>

000000004000346c <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
    4000346c:	f9400000 	ldr	x0, [x0]
    40003470:	d65f03c0 	ret

0000000040003474 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
    40003474:	aa0003e1 	mov	x1, x0
	struct log_msg *msg = list->head;
    40003478:	f9400000 	ldr	x0, [x0]

	if (list->head != NULL) {
    4000347c:	b4000060 	cbz	x0, 40003488 <log_list_head_get+0x14>
		list->head = list->head->next;
    40003480:	f9400002 	ldr	x2, [x0]
    40003484:	f9000022 	str	x2, [x1]
	}

	return msg;
}
    40003488:	d65f03c0 	ret

000000004000348c <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
    4000348c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40003490:	910003fd 	mov	x29, sp
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    40003494:	94000393 	bl	400042e0 <log_msg_chunk_alloc>

	if (msg != NULL) {
    40003498:	b4000080 	cbz	x0, 400034a8 <z_log_msg_std_alloc+0x1c>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    4000349c:	d2800021 	mov	x1, #0x1                   	// #1
    400034a0:	f9000401 	str	x1, [x0, #8]
		msg->hdr.params.raw = 0U;
    400034a4:	7900201f 	strh	wzr, [x0, #16]
			msg->hdr.ids.source_id = 0;
		}
	}

	return msg;
}
    400034a8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400034ac:	d65f03c0 	ret

00000000400034b0 <default_lf_get_timestamp>:
	return IS_ENABLED(CONFIG_LOG_TIMESTAMP_64BIT) ?
		sys_clock_tick_get() : k_cycle_get_32();
}

static log_timestamp_t default_lf_get_timestamp(void)
{
    400034b0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400034b4:	910003fd 	mov	x29, sp
		/* coverity[OVERRUN] */
		return (int64_t) arch_syscall_invoke0(K_SYSCALL_K_UPTIME_TICKS);
	}
#endif
	compiler_barrier();
	return z_impl_k_uptime_ticks();
    400034b8:	940033c5 	bl	400103cc <z_impl_k_uptime_ticks>
	return IS_ENABLED(CONFIG_LOG_TIMESTAMP_64BIT) ?
		k_uptime_get() : k_uptime_get_32();
}
    400034bc:	d2800141 	mov	x1, #0xa                   	// #10
    400034c0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400034c4:	1b017c00 	mul	w0, w0, w1
    400034c8:	d65f03c0 	ret

00000000400034cc <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
    400034cc:	d100c3ff 	sub	sp, sp, #0x30
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    400034d0:	d2800002 	mov	x2, #0x0                   	// #0
    400034d4:	90000001 	adrp	x1, 40003000 <ring_buf_get_finish+0x6c>
    400034d8:	91157021 	add	x1, x1, #0x55c
    400034dc:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    400034e0:	91066000 	add	x0, x0, #0x198
{
    400034e4:	a9017bfd 	stp	x29, x30, [sp, #16]
    400034e8:	910043fd 	add	x29, sp, #0x10
    400034ec:	f90013f3 	str	x19, [sp, #32]
		k_timer_init(&log_process_thread_timer,
    400034f0:	940033e8 	bl	40010490 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    400034f4:	b90003ff 	str	wzr, [sp]
    400034f8:	b00000f3 	adrp	x19, 40020000 <logging_thread>
    400034fc:	91000273 	add	x19, x19, #0x0
    40003500:	f90007ff 	str	xzr, [sp, #8]
    40003504:	aa1303e0 	mov	x0, x19
    40003508:	528001c7 	mov	w7, #0xe                   	// #14
    4000350c:	d2800006 	mov	x6, #0x0                   	// #0
    40003510:	d2800005 	mov	x5, #0x0                   	// #0
    40003514:	d2800004 	mov	x4, #0x0                   	// #0
    40003518:	d2820002 	mov	x2, #0x1000                	// #4096
    4000351c:	90000003 	adrp	x3, 40003000 <ring_buf_get_finish+0x6c>
    40003520:	912b7063 	add	x3, x3, #0xadc
    40003524:	d0000321 	adrp	x1, 40069000 <z_page_frames+0x47725>
    40003528:	91238021 	add	x1, x1, #0x8e0
    4000352c:	94002d7b 	bl	4000eb18 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    40003530:	b0000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40003534:	91151421 	add	x1, x1, #0x545
    40003538:	aa1303e0 	mov	x0, x19
    4000353c:	94002cf2 	bl	4000e904 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    40003540:	52800000 	mov	w0, #0x0                   	// #0
    40003544:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40003548:	f94013f3 	ldr	x19, [sp, #32]
    4000354c:	9100c3ff 	add	sp, sp, #0x30
    40003550:	d65f03c0 	ret

0000000040003554 <dummy_timestamp>:
    40003554:	52800000 	mov	w0, #0x0                   	// #0
    40003558:	d65f03c0 	ret

000000004000355c <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    4000355c:	90000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    40003560:	912ae000 	add	x0, x0, #0xab8
    40003564:	14002f08 	b	4000f184 <z_impl_k_sem_give>

0000000040003568 <z_log_get_s_mask>:
{
    40003568:	aa0003e5 	mov	x5, x0
	uint32_t arg = 0U;
    4000356c:	52800002 	mov	w2, #0x0                   	// #0
	uint32_t mask = 0U;
    40003570:	52800000 	mov	w0, #0x0                   	// #0
	bool arm = false;
    40003574:	52800003 	mov	w3, #0x0                   	// #0
				mask |= BIT(arg);
    40003578:	d2800027 	mov	x7, #0x1                   	// #1
	while ((curr = *str++) && arg < nargs) {
    4000357c:	384014a4 	ldrb	w4, [x5], #1
    40003580:	34000064 	cbz	w4, 4000358c <z_log_get_s_mask+0x24>
    40003584:	6b01005f 	cmp	w2, w1
    40003588:	54000043 	b.cc	40003590 <z_log_get_s_mask+0x28>  // b.lo, b.ul, b.last
}
    4000358c:	d65f03c0 	ret
		if (curr == '%') {
    40003590:	7100949f 	cmp	w4, #0x25
    40003594:	54000061 	b.ne	400035a0 <z_log_get_s_mask+0x38>  // b.any
			arm = !arm;
    40003598:	52000063 	eor	w3, w3, #0x1
    4000359c:	17fffff8 	b	4000357c <z_log_get_s_mask+0x14>
		} else if (arm && isalpha((int)curr)) {
    400035a0:	34fffee3 	cbz	w3, 4000357c <z_log_get_s_mask+0x14>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    400035a4:	321b0086 	orr	w6, w4, #0x20
    400035a8:	510184c6 	sub	w6, w6, #0x61
    400035ac:	710064df 	cmp	w6, #0x19
    400035b0:	54fffe68 	b.hi	4000357c <z_log_get_s_mask+0x14>  // b.pmore
			if (curr == 's') {
    400035b4:	7101cc9f 	cmp	w4, #0x73
    400035b8:	54000061 	b.ne	400035c4 <z_log_get_s_mask+0x5c>  // b.any
				mask |= BIT(arg);
    400035bc:	9ac220e3 	lsl	x3, x7, x2
    400035c0:	2a030000 	orr	w0, w0, w3
			arg++;
    400035c4:	11000442 	add	w2, w2, #0x1
			arm = false;
    400035c8:	52800003 	mov	w3, #0x0                   	// #0
    400035cc:	17ffffec 	b	4000357c <z_log_get_s_mask+0x14>

00000000400035d0 <log_core_init>:
{
    400035d0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	panic_mode = false;
    400035d4:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
	timestamp_func = timestamp_getter;
    400035d8:	90000361 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
{
    400035dc:	910003fd 	mov	x29, sp
	panic_mode = false;
    400035e0:	3922d41f 	strb	wzr, [x0, #2229]
	dropped_cnt = 0;
    400035e4:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    400035e8:	f900bc1f 	str	xzr, [x0, #376]
	timestamp_func = timestamp_getter;
    400035ec:	90000000 	adrp	x0, 40003000 <ring_buf_get_finish+0x6c>
    400035f0:	9112c000 	add	x0, x0, #0x4b0
    400035f4:	f9044820 	str	x0, [x1, #2192]
	log_output_timestamp_freq_set(freq);
    400035f8:	52807d00 	mov	w0, #0x3e8                 	// #1000
    400035fc:	94000665 	bl	40004f90 <log_output_timestamp_freq_set>
		log_msg_pool_init();
    40003600:	94000315 	bl	40004254 <log_msg_pool_init>
		log_list_init(&list);
    40003604:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003608:	91062000 	add	x0, x0, #0x188
    4000360c:	97ffff8d 	bl	40003440 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    40003610:	52800083 	mov	w3, #0x4                   	// #4
    40003614:	d2800602 	mov	x2, #0x30                  	// #48
    40003618:	90000361 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
    4000361c:	91038021 	add	x1, x1, #0xe0
    40003620:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003624:	9107c000 	add	x0, x0, #0x1f0
    40003628:	94002c2c 	bl	4000e6d8 <k_mem_slab_init>
}
    4000362c:	a8c17bfd 	ldp	x29, x30, [sp], #16
		z_log_runtime_filters_init();
    40003630:	1400020d 	b	40003e64 <z_log_runtime_filters_init>

0000000040003634 <log_init>:
{
    40003634:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    40003638:	d00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000363c:	91060021 	add	x1, x1, #0x180
    40003640:	910003fd 	mov	x29, sp
    40003644:	d2800020 	mov	x0, #0x1                   	// #1
    40003648:	a90153f3 	stp	x19, x20, [sp, #16]
    4000364c:	f90013f5 	str	x21, [sp, #32]
    40003650:	97fff65c 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (atomic_inc(&initialized) != 0) {
    40003654:	b5000140 	cbnz	x0, 4000367c <log_init+0x48>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
    40003658:	f0000073 	adrp	x19, 40012000 <__rodata_region_start>
    4000365c:	913c8273 	add	x19, x19, #0xf20
    40003660:	f0000074 	adrp	x20, 40012000 <__rodata_region_start>
    40003664:	913d0294 	add	x20, x20, #0xf40
    40003668:	cb130294 	sub	x20, x20, x19
	for (i = 0; i < log_backend_count_get(); i++) {
    4000366c:	52800015 	mov	w21, #0x0                   	// #0
    40003670:	d3459294 	ubfx	x20, x20, #5, #32
    40003674:	6b1402bf 	cmp	w21, w20
    40003678:	540000ab 	b.lt	4000368c <log_init+0x58>  // b.tstop
}
    4000367c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003680:	f94013f5 	ldr	x21, [sp, #32]
    40003684:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40003688:	d65f03c0 	ret
		if (backend->autostart) {
    4000368c:	39406260 	ldrb	w0, [x19, #24]
    40003690:	34000160 	cbz	w0, 400036bc <log_init+0x88>
			if (backend->api->init != NULL) {
    40003694:	f9400260 	ldr	x0, [x19]
    40003698:	f9401801 	ldr	x1, [x0, #48]
    4000369c:	b4000061 	cbz	x1, 400036a8 <log_init+0x74>
				backend->api->init(backend);
    400036a0:	aa1303e0 	mov	x0, x19
    400036a4:	d63f0020 	blr	x1
			log_backend_enable(backend,
    400036a8:	f9400660 	ldr	x0, [x19, #8]
    400036ac:	52800082 	mov	w2, #0x4                   	// #4
    400036b0:	f9400001 	ldr	x1, [x0]
    400036b4:	aa1303e0 	mov	x0, x19
    400036b8:	94000268 	bl	40004058 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    400036bc:	110006b5 	add	w21, w21, #0x1
    400036c0:	91008273 	add	x19, x19, #0x20
    400036c4:	17ffffec 	b	40003674 <log_init+0x40>

00000000400036c8 <get_msg>:
{
    400036c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400036cc:	910003fd 	mov	x29, sp
    400036d0:	f9000bf3 	str	x19, [sp, #16]
    400036d4:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400036d8:	d50342df 	msr	daifset, #0x2
	msg.msg = log_list_head_get(&list);
    400036dc:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    400036e0:	91062000 	add	x0, x0, #0x188
MAKE_REG_HELPER(daif)
    400036e4:	92407e73 	and	x19, x19, #0xffffffff
    400036e8:	97ffff63 	bl	40003474 <log_list_head_get>
    400036ec:	d51b4233 	msr	daif, x19
}
    400036f0:	f9400bf3 	ldr	x19, [sp, #16]
    400036f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400036f8:	d65f03c0 	ret

00000000400036fc <z_log_notify_backend_enabled>:
{
    400036fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003700:	910003fd 	mov	x29, sp
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
    40003704:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003708:	3962d001 	ldrb	w1, [x0, #2228]
{
    4000370c:	f9000bf3 	str	x19, [sp, #16]
    40003710:	aa0003f3 	mov	x19, x0
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
    40003714:	35000081 	cbnz	w1, 40003724 <z_log_notify_backend_enabled+0x28>
    40003718:	90000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000371c:	912ae000 	add	x0, x0, #0xab8
    40003720:	94002e99 	bl	4000f184 <z_impl_k_sem_give>
	backend_attached = true;
    40003724:	52800020 	mov	w0, #0x1                   	// #1
    40003728:	3922d260 	strb	w0, [x19, #2228]
}
    4000372c:	f9400bf3 	ldr	x19, [sp, #16]
    40003730:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003734:	d65f03c0 	ret

0000000040003738 <z_log_dropped>:
{
    40003738:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000373c:	d00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40003740:	9105e021 	add	x1, x1, #0x178
    40003744:	910003fd 	mov	x29, sp
    40003748:	d2800020 	mov	x0, #0x1                   	// #1
    4000374c:	97fff61d 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    40003750:	d00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40003754:	9105c021 	add	x1, x1, #0x170
    40003758:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4000375c:	97fff619 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
}
    40003760:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40003764:	d65f03c0 	ret

0000000040003768 <z_log_dropped_read_and_clear>:
{
    40003768:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    4000376c:	d00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40003770:	9105e021 	add	x1, x1, #0x178
    40003774:	910003fd 	mov	x29, sp
    40003778:	d2800000 	mov	x0, #0x0                   	// #0
    4000377c:	97fff605 	bl	40000f90 <__aarch64_swp8_acq_rel>
}
    40003780:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40003784:	d65f03c0 	ret

0000000040003788 <dropped_notify>:
{
    40003788:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000378c:	910003fd 	mov	x29, sp
    40003790:	a90153f3 	stp	x19, x20, [sp, #16]
    40003794:	f0000073 	adrp	x19, 40012000 <__rodata_region_start>
    40003798:	913c8273 	add	x19, x19, #0xf20
    4000379c:	f0000074 	adrp	x20, 40012000 <__rodata_region_start>
    400037a0:	913d0294 	add	x20, x20, #0xf40
    400037a4:	cb130294 	sub	x20, x20, x19
    400037a8:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint32_t dropped = z_log_dropped_read_and_clear();
    400037ac:	97ffffef 	bl	40003768 <z_log_dropped_read_and_clear>
    400037b0:	d3459294 	ubfx	x20, x20, #5, #32
    400037b4:	2a0003f6 	mov	w22, w0
	for (int i = 0; i < log_backend_count_get(); i++) {
    400037b8:	52800015 	mov	w21, #0x0                   	// #0
    400037bc:	6b1402bf 	cmp	w21, w20
    400037c0:	540000ab 	b.lt	400037d4 <dropped_notify+0x4c>  // b.tstop
}
    400037c4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400037c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400037cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400037d0:	d65f03c0 	ret
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    400037d4:	f9400660 	ldr	x0, [x19, #8]
		if (log_backend_is_active(backend)) {
    400037d8:	39402400 	ldrb	w0, [x0, #9]
    400037dc:	340000e0 	cbz	w0, 400037f8 <dropped_notify+0x70>
	if (backend->api->dropped != NULL) {
    400037e0:	f9400260 	ldr	x0, [x19]
    400037e4:	f9401002 	ldr	x2, [x0, #32]
    400037e8:	b4000082 	cbz	x2, 400037f8 <dropped_notify+0x70>
		backend->api->dropped(backend, cnt);
    400037ec:	2a1603e1 	mov	w1, w22
    400037f0:	aa1303e0 	mov	x0, x19
    400037f4:	d63f0040 	blr	x2
	for (int i = 0; i < log_backend_count_get(); i++) {
    400037f8:	110006b5 	add	w21, w21, #0x1
    400037fc:	91008273 	add	x19, x19, #0x20
    40003800:	17ffffef 	b	400037bc <dropped_notify+0x34>

0000000040003804 <z_log_strdup>:
{
    40003804:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40003808:	910003fd 	mov	x29, sp
    4000380c:	f9000bf3 	str	x19, [sp, #16]
    40003810:	aa0003f3 	mov	x19, x0
	return (((const char *)addr >= (const char *)RO_START) &&
    40003814:	f0000060 	adrp	x0, 40012000 <__rodata_region_start>
    40003818:	91000000 	add	x0, x0, #0x0
    4000381c:	eb00027f 	cmp	x19, x0
    40003820:	540000a3 	b.cc	40003834 <z_log_strdup+0x30>  // b.lo, b.ul, b.last
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
    40003824:	900000a0 	adrp	x0, 40017000 <__aarch64_have_lse_atomics>
    40003828:	91000000 	add	x0, x0, #0x0
    4000382c:	eb00027f 	cmp	x19, x0
    40003830:	54000263 	b.cc	4000387c <z_log_strdup+0x78>  // b.lo, b.ul, b.last
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    40003834:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003838:	9107c000 	add	x0, x0, #0x1f0
    4000383c:	9100a3e1 	add	x1, sp, #0x28
    40003840:	d2800002 	mov	x2, #0x0                   	// #0
    40003844:	94002bba 	bl	4000e72c <k_mem_slab_alloc>
	if (err != 0) {
    40003848:	35000220 	cbnz	w0, 4000388c <z_log_strdup+0x88>
    4000384c:	f94017e1 	ldr	x1, [sp, #40]
    40003850:	d2800020 	mov	x0, #0x1                   	// #1
    40003854:	97fff5cf 	bl	40000f90 <__aarch64_swp8_acq_rel>
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    40003858:	f94017e0 	ldr	x0, [sp, #40]
    4000385c:	aa1303e1 	mov	x1, x19
    40003860:	d28003e2 	mov	x2, #0x1f                  	// #31
    40003864:	91002000 	add	x0, x0, #0x8
    40003868:	940020af 	bl	4000bb24 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    4000386c:	f94017f3 	ldr	x19, [sp, #40]
    40003870:	52800fc0 	mov	w0, #0x7e                  	// #126
	return dup->buf;
    40003874:	91002273 	add	x19, x19, #0x8
	dup->buf[sizeof(dup->buf) - 2] = '~';
    40003878:	7801f260 	sturh	w0, [x19, #31]
}
    4000387c:	aa1303e0 	mov	x0, x19
    40003880:	f9400bf3 	ldr	x19, [sp, #16]
    40003884:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40003888:	d65f03c0 	ret
		return (char *)log_strdup_fail_msg;
    4000388c:	b0000093 	adrp	x19, 40014000 <CSWTCH.135+0x90>
    40003890:	91058e73 	add	x19, x19, #0x163
    40003894:	17fffffa 	b	4000387c <z_log_strdup+0x78>

0000000040003898 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
    40003898:	b4000120 	cbz	x0, 400038bc <log_is_strdup+0x24>
    4000389c:	90000361 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
    400038a0:	91038021 	add	x1, x1, #0xe0
    400038a4:	eb01001f 	cmp	x0, x1
    400038a8:	540000a3 	b.cc	400038bc <log_is_strdup+0x24>  // b.lo, b.ul, b.last
    400038ac:	91030021 	add	x1, x1, #0xc0
    400038b0:	eb01001f 	cmp	x0, x1
    400038b4:	1a9f27e0 	cset	w0, cc  // cc = lo, ul, last
}
    400038b8:	d65f03c0 	ret
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
    400038bc:	52800000 	mov	w0, #0x0                   	// #0
    400038c0:	17fffffe 	b	400038b8 <log_is_strdup+0x20>

00000000400038c4 <z_impl_log_process>:
{
    400038c4:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    400038c8:	910003fd 	mov	x29, sp
    400038cc:	a9025bf5 	stp	x21, x22, [sp, #32]
    400038d0:	12001c16 	and	w22, w0, #0xff
	if (!backend_attached && !bypass) {
    400038d4:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    400038d8:	3962d000 	ldrb	w0, [x0, #2228]
{
    400038dc:	a90153f3 	stp	x19, x20, [sp, #16]
    400038e0:	a90363f7 	stp	x23, x24, [sp, #48]
    400038e4:	a9046bf9 	stp	x25, x26, [sp, #64]
    400038e8:	a90573fb 	stp	x27, x28, [sp, #80]
	if (!backend_attached && !bypass) {
    400038ec:	35000040 	cbnz	w0, 400038f4 <z_impl_log_process+0x30>
    400038f0:	340002d6 	cbz	w22, 40003948 <z_impl_log_process+0x84>
	msg = get_msg();
    400038f4:	97ffff75 	bl	400036c8 <get_msg>
    400038f8:	aa0003f3 	mov	x19, x0
	if (msg.msg) {
    400038fc:	b4000100 	cbz	x0, 4000391c <z_impl_log_process+0x58>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    40003900:	d00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40003904:	9105c021 	add	x1, x1, #0x170
    40003908:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4000390c:	97fff5ad 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (!bypass) {
    40003910:	340002d6 	cbz	w22, 40003968 <z_impl_log_process+0xa4>
			log_msg_put(msg.msg);
    40003914:	aa1303e0 	mov	x0, x19
    40003918:	940002d6 	bl	40004470 <log_msg_put>
	if (!bypass && z_log_dropped_pending()) {
    4000391c:	350000d6 	cbnz	w22, 40003934 <z_impl_log_process+0x70>
	return dropped_cnt > 0;
    40003920:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
	if (!bypass && z_log_dropped_pending()) {
    40003924:	f940bc00 	ldr	x0, [x0, #376]
    40003928:	f100001f 	cmp	x0, #0x0
    4000392c:	5400004d 	b.le	40003934 <z_impl_log_process+0x70>
		dropped_notify();
    40003930:	97ffff96 	bl	40003788 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
    40003934:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003938:	91062000 	add	x0, x0, #0x188
    4000393c:	97fffecc 	bl	4000346c <log_list_head_peek>
    40003940:	f100001f 	cmp	x0, #0x0
    40003944:	1a9f07f6 	cset	w22, ne  // ne = any
}
    40003948:	2a1603e0 	mov	w0, w22
    4000394c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003950:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003954:	a94363f7 	ldp	x23, x24, [sp, #48]
    40003958:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000395c:	a94573fb 	ldp	x27, x28, [sp, #80]
    40003960:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40003964:	d65f03c0 	ret
		    !panic_mode) {
    40003968:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
		if (!IS_ENABLED(CONFIG_LOG2) &&
    4000396c:	3962d400 	ldrb	w0, [x0, #2229]
    40003970:	35000300 	cbnz	w0, 400039d0 <z_impl_log_process+0x10c>
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    40003974:	79402260 	ldrh	w0, [x19, #16]
	if (!log_msg_is_std(msg)) {
    40003978:	370002c0 	tbnz	w0, #0, 400039d0 <z_impl_log_process+0x10c>
 *
 * @return Source ID.
 */
static inline uint32_t log_dynamic_source_id(struct log_source_dynamic_data *data)
{
	return ((uint8_t *)data - (uint8_t *)__log_dynamic_start)/
    4000397c:	90000379 	adrp	x25, 4006f000 <sys_work_q_stack+0xf20>
    40003980:	91292339 	add	x25, x25, #0xa48
    40003984:	90000374 	adrp	x20, 4006f000 <sys_work_q_stack+0xf20>
    40003988:	91290294 	add	x20, x20, #0xa40
	msg_str = log_msg_str_get(msg);
    4000398c:	aa1303e0 	mov	x0, x19
    40003990:	cb140334 	sub	x20, x25, x20
    40003994:	940002c7 	bl	400044b0 <log_msg_str_get>
    40003998:	aa0003f8 	mov	x24, x0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    4000399c:	aa1303e0 	mov	x0, x19
    400039a0:	9400025e 	bl	40004318 <log_msg_nargs_get>
	return (((const char *)addr >= (const char *)RO_START) &&
    400039a4:	f000007a 	adrp	x26, 40012000 <__rodata_region_start>
    400039a8:	9100035a 	add	x26, x26, #0x0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    400039ac:	2a0003e1 	mov	w1, w0
		if (!is_rodata(str) && !log_is_strdup(str) &&
    400039b0:	b000009b 	adrp	x27, 40014000 <CSWTCH.135+0x90>
    400039b4:	91058f7b 	add	x27, x27, #0x163
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    400039b8:	aa1803e0 	mov	x0, x24
    400039bc:	d342fe94 	lsr	x20, x20, #2
    400039c0:	97fffeea 	bl	40003568 <z_log_get_s_mask>
    400039c4:	2a0003f5 	mov	w21, w0
		idx = 31 - __builtin_clz(mask);
    400039c8:	528003fc 	mov	w28, #0x1f                  	// #31
	while (mask) {
    400039cc:	35000135 	cbnz	w21, 400039f0 <z_impl_log_process+0x12c>
	return __log_backends_end - __log_backends_start;
    400039d0:	f0000074 	adrp	x20, 40012000 <__rodata_region_start>
    400039d4:	913c8294 	add	x20, x20, #0xf20
    400039d8:	f0000075 	adrp	x21, 40012000 <__rodata_region_start>
    400039dc:	913d02b5 	add	x21, x21, #0xf40
    400039e0:	cb1402b5 	sub	x21, x21, x20
    400039e4:	52800017 	mov	w23, #0x0                   	// #0
    400039e8:	d34592b5 	ubfx	x21, x21, #5, #32
    400039ec:	14000039 	b	40003ad0 <z_impl_log_process+0x20c>
		idx = 31 - __builtin_clz(mask);
    400039f0:	5ac012b7 	clz	w23, w21
		str = (const char *)log_msg_arg_get(msg, idx);
    400039f4:	aa1303e0 	mov	x0, x19
		idx = 31 - __builtin_clz(mask);
    400039f8:	4b170397 	sub	w23, w28, w23
		str = (const char *)log_msg_arg_get(msg, idx);
    400039fc:	2a1703e1 	mov	w1, w23
    40003a00:	94000249 	bl	40004324 <log_msg_arg_get>
    40003a04:	aa0003e2 	mov	x2, x0
	return (((const char *)addr >= (const char *)RO_START) &&
    40003a08:	eb1a001f 	cmp	x0, x26
    40003a0c:	540000a3 	b.cc	40003a20 <z_impl_log_process+0x15c>  // b.lo, b.ul, b.last
		if (!is_rodata(str) && !log_is_strdup(str) &&
    40003a10:	900000a0 	adrp	x0, 40017000 <__aarch64_have_lse_atomics>
    40003a14:	91000000 	add	x0, x0, #0x0
    40003a18:	eb00005f 	cmp	x2, x0
    40003a1c:	540002c3 	b.cc	40003a74 <z_impl_log_process+0x1b0>  // b.lo, b.ul, b.last
    40003a20:	aa0203e0 	mov	x0, x2
    40003a24:	97ffff9d 	bl	40003898 <log_is_strdup>
    40003a28:	72001c1f 	tst	w0, #0xff
    40003a2c:	54000241 	b.ne	40003a74 <z_impl_log_process+0x1b0>  // b.any
    40003a30:	eb1b005f 	cmp	x2, x27
    40003a34:	54000200 	b.eq	40003a74 <z_impl_log_process+0x1b0>  // b.none
	return msg->hdr.ids.source_id;
    40003a38:	f9400a61 	ldr	x1, [x19, #16]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
    40003a3c:	52800000 	mov	w0, #0x0                   	// #0
    40003a40:	53167c21 	lsr	w1, w1, #22
    40003a44:	9400011b 	bl	40003eb0 <log_source_name_get>
    40003a48:	aa0003e2 	mov	x2, x0
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
    40003a4c:	b9400320 	ldr	w0, [x25]
    40003a50:	f240081f 	tst	x0, #0x7
    40003a54:	54000100 	b.eq	40003a74 <z_impl_log_process+0x1b0>  // b.none
    40003a58:	531a2684 	ubfiz	w4, w20, #6, #10
    40003a5c:	b0000080 	adrp	x0, 40014000 <CSWTCH.135+0x90>
    40003a60:	9105f400 	add	x0, x0, #0x17d
    40003a64:	32000084 	orr	w4, w4, #0x1
    40003a68:	aa1803e3 	mov	x3, x24
    40003a6c:	93407ee1 	sxtw	x1, w23
    40003a70:	940000ab 	bl	40003d1c <log_3>
		mask &= ~BIT(idx);
    40003a74:	d2800020 	mov	x0, #0x1                   	// #1
    40003a78:	9ad72017 	lsl	x23, x0, x23
    40003a7c:	0a3702b5 	bic	w21, w21, w23
    40003a80:	17ffffd3 	b	400039cc <z_impl_log_process+0x108>
	return backend->cb->active;
    40003a84:	f9400680 	ldr	x0, [x20, #8]
			if (log_backend_is_active(backend) &&
    40003a88:	39402400 	ldrb	w0, [x0, #9]
    40003a8c:	340001e0 	cbz	w0, 40003ac8 <z_impl_log_process+0x204>
	return msg->hdr.ids.level;
    40003a90:	f9400a61 	ldr	x1, [x19, #16]
	backend_level = log_filter_get(backend, domain_id,
    40003a94:	aa1403e0 	mov	x0, x20
    40003a98:	52800023 	mov	w3, #0x1                   	// #1
    40003a9c:	53104838 	ubfx	w24, w1, #16, #3
    40003aa0:	53167c22 	lsr	w2, w1, #22
    40003aa4:	53135421 	ubfx	w1, w1, #19, #3
    40003aa8:	94000183 	bl	400040b4 <log_filter_get>
			if (log_backend_is_active(backend) &&
    40003aac:	6b00031f 	cmp	w24, w0
    40003ab0:	540000c8 	b.hi	40003ac8 <z_impl_log_process+0x204>  // b.pmore
	backend->api->put(backend, msg);
    40003ab4:	f9400280 	ldr	x0, [x20]
    40003ab8:	aa1303e1 	mov	x1, x19
    40003abc:	f9400402 	ldr	x2, [x0, #8]
    40003ac0:	aa1403e0 	mov	x0, x20
    40003ac4:	d63f0040 	blr	x2
		for (int i = 0; i < log_backend_count_get(); i++) {
    40003ac8:	110006f7 	add	w23, w23, #0x1
    40003acc:	91008294 	add	x20, x20, #0x20
    40003ad0:	6b1502ff 	cmp	w23, w21
    40003ad4:	54fffd8b 	b.lt	40003a84 <z_impl_log_process+0x1c0>  // b.tstop
    40003ad8:	17ffff8f 	b	40003914 <z_impl_log_process+0x50>

0000000040003adc <log_process_thread_func>:
{
    40003adc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003ae0:	910003fd 	mov	x29, sp
    40003ae4:	f9000bf3 	str	x19, [sp, #16]
	log_init();
    40003ae8:	97fffed3 	bl	40003634 <log_init>
	return z_impl_z_current_get();
    40003aec:	940030dd 	bl	4000fe60 <z_impl_z_current_get>
	proc_tid = process_tid;
    40003af0:	d00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40003af4:	f9011420 	str	x0, [x1, #552]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    40003af8:	b4000100 	cbz	x0, 40003b18 <log_process_thread_func+0x3c>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    40003afc:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
	    process_tid &&
    40003b00:	f940b800 	ldr	x0, [x0, #368]
    40003b04:	f100241f 	cmp	x0, #0x9
    40003b08:	5400008d 	b.le	40003b18 <log_process_thread_func+0x3c>
	z_impl_k_sem_give(sem);
    40003b0c:	90000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    40003b10:	912ae000 	add	x0, x0, #0xab8
    40003b14:	94002d9c 	bl	4000f184 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
    40003b18:	90000373 	adrp	x19, 4006f000 <sys_work_q_stack+0xf20>
    40003b1c:	912ae273 	add	x19, x19, #0xab8
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    40003b20:	52800000 	mov	w0, #0x0                   	// #0
    40003b24:	97ffff68 	bl	400038c4 <z_impl_log_process>
		if (log_process(false) == false) {
    40003b28:	72001c1f 	tst	w0, #0xff
    40003b2c:	54ffffa1 	b.ne	40003b20 <log_process_thread_func+0x44>  // b.any
    40003b30:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40003b34:	aa1303e0 	mov	x0, x19
    40003b38:	94002dab 	bl	4000f1e4 <z_impl_k_sem_take>
    40003b3c:	17fffff9 	b	40003b20 <log_process_thread_func+0x44>

0000000040003b40 <msg_finalize>:
{
    40003b40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003b44:	910003fd 	mov	x29, sp
    40003b48:	a90153f3 	stp	x19, x20, [sp, #16]
    40003b4c:	aa0003f3 	mov	x19, x0
	msg->hdr.ids = src_level;
    40003b50:	79002401 	strh	w1, [x0, #18]
	msg->hdr.timestamp = timestamp_func();
    40003b54:	90000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    40003b58:	f9444800 	ldr	x0, [x0, #2192]
    40003b5c:	d63f0000 	blr	x0
    40003b60:	b9001660 	str	w0, [x19, #20]
    40003b64:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40003b68:	d50342df 	msr	daifset, #0x2
	log_list_add_tail(&list, msg);
    40003b6c:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003b70:	91062000 	add	x0, x0, #0x188
    40003b74:	aa1303e1 	mov	x1, x19
MAKE_REG_HELPER(daif)
    40003b78:	92407e94 	and	x20, x20, #0xffffffff
    40003b7c:	97fffe33 	bl	40003448 <log_list_add_tail>
    40003b80:	d51b4234 	msr	daif, x20
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    40003b84:	d00000f3 	adrp	x19, 40021000 <k_sys_work_q+0x240>
    40003b88:	9105c261 	add	x1, x19, #0x170
    40003b8c:	d2800020 	mov	x0, #0x1                   	// #1
    40003b90:	97fff50c 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (panic_mode) {
    40003b94:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003b98:	3962d400 	ldrb	w0, [x0, #2229]
    40003b9c:	34000140 	cbz	w0, 40003bc4 <msg_finalize+0x84>
    40003ba0:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40003ba4:	d50342df 	msr	daifset, #0x2
    40003ba8:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    40003bac:	92407e73 	and	x19, x19, #0xffffffff
    40003bb0:	97ffff45 	bl	400038c4 <z_impl_log_process>
    40003bb4:	d51b4233 	msr	daif, x19
}
    40003bb8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003bbc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003bc0:	d65f03c0 	ret
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    40003bc4:	d00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40003bc8:	f9411421 	ldr	x1, [x1, #552]
    40003bcc:	f940ba60 	ldr	x0, [x19, #368]
    40003bd0:	b4ffff41 	cbz	x1, 40003bb8 <msg_finalize+0x78>
    40003bd4:	f100041f 	cmp	x0, #0x1
    40003bd8:	54000101 	b.ne	40003bf8 <msg_finalize+0xb8>  // b.any
}
    40003bdc:	a94153f3 	ldp	x19, x20, [sp, #16]
	z_impl_k_timer_start(timer, duration, period);
    40003be0:	d2800002 	mov	x2, #0x0                   	// #0
    40003be4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003be8:	d2800c81 	mov	x1, #0x64                  	// #100
    40003bec:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003bf0:	91066000 	add	x0, x0, #0x198
    40003bf4:	1400322e 	b	400104ac <z_impl_k_timer_start>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    40003bf8:	f100281f 	cmp	x0, #0xa
    40003bfc:	54fffde1 	b.ne	40003bb8 <msg_finalize+0x78>  // b.any
	z_impl_k_timer_stop(timer);
    40003c00:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003c04:	91066000 	add	x0, x0, #0x198
    40003c08:	9400324d 	bl	4001053c <z_impl_k_timer_stop>
}
    40003c0c:	a94153f3 	ldp	x19, x20, [sp, #16]
	z_impl_k_sem_give(sem);
    40003c10:	90000360 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    40003c14:	912ae000 	add	x0, x0, #0xab8
    40003c18:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003c1c:	14002d5a 	b	4000f184 <z_impl_k_sem_give>

0000000040003c20 <log_0>:
{
    40003c20:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40003c24:	910003fd 	mov	x29, sp
    40003c28:	a90153f3 	stp	x19, x20, [sp, #16]
    40003c2c:	aa0003f4 	mov	x20, x0
    40003c30:	2a0103f3 	mov	w19, w1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
    40003c34:	97fffe16 	bl	4000348c <z_log_msg_std_alloc>

	if (msg != NULL) {
    40003c38:	b40000c0 	cbz	x0, 40003c50 <log_0+0x30>
		msg->str = str;
    40003c3c:	f9000c14 	str	x20, [x0, #24]
		msg_finalize(msg, src_level);
    40003c40:	2a1303e1 	mov	w1, w19
}
    40003c44:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003c48:	a8c27bfd 	ldp	x29, x30, [sp], #32
		msg_finalize(msg, src_level);
    40003c4c:	17ffffbd 	b	40003b40 <msg_finalize>
}
    40003c50:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003c54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003c58:	d65f03c0 	ret

0000000040003c5c <log_1>:
{
    40003c5c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40003c60:	910003fd 	mov	x29, sp
    40003c64:	a90153f3 	stp	x19, x20, [sp, #16]
    40003c68:	aa0103f4 	mov	x20, x1
    40003c6c:	2a0203f3 	mov	w19, w2
    40003c70:	f90013f5 	str	x21, [sp, #32]
    40003c74:	aa0003f5 	mov	x21, x0
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    40003c78:	97fffe05 	bl	4000348c <z_log_msg_std_alloc>

	if (msg != NULL) {
    40003c7c:	b4000160 	cbz	x0, 40003ca8 <log_1+0x4c>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
    40003c80:	79402001 	ldrh	w1, [x0, #16]
    40003c84:	52800022 	mov	w2, #0x1                   	// #1
		msg->payload.single.args[0] = arg1;
    40003c88:	a901d015 	stp	x21, x20, [x0, #24]
		msg->hdr.params.std.nargs = 1U;
    40003c8c:	33140c41 	bfi	w1, w2, #12, #4
    40003c90:	79002001 	strh	w1, [x0, #16]
		msg_finalize(msg, src_level);
    40003c94:	2a1303e1 	mov	w1, w19
}
    40003c98:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003c9c:	f94013f5 	ldr	x21, [sp, #32]
    40003ca0:	a8c37bfd 	ldp	x29, x30, [sp], #48
		msg_finalize(msg, src_level);
    40003ca4:	17ffffa7 	b	40003b40 <msg_finalize>
}
    40003ca8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003cac:	f94013f5 	ldr	x21, [sp, #32]
    40003cb0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40003cb4:	d65f03c0 	ret

0000000040003cb8 <log_2>:
{
    40003cb8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40003cbc:	910003fd 	mov	x29, sp
    40003cc0:	a90153f3 	stp	x19, x20, [sp, #16]
    40003cc4:	aa0203f4 	mov	x20, x2
    40003cc8:	2a0303f3 	mov	w19, w3
    40003ccc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40003cd0:	aa0003f6 	mov	x22, x0
    40003cd4:	aa0103f5 	mov	x21, x1
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    40003cd8:	97fffded 	bl	4000348c <z_log_msg_std_alloc>

	if (msg != NULL) {
    40003cdc:	b4000180 	cbz	x0, 40003d0c <log_2+0x54>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
    40003ce0:	79402001 	ldrh	w1, [x0, #16]
    40003ce4:	52800042 	mov	w2, #0x2                   	// #2
		msg->payload.single.args[0] = arg1;
    40003ce8:	a901d416 	stp	x22, x21, [x0, #24]
		msg->hdr.params.std.nargs = 2U;
    40003cec:	33140c41 	bfi	w1, w2, #12, #4
    40003cf0:	79002001 	strh	w1, [x0, #16]
		msg->payload.single.args[1] = arg2;
    40003cf4:	f9001414 	str	x20, [x0, #40]
		msg_finalize(msg, src_level);
    40003cf8:	2a1303e1 	mov	w1, w19
}
    40003cfc:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003d00:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003d04:	a8c37bfd 	ldp	x29, x30, [sp], #48
		msg_finalize(msg, src_level);
    40003d08:	17ffff8e 	b	40003b40 <msg_finalize>
}
    40003d0c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003d10:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003d14:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40003d18:	d65f03c0 	ret

0000000040003d1c <log_3>:
{
    40003d1c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40003d20:	910003fd 	mov	x29, sp
    40003d24:	a90153f3 	stp	x19, x20, [sp, #16]
    40003d28:	aa0303f4 	mov	x20, x3
    40003d2c:	2a0403f3 	mov	w19, w4
    40003d30:	a9025bf5 	stp	x21, x22, [sp, #32]
    40003d34:	aa0103f6 	mov	x22, x1
    40003d38:	aa0203f5 	mov	x21, x2
    40003d3c:	f9001bf7 	str	x23, [sp, #48]
    40003d40:	aa0003f7 	mov	x23, x0
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
    40003d44:	97fffdd2 	bl	4000348c <z_log_msg_std_alloc>

	if (msg != NULL) {
    40003d48:	b40001a0 	cbz	x0, 40003d7c <log_3+0x60>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
    40003d4c:	79402001 	ldrh	w1, [x0, #16]
    40003d50:	52800062 	mov	w2, #0x3                   	// #3
		msg->payload.single.args[0] = arg1;
    40003d54:	a901d817 	stp	x23, x22, [x0, #24]
		msg->hdr.params.std.nargs = 3U;
    40003d58:	33140c41 	bfi	w1, w2, #12, #4
    40003d5c:	79002001 	strh	w1, [x0, #16]
		msg->payload.single.args[1] = arg2;
		msg->payload.single.args[2] = arg3;
    40003d60:	a902d015 	stp	x21, x20, [x0, #40]
		msg_finalize(msg, src_level);
    40003d64:	2a1303e1 	mov	w1, w19
}
    40003d68:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003d6c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003d70:	f9401bf7 	ldr	x23, [sp, #48]
    40003d74:	a8c47bfd 	ldp	x29, x30, [sp], #64
		msg_finalize(msg, src_level);
    40003d78:	17ffff72 	b	40003b40 <msg_finalize>
}
    40003d7c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003d80:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003d84:	f9401bf7 	ldr	x23, [sp, #48]
    40003d88:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40003d8c:	d65f03c0 	ret

0000000040003d90 <z_impl_log_panic>:
	if (panic_mode) {
    40003d90:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003d94:	3962d401 	ldrb	w1, [x0, #2229]
    40003d98:	35000481 	cbnz	w1, 40003e28 <z_impl_log_panic+0x98>
{
    40003d9c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40003da0:	910003fd 	mov	x29, sp
    40003da4:	a90153f3 	stp	x19, x20, [sp, #16]
	return __log_backends_end - __log_backends_start;
    40003da8:	f0000073 	adrp	x19, 40012000 <__rodata_region_start>
    40003dac:	913c8273 	add	x19, x19, #0xf20
    40003db0:	f0000074 	adrp	x20, 40012000 <__rodata_region_start>
    40003db4:	913d0294 	add	x20, x20, #0xf40
    40003db8:	cb130294 	sub	x20, x20, x19
    40003dbc:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (int i = 0; i < log_backend_count_get(); i++) {
    40003dc0:	52800015 	mov	w21, #0x0                   	// #0
    40003dc4:	d3459294 	ubfx	x20, x20, #5, #32
    40003dc8:	aa0003f6 	mov	x22, x0
	log_init();
    40003dcc:	97fffe1a 	bl	40003634 <log_init>
	for (int i = 0; i < log_backend_count_get(); i++) {
    40003dd0:	6b1402bf 	cmp	w21, w20
    40003dd4:	5400016b 	b.lt	40003e00 <z_impl_log_panic+0x70>  // b.tstop
    40003dd8:	52800000 	mov	w0, #0x0                   	// #0
    40003ddc:	97fffeba 	bl	400038c4 <z_impl_log_process>
		while (log_process(false) == true) {
    40003de0:	72001c1f 	tst	w0, #0xff
    40003de4:	54ffffa1 	b.ne	40003dd8 <z_impl_log_panic+0x48>  // b.any
	panic_mode = true;
    40003de8:	52800020 	mov	w0, #0x1                   	// #1
    40003dec:	3922d6c0 	strb	w0, [x22, #2229]
}
    40003df0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003df4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003df8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40003dfc:	d65f03c0 	ret
	return backend->cb->active;
    40003e00:	f9400660 	ldr	x0, [x19, #8]
		if (log_backend_is_active(backend)) {
    40003e04:	39402400 	ldrb	w0, [x0, #9]
    40003e08:	340000a0 	cbz	w0, 40003e1c <z_impl_log_panic+0x8c>
	backend->api->panic(backend);
    40003e0c:	f9400260 	ldr	x0, [x19]
    40003e10:	f9401401 	ldr	x1, [x0, #40]
    40003e14:	aa1303e0 	mov	x0, x19
    40003e18:	d63f0020 	blr	x1
	for (int i = 0; i < log_backend_count_get(); i++) {
    40003e1c:	110006b5 	add	w21, w21, #0x1
    40003e20:	91008273 	add	x19, x19, #0x20
    40003e24:	17ffffeb 	b	40003dd0 <z_impl_log_panic+0x40>
    40003e28:	d65f03c0 	ret

0000000040003e2c <z_log_free>:
{
    40003e2c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    40003e30:	d1002001 	sub	x1, x0, #0x8
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    40003e34:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
{
    40003e38:	910003fd 	mov	x29, sp
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    40003e3c:	f9000fe1 	str	x1, [sp, #24]
    40003e40:	97fff460 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (atomic_dec(&dup->refcount) == 1) {
    40003e44:	f100041f 	cmp	x0, #0x1
    40003e48:	540000a1 	b.ne	40003e5c <z_log_free+0x30>  // b.any
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    40003e4c:	d00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40003e50:	9107c000 	add	x0, x0, #0x1f0
    40003e54:	910063e1 	add	x1, sp, #0x18
    40003e58:	94002a57 	bl	4000e7b4 <k_mem_slab_free>
}
    40003e5c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40003e60:	d65f03c0 	ret

0000000040003e64 <z_log_runtime_filters_init>:
	 *
	 * Each log source's aggregated runtime level is set to match its
	 * compile-time level. When backends are attached later on in
	 * log_init(), they'll be initialized to the same value.
	 */
	for (int i = 0; i < z_log_sources_count(); i++) {
    40003e64:	f0000061 	adrp	x1, 40012000 <__rodata_region_start>
    40003e68:	913b0021 	add	x1, x1, #0xec0
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    40003e6c:	f0000060 	adrp	x0, 40012000 <__rodata_region_start>
    40003e70:	913c8000 	add	x0, x0, #0xf20
    40003e74:	cb010000 	sub	x0, x0, x1
    40003e78:	90000362 	adrp	x2, 4006f000 <sys_work_q_stack+0xf20>
    40003e7c:	91290042 	add	x2, x2, #0xa40
    40003e80:	52800003 	mov	w3, #0x0                   	// #0
    40003e84:	d3448c00 	ubfx	x0, x0, #4, #32
    40003e88:	91004021 	add	x1, x1, #0x10
    40003e8c:	6b00007f 	cmp	w3, w0
    40003e90:	54000041 	b.ne	40003e98 <z_log_runtime_filters_init+0x34>  // b.any

		LOG_FILTER_SLOT_SET(filters,
				    LOG_FILTER_AGGR_SLOT_IDX,
				    level);
	}
}
    40003e94:	d65f03c0 	ret
		LOG_FILTER_SLOT_SET(filters,
    40003e98:	b9400044 	ldr	w4, [x2]
	for (int i = 0; i < z_log_sources_count(); i++) {
    40003e9c:	11000463 	add	w3, w3, #0x1
		LOG_FILTER_SLOT_SET(filters,
    40003ea0:	385f8025 	ldurb	w5, [x1, #-8]
    40003ea4:	330008a4 	bfxil	w4, w5, #0, #3
    40003ea8:	b8004444 	str	w4, [x2], #4
	for (int i = 0; i < z_log_sources_count(); i++) {
    40003eac:	17fffff7 	b	40003e88 <z_log_runtime_filters_init+0x24>

0000000040003eb0 <log_source_name_get>:
    40003eb0:	f0000062 	adrp	x2, 40012000 <__rodata_region_start>
    40003eb4:	913b0042 	add	x2, x2, #0xec0
    40003eb8:	f0000060 	adrp	x0, 40012000 <__rodata_region_start>
    40003ebc:	913c8000 	add	x0, x0, #0xf20
    40003ec0:	cb020000 	sub	x0, x0, x2
    40003ec4:	d344fc00 	lsr	x0, x0, #4
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    40003ec8:	6b00003f 	cmp	w1, w0
    40003ecc:	54000082 	b.cs	40003edc <log_source_name_get+0x2c>  // b.hs, b.nlast
	return __log_const_start[source_id].name;
    40003ed0:	d37c7c21 	ubfiz	x1, x1, #4, #32
    40003ed4:	f8616840 	ldr	x0, [x2, x1]
}
    40003ed8:	d65f03c0 	ret
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    40003edc:	d2800000 	mov	x0, #0x0                   	// #0
    40003ee0:	17fffffe 	b	40003ed8 <log_source_name_get+0x28>

0000000040003ee4 <z_impl_log_filter_set>:
}

uint32_t z_impl_log_filter_set(struct log_backend const *const backend,
			       uint32_t domain_id, int16_t source_id,
			       uint32_t level)
{
    40003ee4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40003ee8:	910003fd 	mov	x29, sp
    40003eec:	a90153f3 	stp	x19, x20, [sp, #16]
    40003ef0:	a9025bf5 	stp	x21, x22, [sp, #32]
    40003ef4:	13003c56 	sxth	w22, w2
    40003ef8:	2a0303f5 	mov	w21, w3
    40003efc:	a90363f7 	stp	x23, x24, [sp, #48]
    40003f00:	f90023f9 	str	x25, [sp, #64]
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)) {
		uint32_t new_aggr_filter;

		uint32_t *filters = z_log_dynamic_filters_get(source_id);

		if (backend == NULL) {
    40003f04:	b5000380 	cbnz	x0, 40003f74 <z_impl_log_filter_set+0x90>
	return __log_backends_end - __log_backends_start;
    40003f08:	f0000078 	adrp	x24, 40012000 <__rodata_region_start>
    40003f0c:	913c8318 	add	x24, x24, #0xf20
    40003f10:	f0000074 	adrp	x20, 40012000 <__rodata_region_start>
    40003f14:	913d0294 	add	x20, x20, #0xf40
    40003f18:	cb180294 	sub	x20, x20, x24
    40003f1c:	2a0103f9 	mov	w25, w1
    40003f20:	d2800017 	mov	x23, #0x0                   	// #0
			struct log_backend const *iter_backend;
			uint32_t max = 0U;
    40003f24:	52800013 	mov	w19, #0x0                   	// #0
    40003f28:	d3459294 	ubfx	x20, x20, #5, #32
			uint32_t current;

			for (int i = 0; i < log_backend_count_get(); i++) {
    40003f2c:	6b17029f 	cmp	w20, w23
    40003f30:	5400010c 	b.gt	40003f50 <z_impl_log_filter_set+0x6c>
					    new_aggr_filter);
		}
	}

	return level;
}
    40003f34:	2a1303e0 	mov	w0, w19
    40003f38:	a94153f3 	ldp	x19, x20, [sp, #16]
    40003f3c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40003f40:	a94363f7 	ldp	x23, x24, [sp, #48]
    40003f44:	f94023f9 	ldr	x25, [sp, #64]
    40003f48:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40003f4c:	d65f03c0 	ret
		/* coverity[OVERRUN] */
		return (uint32_t) arch_syscall_invoke4(*(uintptr_t *)&backend, *(uintptr_t *)&domain_id, *(uintptr_t *)&source_id, *(uintptr_t *)&level, K_SYSCALL_LOG_FILTER_SET);
	}
#endif
	compiler_barrier();
	return z_impl_log_filter_set(backend, domain_id, source_id, level);
    40003f50:	8b171700 	add	x0, x24, x23, lsl #5
    40003f54:	2a1503e3 	mov	w3, w21
    40003f58:	2a1603e2 	mov	w2, w22
    40003f5c:	2a1903e1 	mov	w1, w25
    40003f60:	97ffffe1 	bl	40003ee4 <z_impl_log_filter_set>
				max = MAX(current, max);
    40003f64:	6b00027f 	cmp	w19, w0
    40003f68:	1a802273 	csel	w19, w19, w0, cs  // cs = hs, nlast
			for (int i = 0; i < log_backend_count_get(); i++) {
    40003f6c:	910006f7 	add	x23, x23, #0x1
    40003f70:	17ffffef 	b	40003f2c <z_impl_log_filter_set+0x48>
	return __log_const_start[source_id].level;
    40003f74:	2a1603e5 	mov	w5, w22
    40003f78:	f0000061 	adrp	x1, 40012000 <__rodata_region_start>
    40003f7c:	913b0021 	add	x1, x1, #0xec0
    40003f80:	d37c7ed6 	ubfiz	x22, x22, #4, #32
	return backend->cb->id;
    40003f84:	f9400400 	ldr	x0, [x0, #8]
    40003f88:	8b160021 	add	x1, x1, x22
			LOG_FILTER_SLOT_SET(filters,
    40003f8c:	90000362 	adrp	x2, 4006f000 <sys_work_q_stack+0xf20>
    40003f90:	91290042 	add	x2, x2, #0xa40

		return LOG_FILTER_SLOT_GET(filters,
					   log_backend_id_get(backend));
	}

	return log_compiled_level_get(source_id);
    40003f94:	39402033 	ldrb	w19, [x1, #8]
			LOG_FILTER_SLOT_SET(filters,
    40003f98:	d28000e1 	mov	x1, #0x7                   	// #7
    40003f9c:	39402000 	ldrb	w0, [x0, #8]
			level = MIN(level, max);
    40003fa0:	6b03027f 	cmp	w19, w3
    40003fa4:	1a839273 	csel	w19, w19, w3, ls  // ls = plast
			LOG_FILTER_SLOT_SET(filters,
    40003fa8:	b8657843 	ldr	w3, [x2, x5, lsl #2]
    40003fac:	0b000400 	add	w0, w0, w0, lsl #1
    40003fb0:	9ac02021 	lsl	x1, x1, x0
    40003fb4:	0a210061 	bic	w1, w3, w1
    40003fb8:	92400a63 	and	x3, x19, #0x7
    40003fbc:	9ac02060 	lsl	x0, x3, x0
    40003fc0:	52800063 	mov	w3, #0x3                   	// #3
    40003fc4:	2a000021 	orr	w1, w1, w0
	uint32_t max_filter = LOG_LEVEL_NONE;
    40003fc8:	52800000 	mov	w0, #0x0                   	// #0
		uint32_t tmp_filter = LOG_FILTER_SLOT_GET(&filters, i);
    40003fcc:	1ac32424 	lsr	w4, w1, w3
    40003fd0:	12000884 	and	w4, w4, #0x7
    40003fd4:	6b04001f 	cmp	w0, w4
    40003fd8:	11000c63 	add	w3, w3, #0x3
    40003fdc:	1a842000 	csel	w0, w0, w4, cs  // cs = hs, nlast
	for (i = first_slot; i < LOG_FILTERS_NUM_OF_SLOTS; i++) {
    40003fe0:	7100787f 	cmp	w3, #0x1e
    40003fe4:	54ffff41 	b.ne	40003fcc <z_impl_log_filter_set+0xe8>  // b.any
			LOG_FILTER_SLOT_SET(filters,
    40003fe8:	121d7021 	and	w1, w1, #0xfffffff8
    40003fec:	2a000021 	orr	w1, w1, w0
    40003ff0:	b8257841 	str	w1, [x2, x5, lsl #2]
	return level;
    40003ff4:	17ffffd0 	b	40003f34 <z_impl_log_filter_set+0x50>

0000000040003ff8 <backend_filter_set>:
{
    40003ff8:	aa0003e8 	mov	x8, x0
    40003ffc:	f0000066 	adrp	x6, 40012000 <__rodata_region_start>
    40004000:	913c80c6 	add	x6, x6, #0xf20
    40004004:	d0000060 	adrp	x0, 40012000 <__rodata_region_start>
    40004008:	913b0000 	add	x0, x0, #0xec0
		for (int i = 0; i < z_log_sources_count(); i++) {
    4000400c:	52800007 	mov	w7, #0x0                   	// #0
    40004010:	cb0000c6 	sub	x6, x6, x0
{
    40004014:	2a0103e9 	mov	w9, w1
    40004018:	d3448cc6 	ubfx	x6, x6, #4, #32
		for (int i = 0; i < z_log_sources_count(); i++) {
    4000401c:	6b0600ff 	cmp	w7, w6
    40004020:	54000041 	b.ne	40004028 <backend_filter_set+0x30>  // b.any
    40004024:	d65f03c0 	ret
{
    40004028:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000402c:	910003fd 	mov	x29, sp
    40004030:	52800001 	mov	w1, #0x0                   	// #0
    40004034:	2a0703e2 	mov	w2, w7
    40004038:	2a0903e3 	mov	w3, w9
    4000403c:	aa0803e0 	mov	x0, x8
		for (int i = 0; i < z_log_sources_count(); i++) {
    40004040:	110004e7 	add	w7, w7, #0x1
    40004044:	97ffffa8 	bl	40003ee4 <z_impl_log_filter_set>
    40004048:	6b0600ff 	cmp	w7, w6
    4000404c:	54ffff21 	b.ne	40004030 <backend_filter_set+0x38>  // b.any
}
    40004050:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004054:	d65f03c0 	ret

0000000040004058 <log_backend_enable>:
{
    40004058:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	id += backend - log_backend_get(0);
    4000405c:	d0000063 	adrp	x3, 40012000 <__rodata_region_start>
    40004060:	913c8063 	add	x3, x3, #0xf20
{
    40004064:	910003fd 	mov	x29, sp
    40004068:	aa0103eb 	mov	x11, x1
    4000406c:	2a0203e1 	mov	w1, w2
	id += backend - log_backend_get(0);
    40004070:	cb030003 	sub	x3, x0, x3
{
    40004074:	aa0003ea 	mov	x10, x0
	backend->cb->id = id;
    40004078:	f9400402 	ldr	x2, [x0, #8]
	id += backend - log_backend_get(0);
    4000407c:	9345fc63 	asr	x3, x3, #5
    40004080:	11000463 	add	w3, w3, #0x1
	log_backend_id_set(backend, id);
    40004084:	39002043 	strb	w3, [x2, #8]
	backend_filter_set(backend, level);
    40004088:	97ffffdc 	bl	40003ff8 <backend_filter_set>
	backend->cb->ctx = ctx;
    4000408c:	f9400540 	ldr	x0, [x10, #8]
	backend->cb->active = true;
    40004090:	52800021 	mov	w1, #0x1                   	// #1
	backend->cb->ctx = ctx;
    40004094:	f900000b 	str	x11, [x0]
	backend->cb->active = true;
    40004098:	39002401 	strb	w1, [x0, #9]
}
    4000409c:	a8c17bfd 	ldp	x29, x30, [sp], #16
	z_log_notify_backend_enabled();
    400040a0:	17fffd97 	b	400036fc <z_log_notify_backend_enabled>

00000000400040a4 <log_backend_disable>:
	backend->cb->active = false;
    400040a4:	f9400401 	ldr	x1, [x0, #8]
    400040a8:	3900243f 	strb	wzr, [x1, #9]
	backend_filter_set(backend, LOG_LEVEL_NONE);
    400040ac:	52800001 	mov	w1, #0x0                   	// #0
    400040b0:	17ffffd2 	b	40003ff8 <backend_filter_set>

00000000400040b4 <log_filter_get>:
{
    400040b4:	13003c42 	sxth	w2, w2
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) && runtime) {
    400040b8:	72001c7f 	tst	w3, #0xff
    400040bc:	54000160 	b.eq	400040e8 <log_filter_get+0x34>  // b.none
		if (source_id < 0) {
    400040c0:	37f80202 	tbnz	w2, #31, 40004100 <log_filter_get+0x4c>
	return backend->cb->id;
    400040c4:	f9400400 	ldr	x0, [x0, #8]
		return LOG_FILTER_SLOT_GET(filters,
    400040c8:	39402000 	ldrb	w0, [x0, #8]
    400040cc:	0b000401 	add	w1, w0, w0, lsl #1
    400040d0:	f0000340 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    400040d4:	91290000 	add	x0, x0, #0xa40
    400040d8:	b8625800 	ldr	w0, [x0, w2, uxtw #2]
    400040dc:	1ac12400 	lsr	w0, w0, w1
    400040e0:	12000800 	and	w0, w0, #0x7
}
    400040e4:	d65f03c0 	ret
	return __log_const_start[source_id].level;
    400040e8:	d37c7c40 	ubfiz	x0, x2, #4, #32
    400040ec:	d0000062 	adrp	x2, 40012000 <__rodata_region_start>
    400040f0:	913b0042 	add	x2, x2, #0xec0
    400040f4:	8b000042 	add	x2, x2, x0
	return log_compiled_level_get(source_id);
    400040f8:	39402040 	ldrb	w0, [x2, #8]
    400040fc:	17fffffa 	b	400040e4 <log_filter_get+0x30>
			return LOG_LEVEL_DBG;
    40004100:	52800080 	mov	w0, #0x4                   	// #4
    40004104:	17fffff8 	b	400040e4 <log_filter_get+0x30>

0000000040004108 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
    40004108:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000410c:	910003fd 	mov	x29, sp
    40004110:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004114:	aa0103f5 	mov	x21, x1
	uint32_t available_len = msg->hdr.params.hexdump.length;
    40004118:	f9400801 	ldr	x1, [x0, #16]
{
    4000411c:	a90153f3 	stp	x19, x20, [sp, #16]
    40004120:	aa0303f3 	mov	x19, x3
    40004124:	a90363f7 	stp	x23, x24, [sp, #48]
	uint32_t available_len = msg->hdr.params.hexdump.length;
    40004128:	53023c23 	ubfx	w3, w1, #2, #14
{
    4000412c:	f90023f9 	str	x25, [sp, #64]
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
    40004130:	d3423c21 	ubfx	x1, x1, #2, #14
    40004134:	eb13003f 	cmp	x1, x19
    40004138:	54000108 	b.hi	40004158 <log_msg_hexdump_data_op+0x50>  // b.pmore
		*length = 0;
    4000413c:	f900005f 	str	xzr, [x2]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
    40004140:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004144:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004148:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000414c:	f94023f9 	ldr	x25, [sp, #64]
    40004150:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40004154:	d65f03c0 	ret
    40004158:	12001c98 	and	w24, w4, #0xff
	if ((offset + *length) > available_len) {
    4000415c:	f9400044 	ldr	x4, [x2]
    40004160:	8b040264 	add	x4, x19, x4
    40004164:	eb04003f 	cmp	x1, x4
    40004168:	54000062 	b.cs	40004174 <log_msg_hexdump_data_op+0x6c>  // b.hs, b.nlast
		*length = available_len - offset;
    4000416c:	cb130021 	sub	x1, x1, x19
    40004170:	f9000041 	str	x1, [x2]
	req_len = *length;
    40004174:	f9400059 	ldr	x25, [x2]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    40004178:	7100807f 	cmp	w3, #0x20
	req_len = *length;
    4000417c:	2a1903f7 	mov	w23, w25
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    40004180:	54000489 	b.ls	40004210 <log_msg_hexdump_data_op+0x108>  // b.plast
		cont = msg->payload.ext.next;
    40004184:	f9401016 	ldr	x22, [x0, #32]
		head_data = msg->payload.ext.data.bytes;
    40004188:	9100a001 	add	x1, x0, #0x28
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    4000418c:	52800303 	mov	w3, #0x18                  	// #24
	if (offset < chunk_len) {
    40004190:	2a0303e2 	mov	w2, w3
    40004194:	eb13005f 	cmp	x2, x19
    40004198:	54000489 	b.ls	40004228 <log_msg_hexdump_data_op+0x120>  // b.plast
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    4000419c:	6b19007f 	cmp	w3, w25
			(void)memcpy(&head_data[offset], data, cpy_len);
    400041a0:	8b130020 	add	x0, x1, x19
    400041a4:	1a838334 	csel	w20, w25, w3, hi  // hi = pmore
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    400041a8:	1a999077 	csel	w23, w3, w25, ls  // ls = plast
			(void)memcpy(&head_data[offset], data, cpy_len);
    400041ac:	aa1403e2 	mov	x2, x20
		if (put_op) {
    400041b0:	34000378 	cbz	w24, 4000421c <log_msg_hexdump_data_op+0x114>
			(void)memcpy(&head_data[offset], data, cpy_len);
    400041b4:	aa1503e1 	mov	x1, x21
		req_len -= cpy_len;
    400041b8:	4b170337 	sub	w23, w25, w23
		data += cpy_len;
    400041bc:	8b1402b5 	add	x21, x21, x20
			(void)memcpy(data, &head_data[offset], cpy_len);
    400041c0:	94001ebf 	bl	4000bcbc <memcpy>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
    400041c4:	52800714 	mov	w20, #0x38                  	// #56
	while ((req_len > 0) && (cont != NULL)) {
    400041c8:	710002ff 	cmp	w23, #0x0
    400041cc:	fa401ac4 	ccmp	x22, #0x0, #0x4, ne  // ne = any
    400041d0:	54fffb80 	b.eq	40004140 <log_msg_hexdump_data_op+0x38>  // b.none
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
    400041d4:	4b130282 	sub	w2, w20, w19
			(void)memcpy(&cont->payload.bytes[offset],
    400041d8:	91002273 	add	x19, x19, #0x8
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    400041dc:	6b17005f 	cmp	w2, w23
			(void)memcpy(&cont->payload.bytes[offset],
    400041e0:	8b1302c0 	add	x0, x22, x19
    400041e4:	1a979053 	csel	w19, w2, w23, ls  // ls = plast
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    400041e8:	1a979059 	csel	w25, w2, w23, ls  // ls = plast
			(void)memcpy(&cont->payload.bytes[offset],
    400041ec:	aa1303e2 	mov	x2, x19
		if (put_op) {
    400041f0:	340002d8 	cbz	w24, 40004248 <log_msg_hexdump_data_op+0x140>
			(void)memcpy(&cont->payload.bytes[offset],
    400041f4:	aa1503e1 	mov	x1, x21
		data += cpy_len;
    400041f8:	8b1302b5 	add	x21, x21, x19
			(void)memcpy(data, &cont->payload.bytes[offset],
    400041fc:	94001eb0 	bl	4000bcbc <memcpy>
		req_len -= cpy_len;
    40004200:	4b1902f7 	sub	w23, w23, w25
		offset = 0;
    40004204:	d2800013 	mov	x19, #0x0                   	// #0
		cont = cont->next;
    40004208:	f94002d6 	ldr	x22, [x22]
		data += cpy_len;
    4000420c:	17ffffef 	b	400041c8 <log_msg_hexdump_data_op+0xc0>
		head_data = msg->payload.single.bytes;
    40004210:	91008001 	add	x1, x0, #0x20
	struct log_msg_cont *cont = NULL;
    40004214:	d2800016 	mov	x22, #0x0                   	// #0
    40004218:	17ffffde 	b	40004190 <log_msg_hexdump_data_op+0x88>
			(void)memcpy(data, &head_data[offset], cpy_len);
    4000421c:	aa0003e1 	mov	x1, x0
    40004220:	aa1503e0 	mov	x0, x21
    40004224:	17ffffe5 	b	400041b8 <log_msg_hexdump_data_op+0xb0>
		offset -= chunk_len;
    40004228:	cb020273 	sub	x19, x19, x2
		if (cont == NULL) {
    4000422c:	b5000056 	cbnz	x22, 40004234 <log_msg_hexdump_data_op+0x12c>
			cont = msg->payload.ext.next;
    40004230:	f9401016 	ldr	x22, [x0, #32]
		while (offset >= chunk_len) {
    40004234:	f100de7f 	cmp	x19, #0x37
    40004238:	54fffc69 	b.ls	400041c4 <log_msg_hexdump_data_op+0xbc>  // b.plast
			offset -= chunk_len;
    4000423c:	d100e273 	sub	x19, x19, #0x38
			cont = cont->next;
    40004240:	f94002d6 	ldr	x22, [x22]
			offset -= chunk_len;
    40004244:	17fffffc 	b	40004234 <log_msg_hexdump_data_op+0x12c>
			(void)memcpy(data, &cont->payload.bytes[offset],
    40004248:	aa0003e1 	mov	x1, x0
    4000424c:	aa1503e0 	mov	x0, x21
    40004250:	17ffffea 	b	400041f8 <log_msg_hexdump_data_op+0xf0>

0000000040004254 <log_msg_pool_init>:
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    40004254:	52800203 	mov	w3, #0x10                  	// #16
    40004258:	d2800802 	mov	x2, #0x40                  	// #64
    4000425c:	f0000341 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
    40004260:	91068021 	add	x1, x1, #0x1a0
    40004264:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40004268:	9108c000 	add	x0, x0, #0x230
    4000426c:	1400291b 	b	4000e6d8 <k_mem_slab_init>

0000000040004270 <log_msg_get>:
{
    40004270:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    40004274:	91002001 	add	x1, x0, #0x8
    40004278:	d2800020 	mov	x0, #0x1                   	// #1
    4000427c:	910003fd 	mov	x29, sp
    40004280:	97fff350 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
}
    40004284:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40004288:	d65f03c0 	ret

000000004000428c <log_msg_no_space_handle>:
{
    4000428c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40004290:	910003fd 	mov	x29, sp
    40004294:	a90153f3 	stp	x19, x20, [sp, #16]
			err = k_mem_slab_alloc(&log_msg_pool,
    40004298:	b00000f4 	adrp	x20, 40021000 <k_sys_work_q+0x240>
    4000429c:	9108c294 	add	x20, x20, #0x230
	union log_msg_chunk *msg = NULL;
    400042a0:	f90017ff 	str	xzr, [sp, #40]
	return z_impl_log_process(bypass);
    400042a4:	52800020 	mov	w0, #0x1                   	// #1
    400042a8:	97fffd87 	bl	400038c4 <z_impl_log_process>
    400042ac:	12001c13 	and	w19, w0, #0xff
			z_log_dropped();
    400042b0:	97fffd22 	bl	40003738 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    400042b4:	9100a3e1 	add	x1, sp, #0x28
    400042b8:	aa1403e0 	mov	x0, x20
    400042bc:	d2800002 	mov	x2, #0x0                   	// #0
    400042c0:	9400291b 	bl	4000e72c <k_mem_slab_alloc>
		} while ((err != 0) && more);
    400042c4:	7100001f 	cmp	w0, #0x0
    400042c8:	7a401a64 	ccmp	w19, #0x0, #0x4, ne  // ne = any
    400042cc:	54fffec1 	b.ne	400042a4 <log_msg_no_space_handle+0x18>  // b.any
}
    400042d0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400042d4:	f94017e0 	ldr	x0, [sp, #40]
    400042d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400042dc:	d65f03c0 	ret

00000000400042e0 <log_msg_chunk_alloc>:
{
    400042e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    400042e4:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    400042e8:	9108c000 	add	x0, x0, #0x230
{
    400042ec:	910003fd 	mov	x29, sp
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    400042f0:	910063e1 	add	x1, sp, #0x18
    400042f4:	d2800002 	mov	x2, #0x0                   	// #0
	union log_msg_chunk *msg = NULL;
    400042f8:	f9000fff 	str	xzr, [sp, #24]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    400042fc:	9400290c 	bl	4000e72c <k_mem_slab_alloc>
	if (err != 0) {
    40004300:	34000060 	cbz	w0, 4000430c <log_msg_chunk_alloc+0x2c>
		msg = log_msg_no_space_handle();
    40004304:	97ffffe2 	bl	4000428c <log_msg_no_space_handle>
    40004308:	f9000fe0 	str	x0, [sp, #24]
}
    4000430c:	f9400fe0 	ldr	x0, [sp, #24]
    40004310:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004314:	d65f03c0 	ret

0000000040004318 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
    40004318:	f9400800 	ldr	x0, [x0, #16]
}
    4000431c:	530c3c00 	ubfx	w0, w0, #12, #4
    40004320:	d65f03c0 	ret

0000000040004324 <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
    40004324:	f9400802 	ldr	x2, [x0, #16]
    40004328:	530c3c42 	ubfx	w2, w2, #12, #4
    4000432c:	6b01005f 	cmp	w2, w1
    40004330:	540002a9 	b.ls	40004384 <log_msg_arg_get+0x60>  // b.plast
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    40004334:	7100105f 	cmp	w2, #0x4
    40004338:	54000088 	b.hi	40004348 <log_msg_arg_get+0x24>  // b.pmore
		arg = msg->payload.single.args[arg_idx];
    4000433c:	8b214c01 	add	x1, x0, w1, uxtw #3
    40004340:	f9401020 	ldr	x0, [x1, #32]
}
    40004344:	d65f03c0 	ret
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
    40004348:	7100083f 	cmp	w1, #0x2
    4000434c:	54000088 	b.hi	4000435c <log_msg_arg_get+0x38>  // b.pmore
		return msg->payload.ext.data.args[arg_idx];
    40004350:	8b214c01 	add	x1, x0, w1, uxtw #3
    40004354:	f9401420 	ldr	x0, [x1, #40]
    40004358:	17fffffb 	b	40004344 <log_msg_arg_get+0x20>
	cont = msg->payload.ext.next;
    4000435c:	f9401000 	ldr	x0, [x0, #32]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
    40004360:	51000c21 	sub	w1, w1, #0x3
	while (arg_idx >= ARGS_CONT_MSG) {
    40004364:	7100183f 	cmp	w1, #0x6
    40004368:	54000088 	b.hi	40004378 <log_msg_arg_get+0x54>  // b.pmore
	return cont->payload.args[arg_idx];
    4000436c:	8b214c01 	add	x1, x0, w1, uxtw #3
    40004370:	f9400420 	ldr	x0, [x1, #8]
    40004374:	17fffff4 	b	40004344 <log_msg_arg_get+0x20>
		arg_idx -= ARGS_CONT_MSG;
    40004378:	51001c21 	sub	w1, w1, #0x7
		cont = cont->next;
    4000437c:	f9400000 	ldr	x0, [x0]
    40004380:	17fffff9 	b	40004364 <log_msg_arg_get+0x40>
		return 0;
    40004384:	d2800000 	mov	x0, #0x0                   	// #0
    40004388:	17ffffef 	b	40004344 <log_msg_arg_get+0x20>

000000004000438c <msg_free>:
{
    4000438c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40004390:	910003fd 	mov	x29, sp
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    40004394:	79402001 	ldrh	w1, [x0, #16]
    40004398:	a90153f3 	stp	x19, x20, [sp, #16]
    4000439c:	a9025bf5 	stp	x21, x22, [sp, #32]
    400043a0:	f9001fe0 	str	x0, [sp, #56]
	if (log_msg_is_std(msg) && nargs) {
    400043a4:	370003a1 	tbnz	w1, #0, 40004418 <msg_free+0x8c>
	return msg->hdr.params.std.nargs;
    400043a8:	f9400800 	ldr	x0, [x0, #16]
    400043ac:	530c3c16 	ubfx	w22, w0, #12, #4
	if (log_msg_is_std(msg) && nargs) {
    400043b0:	72140c1f 	tst	w0, #0xf000
    400043b4:	54000320 	b.eq	40004418 <msg_free+0x8c>  // b.none
		uint32_t smask = 0U;
    400043b8:	52800013 	mov	w19, #0x0                   	// #0
		for (i = 0U; i < nargs; i++) {
    400043bc:	52800014 	mov	w20, #0x0                   	// #0
			void *buf = (void *)log_msg_arg_get(msg, i);
    400043c0:	f9401fe0 	ldr	x0, [sp, #56]
    400043c4:	2a1403e1 	mov	w1, w20
    400043c8:	97ffffd7 	bl	40004324 <log_msg_arg_get>
    400043cc:	aa0003f5 	mov	x21, x0
			if (log_is_strdup(buf)) {
    400043d0:	97fffd32 	bl	40003898 <log_is_strdup>
    400043d4:	72001c1f 	tst	w0, #0xff
    400043d8:	540001a0 	b.eq	4000440c <msg_free+0x80>  // b.none
				if (smask == 0U) {
    400043dc:	350000f3 	cbnz	w19, 400043f8 <msg_free+0x6c>
					smask = z_log_get_s_mask(
    400043e0:	f9401fe0 	ldr	x0, [sp, #56]
    400043e4:	2a1603e1 	mov	w1, w22
    400043e8:	f9400c00 	ldr	x0, [x0, #24]
    400043ec:	97fffc5f 	bl	40003568 <z_log_get_s_mask>
    400043f0:	2a0003f3 	mov	w19, w0
					if (smask == 0U) {
    400043f4:	34000120 	cbz	w0, 40004418 <msg_free+0x8c>
				if (smask & BIT(i)) {
    400043f8:	2a1303e0 	mov	w0, w19
    400043fc:	9ad42400 	lsr	x0, x0, x20
    40004400:	36000060 	tbz	w0, #0, 4000440c <msg_free+0x80>
					z_log_free(buf);
    40004404:	aa1503e0 	mov	x0, x21
    40004408:	97fffe89 	bl	40003e2c <z_log_free>
		for (i = 0U; i < nargs; i++) {
    4000440c:	11000694 	add	w20, w20, #0x1
    40004410:	6b16029f 	cmp	w20, w22
    40004414:	54fffd63 	b.cc	400043c0 <msg_free+0x34>  // b.lo, b.ul, b.last
	if (msg->hdr.params.generic.ext == 1) {
    40004418:	f9401fe0 	ldr	x0, [sp, #56]
    4000441c:	b00000f3 	adrp	x19, 40021000 <k_sys_work_q+0x240>
    40004420:	9108c273 	add	x19, x19, #0x230
    40004424:	79402001 	ldrh	w1, [x0, #16]
    40004428:	360800a1 	tbz	w1, #1, 4000443c <msg_free+0xb0>
		cont_free(msg->payload.ext.next);
    4000442c:	f9401000 	ldr	x0, [x0, #32]
    40004430:	f90027e0 	str	x0, [sp, #72]
	while (cont != NULL) {
    40004434:	f94027e0 	ldr	x0, [sp, #72]
    40004438:	b5000100 	cbnz	x0, 40004458 <msg_free+0xcc>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    4000443c:	9100e3e1 	add	x1, sp, #0x38
    40004440:	aa1303e0 	mov	x0, x19
    40004444:	940028dc 	bl	4000e7b4 <k_mem_slab_free>
}
    40004448:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000444c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004450:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40004454:	d65f03c0 	ret
		next = cont->next;
    40004458:	f9400014 	ldr	x20, [x0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    4000445c:	910123e1 	add	x1, sp, #0x48
    40004460:	aa1303e0 	mov	x0, x19
    40004464:	940028d4 	bl	4000e7b4 <k_mem_slab_free>
		cont = next;
    40004468:	f90027f4 	str	x20, [sp, #72]
    4000446c:	17fffff2 	b	40004434 <msg_free+0xa8>

0000000040004470 <log_msg_put>:
{
    40004470:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    40004474:	91002001 	add	x1, x0, #0x8
    40004478:	910003fd 	mov	x29, sp
    4000447c:	f9000bf3 	str	x19, [sp, #16]
    40004480:	aa0003f3 	mov	x19, x0
    40004484:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    40004488:	97fff2ce 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	if (msg->hdr.ref_cnt == 0) {
    4000448c:	f9400660 	ldr	x0, [x19, #8]
    40004490:	b50000a0 	cbnz	x0, 400044a4 <log_msg_put+0x34>
		msg_free(msg);
    40004494:	aa1303e0 	mov	x0, x19
}
    40004498:	f9400bf3 	ldr	x19, [sp, #16]
    4000449c:	a8c27bfd 	ldp	x29, x30, [sp], #32
		msg_free(msg);
    400044a0:	17ffffbb 	b	4000438c <msg_free>
}
    400044a4:	f9400bf3 	ldr	x19, [sp, #16]
    400044a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400044ac:	d65f03c0 	ret

00000000400044b0 <log_msg_str_get>:
}
    400044b0:	f9400c00 	ldr	x0, [x0, #24]
    400044b4:	d65f03c0 	ret

00000000400044b8 <log_msg_hexdump_data_get>:
void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
	log_msg_hexdump_data_op(msg, data, length, offset, false);
    400044b8:	52800004 	mov	w4, #0x0                   	// #0
    400044bc:	17ffff13 	b	40004108 <log_msg_hexdump_data_op>

00000000400044c0 <log_msg_mem_get_free>:
 *
 * @return Number of unallocated memory blocks.
 */
static inline uint32_t k_mem_slab_num_free_get(struct k_mem_slab *slab)
{
	return slab->num_blocks - slab->num_used;
    400044c0:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    400044c4:	9108c021 	add	x1, x1, #0x230
    400044c8:	b9401022 	ldr	w2, [x1, #16]
    400044cc:	b9403020 	ldr	w0, [x1, #48]
}

uint32_t log_msg_mem_get_free(void)
{
	return k_mem_slab_num_free_get(&log_msg_pool);
}
    400044d0:	4b000040 	sub	w0, w2, w0
    400044d4:	d65f03c0 	ret

00000000400044d8 <log_msg_mem_get_used>:

uint32_t log_msg_mem_get_used(void)
{
	return k_mem_slab_num_used_get(&log_msg_pool);
}
    400044d8:	b00000e0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    400044dc:	b9426000 	ldr	w0, [x0, #608]
    400044e0:	d65f03c0 	ret

00000000400044e4 <buffer_write>:
	return length;
}

static void buffer_write(log_output_func_t outf, uint8_t *buf, size_t len,
			 void *ctx)
{
    400044e4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400044e8:	910003fd 	mov	x29, sp
    400044ec:	a90153f3 	stp	x19, x20, [sp, #16]
    400044f0:	aa0103f4 	mov	x20, x1
    400044f4:	aa0203f3 	mov	x19, x2
    400044f8:	a9025bf5 	stp	x21, x22, [sp, #32]
    400044fc:	aa0003f5 	mov	x21, x0
    40004500:	aa0303f6 	mov	x22, x3
	int processed;

	do {
		processed = outf(buf, len, ctx);
    40004504:	aa1303e1 	mov	x1, x19
    40004508:	aa1403e0 	mov	x0, x20
    4000450c:	aa1603e2 	mov	x2, x22
    40004510:	d63f02a0 	blr	x21
		len -= processed;
		buf += processed;
    40004514:	8b20c294 	add	x20, x20, w0, sxtw
	} while (len != 0);
    40004518:	eb20c273 	subs	x19, x19, w0, sxtw
    4000451c:	54ffff41 	b.ne	40004504 <buffer_write+0x20>  // b.any
}
    40004520:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004524:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004528:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000452c:	d65f03c0 	ret

0000000040004530 <print_formatted>:
{
    40004530:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40004534:	910003fd 	mov	x29, sp
    40004538:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    4000453c:	910403e2 	add	x2, sp, #0x100
    40004540:	a9030be2 	stp	x2, x2, [sp, #48]
    40004544:	910343e2 	add	x2, sp, #0xd0
    40004548:	f90023e2 	str	x2, [sp, #64]
    4000454c:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    40004550:	b9004be2 	str	w2, [sp, #72]
    40004554:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    40004558:	b9004fe2 	str	w2, [sp, #76]
	length = cbvprintf(out_func, (void *)output, fmt, args);
    4000455c:	a9430fe2 	ldp	x2, x3, [sp, #48]
    40004560:	a9010fe2 	stp	x2, x3, [sp, #16]
    40004564:	a9440fe2 	ldp	x2, x3, [sp, #64]
    40004568:	a9020fe2 	stp	x2, x3, [sp, #32]
    4000456c:	910043e3 	add	x3, sp, #0x10
    40004570:	aa0103e2 	mov	x2, x1
    40004574:	aa0003e1 	mov	x1, x0
    40004578:	90000000 	adrp	x0, 40004000 <backend_filter_set+0x8>
    4000457c:	91346000 	add	x0, x0, #0xd18
{
    40004580:	3d8017e0 	str	q0, [sp, #80]
    40004584:	3d801be1 	str	q1, [sp, #96]
    40004588:	3d801fe2 	str	q2, [sp, #112]
    4000458c:	3d8023e3 	str	q3, [sp, #128]
    40004590:	3d8027e4 	str	q4, [sp, #144]
    40004594:	3d802be5 	str	q5, [sp, #160]
    40004598:	3d802fe6 	str	q6, [sp, #176]
    4000459c:	3d8033e7 	str	q7, [sp, #192]
    400045a0:	a90e17e4 	stp	x4, x5, [sp, #224]
    400045a4:	a90f1fe6 	stp	x6, x7, [sp, #240]
	length = cbvprintf(out_func, (void *)output, fmt, args);
    400045a8:	97fff581 	bl	40001bac <cbvprintf>
}
    400045ac:	a8d07bfd 	ldp	x29, x30, [sp], #256
    400045b0:	d65f03c0 	ret

00000000400045b4 <std_print>:
	}
}

static void std_print(struct log_msg *msg,
		      const struct log_output *output)
{
    400045b4:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    400045b8:	910003fd 	mov	x29, sp
    400045bc:	a90153f3 	stp	x19, x20, [sp, #16]
    400045c0:	aa0103f4 	mov	x20, x1
    400045c4:	a9025bf5 	stp	x21, x22, [sp, #32]
    400045c8:	aa0003f6 	mov	x22, x0
    400045cc:	a90363f7 	stp	x23, x24, [sp, #48]
	const char *str = log_msg_str_get(msg);
	uint32_t nargs = log_msg_nargs_get(msg);
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
	int i;

	for (i = 0; i < nargs; i++) {
    400045d0:	52800017 	mov	w23, #0x0                   	// #0
{
    400045d4:	f90023f9 	str	x25, [sp, #64]
    400045d8:	d10143ff 	sub	sp, sp, #0x50
	const char *str = log_msg_str_get(msg);
    400045dc:	97ffffb5 	bl	400044b0 <log_msg_str_get>
    400045e0:	aa0003f5 	mov	x21, x0
	uint32_t nargs = log_msg_nargs_get(msg);
    400045e4:	aa1603e0 	mov	x0, x22
    400045e8:	97ffff4c 	bl	40004318 <log_msg_nargs_get>
    400045ec:	2a0003f8 	mov	w24, w0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
    400045f0:	d37d7f01 	ubfiz	x1, x24, #3, #32
    400045f4:	91003c21 	add	x1, x1, #0xf
    400045f8:	927c7c21 	and	x1, x1, #0xffffffff0
    400045fc:	cb2163ff 	sub	sp, sp, x1
    40004600:	910143f3 	add	x19, sp, #0x50
	for (i = 0; i < nargs; i++) {
    40004604:	6b1802ff 	cmp	w23, w24
    40004608:	54000161 	b.ne	40004634 <std_print+0x80>  // b.any
		args[i] = log_msg_arg_get(msg, i);
	}

	switch (log_msg_nargs_get(msg)) {
    4000460c:	aa1603e0 	mov	x0, x22
    40004610:	97ffff42 	bl	40004318 <log_msg_nargs_get>
    40004614:	71003c1f 	cmp	w0, #0xf
    40004618:	54000228 	b.hi	4000465c <std_print+0xa8>  // b.pmore
    4000461c:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004620:	91007021 	add	x1, x1, #0x1c
    40004624:	78605820 	ldrh	w0, [x1, w0, uxtw #1]
    40004628:	10000061 	adr	x1, 40004634 <std_print+0x80>
    4000462c:	8b20a820 	add	x0, x1, w0, sxth #2
    40004630:	d61f0000 	br	x0
		args[i] = log_msg_arg_get(msg, i);
    40004634:	937d7ef9 	sbfiz	x25, x23, #3, #32
    40004638:	2a1703e1 	mov	w1, w23
    4000463c:	aa1603e0 	mov	x0, x22
	for (i = 0; i < nargs; i++) {
    40004640:	110006f7 	add	w23, w23, #0x1
		args[i] = log_msg_arg_get(msg, i);
    40004644:	97ffff38 	bl	40004324 <log_msg_arg_get>
    40004648:	f8396a60 	str	x0, [x19, x25]
	for (i = 0; i < nargs; i++) {
    4000464c:	17ffffee 	b	40004604 <std_print+0x50>
	case 0:
		print_formatted(output, str);
    40004650:	aa1503e1 	mov	x1, x21
    40004654:	aa1403e0 	mov	x0, x20
    40004658:	97ffffb6 	bl	40004530 <print_formatted>
	default:
		/* Unsupported number of arguments. */
		__ASSERT_NO_MSG(true);
		break;
	}
}
    4000465c:	910003bf 	mov	sp, x29
    40004660:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004664:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004668:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000466c:	f94023f9 	ldr	x25, [sp, #64]
    40004670:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40004674:	d65f03c0 	ret
		print_formatted(output, str, args[0]);
    40004678:	f9400262 	ldr	x2, [x19]
    4000467c:	aa1503e1 	mov	x1, x21
    40004680:	aa1403e0 	mov	x0, x20
    40004684:	97ffffab 	bl	40004530 <print_formatted>
		break;
    40004688:	17fffff5 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1]);
    4000468c:	a9400e62 	ldp	x2, x3, [x19]
    40004690:	aa1503e1 	mov	x1, x21
    40004694:	aa1403e0 	mov	x0, x20
    40004698:	97ffffa6 	bl	40004530 <print_formatted>
		break;
    4000469c:	17fffff0 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2]);
    400046a0:	a9400e62 	ldp	x2, x3, [x19]
    400046a4:	aa1503e1 	mov	x1, x21
    400046a8:	f9400a64 	ldr	x4, [x19, #16]
    400046ac:	aa1403e0 	mov	x0, x20
    400046b0:	97ffffa0 	bl	40004530 <print_formatted>
		break;
    400046b4:	17ffffea 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    400046b8:	a9400e62 	ldp	x2, x3, [x19]
    400046bc:	aa1503e1 	mov	x1, x21
    400046c0:	a9411664 	ldp	x4, x5, [x19, #16]
    400046c4:	aa1403e0 	mov	x0, x20
    400046c8:	97ffff9a 	bl	40004530 <print_formatted>
		break;
    400046cc:	17ffffe4 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    400046d0:	a9400e62 	ldp	x2, x3, [x19]
    400046d4:	aa1503e1 	mov	x1, x21
    400046d8:	a9411664 	ldp	x4, x5, [x19, #16]
    400046dc:	aa1403e0 	mov	x0, x20
    400046e0:	f9401266 	ldr	x6, [x19, #32]
    400046e4:	97ffff93 	bl	40004530 <print_formatted>
		break;
    400046e8:	17ffffdd 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    400046ec:	a9400e62 	ldp	x2, x3, [x19]
    400046f0:	aa1503e1 	mov	x1, x21
    400046f4:	a9411664 	ldp	x4, x5, [x19, #16]
    400046f8:	aa1403e0 	mov	x0, x20
    400046fc:	a9421e66 	ldp	x6, x7, [x19, #32]
    40004700:	97ffff8c 	bl	40004530 <print_formatted>
		break;
    40004704:	17ffffd6 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    40004708:	f9401a60 	ldr	x0, [x19, #48]
    4000470c:	f90003e0 	str	x0, [sp]
    40004710:	aa1503e1 	mov	x1, x21
    40004714:	aa1403e0 	mov	x0, x20
    40004718:	a9400e62 	ldp	x2, x3, [x19]
    4000471c:	a9411664 	ldp	x4, x5, [x19, #16]
    40004720:	a9421e66 	ldp	x6, x7, [x19, #32]
    40004724:	97ffff83 	bl	40004530 <print_formatted>
		break;
    40004728:	17ffffcd 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    4000472c:	f9401e60 	ldr	x0, [x19, #56]
    40004730:	f90007e0 	str	x0, [sp, #8]
    40004734:	aa1503e1 	mov	x1, x21
    40004738:	f9401a60 	ldr	x0, [x19, #48]
    4000473c:	f90003e0 	str	x0, [sp]
    40004740:	aa1403e0 	mov	x0, x20
    40004744:	a9400e62 	ldp	x2, x3, [x19]
    40004748:	a9411664 	ldp	x4, x5, [x19, #16]
    4000474c:	a9421e66 	ldp	x6, x7, [x19, #32]
    40004750:	97ffff78 	bl	40004530 <print_formatted>
		break;
    40004754:	17ffffc2 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    40004758:	f9402260 	ldr	x0, [x19, #64]
    4000475c:	f9000be0 	str	x0, [sp, #16]
    40004760:	aa1503e1 	mov	x1, x21
    40004764:	f9401e60 	ldr	x0, [x19, #56]
    40004768:	f90007e0 	str	x0, [sp, #8]
    4000476c:	f9401a60 	ldr	x0, [x19, #48]
    40004770:	f90003e0 	str	x0, [sp]
    40004774:	aa1403e0 	mov	x0, x20
    40004778:	a9400e62 	ldp	x2, x3, [x19]
    4000477c:	a9411664 	ldp	x4, x5, [x19, #16]
    40004780:	a9421e66 	ldp	x6, x7, [x19, #32]
    40004784:	97ffff6b 	bl	40004530 <print_formatted>
		break;
    40004788:	17ffffb5 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    4000478c:	f9402660 	ldr	x0, [x19, #72]
    40004790:	f9000fe0 	str	x0, [sp, #24]
    40004794:	aa1503e1 	mov	x1, x21
    40004798:	f9402260 	ldr	x0, [x19, #64]
    4000479c:	f9000be0 	str	x0, [sp, #16]
    400047a0:	f9401e60 	ldr	x0, [x19, #56]
    400047a4:	f90007e0 	str	x0, [sp, #8]
    400047a8:	f9401a60 	ldr	x0, [x19, #48]
    400047ac:	f90003e0 	str	x0, [sp]
    400047b0:	aa1403e0 	mov	x0, x20
    400047b4:	a9400e62 	ldp	x2, x3, [x19]
    400047b8:	a9411664 	ldp	x4, x5, [x19, #16]
    400047bc:	a9421e66 	ldp	x6, x7, [x19, #32]
    400047c0:	97ffff5c 	bl	40004530 <print_formatted>
		break;
    400047c4:	17ffffa6 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    400047c8:	f9402a60 	ldr	x0, [x19, #80]
    400047cc:	f90013e0 	str	x0, [sp, #32]
    400047d0:	aa1503e1 	mov	x1, x21
    400047d4:	f9402660 	ldr	x0, [x19, #72]
    400047d8:	f9000fe0 	str	x0, [sp, #24]
    400047dc:	f9402260 	ldr	x0, [x19, #64]
    400047e0:	f9000be0 	str	x0, [sp, #16]
    400047e4:	f9401e60 	ldr	x0, [x19, #56]
    400047e8:	f90007e0 	str	x0, [sp, #8]
    400047ec:	f9401a60 	ldr	x0, [x19, #48]
    400047f0:	f90003e0 	str	x0, [sp]
    400047f4:	aa1403e0 	mov	x0, x20
    400047f8:	a9400e62 	ldp	x2, x3, [x19]
    400047fc:	a9411664 	ldp	x4, x5, [x19, #16]
    40004800:	a9421e66 	ldp	x6, x7, [x19, #32]
    40004804:	97ffff4b 	bl	40004530 <print_formatted>
		break;
    40004808:	17ffff95 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    4000480c:	f9402e60 	ldr	x0, [x19, #88]
    40004810:	f90017e0 	str	x0, [sp, #40]
    40004814:	aa1503e1 	mov	x1, x21
    40004818:	f9402a60 	ldr	x0, [x19, #80]
    4000481c:	f90013e0 	str	x0, [sp, #32]
    40004820:	f9402660 	ldr	x0, [x19, #72]
    40004824:	f9000fe0 	str	x0, [sp, #24]
    40004828:	f9402260 	ldr	x0, [x19, #64]
    4000482c:	f9000be0 	str	x0, [sp, #16]
    40004830:	f9401e60 	ldr	x0, [x19, #56]
    40004834:	f90007e0 	str	x0, [sp, #8]
    40004838:	f9401a60 	ldr	x0, [x19, #48]
    4000483c:	f90003e0 	str	x0, [sp]
    40004840:	aa1403e0 	mov	x0, x20
    40004844:	a9400e62 	ldp	x2, x3, [x19]
    40004848:	a9411664 	ldp	x4, x5, [x19, #16]
    4000484c:	a9421e66 	ldp	x6, x7, [x19, #32]
    40004850:	97ffff38 	bl	40004530 <print_formatted>
		break;
    40004854:	17ffff82 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    40004858:	f9403260 	ldr	x0, [x19, #96]
    4000485c:	f9001be0 	str	x0, [sp, #48]
    40004860:	aa1503e1 	mov	x1, x21
    40004864:	f9402e60 	ldr	x0, [x19, #88]
    40004868:	f90017e0 	str	x0, [sp, #40]
    4000486c:	f9402a60 	ldr	x0, [x19, #80]
    40004870:	f90013e0 	str	x0, [sp, #32]
    40004874:	f9402660 	ldr	x0, [x19, #72]
    40004878:	f9000fe0 	str	x0, [sp, #24]
    4000487c:	f9402260 	ldr	x0, [x19, #64]
    40004880:	f9000be0 	str	x0, [sp, #16]
    40004884:	f9401e60 	ldr	x0, [x19, #56]
    40004888:	f90007e0 	str	x0, [sp, #8]
    4000488c:	f9401a60 	ldr	x0, [x19, #48]
    40004890:	f90003e0 	str	x0, [sp]
    40004894:	aa1403e0 	mov	x0, x20
    40004898:	a9400e62 	ldp	x2, x3, [x19]
    4000489c:	a9411664 	ldp	x4, x5, [x19, #16]
    400048a0:	a9421e66 	ldp	x6, x7, [x19, #32]
    400048a4:	97ffff23 	bl	40004530 <print_formatted>
		break;
    400048a8:	17ffff6d 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    400048ac:	f9403660 	ldr	x0, [x19, #104]
    400048b0:	f9001fe0 	str	x0, [sp, #56]
    400048b4:	aa1503e1 	mov	x1, x21
    400048b8:	f9403260 	ldr	x0, [x19, #96]
    400048bc:	f9001be0 	str	x0, [sp, #48]
    400048c0:	f9402e60 	ldr	x0, [x19, #88]
    400048c4:	f90017e0 	str	x0, [sp, #40]
    400048c8:	f9402a60 	ldr	x0, [x19, #80]
    400048cc:	f90013e0 	str	x0, [sp, #32]
    400048d0:	f9402660 	ldr	x0, [x19, #72]
    400048d4:	f9000fe0 	str	x0, [sp, #24]
    400048d8:	f9402260 	ldr	x0, [x19, #64]
    400048dc:	f9000be0 	str	x0, [sp, #16]
    400048e0:	f9401e60 	ldr	x0, [x19, #56]
    400048e4:	f90007e0 	str	x0, [sp, #8]
    400048e8:	f9401a60 	ldr	x0, [x19, #48]
    400048ec:	f90003e0 	str	x0, [sp]
    400048f0:	aa1403e0 	mov	x0, x20
    400048f4:	a9400e62 	ldp	x2, x3, [x19]
    400048f8:	a9411664 	ldp	x4, x5, [x19, #16]
    400048fc:	a9421e66 	ldp	x6, x7, [x19, #32]
    40004900:	97ffff0c 	bl	40004530 <print_formatted>
		break;
    40004904:	17ffff56 	b	4000465c <std_print+0xa8>
		print_formatted(output, str, args[0], args[1], args[2],
    40004908:	f9403a60 	ldr	x0, [x19, #112]
    4000490c:	f90023e0 	str	x0, [sp, #64]
    40004910:	aa1503e1 	mov	x1, x21
    40004914:	f9403660 	ldr	x0, [x19, #104]
    40004918:	f9001fe0 	str	x0, [sp, #56]
    4000491c:	f9403260 	ldr	x0, [x19, #96]
    40004920:	f9001be0 	str	x0, [sp, #48]
    40004924:	f9402e60 	ldr	x0, [x19, #88]
    40004928:	f90017e0 	str	x0, [sp, #40]
    4000492c:	f9402a60 	ldr	x0, [x19, #80]
    40004930:	f90013e0 	str	x0, [sp, #32]
    40004934:	f9402660 	ldr	x0, [x19, #72]
    40004938:	f9000fe0 	str	x0, [sp, #24]
    4000493c:	f9402260 	ldr	x0, [x19, #64]
    40004940:	f9000be0 	str	x0, [sp, #16]
    40004944:	f9401e60 	ldr	x0, [x19, #56]
    40004948:	f90007e0 	str	x0, [sp, #8]
    4000494c:	f9401a60 	ldr	x0, [x19, #48]
    40004950:	f90003e0 	str	x0, [sp]
    40004954:	aa1403e0 	mov	x0, x20
    40004958:	a9400e62 	ldp	x2, x3, [x19]
    4000495c:	a9411664 	ldp	x4, x5, [x19, #16]
    40004960:	a9421e66 	ldp	x6, x7, [x19, #32]
    40004964:	97fffef3 	bl	40004530 <print_formatted>
}
    40004968:	17ffff3d 	b	4000465c <std_print+0xa8>

000000004000496c <hexdump_line_print>:

static void hexdump_line_print(const struct log_output *output,
			       const uint8_t *data, uint32_t length,
			       int prefix_offset, uint32_t flags)
{
    4000496c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40004970:	910003fd 	mov	x29, sp
    40004974:	a90153f3 	stp	x19, x20, [sp, #16]
    40004978:	aa0003f3 	mov	x19, x0
    4000497c:	2a0303f4 	mov	w20, w3
    40004980:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004984:	aa0103f5 	mov	x21, x1
    40004988:	2a0203f6 	mov	w22, w2
    4000498c:	a90363f7 	stp	x23, x24, [sp, #48]
    40004990:	a9046bf9 	stp	x25, x26, [sp, #64]
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    40004994:	372000a4 	tbnz	w4, #4, 400049a8 <hexdump_line_print+0x3c>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    40004998:	36280684 	tbz	w4, #5, 40004a68 <hexdump_line_print+0xfc>
		print_formatted(ctx, "\n");
    4000499c:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    400049a0:	911be021 	add	x1, x1, #0x6f8
		print_formatted(ctx, "\r\n");
    400049a4:	97fffee3 	bl	40004530 <print_formatted>
	newline_print(output, flags);

	for (int i = 0; i < prefix_offset; i++) {
		print_formatted(output, " ");
    400049a8:	90000098 	adrp	x24, 40014000 <CSWTCH.135+0x90>
    400049ac:	91072718 	add	x24, x24, #0x1c9
{
    400049b0:	52800017 	mov	w23, #0x0                   	// #0
	for (int i = 0; i < prefix_offset; i++) {
    400049b4:	6b1402ff 	cmp	w23, w20
    400049b8:	540005eb 	b.lt	40004a74 <hexdump_line_print+0x108>  // b.tstop
		}

		if (i < length) {
			print_formatted(output, "%02x ", data[i]);
		} else {
			print_formatted(output, "   ");
    400049bc:	90000098 	adrp	x24, 40014000 <CSWTCH.135+0x90>
    400049c0:	91071f18 	add	x24, x24, #0x1c7
			print_formatted(output, "%02x ", data[i]);
    400049c4:	90000099 	adrp	x25, 40014000 <CSWTCH.135+0x90>
    400049c8:	91070739 	add	x25, x25, #0x1c1
    400049cc:	d2800014 	mov	x20, #0x0                   	// #0
			print_formatted(output, " ");
    400049d0:	9000009a 	adrp	x26, 40014000 <CSWTCH.135+0x90>
		if (i < length) {
    400049d4:	2a1403f7 	mov	w23, w20
    400049d8:	6b1402df 	cmp	w22, w20
    400049dc:	54000669 	b.ls	40004aa8 <hexdump_line_print+0x13c>  // b.plast
			print_formatted(output, "%02x ", data[i]);
    400049e0:	38746aa2 	ldrb	w2, [x21, x20]
    400049e4:	aa1903e1 	mov	x1, x25
    400049e8:	aa1303e0 	mov	x0, x19
    400049ec:	97fffed1 	bl	40004530 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    400049f0:	f1003e9f 	cmp	x20, #0xf
    400049f4:	540004a1 	b.ne	40004a88 <hexdump_line_print+0x11c>  // b.any
			char c = (char)data[i];

			print_formatted(output, "%c",
			      isprint((int)c) ? c : '.');
		} else {
			print_formatted(output, " ");
    400049f8:	90000097 	adrp	x23, 40014000 <CSWTCH.135+0x90>
    400049fc:	910726f7 	add	x23, x23, #0x1c9
			print_formatted(output, "%c",
    40004a00:	90000099 	adrp	x25, 40014000 <CSWTCH.135+0x90>
    40004a04:	9135c739 	add	x25, x25, #0xd71
	print_formatted(output, "|");
    40004a08:	d2800014 	mov	x20, #0x0                   	// #0
    40004a0c:	528005da 	mov	w26, #0x2e                  	// #46
    40004a10:	aa1303e0 	mov	x0, x19
    40004a14:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004a18:	91072c21 	add	x1, x1, #0x1cb
    40004a1c:	97fffec5 	bl	40004530 <print_formatted>
		if (i < length) {
    40004a20:	2a1403f8 	mov	w24, w20
    40004a24:	6b1402df 	cmp	w22, w20
    40004a28:	54000589 	b.ls	40004ad8 <hexdump_line_print+0x16c>  // b.plast
			char c = (char)data[i];
    40004a2c:	38746aa2 	ldrb	w2, [x21, x20]
			print_formatted(output, "%c",
    40004a30:	aa1903e1 	mov	x1, x25
	return (int)((((unsigned)c) >= ' ') &&
    40004a34:	51008040 	sub	w0, w2, #0x20
    40004a38:	71017c1f 	cmp	w0, #0x5f
    40004a3c:	aa1303e0 	mov	x0, x19
    40004a40:	1a9a3042 	csel	w2, w2, w26, cc  // cc = lo, ul, last
    40004a44:	97fffebb 	bl	40004530 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    40004a48:	f1003e9f 	cmp	x20, #0xf
    40004a4c:	54000361 	b.ne	40004ab8 <hexdump_line_print+0x14c>  // b.any
		}
	}
}
    40004a50:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004a54:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004a58:	a94363f7 	ldp	x23, x24, [sp, #48]
    40004a5c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40004a60:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40004a64:	d65f03c0 	ret
		print_formatted(ctx, "\r\n");
    40004a68:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004a6c:	910b8821 	add	x1, x1, #0x2e2
    40004a70:	17ffffcd 	b	400049a4 <hexdump_line_print+0x38>
		print_formatted(output, " ");
    40004a74:	aa1803e1 	mov	x1, x24
    40004a78:	aa1303e0 	mov	x0, x19
	for (int i = 0; i < prefix_offset; i++) {
    40004a7c:	110006f7 	add	w23, w23, #0x1
		print_formatted(output, " ");
    40004a80:	97fffeac 	bl	40004530 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    40004a84:	17ffffcc 	b	400049b4 <hexdump_line_print+0x48>
		if (i > 0 && !(i % 8)) {
    40004a88:	110006f7 	add	w23, w23, #0x1
    40004a8c:	f2400aff 	tst	x23, #0x7
    40004a90:	54000081 	b.ne	40004aa0 <hexdump_line_print+0x134>  // b.any
			print_formatted(output, " ");
    40004a94:	91072741 	add	x1, x26, #0x1c9
    40004a98:	aa1303e0 	mov	x0, x19
    40004a9c:	97fffea5 	bl	40004530 <print_formatted>
    40004aa0:	91000694 	add	x20, x20, #0x1
    40004aa4:	17ffffcc 	b	400049d4 <hexdump_line_print+0x68>
			print_formatted(output, "   ");
    40004aa8:	aa1803e1 	mov	x1, x24
    40004aac:	aa1303e0 	mov	x0, x19
    40004ab0:	97fffea0 	bl	40004530 <print_formatted>
    40004ab4:	17ffffcf 	b	400049f0 <hexdump_line_print+0x84>
		if (i > 0 && !(i % 8)) {
    40004ab8:	11000718 	add	w24, w24, #0x1
    40004abc:	f2400b1f 	tst	x24, #0x7
    40004ac0:	54000081 	b.ne	40004ad0 <hexdump_line_print+0x164>  // b.any
			print_formatted(output, " ");
    40004ac4:	aa1703e1 	mov	x1, x23
    40004ac8:	aa1303e0 	mov	x0, x19
    40004acc:	97fffe99 	bl	40004530 <print_formatted>
    40004ad0:	91000694 	add	x20, x20, #0x1
    40004ad4:	17ffffd3 	b	40004a20 <hexdump_line_print+0xb4>
			print_formatted(output, " ");
    40004ad8:	aa1703e1 	mov	x1, x23
    40004adc:	aa1303e0 	mov	x0, x19
    40004ae0:	97fffe94 	bl	40004530 <print_formatted>
    40004ae4:	17ffffd9 	b	40004a48 <hexdump_line_print+0xdc>

0000000040004ae8 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
    40004ae8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40004aec:	910003fd 	mov	x29, sp
    40004af0:	a90153f3 	stp	x19, x20, [sp, #16]
    40004af4:	aa0003f3 	mov	x19, x0
    40004af8:	12001c94 	and	w20, w4, #0xff
    40004afc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004b00:	12001cb6 	and	w22, w5, #0xff
    40004b04:	13003cd5 	sxth	w21, w6
    40004b08:	a90363f7 	stp	x23, x24, [sp, #48]
    40004b0c:	12001c57 	and	w23, w2, #0xff
    40004b10:	121d0038 	and	w24, w1, #0x8
    40004b14:	a9046bf9 	stp	x25, x26, [sp, #64]
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    40004b18:	12000039 	and	w25, w1, #0x1
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
    40004b1c:	36080a41 	tbz	w1, #1, 40004c64 <prefix_print+0x17c>
    40004b20:	2a0303e2 	mov	w2, w3
	if (!format) {
    40004b24:	52800883 	mov	w3, #0x44                  	// #68
    40004b28:	6a03003f 	tst	w1, w3
    40004b2c:	54000681 	b.ne	40004bfc <prefix_print+0x114>  // b.any
		length = print_formatted(output, "[%08lu] ", timestamp);
    40004b30:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004b34:	91076c21 	add	x1, x1, #0x1db
    40004b38:	97fffe7e 	bl	40004530 <print_formatted>
		length += timestamp_print(output, flags, timestamp);
    40004b3c:	2a0003fa 	mov	w26, w0
	if (color) {
    40004b40:	34000199 	cbz	w25, 40004b70 <prefix_print+0x88>
		const char *log_color = start && (colors[level] != NULL) ?
    40004b44:	2a1403e1 	mov	w1, w20
    40004b48:	f0000060 	adrp	x0, 40013000 <shell_cmd_kernel>
    40004b4c:	91046000 	add	x0, x0, #0x118
    40004b50:	f8617802 	ldr	x2, [x0, x1, lsl #3]
    40004b54:	b5000062 	cbnz	x2, 40004b60 <prefix_print+0x78>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    40004b58:	90000082 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40004b5c:	91073442 	add	x2, x2, #0x1cd
		print_formatted(output, "%s", log_color);
    40004b60:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004b64:	91205c21 	add	x1, x1, #0x817
    40004b68:	aa1303e0 	mov	x0, x19
    40004b6c:	97fffe71 	bl	40004530 <print_formatted>
	if (level_on) {
    40004b70:	340007f8 	cbz	w24, 40004c6c <prefix_print+0x184>
		total += print_formatted(output, "<%s> ", severity[level]);
    40004b74:	2a1403e1 	mov	w1, w20
    40004b78:	f0000060 	adrp	x0, 40013000 <shell_cmd_kernel>
    40004b7c:	91050000 	add	x0, x0, #0x140
    40004b80:	f8617802 	ldr	x2, [x0, x1, lsl #3]
    40004b84:	aa1303e0 	mov	x0, x19
    40004b88:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004b8c:	91080021 	add	x1, x1, #0x200
    40004b90:	97fffe68 	bl	40004530 <print_formatted>
    40004b94:	2a0003f8 	mov	w24, w0
	if (source_id >= 0) {
    40004b98:	37f80255 	tbnz	w21, #31, 40004be0 <prefix_print+0xf8>
		total += print_formatted(output,
    40004b9c:	340006d7 	cbz	w23, 40004c74 <prefix_print+0x18c>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    40004ba0:	52800021 	mov	w1, #0x1                   	// #1
		total += print_formatted(output,
    40004ba4:	90000080 	adrp	x0, 40014000 <CSWTCH.135+0x90>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    40004ba8:	1ad42021 	lsl	w1, w1, w20
		total += print_formatted(output,
    40004bac:	91075c00 	add	x0, x0, #0x1d7
    40004bb0:	f27c003f 	tst	x1, #0x10
    40004bb4:	90000094 	adrp	x20, 40014000 <CSWTCH.135+0x90>
    40004bb8:	91074a94 	add	x20, x20, #0x1d2
    40004bbc:	9a800294 	csel	x20, x20, x0, eq  // eq = none
    40004bc0:	2a1503e1 	mov	w1, w21
    40004bc4:	2a1603e0 	mov	w0, w22
    40004bc8:	97fffcba 	bl	40003eb0 <log_source_name_get>
    40004bcc:	aa0003e2 	mov	x2, x0
    40004bd0:	aa1403e1 	mov	x1, x20
    40004bd4:	aa1303e0 	mov	x0, x19
    40004bd8:	97fffe56 	bl	40004530 <print_formatted>
    40004bdc:	0b000318 	add	w24, w24, w0
	length += ids_print(output, level_on, func_on,
			domain_id, source_id, level);


	return length;
}
    40004be0:	0b1a0300 	add	w0, w24, w26
    40004be4:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004be8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004bec:	a94363f7 	ldp	x23, x24, [sp, #48]
    40004bf0:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40004bf4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40004bf8:	d65f03c0 	ret
	} else if (freq != 0U) {
    40004bfc:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40004c00:	b9478826 	ldr	w6, [x1, #1928]
    40004c04:	340002c6 	cbz	w6, 40004c5c <prefix_print+0x174>
		timestamp /= timestamp_div;
    40004c08:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40004c0c:	b9478c21 	ldr	w1, [x1, #1932]
    40004c10:	5281c204 	mov	w4, #0xe10                 	// #3600
			length = print_formatted(output,
    40004c14:	52800787 	mov	w7, #0x3c                  	// #60
		timestamp /= timestamp_div;
    40004c18:	1ac10843 	udiv	w3, w2, w1
		total_seconds = timestamp / freq;
    40004c1c:	1ac60861 	udiv	w1, w3, w6
		seconds -= hours * 3600U;
    40004c20:	1ac40822 	udiv	w2, w1, w4
    40004c24:	1b048444 	msub	w4, w2, w4, w1
		remainder = timestamp % freq;
    40004c28:	1b068c21 	msub	w1, w1, w6, w3
		ms = (remainder * 1000U) / freq;
    40004c2c:	52807d03 	mov	w3, #0x3e8                 	// #1000
    40004c30:	1b037c21 	mul	w1, w1, w3
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    40004c34:	1ac60825 	udiv	w5, w1, w6
    40004c38:	1b0684a1 	msub	w1, w5, w6, w1
    40004c3c:	1b037c21 	mul	w1, w1, w3
			length = print_formatted(output,
    40004c40:	1ac70883 	udiv	w3, w4, w7
    40004c44:	1ac60826 	udiv	w6, w1, w6
    40004c48:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004c4c:	91079021 	add	x1, x1, #0x1e4
    40004c50:	1b079064 	msub	w4, w3, w7, w4
    40004c54:	97fffe37 	bl	40004530 <print_formatted>
    40004c58:	17ffffb9 	b	40004b3c <prefix_print+0x54>
		length = 0;
    40004c5c:	52800000 	mov	w0, #0x0                   	// #0
    40004c60:	17ffffb7 	b	40004b3c <prefix_print+0x54>
    40004c64:	121f003a 	and	w26, w1, #0x2
    40004c68:	17ffffb6 	b	40004b40 <prefix_print+0x58>
	int total = 0;
    40004c6c:	52800018 	mov	w24, #0x0                   	// #0
    40004c70:	17ffffca 	b	40004b98 <prefix_print+0xb0>
		total += print_formatted(output,
    40004c74:	90000094 	adrp	x20, 40014000 <CSWTCH.135+0x90>
    40004c78:	91074a94 	add	x20, x20, #0x1d2
    40004c7c:	17ffffd1 	b	40004bc0 <prefix_print+0xd8>

0000000040004c80 <postfix_print>:

static void postfix_print(const struct log_output *output,
			  uint32_t flags, uint8_t level)
{
    40004c80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40004c84:	910003fd 	mov	x29, sp
    40004c88:	a90153f3 	stp	x19, x20, [sp, #16]
    40004c8c:	aa0003f4 	mov	x20, x0
    40004c90:	2a0103f3 	mov	w19, w1
	if (color) {
    40004c94:	360000d3 	tbz	w19, #0, 40004cac <postfix_print+0x2c>
		print_formatted(output, "%s", log_color);
    40004c98:	90000082 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40004c9c:	91073442 	add	x2, x2, #0x1cd
    40004ca0:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004ca4:	91205c21 	add	x1, x1, #0x817
    40004ca8:	97fffe22 	bl	40004530 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    40004cac:	37200173 	tbnz	w19, #4, 40004cd8 <postfix_print+0x58>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    40004cb0:	362800f3 	tbz	w19, #5, 40004ccc <postfix_print+0x4c>
		print_formatted(ctx, "\n");
    40004cb4:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004cb8:	911be021 	add	x1, x1, #0x6f8
		print_formatted(ctx, "\r\n");
    40004cbc:	aa1403e0 	mov	x0, x20
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(output, flags);
}
    40004cc0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004cc4:	a8c27bfd 	ldp	x29, x30, [sp], #32
		print_formatted(ctx, "\r\n");
    40004cc8:	17fffe1a 	b	40004530 <print_formatted>
    40004ccc:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004cd0:	910b8821 	add	x1, x1, #0x2e2
    40004cd4:	17fffffa 	b	40004cbc <postfix_print+0x3c>
}
    40004cd8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004cdc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004ce0:	d65f03c0 	ret

0000000040004ce4 <log_output_flush>:
{
    40004ce4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40004ce8:	910003fd 	mov	x29, sp
    40004cec:	f9000bf3 	str	x19, [sp, #16]
    40004cf0:	aa0003f3 	mov	x19, x0
	buffer_write(output->func, output->buf,
    40004cf4:	a9408400 	ldp	x0, x1, [x0, #8]
    40004cf8:	a9400c02 	ldp	x2, x3, [x0]
    40004cfc:	f9400260 	ldr	x0, [x19]
    40004d00:	97fffdf9 	bl	400044e4 <buffer_write>
	output->control_block->offset = 0;
    40004d04:	f9400660 	ldr	x0, [x19, #8]
}
    40004d08:	f9400bf3 	ldr	x19, [sp, #16]
	output->control_block->offset = 0;
    40004d0c:	f900001f 	str	xzr, [x0]
}
    40004d10:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004d14:	d65f03c0 	ret

0000000040004d18 <out_func>:
{
    40004d18:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40004d1c:	910003fd 	mov	x29, sp
    40004d20:	a90153f3 	stp	x19, x20, [sp, #16]
    40004d24:	2a0003f4 	mov	w20, w0
    40004d28:	aa0103f3 	mov	x19, x1
	if (out_ctx->control_block->offset == out_ctx->size) {
    40004d2c:	f9400420 	ldr	x0, [x1, #8]
    40004d30:	f9400001 	ldr	x1, [x0]
    40004d34:	f9400e60 	ldr	x0, [x19, #24]
    40004d38:	eb00003f 	cmp	x1, x0
    40004d3c:	54000061 	b.ne	40004d48 <out_func+0x30>  // b.any
		log_output_flush(out_ctx);
    40004d40:	aa1303e0 	mov	x0, x19
    40004d44:	97ffffe8 	bl	40004ce4 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    40004d48:	f9400661 	ldr	x1, [x19, #8]
    40004d4c:	d2800020 	mov	x0, #0x1                   	// #1
    40004d50:	97fff09c 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
	out_ctx->buf[idx] = (uint8_t)c;
    40004d54:	f9400a61 	ldr	x1, [x19, #16]
    40004d58:	3820c834 	strb	w20, [x1, w0, sxtw]
}
    40004d5c:	52800000 	mov	w0, #0x0                   	// #0
    40004d60:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004d64:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40004d68:	d65f03c0 	ret

0000000040004d6c <log_output_msg_process>:

void log_output_msg_process(const struct log_output *output,
			    struct log_msg *msg,
			    uint32_t flags)
{
    40004d6c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40004d70:	910003fd 	mov	x29, sp
	return msg->hdr.ids.level;
    40004d74:	f9400825 	ldr	x5, [x1, #16]
    40004d78:	a90153f3 	stp	x19, x20, [sp, #16]
    40004d7c:	aa0003f3 	mov	x19, x0
    40004d80:	a9025bf5 	stp	x21, x22, [sp, #32]
    40004d84:	aa0103f4 	mov	x20, x1
    40004d88:	2a0203f5 	mov	w21, w2
    40004d8c:	a90363f7 	stp	x23, x24, [sp, #48]
		log_output_msg_syst_process(output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(output, flags, std_msg, timestamp,
    40004d90:	721008bf 	tst	w5, #0x70000
    40004d94:	d35048b8 	ubfx	x24, x5, #16, #3
{
    40004d98:	f90023f9 	str	x25, [sp, #64]
	uint8_t level = (uint8_t)log_msg_level_get(msg);
    40004d9c:	531048b7 	ubfx	w23, w5, #16, #3
			0 : prefix_print(output, flags, std_msg, timestamp,
    40004da0:	54000300 	b.eq	40004e00 <log_output_msg_process+0x94>  // b.none
    40004da4:	b9401683 	ldr	w3, [x20, #20]
    40004da8:	53167ca6 	lsr	w6, w5, #22
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    40004dac:	79402022 	ldrh	w2, [x1, #16]
    40004db0:	d35354a5 	ubfx	x5, x5, #19, #3
    40004db4:	2a1803e4 	mov	w4, w24
    40004db8:	2a1503e1 	mov	w1, w21
    40004dbc:	2a2203e2 	mvn	w2, w2
    40004dc0:	12000042 	and	w2, w2, #0x1
    40004dc4:	97ffff49 	bl	40004ae8 <prefix_print>
    40004dc8:	2a0003f6 	mov	w22, w0
    40004dcc:	79402280 	ldrh	w0, [x20, #16]
    40004dd0:	2a2003e0 	mvn	w0, w0
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
    40004dd4:	12000019 	and	w25, w0, #0x1
    40004dd8:	36000180 	tbz	w0, #0, 40004e08 <log_output_msg_process+0x9c>
		std_print(msg, output);
    40004ddc:	aa1303e1 	mov	x1, x19
    40004de0:	aa1403e0 	mov	x0, x20
    40004de4:	97fffdf4 	bl	400045b4 <std_print>
		raw_string_print(msg, output);
	} else {
		hexdump_print(msg, output, prefix_offset, flags);
	}

	if (!raw_string) {
    40004de8:	34000477 	cbz	w23, 40004e74 <log_output_msg_process+0x108>
		postfix_print(output, flags, level);
    40004dec:	2a1803e2 	mov	w2, w24
    40004df0:	2a1503e1 	mov	w1, w21
    40004df4:	aa1303e0 	mov	x0, x19
    40004df8:	97ffffa2 	bl	40004c80 <postfix_print>
    40004dfc:	1400001e 	b	40004e74 <log_output_msg_process+0x108>
			0 : prefix_print(output, flags, std_msg, timestamp,
    40004e00:	52800016 	mov	w22, #0x0                   	// #0
    40004e04:	17fffff2 	b	40004dcc <log_output_msg_process+0x60>
	} else if (raw_string) {
    40004e08:	35000457 	cbnz	w23, 40004e90 <log_output_msg_process+0x124>
	size_t offset = 0;
    40004e0c:	d2800015 	mov	x21, #0x0                   	// #0
		length = output->size;
    40004e10:	a9410261 	ldp	x1, x0, [x19, #16]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
    40004e14:	aa1503e3 	mov	x3, x21
    40004e18:	910183e2 	add	x2, sp, #0x60
		length = output->size;
    40004e1c:	f90033e0 	str	x0, [sp, #96]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
    40004e20:	aa1403e0 	mov	x0, x20
    40004e24:	97fffda5 	bl	400044b8 <log_msg_hexdump_data_get>
		output->control_block->offset = length;
    40004e28:	f9400660 	ldr	x0, [x19, #8]
    40004e2c:	f94033e1 	ldr	x1, [sp, #96]
    40004e30:	f9000001 	str	x1, [x0]
		if (length != 0) {
    40004e34:	b40000c1 	cbz	x1, 40004e4c <log_output_msg_process+0xe0>
			eol = (output->buf[length - 1] == '\n');
    40004e38:	f9400a60 	ldr	x0, [x19, #16]
    40004e3c:	8b010000 	add	x0, x0, x1
    40004e40:	385ff000 	ldurb	w0, [x0, #-1]
    40004e44:	7100281f 	cmp	w0, #0xa
    40004e48:	1a9f17f9 	cset	w25, eq  // eq = none
		log_output_flush(output);
    40004e4c:	aa1303e0 	mov	x0, x19
    40004e50:	97ffffa5 	bl	40004ce4 <log_output_flush>
		offset += length;
    40004e54:	f94033e0 	ldr	x0, [sp, #96]
    40004e58:	8b0002b5 	add	x21, x21, x0
	} while (length > 0);
    40004e5c:	b5fffda0 	cbnz	x0, 40004e10 <log_output_msg_process+0xa4>
	if (eol) {
    40004e60:	340000b9 	cbz	w25, 40004e74 <log_output_msg_process+0x108>
		print_formatted(output, "\r");
    40004e64:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004e68:	91081821 	add	x1, x1, #0x206
    40004e6c:	aa1303e0 	mov	x0, x19
    40004e70:	97fffdb0 	bl	40004530 <print_formatted>
	}

	log_output_flush(output);
    40004e74:	aa1303e0 	mov	x0, x19
}
    40004e78:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004e7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40004e80:	a94363f7 	ldp	x23, x24, [sp, #48]
    40004e84:	f94023f9 	ldr	x25, [sp, #64]
    40004e88:	a8c77bfd 	ldp	x29, x30, [sp], #112
	log_output_flush(output);
    40004e8c:	17ffff96 	b	40004ce4 <log_output_flush>
	uint32_t offset = 0U;
    40004e90:	52800017 	mov	w23, #0x0                   	// #0
		length = sizeof(buf);
    40004e94:	d2800219 	mov	x25, #0x10                  	// #16
	print_formatted(output, "%s", log_msg_str_get(msg));
    40004e98:	aa1403e0 	mov	x0, x20
    40004e9c:	97fffd85 	bl	400044b0 <log_msg_str_get>
    40004ea0:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004ea4:	91205c21 	add	x1, x1, #0x817
    40004ea8:	aa0003e2 	mov	x2, x0
    40004eac:	aa1303e0 	mov	x0, x19
    40004eb0:	97fffda0 	bl	40004530 <print_formatted>
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    40004eb4:	910163e2 	add	x2, sp, #0x58
    40004eb8:	2a1703e3 	mov	w3, w23
    40004ebc:	910183e1 	add	x1, sp, #0x60
    40004ec0:	aa1403e0 	mov	x0, x20
		length = sizeof(buf);
    40004ec4:	f9002ff9 	str	x25, [sp, #88]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    40004ec8:	97fffd7c 	bl	400044b8 <log_msg_hexdump_data_get>
		if (length) {
    40004ecc:	f9402fe2 	ldr	x2, [sp, #88]
    40004ed0:	b4fff8e2 	cbz	x2, 40004dec <log_output_msg_process+0x80>
			hexdump_line_print(output, buf, length,
    40004ed4:	aa1303e0 	mov	x0, x19
    40004ed8:	2a1503e4 	mov	w4, w21
    40004edc:	2a1603e3 	mov	w3, w22
    40004ee0:	910183e1 	add	x1, sp, #0x60
    40004ee4:	97fffea2 	bl	4000496c <hexdump_line_print>
			offset += length;
    40004ee8:	f9402fe0 	ldr	x0, [sp, #88]
    40004eec:	0b0002f7 	add	w23, w23, w0
		length = sizeof(buf);
    40004ef0:	17fffff1 	b	40004eb4 <log_output_msg_process+0x148>

0000000040004ef4 <log_output_dropped_process>:
	postfix_print(output, flags, level);
	log_output_flush(output);
}

void log_output_dropped_process(const struct log_output *output, uint32_t cnt)
{
    40004ef4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;

	cnt = MIN(cnt, 9999);
    40004ef8:	5284e1e3 	mov	w3, #0x270f                	// #9999
    40004efc:	6b03003f 	cmp	w1, w3
{
    40004f00:	910003fd 	mov	x29, sp
    40004f04:	a90153f3 	stp	x19, x20, [sp, #16]
    40004f08:	aa0003f3 	mov	x19, x0
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    40004f0c:	1a839023 	csel	w3, w1, w3, ls  // ls = plast
    40004f10:	9100e3e0 	add	x0, sp, #0x38
    40004f14:	d28000a1 	mov	x1, #0x5                   	// #5
    40004f18:	90000082 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40004f1c:	912ec042 	add	x2, x2, #0xbb0
	log_output_func_t outf = output->func;
    40004f20:	f9400274 	ldr	x20, [x19]
{
    40004f24:	f90013f5 	str	x21, [sp, #32]
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    40004f28:	97fff113 	bl	40001374 <snprintk>
    40004f2c:	2a0003f5 	mov	w21, w0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    40004f30:	f9400660 	ldr	x0, [x19, #8]
    40004f34:	d2800082 	mov	x2, #0x4                   	// #4
    40004f38:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004f3c:	91090021 	add	x1, x1, #0x240
    40004f40:	f9400403 	ldr	x3, [x0, #8]
    40004f44:	aa1403e0 	mov	x0, x20
    40004f48:	97fffd67 	bl	400044e4 <buffer_write>
		     output->control_block->ctx);
	buffer_write(outf, buf, len, output->control_block->ctx);
    40004f4c:	f9400660 	ldr	x0, [x19, #8]
    40004f50:	93407ea2 	sxtw	x2, w21
    40004f54:	9100e3e1 	add	x1, sp, #0x38
    40004f58:	f9400403 	ldr	x3, [x0, #8]
    40004f5c:	aa1403e0 	mov	x0, x20
    40004f60:	97fffd61 	bl	400044e4 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
    40004f64:	f9400660 	ldr	x0, [x19, #8]
    40004f68:	d28002e2 	mov	x2, #0x17                  	// #23
    40004f6c:	90000081 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40004f70:	9108a021 	add	x1, x1, #0x228
    40004f74:	f9400403 	ldr	x3, [x0, #8]
    40004f78:	aa1403e0 	mov	x0, x20
    40004f7c:	97fffd5a 	bl	400044e4 <buffer_write>
		     output->control_block->ctx);
}
    40004f80:	a94153f3 	ldp	x19, x20, [sp, #16]
    40004f84:	f94013f5 	ldr	x21, [sp, #32]
    40004f88:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40004f8c:	d65f03c0 	ret

0000000040004f90 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
    40004f90:	b00000e2 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    40004f94:	52800021 	mov	w1, #0x1                   	// #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    40004f98:	52884804 	mov	w4, #0x4240                	// #16960
    40004f9c:	72a001e4 	movk	w4, #0xf, lsl #16
	timestamp_div = 1U;
    40004fa0:	b9078c41 	str	w1, [x2, #1932]
	while (frequency > 1000000) {
    40004fa4:	52800003 	mov	w3, #0x0                   	// #0
    40004fa8:	6b04001f 	cmp	w0, w4
    40004fac:	540000c8 	b.hi	40004fc4 <log_output_timestamp_freq_set+0x34>  // b.pmore
    40004fb0:	34000043 	cbz	w3, 40004fb8 <log_output_timestamp_freq_set+0x28>
    40004fb4:	b9078c41 	str	w1, [x2, #1932]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
    40004fb8:	b00000e1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40004fbc:	b9078820 	str	w0, [x1, #1928]
}
    40004fc0:	d65f03c0 	ret
		frequency /= 2U;
    40004fc4:	53017c00 	lsr	w0, w0, #1
		timestamp_div *= 2U;
    40004fc8:	531f7821 	lsl	w1, w1, #1
    40004fcc:	52800023 	mov	w3, #0x1                   	// #1
    40004fd0:	17fffff6 	b	40004fa8 <log_output_timestamp_freq_set+0x18>

0000000040004fd4 <severity_lvl_get>:

static void severity_lvl_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &dsub_module_name;
    40004fd4:	f0000062 	adrp	x2, 40013000 <shell_cmd_kernel>
    40004fd8:	91068042 	add	x2, x2, #0x1a0
    40004fdc:	a900883f 	stp	xzr, x2, [x1, #8]
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
					severity_lvls_sorted[idx] : NULL;
    40004fe0:	f100101f 	cmp	x0, #0x4
	entry->handler = NULL;
    40004fe4:	f9000c3f 	str	xzr, [x1, #24]
					severity_lvls_sorted[idx] : NULL;
    40004fe8:	540000c8 	b.hi	40005000 <severity_lvl_get+0x2c>  // b.pmore
    40004fec:	f0000062 	adrp	x2, 40013000 <shell_cmd_kernel>
    40004ff0:	9107a042 	add	x2, x2, #0x1e8
    40004ff4:	f8607840 	ldr	x0, [x2, x0, lsl #3]
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
    40004ff8:	f9000020 	str	x0, [x1]
}
    40004ffc:	d65f03c0 	ret
					severity_lvls_sorted[idx] : NULL;
    40005000:	d2800000 	mov	x0, #0x0                   	// #0
    40005004:	17fffffd 	b	40004ff8 <severity_lvl_get+0x24>

0000000040005008 <log_halt>:
	backend->cb->active = false;
    40005008:	f9400420 	ldr	x0, [x1, #8]
    4000500c:	3900241f 	strb	wzr, [x0, #9]
		    size_t argc,
		    char **argv)
{
	log_backend_deactivate(backend);
	return 0;
}
    40005010:	52800000 	mov	w0, #0x0                   	// #0
    40005014:	d65f03c0 	ret

0000000040005018 <log_go>:
	backend->cb->active = true;
    40005018:	f9400420 	ldr	x0, [x1, #8]
    4000501c:	52800021 	mov	w1, #0x1                   	// #1
    40005020:	39002401 	strb	w1, [x0, #9]
		  size_t argc,
		  char **argv)
{
	log_backend_activate(backend, backend->cb->ctx);
	return 0;
}
    40005024:	52800000 	mov	w0, #0x0                   	// #0
    40005028:	d65f03c0 	ret

000000004000502c <backend_name_get>:

static void backend_name_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
	entry->help  = NULL;
	entry->subcmd = &sub_log_backend;
    4000502c:	d0000062 	adrp	x2, 40013000 <shell_cmd_kernel>
    40005030:	91124042 	add	x2, x2, #0x490
	return __log_backends_end - __log_backends_start;
    40005034:	b0000063 	adrp	x3, 40012000 <__rodata_region_start>
    40005038:	913c8063 	add	x3, x3, #0xf20
	entry->handler = NULL;
    4000503c:	a9017c22 	stp	x2, xzr, [x1, #16]
    40005040:	b0000062 	adrp	x2, 40012000 <__rodata_region_start>
    40005044:	913d0042 	add	x2, x2, #0xf40
    40005048:	cb030042 	sub	x2, x2, x3
	entry->help  = NULL;
    4000504c:	a9007c3f 	stp	xzr, xzr, [x1]
	entry->syntax  = NULL;

	if (idx < log_backend_count_get()) {
    40005050:	93459042 	sbfx	x2, x2, #5, #32
    40005054:	eb00005f 	cmp	x2, x0
    40005058:	540000a9 	b.ls	4000506c <backend_name_get+0x40>  // b.plast
		const struct log_backend *backend = log_backend_get(idx);

		entry->syntax = backend->name;
    4000505c:	d37b7c00 	ubfiz	x0, x0, #5, #32
    40005060:	8b000063 	add	x3, x3, x0
    40005064:	f9400860 	ldr	x0, [x3, #16]
    40005068:	f9000020 	str	x0, [x1]
	}
}
    4000506c:	d65f03c0 	ret

0000000040005070 <cmd_log_memory_slabs>:
{
    40005070:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005074:	910003fd 	mov	x29, sp
    40005078:	a90153f3 	stp	x19, x20, [sp, #16]
    4000507c:	aa0003f3 	mov	x19, x0
	slabs_free = log_msg_mem_get_free();
    40005080:	97fffd10 	bl	400044c0 <log_msg_mem_get_free>
    40005084:	2a0003f4 	mov	w20, w0
	used = log_msg_mem_get_used();
    40005088:	97fffd14 	bl	400044d8 <log_msg_mem_get_used>
	shell_print(sh, "Blocks used:\t%d", used);
    4000508c:	52800101 	mov	w1, #0x8                   	// #8
    40005090:	2a0003e3 	mov	w3, w0
    40005094:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005098:	91091442 	add	x2, x2, #0x245
    4000509c:	aa1303e0 	mov	x0, x19
    400050a0:	94000b31 	bl	40007d64 <shell_fprintf>
	shell_print(sh, "Blocks free:\t%d", slabs_free);
    400050a4:	2a1403e3 	mov	w3, w20
    400050a8:	aa1303e0 	mov	x0, x19
    400050ac:	52800101 	mov	w1, #0x8                   	// #8
    400050b0:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400050b4:	91095842 	add	x2, x2, #0x256
    400050b8:	94000b2b 	bl	40007d64 <shell_fprintf>
		shell_print(
    400050bc:	aa1303e0 	mov	x0, x19
    400050c0:	52800101 	mov	w1, #0x8                   	// #8
    400050c4:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400050c8:	91099c42 	add	x2, x2, #0x267
    400050cc:	94000b26 	bl	40007d64 <shell_fprintf>
}
    400050d0:	52800000 	mov	w0, #0x0                   	// #0
    400050d4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400050d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400050dc:	d65f03c0 	ret

00000000400050e0 <cmd_log_backends_list>:
{
    400050e0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    400050e4:	910003fd 	mov	x29, sp
    400050e8:	a90153f3 	stp	x19, x20, [sp, #16]
    400050ec:	b0000073 	adrp	x19, 40012000 <__rodata_region_start>
    400050f0:	913c8273 	add	x19, x19, #0xf20
    400050f4:	b0000074 	adrp	x20, 40012000 <__rodata_region_start>
    400050f8:	913d0294 	add	x20, x20, #0xf40
    400050fc:	cb130294 	sub	x20, x20, x19
    40005100:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005104:	aa0003f6 	mov	x22, x0
    40005108:	d3459294 	ubfx	x20, x20, #5, #32
    4000510c:	a90363f7 	stp	x23, x24, [sp, #48]
		shell_fprintf(shell, SHELL_NORMAL,
    40005110:	f0000077 	adrp	x23, 40014000 <CSWTCH.135+0x90>
    40005114:	910aeef7 	add	x23, x23, #0x2bb
    40005118:	f0000078 	adrp	x24, 40014000 <CSWTCH.135+0x90>
    4000511c:	910acf18 	add	x24, x24, #0x2b3
	for (int i = 0; i < backend_count; i++) {
    40005120:	52800015 	mov	w21, #0x0                   	// #0
{
    40005124:	f90023f9 	str	x25, [sp, #64]
		shell_fprintf(shell, SHELL_NORMAL,
    40005128:	f0000079 	adrp	x25, 40014000 <CSWTCH.135+0x90>
	for (int i = 0; i < backend_count; i++) {
    4000512c:	6b1402bf 	cmp	w21, w20
    40005130:	5400010b 	b.lt	40005150 <cmd_log_backends_list+0x70>  // b.tstop
}
    40005134:	52800000 	mov	w0, #0x0                   	// #0
    40005138:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000513c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005140:	a94363f7 	ldp	x23, x24, [sp, #48]
    40005144:	f94023f9 	ldr	x25, [sp, #64]
    40005148:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4000514c:	d65f03c0 	ret
		shell_fprintf(shell, SHELL_NORMAL,
    40005150:	a9408e60 	ldp	x0, x3, [x19, #8]
    40005154:	910b1322 	add	x2, x25, #0x2c4
	for (int i = 0; i < backend_count; i++) {
    40005158:	110006b5 	add	w21, w21, #0x1
    4000515c:	91008273 	add	x19, x19, #0x20
		shell_fprintf(shell, SHELL_NORMAL,
    40005160:	39402401 	ldrb	w1, [x0, #9]
    40005164:	39402005 	ldrb	w5, [x0, #8]
    40005168:	aa1603e0 	mov	x0, x22
    4000516c:	7100003f 	cmp	w1, #0x0
    40005170:	52800101 	mov	w1, #0x8                   	// #8
    40005174:	9a971304 	csel	x4, x24, x23, ne  // ne = any
    40005178:	94000afb 	bl	40007d64 <shell_fprintf>
	for (int i = 0; i < backend_count; i++) {
    4000517c:	17ffffec 	b	4000512c <cmd_log_backends_list+0x4c>

0000000040005180 <log_status>:
{
    40005180:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40005184:	910003fd 	mov	x29, sp
    40005188:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000518c:	aa0103f6 	mov	x22, x1
    40005190:	b0000061 	adrp	x1, 40012000 <__rodata_region_start>
    40005194:	913b0021 	add	x1, x1, #0xec0
    40005198:	a90153f3 	stp	x19, x20, [sp, #16]
    4000519c:	b0000074 	adrp	x20, 40012000 <__rodata_region_start>
    400051a0:	913c8294 	add	x20, x20, #0xf20
    400051a4:	a90363f7 	stp	x23, x24, [sp, #48]
    400051a8:	cb010294 	sub	x20, x20, x1
	return backend->cb->active;
    400051ac:	f94006c1 	ldr	x1, [x22, #8]
    400051b0:	a9046bf9 	stp	x25, x26, [sp, #64]
    400051b4:	aa0003f5 	mov	x21, x0
    400051b8:	d3448e94 	ubfx	x20, x20, #4, #32
	if (!log_backend_is_active(backend)) {
    400051bc:	39402421 	ldrb	w1, [x1, #9]
    400051c0:	350000a1 	cbnz	w1, 400051d4 <log_status+0x54>
		shell_warn(shell, "Logs are halted!");
    400051c4:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400051c8:	910b9442 	add	x2, x2, #0x2e5
    400051cc:	52800061 	mov	w1, #0x3                   	// #3
    400051d0:	94000ae5 	bl	40007d64 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
    400051d4:	f0000063 	adrp	x3, 40014000 <CSWTCH.135+0x90>
    400051d8:	910bdc63 	add	x3, x3, #0x2f7
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
    400051dc:	d0000077 	adrp	x23, 40013000 <shell_cmd_kernel>
    400051e0:	910702f7 	add	x23, x23, #0x1c0
    400051e4:	f0000078 	adrp	x24, 40014000 <CSWTCH.135+0x90>
    400051e8:	910d7b18 	add	x24, x24, #0x35e
	for (int16_t i = 0U; i < modules_cnt; i++) {
    400051ec:	52800013 	mov	w19, #0x0                   	// #0
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
    400051f0:	aa1503e0 	mov	x0, x21
    400051f4:	52800101 	mov	w1, #0x8                   	// #8
    400051f8:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400051fc:	910c0c42 	add	x2, x2, #0x303
    40005200:	94000ad9 	bl	40007d64 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL,
    40005204:	aa1503e0 	mov	x0, x21
    40005208:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    4000520c:	910c8442 	add	x2, x2, #0x321
    40005210:	52800101 	mov	w1, #0x8                   	// #8
    40005214:	94000ad4 	bl	40007d64 <shell_fprintf>
	for (int16_t i = 0U; i < modules_cnt; i++) {
    40005218:	6b14027f 	cmp	w19, w20
    4000521c:	54000103 	b.cc	4000523c <log_status+0xbc>  // b.lo, b.ul, b.last
}
    40005220:	52800000 	mov	w0, #0x0                   	// #0
    40005224:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005228:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000522c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40005230:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40005234:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40005238:	d65f03c0 	ret
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
    4000523c:	2a1303e2 	mov	w2, w19
    40005240:	52800023 	mov	w3, #0x1                   	// #1
    40005244:	52800001 	mov	w1, #0x0                   	// #0
    40005248:	aa1603e0 	mov	x0, x22
    4000524c:	97fffb9a 	bl	400040b4 <log_filter_get>
    40005250:	2a0003f9 	mov	w25, w0
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
    40005254:	2a1303e2 	mov	w2, w19
    40005258:	52800003 	mov	w3, #0x0                   	// #0
    4000525c:	52800001 	mov	w1, #0x0                   	// #0
    40005260:	aa1603e0 	mov	x0, x22
    40005264:	97fffb94 	bl	400040b4 <log_filter_get>
    40005268:	2a0003fa 	mov	w26, w0
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
    4000526c:	2a1303e1 	mov	w1, w19
    40005270:	52800000 	mov	w0, #0x0                   	// #0
    40005274:	97fffb0f 	bl	40003eb0 <log_source_name_get>
	for (int16_t i = 0U; i < modules_cnt; i++) {
    40005278:	11000673 	add	w19, w19, #0x1
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
    4000527c:	f87a5ae5 	ldr	x5, [x23, w26, uxtw #3]
    40005280:	aa0003e3 	mov	x3, x0
    40005284:	f8795ae4 	ldr	x4, [x23, w25, uxtw #3]
    40005288:	aa1803e2 	mov	x2, x24
    4000528c:	aa1503e0 	mov	x0, x21
    40005290:	52800101 	mov	w1, #0x8                   	// #8
	for (int16_t i = 0U; i < modules_cnt; i++) {
    40005294:	13003e73 	sxth	w19, w19
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
    40005298:	94000ab3 	bl	40007d64 <shell_fprintf>
	for (int16_t i = 0U; i < modules_cnt; i++) {
    4000529c:	17ffffdf 	b	40005218 <log_status+0x98>

00000000400052a0 <module_name_get>:
{
    400052a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400052a4:	910003fd 	mov	x29, sp
    400052a8:	f9000bf3 	str	x19, [sp, #16]
    400052ac:	aa0103f3 	mov	x19, x1
	entry->subcmd = &dsub_module_name;
    400052b0:	d0000061 	adrp	x1, 40013000 <shell_cmd_kernel>
    400052b4:	91068021 	add	x1, x1, #0x1a0
    400052b8:	a900867f 	stp	xzr, x1, [x19, #8]
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
    400052bc:	2a0003e1 	mov	w1, w0
    400052c0:	52800000 	mov	w0, #0x0                   	// #0
	entry->handler = NULL;
    400052c4:	f9000e7f 	str	xzr, [x19, #24]
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
    400052c8:	97fffafa 	bl	40003eb0 <log_source_name_get>
    400052cc:	f9000260 	str	x0, [x19]
}
    400052d0:	f9400bf3 	ldr	x19, [sp, #16]
    400052d4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400052d8:	d65f03c0 	ret

00000000400052dc <shell_backend_cmd_execute>:
{
    400052dc:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    400052e0:	910003fd 	mov	x29, sp
    400052e4:	a90573fb 	stp	x27, x28, [sp, #80]
	char const *name = argv[-1];
    400052e8:	f85f805b 	ldur	x27, [x2, #-8]
{
    400052ec:	a90153f3 	stp	x19, x20, [sp, #16]
	return __log_backends_end - __log_backends_start;
    400052f0:	b0000073 	adrp	x19, 40012000 <__rodata_region_start>
    400052f4:	913d0273 	add	x19, x19, #0xf40
    400052f8:	a9046bf9 	stp	x25, x26, [sp, #64]
    400052fc:	b0000079 	adrp	x25, 40012000 <__rodata_region_start>
    40005300:	913c8339 	add	x25, x25, #0xf20
    40005304:	aa0003fa 	mov	x26, x0
    40005308:	cb190273 	sub	x19, x19, x25
	size_t slen = strlen(name);
    4000530c:	aa1b03e0 	mov	x0, x27
{
    40005310:	a9025bf5 	stp	x21, x22, [sp, #32]
    40005314:	aa0203f6 	mov	x22, x2
    40005318:	d3459273 	ubfx	x19, x19, #5, #32
    4000531c:	a90363f7 	stp	x23, x24, [sp, #48]
    40005320:	aa0303f8 	mov	x24, x3
    40005324:	aa0103f7 	mov	x23, x1
	size_t slen = strlen(name);
    40005328:	94001a22 	bl	4000bbb0 <strlen>
    4000532c:	aa0003fc 	mov	x28, x0
	for (int i = 0; i < log_backend_count_get(); i++) {
    40005330:	aa1903e3 	mov	x3, x25
    40005334:	52800014 	mov	w20, #0x0                   	// #0
    40005338:	6b13029f 	cmp	w20, w19
    4000533c:	5400012b 	b.lt	40005360 <shell_backend_cmd_execute+0x84>  // b.tstop
		shell_error(shell, "Invalid backend: %s", name);
    40005340:	aa1b03e3 	mov	x3, x27
    40005344:	aa1a03e0 	mov	x0, x26
    40005348:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    4000534c:	910dc842 	add	x2, x2, #0x372
    40005350:	52800021 	mov	w1, #0x1                   	// #1
		return -ENOEXEC;
    40005354:	128000f5 	mov	w21, #0xfffffff8            	// #-8
		shell_error(shell, "Invalid backend: %s", name);
    40005358:	94000a83 	bl	40007d64 <shell_fprintf>
		return -ENOEXEC;
    4000535c:	14000010 	b	4000539c <shell_backend_cmd_execute+0xc0>
		if (strncmp(name, backend->name, slen) == 0) {
    40005360:	f9400861 	ldr	x1, [x3, #16]
    40005364:	aa1c03e2 	mov	x2, x28
    40005368:	aa1b03e0 	mov	x0, x27
    4000536c:	f90037e3 	str	x3, [sp, #104]
    40005370:	94001a29 	bl	4000bc14 <strncmp>
    40005374:	2a0003f5 	mov	w21, w0
    40005378:	f94037e3 	ldr	x3, [sp, #104]
    4000537c:	91008063 	add	x3, x3, #0x20
    40005380:	350001e0 	cbnz	w0, 400053bc <shell_backend_cmd_execute+0xe0>
	return &__log_backends_start[idx];
    40005384:	d37b7e94 	ubfiz	x20, x20, #5, #32
		func(shell, backend, argc, argv);
    40005388:	aa1603e3 	mov	x3, x22
    4000538c:	aa1703e2 	mov	x2, x23
    40005390:	8b140321 	add	x1, x25, x20
    40005394:	aa1a03e0 	mov	x0, x26
    40005398:	d63f0300 	blr	x24
}
    4000539c:	2a1503e0 	mov	w0, w21
    400053a0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400053a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400053a8:	a94363f7 	ldp	x23, x24, [sp, #48]
    400053ac:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400053b0:	a94573fb 	ldp	x27, x28, [sp, #80]
    400053b4:	a8c77bfd 	ldp	x29, x30, [sp], #112
    400053b8:	d65f03c0 	ret
	for (int i = 0; i < log_backend_count_get(); i++) {
    400053bc:	11000694 	add	w20, w20, #0x1
    400053c0:	17ffffde 	b	40005338 <shell_backend_cmd_execute+0x5c>

00000000400053c4 <cmd_log_backend_status>:
{
    400053c4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_backend_cmd_execute(shell, argc, argv, log_status);
    400053c8:	90000003 	adrp	x3, 40005000 <severity_lvl_get+0x2c>
    400053cc:	91060063 	add	x3, x3, #0x180
{
    400053d0:	910003fd 	mov	x29, sp
	shell_backend_cmd_execute(shell, argc, argv, log_status);
    400053d4:	97ffffc2 	bl	400052dc <shell_backend_cmd_execute>
}
    400053d8:	52800000 	mov	w0, #0x0                   	// #0
    400053dc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400053e0:	d65f03c0 	ret

00000000400053e4 <cmd_log_backend_halt>:
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
    400053e4:	90000003 	adrp	x3, 40005000 <severity_lvl_get+0x2c>
    400053e8:	91002063 	add	x3, x3, #0x8
    400053ec:	17ffffbc 	b	400052dc <shell_backend_cmd_execute>

00000000400053f0 <cmd_log_backend_go>:
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
    400053f0:	90000003 	adrp	x3, 40005000 <severity_lvl_get+0x2c>
    400053f4:	91006063 	add	x3, x3, #0x18
    400053f8:	17ffffb9 	b	400052dc <shell_backend_cmd_execute>

00000000400053fc <cmd_log_backend_enable>:
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
    400053fc:	90000003 	adrp	x3, 40005000 <severity_lvl_get+0x2c>
    40005400:	91186063 	add	x3, x3, #0x618
    40005404:	17ffffb6 	b	400052dc <shell_backend_cmd_execute>

0000000040005408 <cmd_log_backend_disable>:
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
    40005408:	90000003 	adrp	x3, 40005000 <severity_lvl_get+0x2c>
    4000540c:	911ca063 	add	x3, x3, #0x728
    40005410:	17ffffb3 	b	400052dc <shell_backend_cmd_execute>

0000000040005414 <shell_state_precheck>:
	if (shell->log_backend->control_block->state
    40005414:	f9401c01 	ldr	x1, [x0, #56]
    40005418:	f9400c21 	ldr	x1, [x1, #24]
    4000541c:	b9400821 	ldr	w1, [x1, #8]
    40005420:	35000141 	cbnz	w1, 40005448 <shell_state_precheck+0x34>
{
    40005424:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		shell_error(shell, "Shell log backend not initialized.");
    40005428:	52800021 	mov	w1, #0x1                   	// #1
    4000542c:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005430:	910e1c42 	add	x2, x2, #0x387
{
    40005434:	910003fd 	mov	x29, sp
		shell_error(shell, "Shell log backend not initialized.");
    40005438:	94000a4b 	bl	40007d64 <shell_fprintf>
    4000543c:	52800000 	mov	w0, #0x0                   	// #0
}
    40005440:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40005444:	d65f03c0 	ret
	return true;
    40005448:	52800020 	mov	w0, #0x1                   	// #1
}
    4000544c:	d65f03c0 	ret

0000000040005450 <cmd_log_self_status>:
{
    40005450:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40005454:	910003fd 	mov	x29, sp
    40005458:	a90153f3 	stp	x19, x20, [sp, #16]
    4000545c:	aa0003f3 	mov	x19, x0
    40005460:	aa0103f4 	mov	x20, x1
    40005464:	f90013f5 	str	x21, [sp, #32]
    40005468:	aa0203f5 	mov	x21, x2
	if (!shell_state_precheck(shell)) {
    4000546c:	97ffffea 	bl	40005414 <shell_state_precheck>
    40005470:	72001c1f 	tst	w0, #0xff
    40005474:	540000e0 	b.eq	40005490 <cmd_log_self_status+0x40>  // b.none
	log_status(shell, shell->log_backend->backend, argc, argv);
    40005478:	f9401e60 	ldr	x0, [x19, #56]
    4000547c:	aa1503e3 	mov	x3, x21
    40005480:	aa1403e2 	mov	x2, x20
    40005484:	f9400001 	ldr	x1, [x0]
    40005488:	aa1303e0 	mov	x0, x19
    4000548c:	97ffff3d 	bl	40005180 <log_status>
}
    40005490:	52800000 	mov	w0, #0x0                   	// #0
    40005494:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005498:	f94013f5 	ldr	x21, [sp, #32]
    4000549c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400054a0:	d65f03c0 	ret

00000000400054a4 <filters_set>:
{
    400054a4:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	int cnt = all ? z_log_sources_count() : argc;
    400054a8:	f100005f 	cmp	x2, #0x0
{
    400054ac:	910003fd 	mov	x29, sp
    400054b0:	a90153f3 	stp	x19, x20, [sp, #16]
    400054b4:	b0000073 	adrp	x19, 40012000 <__rodata_region_start>
    400054b8:	913c8273 	add	x19, x19, #0xf20
    400054bc:	a90363f7 	stp	x23, x24, [sp, #48]
    400054c0:	aa0103f7 	mov	x23, x1
    400054c4:	b0000061 	adrp	x1, 40012000 <__rodata_region_start>
    400054c8:	913b0021 	add	x1, x1, #0xec0
    400054cc:	a9025bf5 	stp	x21, x22, [sp, #32]
    400054d0:	cb010273 	sub	x19, x19, x1
    400054d4:	a9046bf9 	stp	x25, x26, [sp, #64]
    400054d8:	aa0003f6 	mov	x22, x0
    400054dc:	d344fe73 	lsr	x19, x19, #4
	int cnt = all ? z_log_sources_count() : argc;
    400054e0:	1a931041 	csel	w1, w2, w19, ne  // ne = any
    400054e4:	b90067e1 	str	w1, [sp, #100]
	if (!backend->cb->active) {
    400054e8:	f94006e1 	ldr	x1, [x23, #8]
{
    400054ec:	a90573fb 	stp	x27, x28, [sp, #80]
    400054f0:	aa0203f4 	mov	x20, x2
    400054f4:	aa0303f5 	mov	x21, x3
    400054f8:	2a0403f8 	mov	w24, w4
	if (!backend->cb->active) {
    400054fc:	39402421 	ldrb	w1, [x1, #9]
    40005500:	350000a1 	cbnz	w1, 40005514 <filters_set+0x70>
		shell_warn(shell, "Backend not active.");
    40005504:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005508:	910eac42 	add	x2, x2, #0x3ab
    4000550c:	52800061 	mov	w1, #0x3                   	// #3
    40005510:	94000a15 	bl	40007d64 <shell_fprintf>
				shell_warn(shell, "%s: level set to %s.",
    40005514:	d0000079 	adrp	x25, 40013000 <shell_cmd_kernel>
    40005518:	91070339 	add	x25, x25, #0x1c0
    4000551c:	f000007a 	adrp	x26, 40014000 <CSWTCH.135+0x90>
    40005520:	910f035a 	add	x26, x26, #0x3c0
    40005524:	b9006bf3 	str	w19, [sp, #104]
    40005528:	d2800013 	mov	x19, #0x0                   	// #0
	for (i = 0; i < cnt; i++) {
    4000552c:	b94067e0 	ldr	w0, [sp, #100]
    40005530:	2a1303fb 	mov	w27, w19
    40005534:	2a1303e2 	mov	w2, w19
    40005538:	6b13001f 	cmp	w0, w19
    4000553c:	5400010c 	b.gt	4000555c <filters_set+0xb8>
}
    40005540:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005544:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005548:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000554c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40005550:	a94573fb 	ldp	x27, x28, [sp, #80]
    40005554:	a8c77bfd 	ldp	x29, x30, [sp], #112
    40005558:	d65f03c0 	ret
		id = all ? i : module_id_get(argv[i]);
    4000555c:	b4000314 	cbz	x20, 400055bc <filters_set+0x118>
    40005560:	f8737abc 	ldr	x28, [x21, x19, lsl #3]
	for (i = 0U; i < modules_cnt; i++) {
    40005564:	52800003 	mov	w3, #0x0                   	// #0
    40005568:	b9406be0 	ldr	w0, [sp, #104]
    4000556c:	6b03001f 	cmp	w0, w3
    40005570:	54000101 	b.ne	40005590 <filters_set+0xec>  // b.any
			shell_error(shell, "%s: unknown source name.", argv[i]);
    40005574:	f8737aa3 	ldr	x3, [x21, x19, lsl #3]
    40005578:	aa1603e0 	mov	x0, x22
    4000557c:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005580:	910f5842 	add	x2, x2, #0x3d6
    40005584:	52800021 	mov	w1, #0x1                   	// #1
    40005588:	940009f7 	bl	40007d64 <shell_fprintf>
    4000558c:	1400001d 	b	40005600 <filters_set+0x15c>
		tmp_name = log_source_name_get(CONFIG_LOG_DOMAIN_ID, i);
    40005590:	2a0303e1 	mov	w1, w3
    40005594:	52800000 	mov	w0, #0x0                   	// #0
    40005598:	b9006fe3 	str	w3, [sp, #108]
    4000559c:	97fffa45 	bl	40003eb0 <log_source_name_get>
		if (strncmp(tmp_name, name, 64) == 0) {
    400055a0:	aa1c03e1 	mov	x1, x28
    400055a4:	d2800802 	mov	x2, #0x40                  	// #64
    400055a8:	9400199b 	bl	4000bc14 <strncmp>
    400055ac:	b9406fe3 	ldr	w3, [sp, #108]
    400055b0:	350002c0 	cbnz	w0, 40005608 <filters_set+0x164>
			return i;
    400055b4:	2a0303e2 	mov	w2, w3
		if (id >= 0) {
    400055b8:	37fffde3 	tbnz	w3, #31, 40005574 <filters_set+0xd0>
	return z_impl_log_filter_set(backend, domain_id, source_id, level);
    400055bc:	52800001 	mov	w1, #0x0                   	// #0
    400055c0:	2a1803e3 	mov	w3, w24
    400055c4:	aa1703e0 	mov	x0, x23
    400055c8:	97fffa47 	bl	40003ee4 <z_impl_log_filter_set>
    400055cc:	2a0003fc 	mov	w28, w0
			if (set_lvl != level) {
    400055d0:	6b00031f 	cmp	w24, w0
    400055d4:	54000160 	b.eq	40005600 <filters_set+0x15c>  // b.none
						CONFIG_LOG_DOMAIN_ID, i) :
    400055d8:	b50001d4 	cbnz	x20, 40005610 <filters_set+0x16c>
					log_source_name_get(
    400055dc:	2a1b03e1 	mov	w1, w27
    400055e0:	52800000 	mov	w0, #0x0                   	// #0
    400055e4:	97fffa33 	bl	40003eb0 <log_source_name_get>
    400055e8:	aa0003e3 	mov	x3, x0
				shell_warn(shell, "%s: level set to %s.",
    400055ec:	f87c5b24 	ldr	x4, [x25, w28, uxtw #3]
    400055f0:	aa1a03e2 	mov	x2, x26
    400055f4:	aa1603e0 	mov	x0, x22
    400055f8:	52800061 	mov	w1, #0x3                   	// #3
    400055fc:	940009da 	bl	40007d64 <shell_fprintf>
	for (i = 0; i < cnt; i++) {
    40005600:	91000673 	add	x19, x19, #0x1
    40005604:	17ffffca 	b	4000552c <filters_set+0x88>
	for (i = 0U; i < modules_cnt; i++) {
    40005608:	11000463 	add	w3, w3, #0x1
    4000560c:	17ffffd7 	b	40005568 <filters_set+0xc4>
						CONFIG_LOG_DOMAIN_ID, i) :
    40005610:	f8737aa3 	ldr	x3, [x21, x19, lsl #3]
    40005614:	17fffff6 	b	400055ec <filters_set+0x148>

0000000040005618 <log_enable>:
{
    40005618:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000561c:	910003fd 	mov	x29, sp
    40005620:	a9046bf9 	stp	x25, x26, [sp, #64]
		if (strncmp(str, severity_lvls[i], 4) == 0) {
    40005624:	d0000079 	adrp	x25, 40013000 <shell_cmd_kernel>
    40005628:	91070339 	add	x25, x25, #0x1c0
	severity_level = severity_level_get(argv[1]);
    4000562c:	f940047a 	ldr	x26, [x3, #8]
{
    40005630:	a90153f3 	stp	x19, x20, [sp, #16]
    40005634:	aa0303f4 	mov	x20, x3
    40005638:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000563c:	aa0003f6 	mov	x22, x0
	severity_level = severity_level_get(argv[1]);
    40005640:	d2800015 	mov	x21, #0x0                   	// #0
{
    40005644:	a90363f7 	stp	x23, x24, [sp, #48]
    40005648:	aa0103f7 	mov	x23, x1
    4000564c:	aa0203f8 	mov	x24, x2
		if (strncmp(str, severity_lvls[i], 4) == 0) {
    40005650:	f8757b21 	ldr	x1, [x25, x21, lsl #3]
    40005654:	aa1a03e0 	mov	x0, x26
    40005658:	d2800082 	mov	x2, #0x4                   	// #4
    4000565c:	9400196e 	bl	4000bc14 <strncmp>
    40005660:	2a0003f3 	mov	w19, w0
    40005664:	34000240 	cbz	w0, 400056ac <log_enable+0x94>
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
    40005668:	910006b5 	add	x21, x21, #0x1
    4000566c:	f10016bf 	cmp	x21, #0x5
    40005670:	54ffff01 	b.ne	40005650 <log_enable+0x38>  // b.any
		shell_error(shell, "Invalid severity: %s", argv[1]);
    40005674:	f9400683 	ldr	x3, [x20, #8]
    40005678:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    4000567c:	910fc042 	add	x2, x2, #0x3f0
    40005680:	aa1603e0 	mov	x0, x22
    40005684:	52800021 	mov	w1, #0x1                   	// #1
    40005688:	128000f3 	mov	w19, #0xfffffff8            	// #-8
    4000568c:	940009b6 	bl	40007d64 <shell_fprintf>
}
    40005690:	2a1303e0 	mov	w0, w19
    40005694:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005698:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000569c:	a94363f7 	ldp	x23, x24, [sp, #48]
    400056a0:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400056a4:	a8c57bfd 	ldp	x29, x30, [sp], #80
    400056a8:	d65f03c0 	ret
	filters_set(shell, backend, argc - 2, &argv[2], severity_level);
    400056ac:	2a1503e4 	mov	w4, w21
    400056b0:	91004283 	add	x3, x20, #0x10
    400056b4:	d1000b02 	sub	x2, x24, #0x2
    400056b8:	aa1703e1 	mov	x1, x23
    400056bc:	aa1603e0 	mov	x0, x22
    400056c0:	97ffff79 	bl	400054a4 <filters_set>
	return 0;
    400056c4:	17fffff3 	b	40005690 <log_enable+0x78>

00000000400056c8 <cmd_log_self_enable>:
{
    400056c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400056cc:	910003fd 	mov	x29, sp
    400056d0:	a90153f3 	stp	x19, x20, [sp, #16]
    400056d4:	aa0003f3 	mov	x19, x0
    400056d8:	aa0103f4 	mov	x20, x1
    400056dc:	f90013f5 	str	x21, [sp, #32]
    400056e0:	aa0203f5 	mov	x21, x2
	if (!shell_state_precheck(shell)) {
    400056e4:	97ffff4c 	bl	40005414 <shell_state_precheck>
    400056e8:	72001c1f 	tst	w0, #0xff
    400056ec:	54000140 	b.eq	40005714 <cmd_log_self_enable+0x4c>  // b.none
	return log_enable(shell, shell->log_backend->backend, argc, argv);
    400056f0:	f9401e60 	ldr	x0, [x19, #56]
    400056f4:	aa1503e3 	mov	x3, x21
    400056f8:	aa1403e2 	mov	x2, x20
}
    400056fc:	f94013f5 	ldr	x21, [sp, #32]
	return log_enable(shell, shell->log_backend->backend, argc, argv);
    40005700:	f9400001 	ldr	x1, [x0]
    40005704:	aa1303e0 	mov	x0, x19
}
    40005708:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000570c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return log_enable(shell, shell->log_backend->backend, argc, argv);
    40005710:	17ffffc2 	b	40005618 <log_enable>
}
    40005714:	52800000 	mov	w0, #0x0                   	// #0
    40005718:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000571c:	f94013f5 	ldr	x21, [sp, #32]
    40005720:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40005724:	d65f03c0 	ret

0000000040005728 <log_disable>:
{
    40005728:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	filters_set(shell, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
    4000572c:	91002063 	add	x3, x3, #0x8
    40005730:	d1000442 	sub	x2, x2, #0x1
{
    40005734:	910003fd 	mov	x29, sp
	filters_set(shell, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
    40005738:	52800004 	mov	w4, #0x0                   	// #0
    4000573c:	97ffff5a 	bl	400054a4 <filters_set>
}
    40005740:	52800000 	mov	w0, #0x0                   	// #0
    40005744:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40005748:	d65f03c0 	ret

000000004000574c <cmd_log_self_disable>:
{
    4000574c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40005750:	910003fd 	mov	x29, sp
    40005754:	a90153f3 	stp	x19, x20, [sp, #16]
    40005758:	aa0003f3 	mov	x19, x0
    4000575c:	aa0103f4 	mov	x20, x1
    40005760:	f90013f5 	str	x21, [sp, #32]
    40005764:	aa0203f5 	mov	x21, x2
	if (!shell_state_precheck(shell)) {
    40005768:	97ffff2b 	bl	40005414 <shell_state_precheck>
    4000576c:	72001c1f 	tst	w0, #0xff
    40005770:	54000140 	b.eq	40005798 <cmd_log_self_disable+0x4c>  // b.none
	return log_disable(shell, shell->log_backend->backend, argc, argv);
    40005774:	f9401e60 	ldr	x0, [x19, #56]
    40005778:	aa1503e3 	mov	x3, x21
    4000577c:	aa1403e2 	mov	x2, x20
}
    40005780:	f94013f5 	ldr	x21, [sp, #32]
	return log_disable(shell, shell->log_backend->backend, argc, argv);
    40005784:	f9400001 	ldr	x1, [x0]
    40005788:	aa1303e0 	mov	x0, x19
}
    4000578c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005790:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return log_disable(shell, shell->log_backend->backend, argc, argv);
    40005794:	17ffffe5 	b	40005728 <log_disable>
}
    40005798:	52800000 	mov	w0, #0x0                   	// #0
    4000579c:	a94153f3 	ldp	x19, x20, [sp, #16]
    400057a0:	f94013f5 	ldr	x21, [sp, #32]
    400057a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400057a8:	d65f03c0 	ret

00000000400057ac <cmd_log_self_go>:
{
    400057ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400057b0:	910003fd 	mov	x29, sp
    400057b4:	f9000bf3 	str	x19, [sp, #16]
    400057b8:	aa0003f3 	mov	x19, x0
	if (!shell_state_precheck(shell)) {
    400057bc:	97ffff16 	bl	40005414 <shell_state_precheck>
    400057c0:	72001c1f 	tst	w0, #0xff
    400057c4:	540000c0 	b.eq	400057dc <cmd_log_self_go+0x30>  // b.none
	return log_go(shell, shell->log_backend->backend, argc, argv);
    400057c8:	f9401e60 	ldr	x0, [x19, #56]
	backend->cb->active = true;
    400057cc:	52800021 	mov	w1, #0x1                   	// #1
	log_backend_activate(backend, backend->cb->ctx);
    400057d0:	f9400000 	ldr	x0, [x0]
    400057d4:	f9400400 	ldr	x0, [x0, #8]
    400057d8:	39002401 	strb	w1, [x0, #9]
}
    400057dc:	52800000 	mov	w0, #0x0                   	// #0
    400057e0:	f9400bf3 	ldr	x19, [sp, #16]
    400057e4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400057e8:	d65f03c0 	ret

00000000400057ec <cmd_log_self_halt>:
{
    400057ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400057f0:	910003fd 	mov	x29, sp
    400057f4:	f9000bf3 	str	x19, [sp, #16]
    400057f8:	aa0003f3 	mov	x19, x0
	if (!shell_state_precheck(shell)) {
    400057fc:	97ffff06 	bl	40005414 <shell_state_precheck>
    40005800:	72001c1f 	tst	w0, #0xff
    40005804:	540000a0 	b.eq	40005818 <cmd_log_self_halt+0x2c>  // b.none
	return log_halt(shell, shell->log_backend->backend, argc, argv);
    40005808:	f9401e60 	ldr	x0, [x19, #56]
	backend->cb->active = false;
    4000580c:	f9400000 	ldr	x0, [x0]
    40005810:	f9400400 	ldr	x0, [x0, #8]
    40005814:	3900241f 	strb	wzr, [x0, #9]
}
    40005818:	52800000 	mov	w0, #0x0                   	// #0
    4000581c:	f9400bf3 	ldr	x19, [sp, #16]
    40005820:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005824:	d65f03c0 	ret

0000000040005828 <cmd_kernel_version>:
#include <drivers/timer/system_timer.h>
#include <kernel.h>

static int cmd_kernel_version(const struct shell *shell,
			      size_t argc, char **argv)
{
    40005828:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000582c:	910003fd 	mov	x29, sp
    40005830:	f9000bf3 	str	x19, [sp, #16]
    40005834:	aa0003f3 	mov	x19, x0
	uint32_t version = sys_kernel_version_get();
    40005838:	94002515 	bl	4000ec8c <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Zephyr version %d.%d.%d",
    4000583c:	d3483c05 	ubfx	x5, x0, #8, #8
    40005840:	d3505c04 	ubfx	x4, x0, #16, #8
    40005844:	53187c03 	lsr	w3, w0, #24
    40005848:	52800101 	mov	w1, #0x8                   	// #8
    4000584c:	aa1303e0 	mov	x0, x19
    40005850:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005854:	9116ac42 	add	x2, x2, #0x5ab
    40005858:	94000943 	bl	40007d64 <shell_fprintf>
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
    4000585c:	52800000 	mov	w0, #0x0                   	// #0
    40005860:	f9400bf3 	ldr	x19, [sp, #16]
    40005864:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005868:	d65f03c0 	ret

000000004000586c <cmd_kernel_uptime>:

static int cmd_kernel_uptime(const struct shell *shell,
			     size_t argc, char **argv)
{
    4000586c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005870:	910003fd 	mov	x29, sp
    40005874:	f9000bf3 	str	x19, [sp, #16]
    40005878:	aa0003f3 	mov	x19, x0
	return z_impl_k_uptime_ticks();
    4000587c:	94002ad4 	bl	400103cc <z_impl_k_uptime_ticks>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Uptime: %u ms", k_uptime_get_32());
    40005880:	d2800143 	mov	x3, #0xa                   	// #10
    40005884:	52800101 	mov	w1, #0x8                   	// #8
    40005888:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    4000588c:	91171042 	add	x2, x2, #0x5c4
    40005890:	1b037c03 	mul	w3, w0, w3
    40005894:	aa1303e0 	mov	x0, x19
    40005898:	94000933 	bl	40007d64 <shell_fprintf>
	return 0;
}
    4000589c:	52800000 	mov	w0, #0x0                   	// #0
    400058a0:	f9400bf3 	ldr	x19, [sp, #16]
    400058a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400058a8:	d65f03c0 	ret

00000000400058ac <cmd_kernel_threads>:

}

static int cmd_kernel_threads(const struct shell *shell,
			      size_t argc, char **argv)
{
    400058ac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400058b0:	910003fd 	mov	x29, sp
    400058b4:	f9000bf3 	str	x19, [sp, #16]
    400058b8:	aa0003f3 	mov	x19, x0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Scheduler: %u since last call", sys_clock_elapsed());
    400058bc:	940021fc 	bl	4000e0ac <sys_clock_elapsed>
    400058c0:	2a0003e3 	mov	w3, w0
    400058c4:	52800101 	mov	w1, #0x8                   	// #8
    400058c8:	aa1303e0 	mov	x0, x19
    400058cc:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400058d0:	91174c42 	add	x2, x2, #0x5d3
    400058d4:	94000924 	bl	40007d64 <shell_fprintf>
	shell_print(shell, "Threads:");
    400058d8:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400058dc:	9117c842 	add	x2, x2, #0x5f2
    400058e0:	aa1303e0 	mov	x0, x19
    400058e4:	52800101 	mov	w1, #0x8                   	// #8
    400058e8:	9400091f 	bl	40007d64 <shell_fprintf>
	k_thread_foreach(shell_tdata_dump, (void *)shell);
    400058ec:	aa1303e1 	mov	x1, x19
    400058f0:	90000000 	adrp	x0, 40005000 <severity_lvl_get+0x2c>
    400058f4:	91266000 	add	x0, x0, #0x998
    400058f8:	940023d3 	bl	4000e844 <k_thread_foreach>
	return 0;
}
    400058fc:	52800000 	mov	w0, #0x0                   	// #0
    40005900:	f9400bf3 	ldr	x19, [sp, #16]
    40005904:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005908:	d65f03c0 	ret

000000004000590c <cmd_kernel_stacks>:
extern K_KERNEL_STACK_ARRAY_DEFINE(z_interrupt_stacks, CONFIG_MP_NUM_CPUS,
				   CONFIG_ISR_STACK_SIZE);

static int cmd_kernel_stacks(const struct shell *shell,
			     size_t argc, char **argv)
{
    4000590c:	d100c3ff 	sub	sp, sp, #0x30
	uint8_t *buf;
	size_t size, unused;

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	k_thread_foreach(shell_stack_dump, (void *)shell);
    40005910:	aa0003e1 	mov	x1, x0
{
    40005914:	a9017bfd 	stp	x29, x30, [sp, #16]
    40005918:	910043fd 	add	x29, sp, #0x10
    4000591c:	f90013f3 	str	x19, [sp, #32]
    40005920:	aa0003f3 	mov	x19, x0
	k_thread_foreach(shell_stack_dump, (void *)shell);
    40005924:	90000000 	adrp	x0, 40005000 <severity_lvl_get+0x2c>
    40005928:	912bb000 	add	x0, x0, #0xaec
    4000592c:	940023c6 	bl	4000e844 <k_thread_foreach>
		buf = Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]);
		size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]);

		unused = 0;
		for (size_t i = 0; i < size; i++) {
			if (buf[i] == 0xAAU) {
    40005930:	90000343 	adrp	x3, 4006d000 <z_idle_stacks+0xf20>
    40005934:	91038063 	add	x3, x3, #0xe0
		unused = 0;
    40005938:	d2800006 	mov	x6, #0x0                   	// #0
			if (buf[i] == 0xAAU) {
    4000593c:	386368c0 	ldrb	w0, [x6, x3]
    40005940:	7102a81f 	cmp	w0, #0xaa
    40005944:	54000081 	b.ne	40005954 <cmd_kernel_stacks+0x48>  // b.any
				unused++;
    40005948:	910004c6 	add	x6, x6, #0x1
		for (size_t i = 0; i < size; i++) {
    4000594c:	f14004df 	cmp	x6, #0x1, lsl #12
    40005950:	54ffff61 	b.ne	4000593c <cmd_kernel_stacks+0x30>  // b.any
			} else {
				break;
			}
		}

		shell_print(shell,
    40005954:	d2820005 	mov	x5, #0x1000                	// #4096
    40005958:	cb0600a7 	sub	x7, x5, x6
    4000595c:	d2800c82 	mov	x2, #0x64                  	// #100
    40005960:	aa1303e0 	mov	x0, x19
    40005964:	52800004 	mov	w4, #0x0                   	// #0
    40005968:	52800101 	mov	w1, #0x8                   	// #8
    4000596c:	9b027ce2 	mul	x2, x7, x2
    40005970:	d34cfc42 	lsr	x2, x2, #12
    40005974:	a9000be5 	stp	x5, x2, [sp]
    40005978:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    4000597c:	9117f042 	add	x2, x2, #0x5fc
    40005980:	940008f9 	bl	40007d64 <shell_fprintf>
			      size - unused, size,
			      ((size - unused) * 100U) / size);
	}

	return 0;
}
    40005984:	52800000 	mov	w0, #0x0                   	// #0
    40005988:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000598c:	f94013f3 	ldr	x19, [sp, #32]
    40005990:	9100c3ff 	add	sp, sp, #0x30
    40005994:	d65f03c0 	ret

0000000040005998 <shell_tdata_dump>:
{
    40005998:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000599c:	910003fd 	mov	x29, sp
    400059a0:	a90153f3 	stp	x19, x20, [sp, #16]
    400059a4:	aa0003f3 	mov	x19, x0
    400059a8:	aa0103f4 	mov	x20, x1
    400059ac:	a9025bf5 	stp	x21, x22, [sp, #32]
	size_t size = thread->stack_info.size;
    400059b0:	f9409416 	ldr	x22, [x0, #296]
	tname = k_thread_name_get(thread);
    400059b4:	940023e4 	bl	4000e944 <k_thread_name_get>
    400059b8:	aa0003f5 	mov	x21, x0
	return z_impl_z_current_get();
    400059bc:	94002929 	bl	4000fe60 <z_impl_z_current_get>
	shell_print(shell, "%s%p %-10s",
    400059c0:	eb00027f 	cmp	x19, x0
    400059c4:	f0000063 	adrp	x3, 40014000 <CSWTCH.135+0x90>
    400059c8:	f0000061 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    400059cc:	91072460 	add	x0, x3, #0x1c9
    400059d0:	91190823 	add	x3, x1, #0x642
    400059d4:	9a800063 	csel	x3, x3, x0, eq  // eq = none
    400059d8:	b5000075 	cbnz	x21, 400059e4 <shell_tdata_dump+0x4c>
    400059dc:	f0000075 	adrp	x21, 40014000 <CSWTCH.135+0x90>
    400059e0:	911912b5 	add	x21, x21, #0x644
    400059e4:	aa1503e5 	mov	x5, x21
    400059e8:	aa1303e4 	mov	x4, x19
    400059ec:	aa1403e0 	mov	x0, x20
    400059f0:	52800101 	mov	w1, #0x8                   	// #8
    400059f4:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400059f8:	91191c42 	add	x2, x2, #0x647
    400059fc:	940008da 	bl	40007d64 <shell_fprintf>
	shell_print(shell, "\toptions: 0x%x, priority: %d timeout: %" PRId64,
    40005a00:	39c06a64 	ldrsb	w4, [x19, #26]
    40005a04:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005a08:	91194c42 	add	x2, x2, #0x653
    40005a0c:	39406263 	ldrb	w3, [x19, #24]
    40005a10:	f9402265 	ldr	x5, [x19, #64]
    40005a14:	52800101 	mov	w1, #0x8                   	// #8
    40005a18:	aa1403e0 	mov	x0, x20
    40005a1c:	940008d2 	bl	40007d64 <shell_fprintf>
	shell_print(shell, "\tstate: %s, entry: %p", k_thread_state_str(thread),
    40005a20:	aa1303e0 	mov	x0, x19
    40005a24:	940023ca 	bl	4000e94c <k_thread_state_str>
    40005a28:	f9406a64 	ldr	x4, [x19, #208]
    40005a2c:	aa0003e3 	mov	x3, x0
    40005a30:	52800101 	mov	w1, #0x8                   	// #8
    40005a34:	aa1403e0 	mov	x0, x20
    40005a38:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005a3c:	9119fc42 	add	x2, x2, #0x67f
    40005a40:	940008c9 	bl	40007d64 <shell_fprintf>
	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
    40005a44:	9100e3e1 	add	x1, sp, #0x38
    40005a48:	aa1303e0 	mov	x0, x19
    40005a4c:	94002484 	bl	4000ec5c <z_impl_k_thread_stack_space_get>
    40005a50:	2a0003e3 	mov	w3, w0
	if (ret) {
    40005a54:	34000140 	cbz	w0, 40005a7c <shell_tdata_dump+0xe4>
		shell_print(shell,
    40005a58:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005a5c:	911a5842 	add	x2, x2, #0x696
    40005a60:	aa1403e0 	mov	x0, x20
    40005a64:	52800101 	mov	w1, #0x8                   	// #8
    40005a68:	940008bf 	bl	40007d64 <shell_fprintf>
}
    40005a6c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005a70:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005a74:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40005a78:	d65f03c0 	ret
		pcnt = ((size - unused) * 100U) / size;
    40005a7c:	f9401fe4 	ldr	x4, [sp, #56]
    40005a80:	d2800c87 	mov	x7, #0x64                  	// #100
		shell_print(shell,
    40005a84:	aa1603e6 	mov	x6, x22
    40005a88:	aa1603e3 	mov	x3, x22
		pcnt = ((size - unused) * 100U) / size;
    40005a8c:	cb0402c5 	sub	x5, x22, x4
		shell_print(shell,
    40005a90:	aa1403e0 	mov	x0, x20
    40005a94:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005a98:	911b0c42 	add	x2, x2, #0x6c3
    40005a9c:	52800101 	mov	w1, #0x8                   	// #8
		pcnt = ((size - unused) * 100U) / size;
    40005aa0:	9b077ca7 	mul	x7, x5, x7
		shell_print(shell,
    40005aa4:	9ad608e7 	udiv	x7, x7, x22
    40005aa8:	940008af 	bl	40007d64 <shell_fprintf>
}
    40005aac:	17fffff0 	b	40005a6c <shell_tdata_dump+0xd4>

0000000040005ab0 <cmd_kernel_cycles>:
{
    40005ab0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005ab4:	910003fd 	mov	x29, sp
    40005ab8:	f9000bf3 	str	x19, [sp, #16]
    40005abc:	aa0003f3 	mov	x19, x0
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
    40005ac0:	94002187 	bl	4000e0dc <sys_clock_cycle_get_32>
	shell_print(shell, "cycles: %u hw cycles", k_cycle_get_32());
    40005ac4:	2a0003e3 	mov	w3, w0
    40005ac8:	52800101 	mov	w1, #0x8                   	// #8
    40005acc:	aa1303e0 	mov	x0, x19
    40005ad0:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005ad4:	911be842 	add	x2, x2, #0x6fa
    40005ad8:	940008a3 	bl	40007d64 <shell_fprintf>
}
    40005adc:	52800000 	mov	w0, #0x0                   	// #0
    40005ae0:	f9400bf3 	ldr	x19, [sp, #16]
    40005ae4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005ae8:	d65f03c0 	ret

0000000040005aec <shell_stack_dump>:
{
    40005aec:	d10143ff 	sub	sp, sp, #0x50
    40005af0:	a9017bfd 	stp	x29, x30, [sp, #16]
    40005af4:	910043fd 	add	x29, sp, #0x10
    40005af8:	a90253f3 	stp	x19, x20, [sp, #32]
    40005afc:	aa0003f3 	mov	x19, x0
    40005b00:	aa0103f4 	mov	x20, x1
    40005b04:	f9001bf5 	str	x21, [sp, #48]
	size_t size = thread->stack_info.size;
    40005b08:	f9409415 	ldr	x21, [x0, #296]
    40005b0c:	910123e1 	add	x1, sp, #0x48
    40005b10:	94002453 	bl	4000ec5c <z_impl_k_thread_stack_space_get>
	if (ret) {
    40005b14:	34000180 	cbz	w0, 40005b44 <shell_stack_dump+0x58>
    40005b18:	2a0003e3 	mov	w3, w0
		shell_print(shell,
    40005b1c:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005b20:	911a5842 	add	x2, x2, #0x696
    40005b24:	aa1403e0 	mov	x0, x20
    40005b28:	52800101 	mov	w1, #0x8                   	// #8
    40005b2c:	9400088e 	bl	40007d64 <shell_fprintf>
}
    40005b30:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40005b34:	a94253f3 	ldp	x19, x20, [sp, #32]
    40005b38:	f9401bf5 	ldr	x21, [sp, #48]
    40005b3c:	910143ff 	add	sp, sp, #0x50
    40005b40:	d65f03c0 	ret
	tname = k_thread_name_get((struct k_thread *)thread);
    40005b44:	aa1303e0 	mov	x0, x19
    40005b48:	9400237f 	bl	4000e944 <k_thread_name_get>
	pcnt = ((size - unused) * 100U) / size;
    40005b4c:	f94027e6 	ldr	x6, [sp, #72]
    40005b50:	d2800c82 	mov	x2, #0x64                  	// #100
	tname = k_thread_name_get((struct k_thread *)thread);
    40005b54:	aa0003e4 	mov	x4, x0
	pcnt = ((size - unused) * 100U) / size;
    40005b58:	cb0602a7 	sub	x7, x21, x6
    40005b5c:	9b027ce2 	mul	x2, x7, x2
    40005b60:	9ad50842 	udiv	x2, x2, x21
	shell_print((const struct shell *)user_data,
    40005b64:	b5000060 	cbnz	x0, 40005b70 <shell_stack_dump+0x84>
    40005b68:	f0000064 	adrp	x4, 40014000 <CSWTCH.135+0x90>
    40005b6c:	91191084 	add	x4, x4, #0x644
    40005b70:	f90003f5 	str	x21, [sp]
    40005b74:	aa1503e5 	mov	x5, x21
    40005b78:	b9000be2 	str	w2, [sp, #8]
    40005b7c:	aa1303e3 	mov	x3, x19
    40005b80:	aa1403e0 	mov	x0, x20
    40005b84:	52800101 	mov	w1, #0x8                   	// #8
    40005b88:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005b8c:	911c4042 	add	x2, x2, #0x710
    40005b90:	94000875 	bl	40007d64 <shell_fprintf>
    40005b94:	17ffffe7 	b	40005b30 <shell_stack_dump+0x44>

0000000040005b98 <get_device_name>:
};

static const char *get_device_name(const struct device *dev,
				   char *buf,
				   size_t len)
{
    40005b98:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005b9c:	aa0003e3 	mov	x3, x0
    40005ba0:	910003fd 	mov	x29, sp
	const char *name = dev->name;
    40005ba4:	f9400000 	ldr	x0, [x0]
{
    40005ba8:	f9000bf3 	str	x19, [sp, #16]
    40005bac:	aa0103f3 	mov	x19, x1
    40005bb0:	aa0203e1 	mov	x1, x2

	if ((name == NULL) || (name[0] == 0)) {
    40005bb4:	b4000060 	cbz	x0, 40005bc0 <get_device_name+0x28>
    40005bb8:	39400002 	ldrb	w2, [x0]
    40005bbc:	350000c2 	cbnz	w2, 40005bd4 <get_device_name+0x3c>
		snprintf(buf, len, "[%p]", dev);
    40005bc0:	aa1303e0 	mov	x0, x19
    40005bc4:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005bc8:	911f9c42 	add	x2, x2, #0x7e7
    40005bcc:	9400185e 	bl	4000bd44 <snprintf>
		name = buf;
    40005bd0:	aa1303e0 	mov	x0, x19
	}

	return name;
}
    40005bd4:	f9400bf3 	ldr	x19, [sp, #16]
    40005bd8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005bdc:	d65f03c0 	ret

0000000040005be0 <cmd_device_list_visitor>:
	size_t buf_size;
};

static int cmd_device_list_visitor(const struct device *dev,
				   void *context)
{
    40005be0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40005be4:	910003fd 	mov	x29, sp
	const struct cmd_device_list_visitor_context *ctx = context;

	shell_fprintf(ctx->shell, SHELL_NORMAL, "  requires: %s\n",
    40005be8:	f9400822 	ldr	x2, [x1, #16]
{
    40005bec:	f9000bf3 	str	x19, [sp, #16]
	shell_fprintf(ctx->shell, SHELL_NORMAL, "  requires: %s\n",
    40005bf0:	a9400433 	ldp	x19, x1, [x1]
    40005bf4:	97ffffe9 	bl	40005b98 <get_device_name>
    40005bf8:	aa0003e3 	mov	x3, x0
    40005bfc:	52800101 	mov	w1, #0x8                   	// #8
    40005c00:	aa1303e0 	mov	x0, x19
    40005c04:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005c08:	911fb042 	add	x2, x2, #0x7ec
    40005c0c:	94000856 	bl	40007d64 <shell_fprintf>
		      get_device_name(dev, ctx->buf, ctx->buf_size));

	return 0;
}
    40005c10:	52800000 	mov	w0, #0x0                   	// #0
    40005c14:	f9400bf3 	ldr	x19, [sp, #16]
    40005c18:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005c1c:	d65f03c0 	ret

0000000040005c20 <cmd_device_list>:

static int cmd_device_list(const struct shell *shell,
			   size_t argc, char **argv)
{
    40005c20:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
    40005c24:	910003fd 	mov	x29, sp
    40005c28:	a90153f3 	stp	x19, x20, [sp, #16]
    40005c2c:	aa0003f4 	mov	x20, x0
	const struct device *devlist;
	size_t devcnt = z_device_get_all_static(&devlist);
    40005c30:	910123e0 	add	x0, sp, #0x48
{
    40005c34:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (dev = devlist; dev < devlist_end; dev++) {
		char buf[20];
		const char *name = get_device_name(dev, buf, sizeof(buf));
		const char *state = "READY";

		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
    40005c38:	f0000076 	adrp	x22, 40014000 <CSWTCH.135+0x90>
    40005c3c:	912056d6 	add	x22, x22, #0x815
{
    40005c40:	a90363f7 	stp	x23, x24, [sp, #48]
	size_t devcnt = z_device_get_all_static(&devlist);
    40005c44:	9400217f 	bl	4000e240 <z_device_get_all_static>
	const struct device *devlist_end = devlist + devcnt;
    40005c48:	d2800602 	mov	x2, #0x30                  	// #48
    40005c4c:	f94027e1 	ldr	x1, [sp, #72]
		if (!device_is_ready(dev)) {
			state = "DISABLED";
    40005c50:	f0000077 	adrp	x23, 40014000 <CSWTCH.135+0x90>
    40005c54:	91200af7 	add	x23, x23, #0x802
		const char *name = get_device_name(dev, buf, sizeof(buf));
    40005c58:	910143f8 	add	x24, sp, #0x50
	const struct device *devlist_end = devlist + devcnt;
    40005c5c:	9b020415 	madd	x21, x0, x2, x1
	shell_fprintf(shell, SHELL_NORMAL, "devices:\n");
    40005c60:	aa1403e0 	mov	x0, x20
    40005c64:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005c68:	91202c42 	add	x2, x2, #0x80b
    40005c6c:	52800101 	mov	w1, #0x8                   	// #8
    40005c70:	9400083d 	bl	40007d64 <shell_fprintf>
	for (dev = devlist; dev < devlist_end; dev++) {
    40005c74:	f94027f3 	ldr	x19, [sp, #72]
    40005c78:	eb15027f 	cmp	x19, x21
    40005c7c:	540000e3 	b.cc	40005c98 <cmd_device_list+0x78>  // b.lo, b.ul, b.last
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
		}
	}

	return 0;
}
    40005c80:	52800000 	mov	w0, #0x0                   	// #0
    40005c84:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005c88:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005c8c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40005c90:	a8c87bfd 	ldp	x29, x30, [sp], #128
    40005c94:	d65f03c0 	ret
		const char *name = get_device_name(dev, buf, sizeof(buf));
    40005c98:	aa1803e1 	mov	x1, x24
    40005c9c:	aa1303e0 	mov	x0, x19
    40005ca0:	d2800282 	mov	x2, #0x14                  	// #20
    40005ca4:	97ffffbd 	bl	40005b98 <get_device_name>
		shell_fprintf(shell, SHELL_NORMAL, "- %s", name);
    40005ca8:	aa1603e2 	mov	x2, x22
    40005cac:	aa0003e3 	mov	x3, x0
    40005cb0:	52800101 	mov	w1, #0x8                   	// #8
    40005cb4:	aa1403e0 	mov	x0, x20
    40005cb8:	9400082b 	bl	40007d64 <shell_fprintf>
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
    40005cbc:	aa1303e0 	mov	x0, x19
    40005cc0:	9400216b 	bl	4000e26c <z_device_ready>
			state = "DISABLED";
    40005cc4:	72001c1f 	tst	w0, #0xff
    40005cc8:	f0000063 	adrp	x3, 40014000 <CSWTCH.135+0x90>
		shell_fprintf(shell, SHELL_NORMAL, " (%s)\n", state);
    40005ccc:	911ff063 	add	x3, x3, #0x7fc
    40005cd0:	aa1403e0 	mov	x0, x20
    40005cd4:	9a971063 	csel	x3, x3, x23, ne  // ne = any
    40005cd8:	52800101 	mov	w1, #0x8                   	// #8
    40005cdc:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005ce0:	91206842 	add	x2, x2, #0x81a
    40005ce4:	94000820 	bl	40007d64 <shell_fprintf>
			struct cmd_device_list_visitor_context ctx = {
    40005ce8:	a906e3f4 	stp	x20, x24, [sp, #104]
    40005cec:	d2800280 	mov	x0, #0x14                  	// #20
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
    40005cf0:	9101a3e2 	add	x2, sp, #0x68
    40005cf4:	90000001 	adrp	x1, 40005000 <severity_lvl_get+0x2c>
    40005cf8:	912f8021 	add	x1, x1, #0xbe0
			struct cmd_device_list_visitor_context ctx = {
    40005cfc:	f9003fe0 	str	x0, [sp, #120]
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
    40005d00:	aa1303e0 	mov	x0, x19
	for (dev = devlist; dev < devlist_end; dev++) {
    40005d04:	9100c273 	add	x19, x19, #0x30
			(void)device_required_foreach(dev, cmd_device_list_visitor, &ctx);
    40005d08:	94002162 	bl	4000e290 <device_required_foreach>
	for (dev = devlist; dev < devlist_end; dev++) {
    40005d0c:	17ffffdb 	b	40005c78 <cmd_device_list+0x58>

0000000040005d10 <device_get_config_level>:
{
    40005d10:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40005d14:	d0000062 	adrp	x2, 40013000 <shell_cmd_kernel>
    40005d18:	91180042 	add	x2, x2, #0x600
{
    40005d1c:	910003fd 	mov	x29, sp
    40005d20:	a90153f3 	stp	x19, x20, [sp, #16]
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40005d24:	f861d853 	ldr	x19, [x2, w1, sxtw #3]
    40005d28:	11000421 	add	w1, w1, #0x1
{
    40005d2c:	a90363f7 	stp	x23, x24, [sp, #48]
	bool devices = false;
    40005d30:	52800017 	mov	w23, #0x0                   	// #0
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40005d34:	f861d858 	ldr	x24, [x2, w1, sxtw #3]
{
    40005d38:	a9025bf5 	stp	x21, x22, [sp, #32]
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
    40005d3c:	f0000076 	adrp	x22, 40014000 <CSWTCH.135+0x90>
    40005d40:	912086d6 	add	x22, x22, #0x821
{
    40005d44:	aa0003f5 	mov	x21, x0
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40005d48:	eb13031f 	cmp	x24, x19
    40005d4c:	540000e8 	b.hi	40005d68 <device_get_config_level+0x58>  // b.pmore
}
    40005d50:	2a1703e0 	mov	w0, w23
    40005d54:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005d58:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005d5c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40005d60:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40005d64:	d65f03c0 	ret
    40005d68:	aa1303e0 	mov	x0, x19
    40005d6c:	94002140 	bl	4000e26c <z_device_ready>
    40005d70:	72001c14 	ands	w20, w0, #0xff
    40005d74:	54000160 	b.eq	40005da0 <device_get_config_level+0x90>  // b.none
			devices = true;
    40005d78:	2a1403f7 	mov	w23, w20
			shell_fprintf(shell, SHELL_NORMAL, "- %s\n",
    40005d7c:	910123e1 	add	x1, sp, #0x48
    40005d80:	d2800282 	mov	x2, #0x14                  	// #20
    40005d84:	aa1303e0 	mov	x0, x19
    40005d88:	97ffff84 	bl	40005b98 <get_device_name>
    40005d8c:	aa0003e3 	mov	x3, x0
    40005d90:	aa1603e2 	mov	x2, x22
    40005d94:	aa1503e0 	mov	x0, x21
    40005d98:	52800101 	mov	w1, #0x8                   	// #8
    40005d9c:	940007f2 	bl	40007d64 <shell_fprintf>
	for (dev = levels[level]; dev < levels[level+1]; dev++) {
    40005da0:	9100c273 	add	x19, x19, #0x30
    40005da4:	17ffffe9 	b	40005d48 <device_get_config_level+0x38>

0000000040005da8 <cmd_device_levels>:
{
    40005da8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
    40005dac:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005db0:	91209c42 	add	x2, x2, #0x827
{
    40005db4:	910003fd 	mov	x29, sp
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
    40005db8:	52800101 	mov	w1, #0x8                   	// #8
{
    40005dbc:	f9000bf3 	str	x19, [sp, #16]
    40005dc0:	aa0003f3 	mov	x19, x0
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 1:\n");
    40005dc4:	940007e8 	bl	40007d64 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_1);
    40005dc8:	aa1303e0 	mov	x0, x19
    40005dcc:	52800001 	mov	w1, #0x0                   	// #0
    40005dd0:	97ffffd0 	bl	40005d10 <device_get_config_level>
	if (ret == false) {
    40005dd4:	72001c1f 	tst	w0, #0xff
    40005dd8:	540000c1 	b.ne	40005df0 <cmd_device_levels+0x48>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    40005ddc:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005de0:	9120d842 	add	x2, x2, #0x836
    40005de4:	aa1303e0 	mov	x0, x19
    40005de8:	52800101 	mov	w1, #0x8                   	// #8
    40005dec:	940007de 	bl	40007d64 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "PRE KERNEL 2:\n");
    40005df0:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005df4:	9120f842 	add	x2, x2, #0x83e
    40005df8:	aa1303e0 	mov	x0, x19
    40005dfc:	52800101 	mov	w1, #0x8                   	// #8
    40005e00:	940007d9 	bl	40007d64 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_PRE_KERNEL_2);
    40005e04:	aa1303e0 	mov	x0, x19
    40005e08:	52800021 	mov	w1, #0x1                   	// #1
    40005e0c:	97ffffc1 	bl	40005d10 <device_get_config_level>
	if (ret == false) {
    40005e10:	72001c1f 	tst	w0, #0xff
    40005e14:	540000c1 	b.ne	40005e2c <cmd_device_levels+0x84>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    40005e18:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005e1c:	9120d842 	add	x2, x2, #0x836
    40005e20:	aa1303e0 	mov	x0, x19
    40005e24:	52800101 	mov	w1, #0x8                   	// #8
    40005e28:	940007cf 	bl	40007d64 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "POST_KERNEL:\n");
    40005e2c:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005e30:	91213442 	add	x2, x2, #0x84d
    40005e34:	aa1303e0 	mov	x0, x19
    40005e38:	52800101 	mov	w1, #0x8                   	// #8
    40005e3c:	940007ca 	bl	40007d64 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_POST_KERNEL);
    40005e40:	aa1303e0 	mov	x0, x19
    40005e44:	52800041 	mov	w1, #0x2                   	// #2
    40005e48:	97ffffb2 	bl	40005d10 <device_get_config_level>
	if (ret == false) {
    40005e4c:	72001c1f 	tst	w0, #0xff
    40005e50:	540000c1 	b.ne	40005e68 <cmd_device_levels+0xc0>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    40005e54:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005e58:	9120d842 	add	x2, x2, #0x836
    40005e5c:	aa1303e0 	mov	x0, x19
    40005e60:	52800101 	mov	w1, #0x8                   	// #8
    40005e64:	940007c0 	bl	40007d64 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "APPLICATION:\n");
    40005e68:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005e6c:	91216c42 	add	x2, x2, #0x85b
    40005e70:	aa1303e0 	mov	x0, x19
    40005e74:	52800101 	mov	w1, #0x8                   	// #8
    40005e78:	940007bb 	bl	40007d64 <shell_fprintf>
	ret = device_get_config_level(shell, _SYS_INIT_LEVEL_APPLICATION);
    40005e7c:	aa1303e0 	mov	x0, x19
    40005e80:	52800061 	mov	w1, #0x3                   	// #3
    40005e84:	97ffffa3 	bl	40005d10 <device_get_config_level>
	if (ret == false) {
    40005e88:	72001c1f 	tst	w0, #0xff
    40005e8c:	540000c1 	b.ne	40005ea4 <cmd_device_levels+0xfc>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "- None\n");
    40005e90:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005e94:	9120d842 	add	x2, x2, #0x836
    40005e98:	aa1303e0 	mov	x0, x19
    40005e9c:	52800101 	mov	w1, #0x8                   	// #8
    40005ea0:	940007b1 	bl	40007d64 <shell_fprintf>
}
    40005ea4:	52800000 	mov	w0, #0x0                   	// #0
    40005ea8:	f9400bf3 	ldr	x19, [sp, #16]
    40005eac:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40005eb0:	d65f03c0 	ret

0000000040005eb4 <cmd_devmem>:
	return err;
}

/* The syntax of the command is similar to busybox's devmem */
static int cmd_devmem(const struct shell *sh, size_t argc, char **argv)
{
    40005eb4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40005eb8:	910003fd 	mov	x29, sp
    40005ebc:	a90153f3 	stp	x19, x20, [sp, #16]
    40005ec0:	aa0003f4 	mov	x20, x0
	mem_addr_t phys_addr, addr;
	uint32_t value = 0;
	uint8_t width;

	if (argc < 2 || argc > 4) {
    40005ec4:	d1000820 	sub	x0, x1, #0x2
{
    40005ec8:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (argc < 2 || argc > 4) {
    40005ecc:	f100081f 	cmp	x0, #0x2
    40005ed0:	54000868 	b.hi	40005fdc <cmd_devmem+0x128>  // b.pmore
    40005ed4:	aa0203f5 	mov	x21, x2
		return -EINVAL;
	}

	phys_addr = strtoul(argv[1], NULL, 16);
    40005ed8:	aa0103f6 	mov	x22, x1
    40005edc:	52800202 	mov	w2, #0x10                  	// #16
    40005ee0:	d2800001 	mov	x1, #0x0                   	// #0
    40005ee4:	f94006a0 	ldr	x0, [x21, #8]
    40005ee8:	94001686 	bl	4000b900 <strtoul>
{
#ifdef CONFIG_MMU
	/* Pass along flags and add that we want supervisor mode
	 * read-write access.
	 */
	z_phys_map((uint8_t **)virt_addr, phys_addr, size,
    40005eec:	aa0003e1 	mov	x1, x0
    40005ef0:	aa0003f3 	mov	x19, x0
    40005ef4:	52800143 	mov	w3, #0xa                   	// #10
    40005ef8:	9100e3e0 	add	x0, sp, #0x38
    40005efc:	d2802002 	mov	x2, #0x100                 	// #256
    40005f00:	94002a34 	bl	400107d0 <z_phys_map>

#if defined(CONFIG_MMU) || defined(CONFIG_PCIE)
	device_map((mm_reg_t *)&addr, phys_addr, 0x100, K_MEM_CACHE_NONE);

	shell_print(sh, "Mapped 0x%lx to 0x%lx\n", phys_addr, addr);
    40005f04:	f9401fe4 	ldr	x4, [sp, #56]
    40005f08:	aa1303e3 	mov	x3, x19
    40005f0c:	aa1403e0 	mov	x0, x20
    40005f10:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005f14:	9122fc42 	add	x2, x2, #0x8bf
    40005f18:	52800101 	mov	w1, #0x8                   	// #8
    40005f1c:	94000792 	bl	40007d64 <shell_fprintf>
#else
	addr = phys_addr;
#endif /* defined(CONFIG_MMU) || defined(CONFIG_PCIE) */

	if (argc < 3) {
    40005f20:	f1000adf 	cmp	x22, #0x2
    40005f24:	54000440 	b.eq	40005fac <cmd_devmem+0xf8>  // b.none
		width = 32;
	} else {
		width = strtoul(argv[2], NULL, 10);
    40005f28:	f9400aa0 	ldr	x0, [x21, #16]
    40005f2c:	52800142 	mov	w2, #0xa                   	// #10
    40005f30:	d2800001 	mov	x1, #0x0                   	// #0
    40005f34:	94001673 	bl	4000b900 <strtoul>
    40005f38:	12001c13 	and	w19, w0, #0xff
	}

	shell_fprintf(sh, SHELL_NORMAL, "Using data width %d\n", width);
    40005f3c:	2a1303e3 	mov	w3, w19
    40005f40:	aa1403e0 	mov	x0, x20
    40005f44:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005f48:	91235c42 	add	x2, x2, #0x8d7
    40005f4c:	52800101 	mov	w1, #0x8                   	// #8
    40005f50:	94000785 	bl	40007d64 <shell_fprintf>

	if (argc <= 3) {
    40005f54:	f10012df 	cmp	x22, #0x4
    40005f58:	54000460 	b.eq	40005fe4 <cmd_devmem+0x130>  // b.none
	switch (width) {
    40005f5c:	7100427f 	cmp	w19, #0x10
		return memory_read(sh, addr, width);
    40005f60:	f9401fe3 	ldr	x3, [sp, #56]
	switch (width) {
    40005f64:	54000280 	b.eq	40005fb4 <cmd_devmem+0x100>  // b.none
    40005f68:	7100827f 	cmp	w19, #0x20
    40005f6c:	540002a0 	b.eq	40005fc0 <cmd_devmem+0x10c>  // b.none
    40005f70:	7100227f 	cmp	w19, #0x8
    40005f74:	540002a1 	b.ne	40005fc8 <cmd_devmem+0x114>  // b.any
 */
static ALWAYS_INLINE uint8_t sys_read8(mem_addr_t addr)
{
	uint8_t val;

	__asm__ volatile("ldrb %w0, [%1]" : "=r" (val) : "r" (addr));
    40005f78:	39400063 	ldrb	w3, [x3]
    40005f7c:	12001c63 	and	w3, w3, #0xff
{
	uint32_t val;

	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));

	__DMB();
    40005f80:	d5033fbf 	dmb	sy
		shell_fprintf(sh, SHELL_NORMAL, "Read value 0x%x\n", value);
    40005f84:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005f88:	91240842 	add	x2, x2, #0x902
    40005f8c:	aa1403e0 	mov	x0, x20
    40005f90:	52800101 	mov	w1, #0x8                   	// #8
    40005f94:	94000774 	bl	40007d64 <shell_fprintf>
	int err = 0;
    40005f98:	52800000 	mov	w0, #0x0                   	// #0
	value = strtoul(argv[3], NULL, 16);

	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);

	return memory_write(sh, addr, width, value);
}
    40005f9c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40005fa0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40005fa4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40005fa8:	d65f03c0 	ret
		width = 32;
    40005fac:	52800413 	mov	w19, #0x20                  	// #32
    40005fb0:	17ffffe3 	b	40005f3c <cmd_devmem+0x88>
	__asm__ volatile("ldrh %w0, [%1]" : "=r" (val) : "r" (addr));
    40005fb4:	79400063 	ldrh	w3, [x3]
    40005fb8:	12003c63 	and	w3, w3, #0xffff
	__DMB();
    40005fbc:	17fffff1 	b	40005f80 <cmd_devmem+0xcc>
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    40005fc0:	b9400063 	ldr	w3, [x3]
    40005fc4:	17ffffef 	b	40005f80 <cmd_devmem+0xcc>
		shell_fprintf(sh, SHELL_NORMAL, "Incorrect data width\n");
    40005fc8:	f0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40005fcc:	9123b042 	add	x2, x2, #0x8ec
    40005fd0:	aa1403e0 	mov	x0, x20
    40005fd4:	52800101 	mov	w1, #0x8                   	// #8
    40005fd8:	94000763 	bl	40007d64 <shell_fprintf>
		return -EINVAL;
    40005fdc:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40005fe0:	17ffffef 	b	40005f9c <cmd_devmem+0xe8>
	value = strtoul(argv[3], NULL, 16);
    40005fe4:	f9400ea0 	ldr	x0, [x21, #24]
    40005fe8:	52800202 	mov	w2, #0x10                  	// #16
    40005fec:	d2800001 	mov	x1, #0x0                   	// #0
    40005ff0:	94001644 	bl	4000b900 <strtoul>
    40005ff4:	aa0003f5 	mov	x21, x0
	shell_fprintf(sh, SHELL_NORMAL, "Writing value 0x%x\n", value);
    40005ff8:	2a0003e3 	mov	w3, w0
    40005ffc:	52800101 	mov	w1, #0x8                   	// #8
    40006000:	aa1403e0 	mov	x0, x20
    40006004:	d0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40006008:	91244c42 	add	x2, x2, #0x913
    4000600c:	94000756 	bl	40007d64 <shell_fprintf>
	return memory_write(sh, addr, width, value);
    40006010:	92407ea1 	and	x1, x21, #0xffffffff
	switch (width) {
    40006014:	7100427f 	cmp	w19, #0x10
	return memory_write(sh, addr, width, value);
    40006018:	f9401fe0 	ldr	x0, [sp, #56]
	switch (width) {
    4000601c:	54000100 	b.eq	4000603c <cmd_devmem+0x188>  // b.none
    40006020:	7100827f 	cmp	w19, #0x20
    40006024:	54000120 	b.eq	40006048 <cmd_devmem+0x194>  // b.none
    40006028:	7100227f 	cmp	w19, #0x8
    4000602c:	54fffce1 	b.ne	40005fc8 <cmd_devmem+0x114>  // b.any
	__DMB();
    40006030:	d5033fbf 	dmb	sy
	__asm__ volatile("strb %w0, [%1]" : : "r" (data), "r" (addr));
    40006034:	39000001 	strb	w1, [x0]
    40006038:	17ffffd8 	b	40005f98 <cmd_devmem+0xe4>
	__DMB();
    4000603c:	d5033fbf 	dmb	sy
	__asm__ volatile("strh %w0, [%1]" : : "r" (data), "r" (addr));
    40006040:	79000001 	strh	w1, [x0]
    40006044:	17ffffd5 	b	40005f98 <cmd_devmem+0xe4>
	return val;
}

static ALWAYS_INLINE void sys_write32(uint32_t data, mem_addr_t addr)
{
	__DMB();
    40006048:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000604c:	b9000015 	str	w21, [x0]
    40006050:	17ffffd2 	b	40005f98 <cmd_devmem+0xe4>

0000000040006054 <set_bypass.isra.0>:
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
    40006054:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40006058:	910003fd 	mov	x29, sp
    4000605c:	a90153f3 	stp	x19, x20, [sp, #16]
	if (bypass && in_use) {
    40006060:	f00000d3 	adrp	x19, 40021000 <k_sys_work_q+0x240>
    40006064:	3962e262 	ldrb	w2, [x19, #2232]
static int set_bypass(const struct shell *sh, shell_bypass_cb_t bypass)
    40006068:	f90013f5 	str	x21, [sp, #32]
    4000606c:	aa0003f4 	mov	x20, x0
    40006070:	aa0103f5 	mov	x21, x1
	if (bypass && in_use) {
    40006074:	b4000121 	cbz	x1, 40006098 <set_bypass.isra.0+0x44>
    40006078:	34000102 	cbz	w2, 40006098 <set_bypass.isra.0+0x44>
}
    4000607c:	a94153f3 	ldp	x19, x20, [sp, #16]
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
    40006080:	d0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40006084:	91249c42 	add	x2, x2, #0x927
    40006088:	52800021 	mov	w1, #0x1                   	// #1
}
    4000608c:	f94013f5 	ldr	x21, [sp, #32]
    40006090:	a8c37bfd 	ldp	x29, x30, [sp], #48
		shell_error(sh, "devmem load supports setting bypass on a single instance.");
    40006094:	14000734 	b	40007d64 <shell_fprintf>
	in_use = !in_use;
    40006098:	52000042 	eor	w2, w2, #0x1
    4000609c:	3922e262 	strb	w2, [x19, #2232]
	if (in_use) {
    400060a0:	34000102 	cbz	w2, 400060c0 <set_bypass.isra.0+0x6c>
		shell_print(sh, "Loading...\npress ctrl-x ctrl-q to escape");
    400060a4:	aa1403e0 	mov	x0, x20
    400060a8:	d0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400060ac:	91258842 	add	x2, x2, #0x962
    400060b0:	52800101 	mov	w1, #0x8                   	// #8
    400060b4:	9400072c 	bl	40007d64 <shell_fprintf>
		in_use = true;
    400060b8:	52800020 	mov	w0, #0x1                   	// #1
    400060bc:	3922e260 	strb	w0, [x19, #2232]
	shell_set_bypass(sh, bypass);
    400060c0:	aa1503e1 	mov	x1, x21
    400060c4:	aa1403e0 	mov	x0, x20
}
    400060c8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400060cc:	f94013f5 	ldr	x21, [sp, #32]
    400060d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
	shell_set_bypass(sh, bypass);
    400060d4:	14000761 	b	40007e58 <shell_set_bypass>

00000000400060d8 <bypass_cb>:
{
    400060d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400060dc:	910003fd 	mov	x29, sp
    400060e0:	a90153f3 	stp	x19, x20, [sp, #16]
    400060e4:	aa0003f4 	mov	x20, x0
	if (tail == CHAR_CAN && recv[0] == CHAR_DC1) {
    400060e8:	f00000c3 	adrp	x3, 40021000 <k_sys_work_q+0x240>
    400060ec:	3962e860 	ldrb	w0, [x3, #2234]
    400060f0:	aa0303e4 	mov	x4, x3
    400060f4:	7100601f 	cmp	w0, #0x18
    400060f8:	54000081 	b.ne	40006108 <bypass_cb+0x30>  // b.any
    400060fc:	39400020 	ldrb	w0, [x1]
    40006100:	7100441f 	cmp	w0, #0x11
    40006104:	54000640 	b.eq	400061cc <bypass_cb+0xf4>  // b.none
		for (int i = 0; i < (len - 1); i++) {
    40006108:	d1000442 	sub	x2, x2, #0x1
    4000610c:	52800003 	mov	w3, #0x0                   	// #0
    40006110:	93407c60 	sxtw	x0, w3
    40006114:	eb23c05f 	cmp	x2, w3, sxtw
    40006118:	540004c8 	b.hi	400061b0 <bypass_cb+0xd8>  // b.pmore
	tail = recv[len - 1];
    4000611c:	38626820 	ldrb	w0, [x1, x2]
    40006120:	f00000d3 	adrp	x19, 40021000 <k_sys_work_q+0x240>
	if (is_ascii(*recv)) {
    40006124:	39400021 	ldrb	w1, [x1]
	tail = recv[len - 1];
    40006128:	3922e880 	strb	w0, [x4, #2234]
	return (data >= 0x30 && data <= 0x39) || (data >= 0x61 && data <= 0x66) ||
    4000612c:	5100c020 	sub	w0, w1, #0x30
    40006130:	12001c00 	and	w0, w0, #0xff
    40006134:	7100241f 	cmp	w0, #0x9
    40006138:	540000c9 	b.ls	40006150 <bypass_cb+0x78>  // b.plast
	if (is_ascii(*recv)) {
    4000613c:	121a7820 	and	w0, w1, #0xffffffdf
    40006140:	51010400 	sub	w0, w0, #0x41
    40006144:	12001c00 	and	w0, w0, #0xff
    40006148:	7100141f 	cmp	w0, #0x5
    4000614c:	540000e8 	b.hi	40006168 <bypass_cb+0x90>  // b.pmore
		chunk[chunk_element] = *recv;
    40006150:	b9479260 	ldr	w0, [x19, #1936]
    40006154:	f00000c2 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    40006158:	9122d842 	add	x2, x2, #0x8b6
    4000615c:	3820c841 	strb	w1, [x2, w0, sxtw]
		chunk_element++;
    40006160:	11000400 	add	w0, w0, #0x1
    40006164:	b9079260 	str	w0, [x19, #1936]
	if (chunk_element == 2) {
    40006168:	b9479260 	ldr	w0, [x19, #1936]
    4000616c:	7100081f 	cmp	w0, #0x2
    40006170:	54000641 	b.ne	40006238 <bypass_cb+0x160>  // b.any
		byte = (uint8_t)strtoul(chunk, NULL, 16);
    40006174:	52800202 	mov	w2, #0x10                  	// #16
    40006178:	d2800001 	mov	x1, #0x0                   	// #0
    4000617c:	f00000c0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40006180:	9122d800 	add	x0, x0, #0x8b6
    40006184:	940015df 	bl	4000b900 <strtoul>
		chunk_element = 0;
    40006188:	b907927f 	str	wzr, [x19, #1936]
		*bytes = byte;
    4000618c:	f00000c2 	adrp	x2, 40021000 <k_sys_work_q+0x240>
		byte = (uint8_t)strtoul(chunk, NULL, 16);
    40006190:	f9413441 	ldr	x1, [x2, #616]
    40006194:	38001420 	strb	w0, [x1], #1
		bytes++;
    40006198:	f9013441 	str	x1, [x2, #616]
		sum++;
    4000619c:	f00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    400061a0:	b9479420 	ldr	w0, [x1, #1940]
    400061a4:	11000400 	add	w0, w0, #0x1
    400061a8:	b9079420 	str	w0, [x1, #1940]
		chunk_element = 0;
    400061ac:	14000023 	b	40006238 <bypass_cb+0x160>
			if (recv[i] == CHAR_CAN && recv[i + 1] == CHAR_DC1) {
    400061b0:	38606820 	ldrb	w0, [x1, x0]
    400061b4:	11000463 	add	w3, w3, #0x1
    400061b8:	7100601f 	cmp	w0, #0x18
    400061bc:	54fffaa1 	b.ne	40006110 <bypass_cb+0x38>  // b.any
    400061c0:	3863c820 	ldrb	w0, [x1, w3, sxtw]
    400061c4:	7100441f 	cmp	w0, #0x11
    400061c8:	54fffa41 	b.ne	40006110 <bypass_cb+0x38>  // b.any
		shell_print(sh, "Number of bytes read: %d", sum);
    400061cc:	f00000d3 	adrp	x19, 40021000 <k_sys_work_q+0x240>
    400061d0:	b9479663 	ldr	w3, [x19, #1940]
    400061d4:	d0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400061d8:	91263042 	add	x2, x2, #0x98c
    400061dc:	aa1403e0 	mov	x0, x20
    400061e0:	52800101 	mov	w1, #0x8                   	// #8
    400061e4:	940006e0 	bl	40007d64 <shell_fprintf>
		set_bypass(sh, NULL);
    400061e8:	aa1403e0 	mov	x0, x20
    400061ec:	d2800001 	mov	x1, #0x0                   	// #0
    400061f0:	97ffff99 	bl	40006054 <set_bypass.isra.0>
		if (!littleendian) {
    400061f4:	f00000c0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    400061f8:	3962e403 	ldrb	w3, [x0, #2233]
    400061fc:	350001e3 	cbnz	w3, 40006238 <bypass_cb+0x160>
    40006200:	f00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40006204:	f9413822 	ldr	x2, [x1, #624]
    40006208:	b9479660 	ldr	w0, [x19, #1940]
			while (sum > 4) {
    4000620c:	7100101f 	cmp	w0, #0x4
    40006210:	540001ac 	b.gt	40006244 <bypass_cb+0x16c>
    40006214:	34000063 	cbz	w3, 40006220 <bypass_cb+0x148>
    40006218:	f9013822 	str	x2, [x1, #624]
    4000621c:	b9079660 	str	w0, [x19, #1940]
			if (sum % 4 == 0) {
    40006220:	72000402 	ands	w2, w0, #0x3
    40006224:	540001c1 	b.ne	4000625c <bypass_cb+0x184>  // b.any
				*data = __bswap_32(*data);
    40006228:	f9413821 	ldr	x1, [x1, #624]
    4000622c:	b9400020 	ldr	w0, [x1]
    40006230:	5ac00800 	rev	w0, w0
				*data = __bswap_16(*data);
    40006234:	b9000020 	str	w0, [x1]
}
    40006238:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000623c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40006240:	d65f03c0 	ret
				*data = __bswap_32(*data);
    40006244:	b9400043 	ldr	w3, [x2]
				sum = sum - 4;
    40006248:	51001000 	sub	w0, w0, #0x4
    4000624c:	5ac00863 	rev	w3, w3
				*data = __bswap_32(*data);
    40006250:	b8004443 	str	w3, [x2], #4
				sum = sum - 4;
    40006254:	52800023 	mov	w3, #0x1                   	// #1
    40006258:	17ffffed 	b	4000620c <bypass_cb+0x134>
			} else if (sum % 4 == 2) {
    4000625c:	6b0003e0 	negs	w0, w0
    40006260:	12000400 	and	w0, w0, #0x3
    40006264:	5a804440 	csneg	w0, w2, w0, mi  // mi = first
    40006268:	7100081f 	cmp	w0, #0x2
    4000626c:	540000c1 	b.ne	40006284 <bypass_cb+0x1ac>  // b.any
				*data = __bswap_16(*data);
    40006270:	f9413821 	ldr	x1, [x1, #624]
    40006274:	79400020 	ldrh	w0, [x1]
    40006278:	5ac00400 	rev16	w0, w0
    4000627c:	12003c00 	and	w0, w0, #0xffff
    40006280:	17ffffed 	b	40006234 <bypass_cb+0x15c>
			} else if (sum % 4 == 3) {
    40006284:	71000c1f 	cmp	w0, #0x3
    40006288:	54fffd81 	b.ne	40006238 <bypass_cb+0x160>  // b.any
				*data = __bswap_24(*data);
    4000628c:	f9413822 	ldr	x2, [x1, #624]
    40006290:	b9400041 	ldr	w1, [x2]
    40006294:	d3505c20 	ubfx	x0, x1, #16, #8
    40006298:	53101c23 	ubfiz	w3, w1, #16, #8
    4000629c:	2a030000 	orr	w0, w0, w3
    400062a0:	12181c21 	and	w1, w1, #0xff00
    400062a4:	2a010000 	orr	w0, w0, w1
    400062a8:	b9000040 	str	w0, [x2]
    400062ac:	17ffffe3 	b	40006238 <bypass_cb+0x160>

00000000400062b0 <cmd_load>:
{
    400062b0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    400062b4:	910003fd 	mov	x29, sp
    400062b8:	a9025bf5 	stp	x21, x22, [sp, #32]
    400062bc:	aa0103f5 	mov	x21, x1
	chunk_element = 0;
    400062c0:	f00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
{
    400062c4:	aa0003f6 	mov	x22, x0
	littleendian = false;
    400062c8:	f00000c0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
	chunk_element = 0;
    400062cc:	b907903f 	str	wzr, [x1, #1936]
	sum = 0;
    400062d0:	f00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
{
    400062d4:	a90153f3 	stp	x19, x20, [sp, #16]
    400062d8:	aa0203f3 	mov	x19, x2
    400062dc:	a90363f7 	stp	x23, x24, [sp, #48]
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    400062e0:	d0000077 	adrp	x23, 40014000 <CSWTCH.135+0x90>
    400062e4:	91269af7 	add	x23, x23, #0x9a6
{
    400062e8:	a9046bf9 	stp	x25, x26, [sp, #64]
		if (!strncmp(arg, "-e", 2)) {
    400062ec:	d0000079 	adrp	x25, 40014000 <CSWTCH.135+0x90>
    400062f0:	9126a739 	add	x25, x25, #0x9a9
    400062f4:	aa0003fa 	mov	x26, x0
	littleendian = false;
    400062f8:	3922e41f 	strb	wzr, [x0, #2233]
	sum = 0;
    400062fc:	b907943f 	str	wzr, [x1, #1940]
{
    40006300:	f9002bfb 	str	x27, [sp, #80]
	while (argc >= 2) {
    40006304:	f10006bf 	cmp	x21, #0x1
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    40006308:	f9400678 	ldr	x24, [x19, #8]
	while (argc >= 2) {
    4000630c:	540003a9 	b.ls	40006380 <cmd_load+0xd0>  // b.plast
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    40006310:	aa1703e1 	mov	x1, x23
    40006314:	aa1803e0 	mov	x0, x24
    40006318:	d2800042 	mov	x2, #0x2                   	// #2
    4000631c:	9400163e 	bl	4000bc14 <strncmp>
    40006320:	35000220 	cbnz	w0, 40006364 <cmd_load+0xb4>
    40006324:	f9400660 	ldr	x0, [x19, #8]
    40006328:	39400800 	ldrb	w0, [x0, #2]
    4000632c:	7100001f 	cmp	w0, #0x0
    40006330:	1a9f07f4 	cset	w20, ne  // ne = any
    40006334:	93407e9b 	sxtw	x27, w20
    40006338:	8b34c314 	add	x20, x24, w20, sxtw
		if (!strncmp(arg, "-e", 2)) {
    4000633c:	aa1903e1 	mov	x1, x25
    40006340:	aa1403e0 	mov	x0, x20
    40006344:	d2800042 	mov	x2, #0x2                   	// #2
    40006348:	94001633 	bl	4000bc14 <strncmp>
    4000634c:	35000100 	cbnz	w0, 4000636c <cmd_load+0xbc>
			littleendian = true;
    40006350:	52800020 	mov	w0, #0x1                   	// #1
    40006354:	3922e740 	strb	w0, [x26, #2233]
		argv++;
    40006358:	91002273 	add	x19, x19, #0x8
		argc--;
    4000635c:	d10006b5 	sub	x21, x21, #0x1
    40006360:	17ffffe9 	b	40006304 <cmd_load+0x54>
		arg = argv[1] + (!strncmp(argv[1], "--", 2) && argv[1][2]);
    40006364:	52800014 	mov	w20, #0x0                   	// #0
    40006368:	17fffff3 	b	40006334 <cmd_load+0x84>
		} else if (!strcmp(arg, "--")) {
    4000636c:	aa1703e1 	mov	x1, x23
    40006370:	aa1403e0 	mov	x0, x20
    40006374:	9400161f 	bl	4000bbf0 <strcmp>
    40006378:	35000340 	cbnz	w0, 400063e0 <cmd_load+0x130>
			argv++;
    4000637c:	91002273 	add	x19, x19, #0x8
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
    40006380:	f9400660 	ldr	x0, [x19, #8]
    40006384:	52800002 	mov	w2, #0x0                   	// #0
    40006388:	d2800001 	mov	x1, #0x0                   	// #0
    4000638c:	940014fb 	bl	4000b778 <strtol>
    40006390:	f00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
	data = (uint32_t *)strtol(argv[1], NULL, 0);
    40006394:	52800002 	mov	w2, #0x0                   	// #0
	bytes = (unsigned char *)strtol(argv[1], NULL, 0);
    40006398:	f9013420 	str	x0, [x1, #616]
	data = (uint32_t *)strtol(argv[1], NULL, 0);
    4000639c:	d2800001 	mov	x1, #0x0                   	// #0
    400063a0:	f9400660 	ldr	x0, [x19, #8]
    400063a4:	940014f5 	bl	4000b778 <strtol>
    400063a8:	f00000c1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    400063ac:	f9013820 	str	x0, [x1, #624]
	set_bypass(sh, bypass_cb);
    400063b0:	aa1603e0 	mov	x0, x22
    400063b4:	90000001 	adrp	x1, 40006000 <cmd_devmem+0x14c>
    400063b8:	91036021 	add	x1, x1, #0xd8
    400063bc:	97ffff26 	bl	40006054 <set_bypass.isra.0>
}
    400063c0:	52800000 	mov	w0, #0x0                   	// #0
    400063c4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400063c8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400063cc:	a94363f7 	ldp	x23, x24, [sp, #48]
    400063d0:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400063d4:	f9402bfb 	ldr	x27, [sp, #80]
    400063d8:	a8c67bfd 	ldp	x29, x30, [sp], #96
    400063dc:	d65f03c0 	ret
		} else if (arg[0] == '-' && arg[1]) {
    400063e0:	387b6b00 	ldrb	w0, [x24, x27]
    400063e4:	7100b41f 	cmp	w0, #0x2d
    400063e8:	54fffcc1 	b.ne	40006380 <cmd_load+0xd0>  // b.any
    400063ec:	39400680 	ldrb	w0, [x20, #1]
    400063f0:	34fffc80 	cbz	w0, 40006380 <cmd_load+0xd0>
			shell_print(sh, "Unknown option \"%s\"", arg);
    400063f4:	aa1403e3 	mov	x3, x20
    400063f8:	aa1603e0 	mov	x0, x22
    400063fc:	d0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40006400:	9126b042 	add	x2, x2, #0x9ac
    40006404:	52800101 	mov	w1, #0x8                   	// #8
    40006408:	94000657 	bl	40007d64 <shell_fprintf>
    4000640c:	17ffffd3 	b	40006358 <cmd_load+0xa8>

0000000040006410 <uart_irq_tx_disable>:
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	if (api->irq_tx_disable != NULL) {
    40006410:	f9400801 	ldr	x1, [x0, #16]
    40006414:	f9402021 	ldr	x1, [x1, #64]
    40006418:	b4000061 	cbz	x1, 40006424 <uart_irq_tx_disable+0x14>
		api->irq_tx_disable(dev);
    4000641c:	aa0103f0 	mov	x16, x1
    40006420:	d61f0200 	br	x16
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_disable(dev);
}
    40006424:	d65f03c0 	ret

0000000040006428 <uninit>:

	return 0;
}

static int uninit(const struct shell_transport *transport)
{
    40006428:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000642c:	910003fd 	mov	x29, sp
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN)) {
		const struct device *dev = sh_uart->ctrl_blk->dev;
    40006430:	f9400400 	ldr	x0, [x0, #8]
    40006434:	f9400000 	ldr	x0, [x0]
{
    40006438:	f9000bf3 	str	x19, [sp, #16]
		const struct device *dev = sh_uart->ctrl_blk->dev;
    4000643c:	f9400013 	ldr	x19, [x0]

		uart_irq_tx_disable(dev);
    40006440:	aa1303e0 	mov	x0, x19
    40006444:	97fffff3 	bl	40006410 <uart_irq_tx_disable>
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	if (api->irq_rx_disable != NULL) {
    40006448:	f9400a60 	ldr	x0, [x19, #16]
    4000644c:	f9402c01 	ldr	x1, [x0, #88]
    40006450:	b4000061 	cbz	x1, 4000645c <uninit+0x34>
		api->irq_rx_disable(dev);
    40006454:	aa1303e0 	mov	x0, x19
    40006458:	d63f0020 	blr	x1
	} else {
		k_timer_stop(sh_uart->timer);
	}

	return 0;
}
    4000645c:	52800000 	mov	w0, #0x0                   	// #0
    40006460:	f9400bf3 	ldr	x19, [sp, #16]
    40006464:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40006468:	d65f03c0 	ret

000000004000646c <enable>:

static int enable(const struct shell_transport *transport, bool blocking_tx)
{
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
    4000646c:	f9400400 	ldr	x0, [x0, #8]
{
    40006470:	12001c21 	and	w1, w1, #0xff
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
    40006474:	f9400000 	ldr	x0, [x0]
    40006478:	39008001 	strb	w1, [x0, #32]

	if (blocking_tx) {
    4000647c:	34000101 	cbz	w1, 4000649c <enable+0x30>
{
    40006480:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40006484:	910003fd 	mov	x29, sp
#ifdef CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
    40006488:	f9400000 	ldr	x0, [x0]
    4000648c:	97ffffe1 	bl	40006410 <uart_irq_tx_disable>
#endif
	}

	return 0;
}
    40006490:	52800000 	mov	w0, #0x0                   	// #0
    40006494:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40006498:	d65f03c0 	ret
    4000649c:	52800000 	mov	w0, #0x0                   	// #0
    400064a0:	d65f03c0 	ret

00000000400064a4 <read>:
	return 0;
}

static int read(const struct shell_transport *transport,
		void *data, size_t length, size_t *cnt)
{
    400064a4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400064a8:	910003fd 	mov	x29, sp
	struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;

	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
    400064ac:	f9400400 	ldr	x0, [x0, #8]
    400064b0:	f9400c00 	ldr	x0, [x0, #24]
{
    400064b4:	f9000bf3 	str	x19, [sp, #16]
    400064b8:	aa0303f3 	mov	x19, x3
	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
    400064bc:	97fff2d5 	bl	40003010 <ring_buf_get>
    400064c0:	2a0003e0 	mov	w0, w0
    400064c4:	f9000260 	str	x0, [x19]

	return 0;
}
    400064c8:	52800000 	mov	w0, #0x0                   	// #0
    400064cc:	f9400bf3 	ldr	x19, [sp, #16]
    400064d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400064d4:	d65f03c0 	ret

00000000400064d8 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_SMP_SHELL */
};

static int enable_shell_uart(const struct device *arg)
{
    400064d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400064dc:	910003fd 	mov	x29, sp
    400064e0:	f9000bf3 	str	x19, [sp, #16]
    400064e4:	90000073 	adrp	x19, 40012000 <__rodata_region_start>
    400064e8:	91028273 	add	x19, x19, #0xa0
    400064ec:	aa1303e0 	mov	x0, x19
    400064f0:	94001f5f 	bl	4000e26c <z_device_ready>
    400064f4:	72001c1f 	tst	w0, #0xff
    400064f8:	540001a0 	b.eq	4000652c <enable_shell_uart+0x54>  // b.none

	if (IS_ENABLED(CONFIG_MCUMGR_SMP_SHELL)) {
		smp_shell_init();
	}

	shell_init(&shell_uart, dev, cfg_flags, log_backend, level);
    400064fc:	d0000060 	adrp	x0, 40014000 <CSWTCH.135+0x90>
    40006500:	b9403c02 	ldr	w2, [x0, #60]
    40006504:	aa1303e1 	mov	x1, x19
    40006508:	52800084 	mov	w4, #0x4                   	// #4
    4000650c:	52800023 	mov	w3, #0x1                   	// #1
    40006510:	90000060 	adrp	x0, 40012000 <__rodata_region_start>
    40006514:	913d0000 	add	x0, x0, #0xf40
    40006518:	94000519 	bl	4000797c <shell_init>

	return 0;
    4000651c:	52800000 	mov	w0, #0x0                   	// #0
}
    40006520:	f9400bf3 	ldr	x19, [sp, #16]
    40006524:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40006528:	d65f03c0 	ret
		return -ENODEV;
    4000652c:	12800240 	mov	w0, #0xffffffed            	// #-19
    40006530:	17fffffc 	b	40006520 <enable_shell_uart+0x48>

0000000040006534 <write>:
{
    40006534:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40006538:	910003fd 	mov	x29, sp
    4000653c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40006540:	aa0303f6 	mov	x22, x3
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
    40006544:	f9400415 	ldr	x21, [x0, #8]
{
    40006548:	a90153f3 	stp	x19, x20, [sp, #16]
    4000654c:	aa0203f4 	mov	x20, x2
		!sh_uart->ctrl_blk->blocking_tx) {
    40006550:	f94002a0 	ldr	x0, [x21]
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
    40006554:	39408000 	ldrb	w0, [x0, #32]
{
    40006558:	f9001bf7 	str	x23, [sp, #48]
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
    4000655c:	34000160 	cbz	w0, 40006588 <write+0x54>
    40006560:	aa0103f3 	mov	x19, x1
    40006564:	8b020037 	add	x23, x1, x2
		for (size_t i = 0; i < length; i++) {
    40006568:	eb17027f 	cmp	x19, x23
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
    4000656c:	f94002a0 	ldr	x0, [x21]
		for (size_t i = 0; i < length; i++) {
    40006570:	54000361 	b.ne	400065dc <write+0xa8>  // b.any
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    40006574:	a9408402 	ldp	x2, x1, [x0, #8]
		*cnt = length;
    40006578:	f90002d4 	str	x20, [x22]
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    4000657c:	52800020 	mov	w0, #0x1                   	// #1
    40006580:	d63f0040 	blr	x2
    40006584:	14000010 	b	400065c4 <write+0x90>
	*cnt = ring_buf_put(sh_uart->tx_ringbuf, data, length);
    40006588:	f9400aa0 	ldr	x0, [x21, #16]
    4000658c:	97fff23b 	bl	40002e78 <ring_buf_put>
    40006590:	2a0003e0 	mov	w0, w0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    40006594:	f94002a1 	ldr	x1, [x21]
    40006598:	f90002c0 	str	x0, [x22]
    4000659c:	d2800020 	mov	x0, #0x1                   	// #1
    400065a0:	91006021 	add	x1, x1, #0x18
    400065a4:	97ffea7b 	bl	40000f90 <__aarch64_swp8_acq_rel>
	if (atomic_set(&sh_uart->ctrl_blk->tx_busy, 1) == 0) {
    400065a8:	b50000e0 	cbnz	x0, 400065c4 <write+0x90>
		uart_irq_tx_enable(sh_uart->ctrl_blk->dev);
    400065ac:	f94002a0 	ldr	x0, [x21]
    400065b0:	f9400000 	ldr	x0, [x0]
	if (api->irq_tx_enable != NULL) {
    400065b4:	f9400801 	ldr	x1, [x0, #16]
    400065b8:	f9401c21 	ldr	x1, [x1, #56]
    400065bc:	b4000041 	cbz	x1, 400065c4 <write+0x90>
		api->irq_tx_enable(dev);
    400065c0:	d63f0020 	blr	x1
}
    400065c4:	52800000 	mov	w0, #0x0                   	// #0
    400065c8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400065cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400065d0:	f9401bf7 	ldr	x23, [sp, #48]
    400065d4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400065d8:	d65f03c0 	ret
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
    400065dc:	38401661 	ldrb	w1, [x19], #1
    400065e0:	f9400000 	ldr	x0, [x0]
	api->poll_out(dev, out_char);
    400065e4:	f9400802 	ldr	x2, [x0, #16]
    400065e8:	f9400442 	ldr	x2, [x2, #8]
    400065ec:	d63f0040 	blr	x2
		for (size_t i = 0; i < length; i++) {
    400065f0:	17ffffde 	b	40006568 <write+0x34>

00000000400065f4 <init>:
{
    400065f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400065f8:	910003fd 	mov	x29, sp
    400065fc:	a90153f3 	stp	x19, x20, [sp, #16]
    40006600:	aa0103f3 	mov	x19, x1
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
    40006604:	f9400414 	ldr	x20, [x0, #8]
	sh_uart->ctrl_blk->dev = (const struct device *)config;
    40006608:	f9400280 	ldr	x0, [x20]
	sh_uart->ctrl_blk->handler = evt_handler;
    4000660c:	a9000801 	stp	x1, x2, [x0]
 */
static inline void ring_buf_reset(struct ring_buf *buf)
{
	buf->head = 0;
	buf->tail = 0;
	memset(&buf->misc, 0, sizeof(buf->misc));
    40006610:	d2800102 	mov	x2, #0x8                   	// #8
    40006614:	52800001 	mov	w1, #0x0                   	// #0
	sh_uart->ctrl_blk->context = context;
    40006618:	f9000803 	str	x3, [x0, #16]
	buf->head = 0;
    4000661c:	f9400a80 	ldr	x0, [x20, #16]
    40006620:	f800841f 	str	xzr, [x0], #8
	memset(&buf->misc, 0, sizeof(buf->misc));
    40006624:	940015ae 	bl	4000bcdc <memset>
	buf->head = 0;
    40006628:	f9400e80 	ldr	x0, [x20, #24]
	memset(&buf->misc, 0, sizeof(buf->misc));
    4000662c:	d2800102 	mov	x2, #0x8                   	// #8
    40006630:	52800001 	mov	w1, #0x0                   	// #0
	buf->head = 0;
    40006634:	f800841f 	str	xzr, [x0], #8
	memset(&buf->misc, 0, sizeof(buf->misc));
    40006638:	940015a9 	bl	4000bcdc <memset>
	sh_uart->ctrl_blk->tx_busy = 0;
    4000663c:	f9400280 	ldr	x0, [x20]
    40006640:	f9000c1f 	str	xzr, [x0, #24]
static inline void uart_irq_callback_user_data_set(const struct device *dev,
						   uart_irq_callback_user_data_t cb,
						   void *user_data)
{
#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	const struct uart_driver_api *api =
    40006644:	f9400a60 	ldr	x0, [x19, #16]
		(const struct uart_driver_api *)dev->api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
    40006648:	b4000100 	cbz	x0, 40006668 <init+0x74>
    4000664c:	f9404803 	ldr	x3, [x0, #144]
    40006650:	b40000c3 	cbz	x3, 40006668 <init+0x74>
		api->irq_callback_set(dev, cb, user_data);
    40006654:	90000001 	adrp	x1, 40006000 <cmd_devmem+0x14c>
    40006658:	911a3021 	add	x1, x1, #0x68c
    4000665c:	aa1403e2 	mov	x2, x20
    40006660:	aa1303e0 	mov	x0, x19
    40006664:	d63f0060 	blr	x3
	if (api->irq_rx_enable != NULL) {
    40006668:	f9400a60 	ldr	x0, [x19, #16]
    4000666c:	f9402801 	ldr	x1, [x0, #80]
    40006670:	b4000061 	cbz	x1, 4000667c <init+0x88>
		api->irq_rx_enable(dev);
    40006674:	aa1303e0 	mov	x0, x19
    40006678:	d63f0020 	blr	x1
}
    4000667c:	52800000 	mov	w0, #0x0                   	// #0
    40006680:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006684:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40006688:	d65f03c0 	ret

000000004000668c <uart_callback>:
{
    4000668c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40006690:	910003fd 	mov	x29, sp
    40006694:	a90153f3 	stp	x19, x20, [sp, #16]
    40006698:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000669c:	aa0103f5 	mov	x21, x1
    400066a0:	a90363f7 	stp	x23, x24, [sp, #48]
    400066a4:	a9046bf9 	stp	x25, x26, [sp, #64]
    400066a8:	aa0003fa 	mov	x26, x0
	if (api->irq_update == NULL) {
    400066ac:	f9400801 	ldr	x1, [x0, #16]
    400066b0:	f9404421 	ldr	x1, [x1, #136]
    400066b4:	b4000041 	cbz	x1, 400066bc <uart_callback+0x30>
	return api->irq_update(dev);
    400066b8:	d63f0020 	blr	x1
	if (api->irq_rx_ready == NULL) {
    400066bc:	f9400b40 	ldr	x0, [x26, #16]
    400066c0:	f9403401 	ldr	x1, [x0, #104]
    400066c4:	b5000501 	cbnz	x1, 40006764 <uart_callback+0xd8>
	return ((uint8_t *)data - (uint8_t *)__log_dynamic_start)/
    400066c8:	b0000357 	adrp	x23, 4006f000 <sys_work_q_stack+0xf20>
    400066cc:	912952f7 	add	x23, x23, #0xa54
    400066d0:	b0000354 	adrp	x20, 4006f000 <sys_work_q_stack+0xf20>
    400066d4:	91290294 	add	x20, x20, #0xa40
    400066d8:	cb1402f4 	sub	x20, x23, x20
			LOG_WRN("RX ring buffer full.");
    400066dc:	d0000079 	adrp	x25, 40014000 <CSWTCH.135+0x90>
    400066e0:	91293b39 	add	x25, x25, #0xa4e
    400066e4:	52800018 	mov	w24, #0x0                   	// #0
    400066e8:	d342fe94 	lsr	x20, x20, #2
    400066ec:	531a2694 	ubfiz	w20, w20, #6, #10
    400066f0:	321f0294 	orr	w20, w20, #0x2
		len = ring_buf_put_claim(sh_uart->rx_ringbuf, &data,
    400066f4:	f9400ea0 	ldr	x0, [x21, #24]
    400066f8:	910163e1 	add	x1, sp, #0x58
    400066fc:	b9401002 	ldr	w2, [x0, #16]
    40006700:	97fff1ad 	bl	40002db4 <ring_buf_put_claim>
    40006704:	2a0003f6 	mov	w22, w0
		if (len > 0) {
    40006708:	34000540 	cbz	w0, 400067b0 <uart_callback+0x124>
	if (api->fifo_read == NULL) {
    4000670c:	f9400b40 	ldr	x0, [x26, #16]
			rd_len = uart_fifo_read(dev, data, len);
    40006710:	f9402fe1 	ldr	x1, [sp, #88]
    40006714:	f9401803 	ldr	x3, [x0, #48]
    40006718:	b4000483 	cbz	x3, 400067a8 <uart_callback+0x11c>
	return api->fifo_read(dev, rx_data, size);
    4000671c:	2a1603e2 	mov	w2, w22
    40006720:	aa1a03e0 	mov	x0, x26
    40006724:	d63f0060 	blr	x3
    40006728:	2a0003f3 	mov	w19, w0
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
    4000672c:	f9400ea0 	ldr	x0, [x21, #24]
				new_data = true;
    40006730:	7100027f 	cmp	w19, #0x0
    40006734:	1a9f0718 	csinc	w24, w24, wzr, eq  // eq = none
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
    40006738:	2a1303e1 	mov	w1, w19
    4000673c:	97fff1b5 	bl	40002e10 <ring_buf_put_finish>
	} while (rd_len && (rd_len == len));
    40006740:	7100027f 	cmp	w19, #0x0
    40006744:	7a5312c0 	ccmp	w22, w19, #0x0, ne  // ne = any
    40006748:	54fffd60 	b.eq	400066f4 <uart_callback+0x68>  // b.none
	if (new_data) {
    4000674c:	34000138 	cbz	w24, 40006770 <uart_callback+0xe4>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
    40006750:	f94002a0 	ldr	x0, [x21]
    40006754:	a9408402 	ldp	x2, x1, [x0, #8]
    40006758:	52800000 	mov	w0, #0x0                   	// #0
    4000675c:	d63f0040 	blr	x2
}
    40006760:	14000004 	b	40006770 <uart_callback+0xe4>
	return api->irq_rx_ready(dev);
    40006764:	aa1a03e0 	mov	x0, x26
    40006768:	d63f0020 	blr	x1
	if (uart_irq_rx_ready(dev)) {
    4000676c:	35fffae0 	cbnz	w0, 400066c8 <uart_callback+0x3c>
	if (api->irq_tx_ready == NULL) {
    40006770:	f9400b40 	ldr	x0, [x26, #16]
    40006774:	f9402401 	ldr	x1, [x0, #72]
    40006778:	b50003e1 	cbnz	x1, 400067f4 <uart_callback+0x168>
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (uint8_t **)&data,
    4000677c:	f9400aa0 	ldr	x0, [x21, #16]
    40006780:	910163e1 	add	x1, sp, #0x58
    40006784:	b9401002 	ldr	w2, [x0, #16]
    40006788:	97fff1dc 	bl	40002ef8 <ring_buf_get_claim>
    4000678c:	2a0003e2 	mov	w2, w0
	if (len) {
    40006790:	35000440 	cbnz	w0, 40006818 <uart_callback+0x18c>
		uart_irq_tx_disable(dev);
    40006794:	aa1a03e0 	mov	x0, x26
    40006798:	97ffff1e 	bl	40006410 <uart_irq_tx_disable>
		sh_uart->ctrl_blk->tx_busy = 0;
    4000679c:	f94002a0 	ldr	x0, [x21]
    400067a0:	f9000c1f 	str	xzr, [x0, #24]
    400067a4:	14000026 	b	4000683c <uart_callback+0x1b0>
		return -ENOSYS;
    400067a8:	12800af3 	mov	w19, #0xffffffa8            	// #-88
    400067ac:	17ffffe0 	b	4000672c <uart_callback+0xa0>
			LOG_WRN("RX ring buffer full.");
    400067b0:	b94002e0 	ldr	w0, [x23]
    400067b4:	721f041f 	tst	w0, #0x6
    400067b8:	54000080 	b.eq	400067c8 <uart_callback+0x13c>  // b.none
    400067bc:	2a1403e1 	mov	w1, w20
    400067c0:	aa1903e0 	mov	x0, x25
    400067c4:	97fff517 	bl	40003c20 <log_0>
	if (api->fifo_read == NULL) {
    400067c8:	f9400b40 	ldr	x0, [x26, #16]
    400067cc:	f9401803 	ldr	x3, [x0, #48]
    400067d0:	b40000e3 	cbz	x3, 400067ec <uart_callback+0x160>
	return api->fifo_read(dev, rx_data, size);
    400067d4:	91015fe1 	add	x1, sp, #0x57
    400067d8:	aa1a03e0 	mov	x0, x26
    400067dc:	52800022 	mov	w2, #0x1                   	// #1
    400067e0:	d63f0060 	blr	x3
    400067e4:	2a0003f3 	mov	w19, w0
    400067e8:	17ffffd6 	b	40006740 <uart_callback+0xb4>
		return -ENOSYS;
    400067ec:	12800af3 	mov	w19, #0xffffffa8            	// #-88
    400067f0:	17ffffd4 	b	40006740 <uart_callback+0xb4>
	return api->irq_tx_ready(dev);
    400067f4:	aa1a03e0 	mov	x0, x26
    400067f8:	d63f0020 	blr	x1
	if (uart_irq_tx_ready(dev)) {
    400067fc:	35fffc00 	cbnz	w0, 4000677c <uart_callback+0xf0>
}
    40006800:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006804:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006808:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000680c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40006810:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40006814:	d65f03c0 	ret
	if (api->fifo_fill == NULL) {
    40006818:	f9400b40 	ldr	x0, [x26, #16]
		len = uart_fifo_fill(dev, data, len);
    4000681c:	f9402fe1 	ldr	x1, [sp, #88]
    40006820:	f9401403 	ldr	x3, [x0, #40]
    40006824:	b4000163 	cbz	x3, 40006850 <uart_callback+0x1c4>
	return api->fifo_fill(dev, tx_data, size);
    40006828:	aa1a03e0 	mov	x0, x26
    4000682c:	d63f0060 	blr	x3
    40006830:	2a0003e1 	mov	w1, w0
		err = ring_buf_get_finish(sh_uart->tx_ringbuf, len);
    40006834:	f9400aa0 	ldr	x0, [x21, #16]
    40006838:	97fff1d7 	bl	40002f94 <ring_buf_get_finish>
	sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
    4000683c:	f94002a0 	ldr	x0, [x21]
    40006840:	a9408402 	ldp	x2, x1, [x0, #8]
    40006844:	52800020 	mov	w0, #0x1                   	// #1
    40006848:	d63f0040 	blr	x2
}
    4000684c:	17ffffed 	b	40006800 <uart_callback+0x174>
		return -ENOSYS;
    40006850:	12800ae1 	mov	w1, #0xffffffa8            	// #-88
    40006854:	17fffff8 	b	40006834 <uart_callback+0x1a8>

0000000040006858 <atomic_or>:
 * @param value Value to OR.
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
    40006858:	aa0003e2 	mov	x2, x0
    4000685c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40006860:	aa0103e0 	mov	x0, x1
    40006864:	910003fd 	mov	x29, sp
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    40006868:	aa0203e1 	mov	x1, x2
    4000686c:	97ffe9ed 	bl	40001020 <__aarch64_ldset8_acq_rel>
}
    40006870:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40006874:	d65f03c0 	ret

0000000040006878 <atomic_and>:
 * @param value Value to AND.
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
    40006878:	aa0103e2 	mov	x2, x1
    4000687c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    40006880:	aa0003e1 	mov	x1, x0
{
    40006884:	910003fd 	mov	x29, sp
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    40006888:	aa2203e0 	mvn	x0, x2
    4000688c:	97ffe9d9 	bl	40000ff0 <__aarch64_ldclr8_acq_rel>
}
    40006890:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40006894:	d65f03c0 	ret

0000000040006898 <shell_signal_handle>:
typedef void (*shell_signal_handler_t)(const struct shell *shell);

static void shell_signal_handle(const struct shell *shell,
				enum shell_signal sig_idx,
				shell_signal_handler_t handler)
{
    40006898:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    4000689c:	2a0103e1 	mov	w1, w1
{
    400068a0:	910003fd 	mov	x29, sp
    400068a4:	a90153f3 	stp	x19, x20, [sp, #16]
    400068a8:	aa0003f3 	mov	x19, x0
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    400068ac:	d2800300 	mov	x0, #0x18                  	// #24
    400068b0:	9b007c21 	mul	x1, x1, x0
    400068b4:	f9400a74 	ldr	x20, [x19, #16]
    400068b8:	910aa021 	add	x1, x1, #0x2a8
{
    400068bc:	f90013f5 	str	x21, [sp, #32]
    400068c0:	aa0203f5 	mov	x21, x2
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
    400068c4:	8b010294 	add	x20, x20, x1
		arch_syscall_invoke3(*(uintptr_t *)&sig, *(uintptr_t *)&signaled, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_CHECK);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_check(sig, signaled, result);
    400068c8:	aa1403e0 	mov	x0, x20
    400068cc:	9100f3e2 	add	x2, sp, #0x3c
    400068d0:	9100e3e1 	add	x1, sp, #0x38
    400068d4:	94002977 	bl	40010eb0 <z_impl_k_poll_signal_check>
	int set;
	int res;

	k_poll_signal_check(signal, &set, &res);

	if (set) {
    400068d8:	b9403be0 	ldr	w0, [sp, #56]
    400068dc:	340000a0 	cbz	w0, 400068f0 <shell_signal_handle+0x58>
	z_impl_k_poll_signal_reset(sig);
    400068e0:	aa1403e0 	mov	x0, x20
    400068e4:	94002971 	bl	40010ea8 <z_impl_k_poll_signal_reset>
		k_poll_signal_reset(signal);
		handler(shell);
    400068e8:	aa1303e0 	mov	x0, x19
    400068ec:	d63f02a0 	blr	x21
	}
}
    400068f0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400068f4:	f94013f5 	ldr	x21, [sp, #32]
    400068f8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400068fc:	d65f03c0 	ret

0000000040006900 <z_shell_strlen>:
void z_shell_multiline_data_calc(struct shell_multiline_cons *cons,
				 uint16_t buff_pos, uint16_t buff_len);

static inline uint16_t z_shell_strlen(const char *str)
{
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40006900:	b40000e0 	cbz	x0, 4000691c <z_shell_strlen+0x1c>
{
    40006904:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40006908:	910003fd 	mov	x29, sp
	return str == NULL ? 0U : (uint16_t)strlen(str);
    4000690c:	940014a9 	bl	4000bbb0 <strlen>
    40006910:	12003c00 	and	w0, w0, #0xffff
}
    40006914:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40006918:	d65f03c0 	ret
	return str == NULL ? 0U : (uint16_t)strlen(str);
    4000691c:	52800000 	mov	w0, #0x0                   	// #0
}
    40006920:	d65f03c0 	ret

0000000040006924 <z_shell_raw_fprintf>:
extern "C" {
#endif

static inline void z_shell_raw_fprintf(const struct shell_fprintf *const ctx,
				       const char *fmt, ...)
{
    40006924:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40006928:	910003fd 	mov	x29, sp
    4000692c:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_list args;

	va_start(args, fmt);
    40006930:	910403e2 	add	x2, sp, #0x100
    40006934:	a9030be2 	stp	x2, x2, [sp, #48]
    40006938:	910343e2 	add	x2, sp, #0xd0
    4000693c:	f90023e2 	str	x2, [sp, #64]
    40006940:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    40006944:	b9004be2 	str	w2, [sp, #72]
    40006948:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    4000694c:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40006950:	a9430fe2 	ldp	x2, x3, [sp, #48]
    40006954:	a9010fe2 	stp	x2, x3, [sp, #16]
    40006958:	a9440fe2 	ldp	x2, x3, [sp, #64]
    4000695c:	a9020fe2 	stp	x2, x3, [sp, #32]
    40006960:	910043e2 	add	x2, sp, #0x10
{
    40006964:	3d8017e0 	str	q0, [sp, #80]
    40006968:	3d801be1 	str	q1, [sp, #96]
    4000696c:	3d801fe2 	str	q2, [sp, #112]
    40006970:	3d8023e3 	str	q3, [sp, #128]
    40006974:	3d8027e4 	str	q4, [sp, #144]
    40006978:	3d802be5 	str	q5, [sp, #160]
    4000697c:	3d802fe6 	str	q6, [sp, #176]
    40006980:	3d8033e7 	str	q7, [sp, #192]
    40006984:	a90e17e4 	stp	x4, x5, [sp, #224]
    40006988:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    4000698c:	94000545 	bl	40007ea0 <z_shell_fprintf_fmt>
	va_end(args);
}
    40006990:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40006994:	d65f03c0 	ret

0000000040006998 <shell_internal_help_print>:
{
    40006998:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000699c:	910003fd 	mov	x29, sp
	z_shell_help_cmd_print(shell, &shell->ctx->active_cmd);
    400069a0:	f9400801 	ldr	x1, [x0, #16]
{
    400069a4:	f9000bf3 	str	x19, [sp, #16]
    400069a8:	aa0003f3 	mov	x19, x0
	z_shell_help_cmd_print(shell, &shell->ctx->active_cmd);
    400069ac:	91004021 	add	x1, x1, #0x10
    400069b0:	94000c1c 	bl	40009a20 <z_shell_help_cmd_print>
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
    400069b4:	aa1303e0 	mov	x0, x19
    400069b8:	d0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400069bc:	912a4042 	add	x2, x2, #0xa90
    400069c0:	f9400a61 	ldr	x1, [x19, #16]
}
    400069c4:	f9400bf3 	ldr	x19, [sp, #16]
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
    400069c8:	91004021 	add	x1, x1, #0x10
}
    400069cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_shell_help_subcmd_print(shell, &shell->ctx->active_cmd,
    400069d0:	14000bc6 	b	400098e8 <z_shell_help_subcmd_print>

00000000400069d4 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
    400069d4:	14002166 	b	4000ef6c <z_impl_k_mutex_lock>

00000000400069d8 <transport_evt_handler>:
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
    400069d8:	f9400821 	ldr	x1, [x1, #16]
    400069dc:	7100001f 	cmp	w0, #0x0
    400069e0:	910aa022 	add	x2, x1, #0x2a8
    400069e4:	910bc021 	add	x1, x1, #0x2f0
    400069e8:	9a821020 	csel	x0, x1, x2, ne  // ne = any
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sig, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(sig, result);
    400069ec:	52800001 	mov	w1, #0x0                   	// #0
    400069f0:	14002935 	b	40010ec4 <z_impl_k_poll_signal_raise>

00000000400069f4 <kill_handler>:

static void kill_handler(const struct shell *shell)
{
    400069f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400069f8:	910003fd 	mov	x29, sp
    400069fc:	a90153f3 	stp	x19, x20, [sp, #16]
    40006a00:	aa0003f3 	mov	x19, x0
	return ret;
}

static inline bool z_flag_processing_get(const struct shell *sh)
{
	return sh->ctx->ctx.flags.processing == 1;
    40006a04:	f9400800 	ldr	x0, [x0, #16]
    40006a08:	b942a000 	ldr	w0, [x0, #672]
	if (z_flag_processing_get(shell)) {
    40006a0c:	37000320 	tbnz	w0, #0, 40006a70 <kill_handler+0x7c>
		z_shell_log_backend_disable(shell->log_backend);
    40006a10:	f9401e60 	ldr	x0, [x19, #56]
    40006a14:	94000acf 	bl	40009550 <z_shell_log_backend_disable>
	err = shell->iface->api->uninit(shell->iface);
    40006a18:	f9400660 	ldr	x0, [x19, #8]
    40006a1c:	f9400001 	ldr	x1, [x0]
    40006a20:	f9400421 	ldr	x1, [x1, #8]
    40006a24:	d63f0020 	blr	x1
    40006a28:	2a0003f4 	mov	w20, w0
	if (err != 0) {
    40006a2c:	350000a0 	cbnz	w0, 40006a40 <kill_handler+0x4c>
	z_shell_history_purge(shell->history);
    40006a30:	f9400e60 	ldr	x0, [x19, #24]
    40006a34:	94000dc5 	bl	4000a148 <z_shell_history_purge>
	shell->ctx->state = state;
    40006a38:	f9400a60 	ldr	x0, [x19, #16]
    40006a3c:	b900081f 	str	wzr, [x0, #8]
	int err = instance_uninit(shell);

	if (shell->ctx->uninit_cb) {
    40006a40:	f9400a60 	ldr	x0, [x19, #16]
    40006a44:	f9403002 	ldr	x2, [x0, #96]
    40006a48:	b4000082 	cbz	x2, 40006a58 <kill_handler+0x64>
		shell->ctx->uninit_cb(shell, err);
    40006a4c:	2a1403e1 	mov	w1, w20
    40006a50:	aa1303e0 	mov	x0, x19
    40006a54:	d63f0040 	blr	x2
	}

	shell->ctx->tid = NULL;
    40006a58:	f9400a60 	ldr	x0, [x19, #16]
    40006a5c:	f901e41f 	str	xzr, [x0, #968]
	return z_impl_z_current_get();
    40006a60:	94002500 	bl	4000fe60 <z_impl_z_current_get>
	k_thread_abort(k_current_get());
}
    40006a64:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006a68:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_impl_k_thread_abort(thread);
    40006a6c:	14002549 	b	4000ff90 <z_impl_k_thread_abort>
		return -EBUSY;
    40006a70:	128001f4 	mov	w20, #0xfffffff0            	// #-16
    40006a74:	17fffff3 	b	40006a40 <kill_handler+0x4c>

0000000040006a78 <z_cursor_next_line_move.isra.0>:
/* Function forcing new line - cannot be replaced with function
 * cursor_down_move.
 */
static inline void z_cursor_next_line_move(const struct shell *sh)
{
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
    40006a78:	d0000061 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40006a7c:	911be021 	add	x1, x1, #0x6f8
    40006a80:	17ffffa9 	b	40006924 <z_shell_raw_fprintf>

0000000040006a84 <z_flag_history_exit_set.isra.0>:
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, history_exit, val, ret);
    40006a84:	910a8000 	add	x0, x0, #0x2a0
    40006a88:	72001c3f 	tst	w1, #0xff
    40006a8c:	54000060 	b.eq	40006a98 <z_flag_history_exit_set.isra.0+0x14>  // b.none
    40006a90:	d2800081 	mov	x1, #0x4                   	// #4
    40006a94:	17ffff71 	b	40006858 <atomic_or>
    40006a98:	12800081 	mov	w1, #0xfffffffb            	// #-5
    40006a9c:	17ffff77 	b	40006878 <atomic_and>

0000000040006aa0 <history_handle>:
{
    40006aa0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40006aa4:	910003fd 	mov	x29, sp
    40006aa8:	a90153f3 	stp	x19, x20, [sp, #16]
    40006aac:	aa0003f3 	mov	x19, x0
    40006ab0:	12001c34 	and	w20, w1, #0xff
	return sh->ctx->ctx.flags.history_exit == 1;
    40006ab4:	f9400800 	ldr	x0, [x0, #16]
    40006ab8:	b942a001 	ldr	w1, [x0, #672]
	if (z_flag_history_exit_get(shell)) {
    40006abc:	361000a1 	tbz	w1, #2, 40006ad0 <history_handle+0x30>
		z_flag_history_exit_set(shell, false);
    40006ac0:	52800001 	mov	w1, #0x0                   	// #0
    40006ac4:	97fffff0 	bl	40006a84 <z_flag_history_exit_set.isra.0>
		z_shell_history_mode_exit(shell->history);
    40006ac8:	f9400e60 	ldr	x0, [x19, #24]
    40006acc:	94000d72 	bl	4000a094 <z_shell_history_mode_exit>
 *
 * @return True if in browsing mode.
 */
static inline bool z_shell_history_active(struct shell_history *history)
{
	return (history->current) ? true : false;
    40006ad0:	f9400e60 	ldr	x0, [x19, #24]
	if (!z_shell_history_active(shell->history)) {
    40006ad4:	f9400c00 	ldr	x0, [x0, #24]
    40006ad8:	b5000160 	cbnz	x0, 40006b04 <history_handle+0x64>
		if (up) {
    40006adc:	34000554 	cbz	w20, 40006b84 <history_handle+0xe4>
			uint16_t cmd_len = z_shell_strlen(shell->ctx->cmd_buff);
    40006ae0:	f9400a60 	ldr	x0, [x19, #16]
    40006ae4:	9101d800 	add	x0, x0, #0x76
    40006ae8:	97ffff86 	bl	40006900 <z_shell_strlen>
			if (cmd_len) {
    40006aec:	72003c1f 	tst	w0, #0xffff
    40006af0:	f9400a60 	ldr	x0, [x19, #16]
    40006af4:	540004e0 	b.eq	40006b90 <history_handle+0xf0>  // b.none
				strcpy(shell->ctx->temp_buff,
    40006af8:	9101d801 	add	x1, x0, #0x76
    40006afc:	9105d800 	add	x0, x0, #0x176
    40006b00:	94001400 	bl	4000bb00 <strcpy>
	history_mode = z_shell_history_get(shell->history, up,
    40006b04:	a9410262 	ldp	x2, x0, [x19, #16]
    40006b08:	9100bbe3 	add	x3, sp, #0x2e
    40006b0c:	2a1403e1 	mov	w1, w20
    40006b10:	9101d842 	add	x2, x2, #0x76
    40006b14:	94000d62 	bl	4000a09c <z_shell_history_get>
	if (!history_mode) {
    40006b18:	72001c1f 	tst	w0, #0xff
    40006b1c:	54000121 	b.ne	40006b40 <history_handle+0xa0>  // b.any
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
    40006b20:	f9400a60 	ldr	x0, [x19, #16]
    40006b24:	9105d801 	add	x1, x0, #0x176
    40006b28:	9101d800 	add	x0, x0, #0x76
    40006b2c:	940013f5 	bl	4000bb00 <strcpy>
		len = z_shell_strlen(shell->ctx->cmd_buff);
    40006b30:	f9400a60 	ldr	x0, [x19, #16]
    40006b34:	9101d800 	add	x0, x0, #0x76
    40006b38:	97ffff72 	bl	40006900 <z_shell_strlen>
    40006b3c:	79005fe0 	strh	w0, [sp, #46]
	z_shell_op_cursor_home_move(shell);
    40006b40:	aa1303e0 	mov	x0, x19
    40006b44:	940007de 	bl	40008abc <z_shell_op_cursor_home_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40006b48:	f9400a60 	ldr	x0, [x19, #16]
    40006b4c:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
    40006b50:	362800a0 	tbz	w0, #5, 40006b64 <history_handle+0xc4>
    40006b54:	f9401660 	ldr	x0, [x19, #40]
    40006b58:	b0000061 	adrp	x1, 40013000 <shell_cmd_kernel>
    40006b5c:	91014021 	add	x1, x1, #0x50
    40006b60:	97ffff71 	bl	40006924 <z_shell_raw_fprintf>
	z_shell_print_cmd(shell);
    40006b64:	aa1303e0 	mov	x0, x19
    40006b68:	9400080a 	bl	40008b90 <z_shell_print_cmd>
	shell->ctx->cmd_buff_pos = len;
    40006b6c:	f9400a60 	ldr	x0, [x19, #16]
    40006b70:	79405fe1 	ldrh	w1, [sp, #46]
	shell->ctx->cmd_buff_len = len;
    40006b74:	7900e001 	strh	w1, [x0, #112]
	shell->ctx->cmd_buff_pos = len;
    40006b78:	7900e401 	strh	w1, [x0, #114]
	z_shell_op_cond_next_line(shell);
    40006b7c:	aa1303e0 	mov	x0, x19
    40006b80:	9400073f 	bl	4000887c <z_shell_op_cond_next_line>
}
    40006b84:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006b88:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40006b8c:	d65f03c0 	ret
				shell->ctx->temp_buff[0] = '\0';
    40006b90:	3905d81f 	strb	wzr, [x0, #374]
    40006b94:	17ffffdc 	b	40006b04 <history_handle+0x64>

0000000040006b98 <z_flag_insert_mode_set.isra.0>:
static inline bool z_flag_insert_mode_set(const struct shell *sh, bool val)
    40006b98:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
    40006b9c:	910a6000 	add	x0, x0, #0x298
    40006ba0:	72001c3f 	tst	w1, #0xff
static inline bool z_flag_insert_mode_set(const struct shell *sh, bool val)
    40006ba4:	910003fd 	mov	x29, sp
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
    40006ba8:	540000c0 	b.eq	40006bc0 <z_flag_insert_mode_set.isra.0+0x28>  // b.none
    40006bac:	d2800021 	mov	x1, #0x1                   	// #1
    40006bb0:	97ffff2a 	bl	40006858 <atomic_or>
}
    40006bb4:	12000000 	and	w0, w0, #0x1
    40006bb8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40006bbc:	d65f03c0 	ret
	Z_SHELL_SET_FLAG_ATOMIC(sh, cfg, insert_mode, val, ret);
    40006bc0:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
    40006bc4:	97ffff2d 	bl	40006878 <atomic_and>
    40006bc8:	17fffffb 	b	40006bb4 <z_flag_insert_mode_set.isra.0+0x1c>

0000000040006bcc <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
    40006bcc:	1400213d 	b	4000f0c0 <z_impl_k_mutex_unlock>

0000000040006bd0 <shell_log_process>:
{
    40006bd0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40006bd4:	910003fd 	mov	x29, sp
    40006bd8:	a90153f3 	stp	x19, x20, [sp, #16]
    40006bdc:	aa0003f3 	mov	x19, x0
    40006be0:	f90013f5 	str	x21, [sp, #32]
	int signaled = 0;
    40006be4:	b9003bff 	str	wzr, [sp, #56]
			z_shell_cmd_line_erase(shell);
    40006be8:	aa1303e0 	mov	x0, x19
    40006bec:	940007d1 	bl	40008b30 <z_shell_cmd_line_erase>
			processed = z_shell_log_backend_process(
    40006bf0:	f9401e60 	ldr	x0, [x19, #56]
    40006bf4:	94000a63 	bl	40009580 <z_shell_log_backend_process>
    40006bf8:	12001c14 	and	w20, w0, #0xff
		z_shell_print_prompt_and_cmd(shell);
    40006bfc:	aa1303e0 	mov	x0, x19
		struct k_poll_signal *signal =
    40006c00:	f9400a75 	ldr	x21, [x19, #16]
		z_shell_print_prompt_and_cmd(shell);
    40006c04:	940009ab 	bl	400092b0 <z_shell_print_prompt_and_cmd>
		if (shell->ctx->cmd_buff_len) {
    40006c08:	f9400a60 	ldr	x0, [x19, #16]
		struct k_poll_signal *signal =
    40006c0c:	910aa2b5 	add	x21, x21, #0x2a8
		if (shell->ctx->cmd_buff_len) {
    40006c10:	7940e000 	ldrh	w0, [x0, #112]
    40006c14:	34000060 	cbz	w0, 40006c20 <shell_log_process+0x50>
	return z_impl_k_sleep(timeout);
    40006c18:	d2800040 	mov	x0, #0x2                   	// #2
    40006c1c:	94002480 	bl	4000fe1c <z_impl_k_sleep>
	z_impl_k_poll_signal_check(sig, signaled, result);
    40006c20:	9100f3e2 	add	x2, sp, #0x3c
    40006c24:	9100e3e1 	add	x1, sp, #0x38
    40006c28:	aa1503e0 	mov	x0, x21
    40006c2c:	940028a1 	bl	40010eb0 <z_impl_k_poll_signal_check>
	} while (processed && !signaled);
    40006c30:	34000074 	cbz	w20, 40006c3c <shell_log_process+0x6c>
    40006c34:	b9403be0 	ldr	w0, [sp, #56]
    40006c38:	34fffd80 	cbz	w0, 40006be8 <shell_log_process+0x18>
}
    40006c3c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006c40:	f94013f5 	ldr	x21, [sp, #32]
    40006c44:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40006c48:	d65f03c0 	ret

0000000040006c4c <execute>:
{
    40006c4c:	a9ab7bfd 	stp	x29, x30, [sp, #-336]!
    40006c50:	910003fd 	mov	x29, sp
	char *cmd_buf = shell->ctx->cmd_buff;
    40006c54:	f9400801 	ldr	x1, [x0, #16]
{
    40006c58:	a90153f3 	stp	x19, x20, [sp, #16]
	char *cmd_buf = shell->ctx->cmd_buff;
    40006c5c:	9101d821 	add	x1, x1, #0x76
{
    40006c60:	a9025bf5 	stp	x21, x22, [sp, #32]
    40006c64:	a90363f7 	stp	x23, x24, [sp, #48]
    40006c68:	aa0003f7 	mov	x23, x0
    40006c6c:	a9046bf9 	stp	x25, x26, [sp, #64]
    40006c70:	a90573fb 	stp	x27, x28, [sp, #80]
	char *cmd_buf = shell->ctx->cmd_buff;
    40006c74:	f9003be1 	str	x1, [sp, #112]
	size_t argc = 0, args_left = SIZE_MAX;
    40006c78:	a908ffff 	stp	xzr, xzr, [sp, #136]
	z_shell_op_cursor_end_move(shell);
    40006c7c:	94000794 	bl	40008acc <z_shell_op_cursor_end_move>
	if (!z_shell_cursor_in_empty_line(shell)) {
    40006c80:	aa1703e0 	mov	x0, x23
    40006c84:	940006e8 	bl	40008824 <z_shell_cursor_in_empty_line>
    40006c88:	72001c1f 	tst	w0, #0xff
    40006c8c:	54000061 	b.ne	40006c98 <execute+0x4c>  // b.any
		z_cursor_next_line_move(shell);
    40006c90:	f94016e0 	ldr	x0, [x23, #40]
    40006c94:	97ffff79 	bl	40006a78 <z_cursor_next_line_move.isra.0>
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
    40006c98:	f9400ae0 	ldr	x0, [x23, #16]
    40006c9c:	d2800502 	mov	x2, #0x28                  	// #40
    40006ca0:	52800001 	mov	w1, #0x0                   	// #0
		z_shell_wildcard_prepare(shell);
    40006ca4:	9103a3f4 	add	x20, sp, #0xe8
	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
    40006ca8:	91004000 	add	x0, x0, #0x10
    40006cac:	9400140c 	bl	4000bcdc <memset>
		z_shell_cmd_trim(shell);
    40006cb0:	aa1703e0 	mov	x0, x23
    40006cb4:	9400064b 	bl	400085e0 <z_shell_cmd_trim>
	z_shell_history_put(shell->history, line, length);
    40006cb8:	a94102e1 	ldp	x1, x0, [x23, #16]
				z_shell_fprintf(shell, SHELL_ERROR,
    40006cbc:	d000007c 	adrp	x28, 40014000 <CSWTCH.135+0x90>
    40006cc0:	91375f9c 	add	x28, x28, #0xdd7
    40006cc4:	aa1403f9 	mov	x25, x20
		help_entry.help = NULL;
    40006cc8:	d2800015 	mov	x21, #0x0                   	// #0
	size_t argc = 0, args_left = SIZE_MAX;
    40006ccc:	92800013 	mov	x19, #0xffffffffffffffff    	// #-1
	size_t cmd_with_handler_lvl = 0;
    40006cd0:	d2800016 	mov	x22, #0x0                   	// #0
		z_shell_wildcard_prepare(shell);
    40006cd4:	52800018 	mov	w24, #0x0                   	// #0
    40006cd8:	d280001a 	mov	x26, #0x0                   	// #0
    40006cdc:	d280001b 	mov	x27, #0x0                   	// #0
	z_shell_history_put(shell->history, line, length);
    40006ce0:	7940e022 	ldrh	w2, [x1, #112]
    40006ce4:	9101d821 	add	x1, x1, #0x76
    40006ce8:	94000d27 	bl	4000a184 <z_shell_history_put>
		z_shell_wildcard_prepare(shell);
    40006cec:	aa1703e0 	mov	x0, x23
    40006cf0:	94000d9c 	bl	4000a360 <z_shell_wildcard_prepare>
				z_shell_fprintf(shell, SHELL_ERROR,
    40006cf4:	d0000060 	adrp	x0, 40014000 <CSWTCH.135+0x90>
    40006cf8:	912bfc00 	add	x0, x0, #0xaff
		z_shell_wildcard_prepare(shell);
    40006cfc:	b9006fff 	str	wzr, [sp, #108]
				z_shell_fprintf(shell, SHELL_ERROR,
    40006d00:	f9003fe0 	str	x0, [sp, #120]
	while ((argc != 1) && (cmd_lvl < CONFIG_SHELL_ARGC_MAX)
    40006d04:	a94887e0 	ldp	x0, x1, [sp, #136]
    40006d08:	f100043f 	cmp	x1, #0x1
    40006d0c:	54001720 	b.eq	40006ff0 <execute+0x3a4>  // b.none
    40006d10:	f1002c1f 	cmp	x0, #0xb
    40006d14:	54001349 	b.ls	40006f7c <execute+0x330>  // b.plast
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
    40006d18:	f9404be0 	ldr	x0, [sp, #144]
    40006d1c:	f100081f 	cmp	x0, #0x2
    40006d20:	54001301 	b.ne	40006f80 <execute+0x334>  // b.any
		z_shell_fprintf(shell, SHELL_ERROR, "%s\n",
    40006d24:	aa1703e0 	mov	x0, x23
    40006d28:	d0000063 	adrp	x3, 40014000 <CSWTCH.135+0x90>
    40006d2c:	912c4c63 	add	x3, x3, #0xb13
    40006d30:	d0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40006d34:	91208c42 	add	x2, x2, #0x823
    40006d38:	52800021 	mov	w1, #0x1                   	// #1
    40006d3c:	9400082f 	bl	40008df8 <z_shell_fprintf>
		return -ENOEXEC;
    40006d40:	1400000b 	b	40006d6c <execute+0x120>
		quote = z_shell_make_argv(&argc, argvp, cmd_buf, 2);
    40006d44:	f9403be2 	ldr	x2, [sp, #112]
    40006d48:	aa1403e1 	mov	x1, x20
    40006d4c:	52800043 	mov	w3, #0x2                   	// #2
    40006d50:	910243e0 	add	x0, sp, #0x90
    40006d54:	940004b5 	bl	40008028 <z_shell_make_argv>
    40006d58:	12001c03 	and	w3, w0, #0xff
		if (argc == 0) {
    40006d5c:	f9404be1 	ldr	x1, [sp, #144]
		cmd_buf = (char *)argvp[1];
    40006d60:	f9400680 	ldr	x0, [x20, #8]
    40006d64:	f9003be0 	str	x0, [sp, #112]
		if (argc == 0) {
    40006d68:	b5000141 	cbnz	x1, 40006d90 <execute+0x144>
			return -ENOEXEC;
    40006d6c:	128000f3 	mov	w19, #0xfffffff8            	// #-8
}
    40006d70:	2a1303e0 	mov	w0, w19
    40006d74:	a94153f3 	ldp	x19, x20, [sp, #16]
    40006d78:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40006d7c:	a94363f7 	ldp	x23, x24, [sp, #48]
    40006d80:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40006d84:	a94573fb 	ldp	x27, x28, [sp, #80]
    40006d88:	a8d57bfd 	ldp	x29, x30, [sp], #336
    40006d8c:	d65f03c0 	ret
		} else if ((argc == 1) && (quote != 0)) {
    40006d90:	f100043f 	cmp	x1, #0x1
    40006d94:	540000e1 	b.ne	40006db0 <execute+0x164>  // b.any
    40006d98:	340000c3 	cbz	w3, 40006db0 <execute+0x164>
			z_shell_fprintf(shell, SHELL_ERROR,
    40006d9c:	aa1703e0 	mov	x0, x23
    40006da0:	d0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40006da4:	912a7842 	add	x2, x2, #0xa9e
    40006da8:	94000814 	bl	40008df8 <z_shell_fprintf>
    40006dac:	17fffff0 	b	40006d6c <execute+0x120>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
    40006db0:	f94047e0 	ldr	x0, [sp, #136]
    40006db4:	b4000520 	cbz	x0, 40006e58 <execute+0x20c>
		    z_shell_help_request(argvp[0])) {
    40006db8:	f9400280 	ldr	x0, [x20]
    40006dbc:	94000b39 	bl	40009aa0 <z_shell_help_request>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
    40006dc0:	72001c1f 	tst	w0, #0xff
    40006dc4:	540002a0 	b.eq	40006e18 <execute+0x1cc>  // b.none
			if (help_entry.help) {
    40006dc8:	b40001d5 	cbz	x21, 40006e00 <execute+0x1b4>
				shell->ctx->active_cmd = help_entry;
    40006dcc:	f9400ae1 	ldr	x1, [x23, #16]
    40006dd0:	f90067f5 	str	x21, [sp, #200]
    40006dd4:	91004020 	add	x0, x1, #0x10
    40006dd8:	a94c0fe2 	ldp	x2, x3, [sp, #192]
    40006ddc:	a9010c22 	stp	x2, x3, [x1, #16]
    40006de0:	a94d0fe2 	ldp	x2, x3, [sp, #208]
    40006de4:	a9020c22 	stp	x2, x3, [x1, #32]
    40006de8:	f94073e1 	ldr	x1, [sp, #224]
    40006dec:	f9001001 	str	x1, [x0, #32]
			shell_internal_help_print(shell);
    40006df0:	aa1703e0 	mov	x0, x23
			return SHELL_CMD_HELP_PRINTED;
    40006df4:	52800033 	mov	w19, #0x1                   	// #1
			shell_internal_help_print(shell);
    40006df8:	97fffee8 	bl	40006998 <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
    40006dfc:	17ffffdd 	b	40006d70 <execute+0x124>
			z_shell_fprintf(shell, SHELL_ERROR,
    40006e00:	d0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40006e04:	912ac842 	add	x2, x2, #0xab2
		z_shell_fprintf(shell, SHELL_ERROR,
    40006e08:	aa1703e0 	mov	x0, x23
    40006e0c:	52800021 	mov	w1, #0x1                   	// #1
    40006e10:	940007fa 	bl	40008df8 <z_shell_fprintf>
		return false;
    40006e14:	17ffffd6 	b	40006d6c <execute+0x120>
		if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {
    40006e18:	f94047e0 	ldr	x0, [sp, #136]
    40006e1c:	b40001e0 	cbz	x0, 40006e58 <execute+0x20c>
			status = z_shell_wildcard_process(shell, entry,
    40006e20:	f9400282 	ldr	x2, [x20]
    40006e24:	aa1a03e1 	mov	x1, x26
    40006e28:	aa1703e0 	mov	x0, x23
    40006e2c:	94000d6b 	bl	4000a3d8 <z_shell_wildcard_process>
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
    40006e30:	7100081f 	cmp	w0, #0x2
    40006e34:	54000de0 	b.eq	40006ff0 <execute+0x3a4>  // b.none
			if (status != SHELL_WILDCARD_NOT_FOUND) {
    40006e38:	71000c1f 	cmp	w0, #0x3
    40006e3c:	540000e0 	b.eq	40006e58 <execute+0x20c>  // b.none
				++cmd_lvl;
    40006e40:	f94047e0 	ldr	x0, [sp, #136]
    40006e44:	91000400 	add	x0, x0, #0x1
    40006e48:	f90047e0 	str	x0, [sp, #136]
				wildcard_found = true;
    40006e4c:	52800020 	mov	w0, #0x1                   	// #1
    40006e50:	b9006fe0 	str	w0, [sp, #108]
				continue;
    40006e54:	17ffffac 	b	40006d04 <execute+0xb8>
		if (has_last_handler == false) {
    40006e58:	350000d8 	cbnz	w24, 40006e70 <execute+0x224>
			entry = z_shell_find_cmd(parent, argvp[0], &dloc);
    40006e5c:	f9400281 	ldr	x1, [x20]
    40006e60:	910263e2 	add	x2, sp, #0x98
    40006e64:	aa1b03e0 	mov	x0, x27
    40006e68:	94000562 	bl	400083f0 <z_shell_find_cmd>
    40006e6c:	aa0003fa 	mov	x26, x0
		argvp++;
    40006e70:	91002294 	add	x20, x20, #0x8
		args_left--;
    40006e74:	d1000673 	sub	x19, x19, #0x1
		if (entry) {
    40006e78:	b400065a 	cbz	x26, 40006f40 <execute+0x2f4>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && found && entry->handler) {
    40006e7c:	b9406fe1 	ldr	w1, [sp, #108]
    40006e80:	f9400f40 	ldr	x0, [x26, #24]
    40006e84:	34000121 	cbz	w1, 40006ea8 <execute+0x25c>
    40006e88:	b4000380 	cbz	x0, 40006ef8 <execute+0x2ac>
		z_shell_op_cursor_end_move(shell);
    40006e8c:	aa1703e0 	mov	x0, x23
    40006e90:	9400070f 	bl	40008acc <z_shell_op_cursor_end_move>
		z_shell_op_cond_next_line(shell);
    40006e94:	aa1703e0 	mov	x0, x23
    40006e98:	94000679 	bl	4000887c <z_shell_op_cond_next_line>
		z_shell_fprintf(shell, SHELL_ERROR,
    40006e9c:	d0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40006ea0:	912b4042 	add	x2, x2, #0xad0
    40006ea4:	17ffffd9 	b	40006e08 <execute+0x1bc>
	if (entry->handler) {
    40006ea8:	b4000280 	cbz	x0, 40006ef8 <execute+0x2ac>
		*active_cmd = *entry;
    40006eac:	f9400ae1 	ldr	x1, [x23, #16]
    40006eb0:	a9400f42 	ldp	x2, x3, [x26]
    40006eb4:	91004020 	add	x0, x1, #0x10
    40006eb8:	a9010c22 	stp	x2, x3, [x1, #16]
    40006ebc:	a9410f42 	ldp	x2, x3, [x26, #16]
    40006ec0:	a9020c22 	stp	x2, x3, [x1, #32]
    40006ec4:	f9401341 	ldr	x1, [x26, #32]
    40006ec8:	f9001001 	str	x1, [x0, #32]
		if ((entry->subcmd == NULL)
    40006ecc:	f9400b40 	ldr	x0, [x26, #16]
		*handler_lvl = *lvl;
    40006ed0:	f94047f6 	ldr	x22, [sp, #136]
		if ((entry->subcmd == NULL)
    40006ed4:	b5000120 	cbnz	x0, 40006ef8 <execute+0x2ac>
		    && entry->args.optional == SHELL_OPT_ARG_RAW) {
    40006ed8:	39408740 	ldrb	w0, [x26, #33]
    40006edc:	7103f81f 	cmp	w0, #0xfe
    40006ee0:	540000c1 	b.ne	40006ef8 <execute+0x2ac>  // b.any
			*args_left = entry->args.mandatory - 1;
    40006ee4:	39408353 	ldrb	w19, [x26, #32]
			*lvl = *lvl + 1;
    40006ee8:	910006c0 	add	x0, x22, #0x1
    40006eec:	f90047e0 	str	x0, [sp, #136]
			*args_left = entry->args.mandatory - 1;
    40006ef0:	51000673 	sub	w19, w19, #0x1
    40006ef4:	93407e73 	sxtw	x19, w19
	if (entry->help) {
    40006ef8:	f9400740 	ldr	x0, [x26, #8]
    40006efc:	b4000100 	cbz	x0, 40006f1c <execute+0x2d0>
		*help_entry = *entry;
    40006f00:	a9400f42 	ldp	x2, x3, [x26]
    40006f04:	aa0003f5 	mov	x21, x0
    40006f08:	a90c0fe2 	stp	x2, x3, [sp, #192]
    40006f0c:	a9410f42 	ldp	x2, x3, [x26, #16]
    40006f10:	a90d0fe2 	stp	x2, x3, [sp, #208]
    40006f14:	f9401341 	ldr	x1, [x26, #32]
    40006f18:	f90073e1 	str	x1, [sp, #224]
    40006f1c:	aa1a03fb 	mov	x27, x26
		if (args_left || (argc == 2)) {
    40006f20:	b5000093 	cbnz	x19, 40006f30 <execute+0x2e4>
    40006f24:	f9404be0 	ldr	x0, [sp, #144]
    40006f28:	f100081f 	cmp	x0, #0x2
    40006f2c:	54ffeec1 	b.ne	40006d04 <execute+0xb8>  // b.any
			cmd_lvl++;
    40006f30:	f94047e0 	ldr	x0, [sp, #136]
    40006f34:	91000400 	add	x0, x0, #0x1
    40006f38:	f90047e0 	str	x0, [sp, #136]
    40006f3c:	17ffff72 	b	40006d04 <execute+0xb8>
			if (cmd_lvl == 0 &&
    40006f40:	f94047e0 	ldr	x0, [sp, #136]
    40006f44:	b5000180 	cbnz	x0, 40006f74 <execute+0x328>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
}

static inline bool z_shell_in_select_mode(const struct shell *shell)
{
	return shell->ctx->selected_cmd == NULL ? false : true;
    40006f48:	f9400ae0 	ldr	x0, [x23, #16]
    40006f4c:	f9401c00 	ldr	x0, [x0, #56]
    40006f50:	b4000060 	cbz	x0, 40006f5c <execute+0x310>
				(!z_shell_in_select_mode(shell) ||
    40006f54:	f9400c00 	ldr	x0, [x0, #24]
    40006f58:	b50000e0 	cbnz	x0, 40006f74 <execute+0x328>
				z_shell_fprintf(shell, SHELL_ERROR,
    40006f5c:	f9403fe4 	ldr	x4, [sp, #120]
    40006f60:	aa1c03e2 	mov	x2, x28
    40006f64:	f94077e3 	ldr	x3, [sp, #232]
    40006f68:	aa1703e0 	mov	x0, x23
    40006f6c:	52800021 	mov	w1, #0x1                   	// #1
    40006f70:	940007a2 	bl	40008df8 <z_shell_fprintf>
			has_last_handler = true;
    40006f74:	52800038 	mov	w24, #0x1                   	// #1
    40006f78:	17ffffea 	b	40006f20 <execute+0x2d4>
		&& args_left > 0) {
    40006f7c:	b5ffee53 	cbnz	x19, 40006d44 <execute+0xf8>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
    40006f80:	b9406fe0 	ldr	w0, [sp, #108]
    40006f84:	34000120 	cbz	w0, 40006fa8 <execute+0x35c>
		z_shell_wildcard_finalize(shell);
    40006f88:	aa1703e0 	mov	x0, x23
    40006f8c:	94000d72 	bl	4000a554 <z_shell_wildcard_finalize>
					shell->ctx->cmd_buff,
    40006f90:	f9400ae2 	ldr	x2, [x23, #16]
		(void)z_shell_make_argv(&cmd_lvl,
    40006f94:	aa1903e1 	mov	x1, x25
    40006f98:	910223e0 	add	x0, sp, #0x88
    40006f9c:	52800183 	mov	w3, #0xc                   	// #12
    40006fa0:	9101d842 	add	x2, x2, #0x76
    40006fa4:	94000421 	bl	40008028 <z_shell_make_argv>
	if (shell->ctx->active_cmd.handler == NULL) {
    40006fa8:	f9400ae0 	ldr	x0, [x23, #16]
	argv[cmd_lvl] = NULL;
    40006fac:	f94047f3 	ldr	x19, [sp, #136]
	if (shell->ctx->active_cmd.handler == NULL) {
    40006fb0:	f9401401 	ldr	x1, [x0, #40]
	argv[cmd_lvl] = NULL;
    40006fb4:	f8337b3f 	str	xzr, [x25, x19, lsl #3]
	if (shell->ctx->active_cmd.handler == NULL) {
    40006fb8:	b5000241 	cbnz	x1, 40007000 <execute+0x3b4>
			if (help_entry->help == NULL) {
    40006fbc:	b4ffed95 	cbz	x21, 40006d6c <execute+0x120>
			if (help_entry->help != shell->ctx->active_cmd.help) {
    40006fc0:	f9400c01 	ldr	x1, [x0, #24]
    40006fc4:	eb15003f 	cmp	x1, x21
    40006fc8:	54fff140 	b.eq	40006df0 <execute+0x1a4>  // b.none
				shell->ctx->active_cmd = *help_entry;
    40006fcc:	f90067f5 	str	x21, [sp, #200]
    40006fd0:	91004001 	add	x1, x0, #0x10
    40006fd4:	a94c0fe2 	ldp	x2, x3, [sp, #192]
    40006fd8:	a9010c02 	stp	x2, x3, [x0, #16]
    40006fdc:	a94d0fe2 	ldp	x2, x3, [sp, #208]
    40006fe0:	a9020c02 	stp	x2, x3, [x0, #32]
    40006fe4:	f94073e0 	ldr	x0, [sp, #224]
    40006fe8:	f9001020 	str	x0, [x1, #32]
    40006fec:	17ffff81 	b	40006df0 <execute+0x1a4>
	if ((cmd_lvl >= CONFIG_SHELL_ARGC_MAX) && (argc == 2)) {
    40006ff0:	f94047e0 	ldr	x0, [sp, #136]
    40006ff4:	f1002c1f 	cmp	x0, #0xb
    40006ff8:	54fffc49 	b.ls	40006f80 <execute+0x334>  // b.plast
    40006ffc:	17ffff47 	b	40006d18 <execute+0xcc>
	if (shell->ctx->active_cmd.args.mandatory) {
    40007000:	3940c002 	ldrb	w2, [x0, #48]
	return exec_cmd(shell, cmd_lvl - cmd_with_handler_lvl,
    40007004:	cb160273 	sub	x19, x19, x22
	if (shell->ctx->active_cmd.args.mandatory) {
    40007008:	34000282 	cbz	w2, 40007058 <execute+0x40c>
		uint8_t opt8 = shell->ctx->active_cmd.args.optional;
    4000700c:	3940c401 	ldrb	w1, [x0, #49]
				UINT16_MAX : opt8;
    40007010:	529fffe3 	mov	w3, #0xffff                	// #65535
    40007014:	7103fc3f 	cmp	w1, #0xff
    40007018:	1a831021 	csel	w1, w1, w3, ne  // ne = any
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
    4000701c:	eb22027f 	cmp	x19, w2, uxtb
    40007020:	54000083 	b.cc	40007030 <execute+0x3e4>  // b.lo, b.ul, b.last
    40007024:	0b010042 	add	w2, w2, w1
	if (!arg_cnt_ok) {
    40007028:	eb02027f 	cmp	x19, x2
    4000702c:	54000169 	b.ls	40007058 <execute+0x40c>  // b.plast
		z_shell_fprintf(shell, SHELL_ERROR,
    40007030:	f9400803 	ldr	x3, [x0, #16]
    40007034:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40007038:	912cdc42 	add	x2, x2, #0xb37
    4000703c:	52800021 	mov	w1, #0x1                   	// #1
    40007040:	aa1703e0 	mov	x0, x23
		return -EINVAL;
    40007044:	128002b3 	mov	w19, #0xffffffea            	// #-22
		z_shell_fprintf(shell, SHELL_ERROR,
    40007048:	9400076c 	bl	40008df8 <z_shell_fprintf>
			shell_internal_help_print(shell);
    4000704c:	aa1703e0 	mov	x0, x23
    40007050:	97fffe52 	bl	40006998 <shell_internal_help_print>
	if (!ret_val) {
    40007054:	17ffff47 	b	40006d70 <execute+0x124>
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, cmd_ctx, val, ret);
    40007058:	d2810001 	mov	x1, #0x800                 	// #2048
    4000705c:	910a8000 	add	x0, x0, #0x2a0
    40007060:	97fffdfe 	bl	40006858 <atomic_or>
		k_mutex_unlock(&shell->ctx->wr_mtx);
    40007064:	f9400ae0 	ldr	x0, [x23, #16]
    40007068:	910ea000 	add	x0, x0, #0x3a8
    4000706c:	97fffed8 	bl	40006bcc <k_mutex_unlock.isra.0>
		ret_val = shell->ctx->active_cmd.handler(shell, argc,
    40007070:	f9400ae0 	ldr	x0, [x23, #16]
    40007074:	8b160f22 	add	x2, x25, x22, lsl #3
    40007078:	aa1303e1 	mov	x1, x19
    4000707c:	f9401403 	ldr	x3, [x0, #40]
    40007080:	aa1703e0 	mov	x0, x23
    40007084:	d63f0060 	blr	x3
    40007088:	2a0003f3 	mov	w19, w0
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    4000708c:	f9400ae0 	ldr	x0, [x23, #16]
    40007090:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40007094:	910ea000 	add	x0, x0, #0x3a8
    40007098:	97fffe4f 	bl	400069d4 <k_mutex_lock.constprop.0.isra.0>
    4000709c:	f9400ae0 	ldr	x0, [x23, #16]
    400070a0:	12810001 	mov	w1, #0xfffff7ff            	// #-2049
    400070a4:	910a8000 	add	x0, x0, #0x2a0
    400070a8:	97fffdf4 	bl	40006878 <atomic_and>
	return ret;
    400070ac:	17ffff31 	b	40006d70 <execute+0x124>

00000000400070b0 <state_set.constprop.0>:
	shell->ctx->state = state;
    400070b0:	f9400801 	ldr	x1, [x0, #16]
    400070b4:	52800042 	mov	w2, #0x2                   	// #2
    400070b8:	b9000822 	str	w2, [x1, #8]
	if (state == SHELL_STATE_ACTIVE && !shell->ctx->bypass) {
    400070bc:	f9403422 	ldr	x2, [x1, #104]
    400070c0:	b50002e2 	cbnz	x2, 4000711c <state_set.constprop.0+0x6c>
static inline void state_set(const struct shell *shell, enum shell_state state)
    400070c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400070c8:	910003fd 	mov	x29, sp
    400070cc:	f9000bf3 	str	x19, [sp, #16]
    400070d0:	aa0003f3 	mov	x19, x0
	shell->ctx->cmd_buff_len = 0;
    400070d4:	b900703f 	str	wzr, [x1, #112]
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
    400070d8:	3901d83f 	strb	wzr, [x1, #118]
	return sh->ctx->ctx.flags.print_noinit == 1;
    400070dc:	b942a021 	ldr	w1, [x1, #672]
		if (z_flag_print_noinit_get(shell)) {
    400070e0:	36600161 	tbz	w1, #12, 4000710c <state_set.constprop.0+0x5c>
			z_shell_fprintf(shell, SHELL_WARNING, "%s",
    400070e4:	52800061 	mov	w1, #0x3                   	// #3
    400070e8:	b0000063 	adrp	x3, 40014000 <CSWTCH.135+0x90>
    400070ec:	912d4863 	add	x3, x3, #0xb52
    400070f0:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400070f4:	91205c42 	add	x2, x2, #0x817
    400070f8:	94000740 	bl	40008df8 <z_shell_fprintf>
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
    400070fc:	f9400a60 	ldr	x0, [x19, #16]
    40007100:	12820001 	mov	w1, #0xffffefff            	// #-4097
    40007104:	910a8000 	add	x0, x0, #0x2a0
    40007108:	97fffddc 	bl	40006878 <atomic_and>
		z_shell_print_prompt_and_cmd(shell);
    4000710c:	aa1303e0 	mov	x0, x19
}
    40007110:	f9400bf3 	ldr	x19, [sp, #16]
    40007114:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_shell_print_prompt_and_cmd(shell);
    40007118:	14000866 	b	400092b0 <z_shell_print_prompt_and_cmd>
    4000711c:	d65f03c0 	ret

0000000040007120 <shell_process>:

	return 0;
}

void shell_process(const struct shell *shell)
{
    40007120:	a9a67bfd 	stp	x29, x30, [sp, #-416]!
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, processing, val, ret);
    40007124:	d2800021 	mov	x1, #0x1                   	// #1
    40007128:	910003fd 	mov	x29, sp
    4000712c:	a90153f3 	stp	x19, x20, [sp, #16]
    40007130:	aa0003f3 	mov	x19, x0
    40007134:	f9400800 	ldr	x0, [x0, #16]
    40007138:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000713c:	910a8000 	add	x0, x0, #0x2a0
    40007140:	a90363f7 	stp	x23, x24, [sp, #48]
    40007144:	a9046bf9 	stp	x25, x26, [sp, #64]
    40007148:	a90573fb 	stp	x27, x28, [sp, #80]
    4000714c:	97fffdc3 	bl	40006858 <atomic_or>
	__ASSERT_NO_MSG(shell->ctx);

	/* atomically set the processing flag */
	z_flag_processing_set(shell, true);

	switch (shell->ctx->state) {
    40007150:	f9400a60 	ldr	x0, [x19, #16]
    40007154:	b9400800 	ldr	w0, [x0, #8]
    40007158:	7100081f 	cmp	w0, #0x2
    4000715c:	54000321 	b.ne	400071c0 <shell_process+0xa0>  // b.any
		switch (shell->ctx->receive_state) {
    40007160:	b0000060 	adrp	x0, 40014000 <CSWTCH.135+0x90>
    40007164:	91010000 	add	x0, x0, #0x40
    40007168:	f90043e0 	str	x0, [sp, #128]
	size_t count = 0;
    4000716c:	f90057ff 	str	xzr, [sp, #168]
		shell_bypass_cb_t bypass = shell->ctx->bypass;
    40007170:	f9400a60 	ldr	x0, [x19, #16]
			(void)shell->iface->api->read(shell->iface, buf,
    40007174:	9102a3e3 	add	x3, sp, #0xa8
		shell_bypass_cb_t bypass = shell->ctx->bypass;
    40007178:	f9403414 	ldr	x20, [x0, #104]
			(void)shell->iface->api->read(shell->iface, buf,
    4000717c:	f9400660 	ldr	x0, [x19, #8]
    40007180:	f9400001 	ldr	x1, [x0]
    40007184:	f9401024 	ldr	x4, [x1, #32]
		if (bypass) {
    40007188:	b4000314 	cbz	x20, 400071e8 <shell_process+0xc8>
			(void)shell->iface->api->read(shell->iface, buf,
    4000718c:	d2800202 	mov	x2, #0x10                  	// #16
    40007190:	9104e3e1 	add	x1, sp, #0x138
    40007194:	d63f0080 	blr	x4
			if (count) {
    40007198:	f94057e2 	ldr	x2, [sp, #168]
    4000719c:	b4000122 	cbz	x2, 400071c0 <shell_process+0xa0>
				bypass(shell, buf, count);
    400071a0:	aa1303e0 	mov	x0, x19
    400071a4:	9104e3e1 	add	x1, sp, #0x138
    400071a8:	d63f0280 	blr	x20
				if (!(volatile shell_bypass_cb_t *)shell->ctx->bypass) {
    400071ac:	f9400a60 	ldr	x0, [x19, #16]
    400071b0:	f9403400 	ldr	x0, [x0, #104]
    400071b4:	b5fffde0 	cbnz	x0, 40007170 <shell_process+0x50>
					state_set(shell, SHELL_STATE_ACTIVE);
    400071b8:	aa1303e0 	mov	x0, x19
    400071bc:	97ffffbd 	bl	400070b0 <state_set.constprop.0>
    400071c0:	f9400a60 	ldr	x0, [x19, #16]
    400071c4:	b27f7be1 	mov	x1, #0xfffffffe            	// #4294967294
		break;
	}

	/* atomically clear the processing flag */
	z_flag_processing_set(shell, false);
}
    400071c8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400071cc:	910a8000 	add	x0, x0, #0x2a0
    400071d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400071d4:	a94363f7 	ldp	x23, x24, [sp, #48]
    400071d8:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400071dc:	a94573fb 	ldp	x27, x28, [sp, #80]
    400071e0:	a8da7bfd 	ldp	x29, x30, [sp], #416
    400071e4:	17fffda5 	b	40006878 <atomic_and>
		(void)shell->iface->api->read(shell->iface, &data,
    400071e8:	91029fe1 	add	x1, sp, #0xa7
    400071ec:	d2800022 	mov	x2, #0x1                   	// #1
    400071f0:	d63f0080 	blr	x4
		if (count == 0) {
    400071f4:	f94057e0 	ldr	x0, [sp, #168]
    400071f8:	b4fffe40 	cbz	x0, 400071c0 <shell_process+0xa0>
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
    400071fc:	39c29fe2 	ldrsb	w2, [sp, #167]
		if (ascii_filter(data) != 0) {
    40007200:	39429fe1 	ldrb	w1, [sp, #167]
		switch (shell->ctx->receive_state) {
    40007204:	f9400a60 	ldr	x0, [x19, #16]
	return (uint8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
    40007208:	37fffb42 	tbnz	w2, #31, 40007170 <shell_process+0x50>
		switch (shell->ctx->receive_state) {
    4000720c:	b9400c02 	ldr	w2, [x0, #12]
    40007210:	71000c5f 	cmp	w2, #0x3
    40007214:	54003668 	b.hi	400078e0 <shell_process+0x7c0>  // b.pmore
    40007218:	f94043e3 	ldr	x3, [sp, #128]
    4000721c:	78625862 	ldrh	w2, [x3, w2, uxtw #1]
    40007220:	10000063 	adr	x3, 4000722c <shell_process+0x10c>
    40007224:	8b22a862 	add	x2, x3, w2, sxth #2
    40007228:	d61f0040 	br	x2
	if ((data != '\r') && (data != '\n')) {
    4000722c:	7100343f 	cmp	w1, #0xd
    40007230:	7a4a1824 	ccmp	w1, #0xa, #0x4, ne  // ne = any
    40007234:	54000220 	b.eq	40007278 <shell_process+0x158>  // b.none
	sh->ctx->ctx.flags.last_nl = val;
    40007238:	79454002 	ldrh	w2, [x0, #672]
    4000723c:	12155c42 	and	w2, w2, #0xfffff807
    40007240:	79054002 	strh	w2, [x0, #672]
			switch (data) {
    40007244:	7100243f 	cmp	w1, #0x9
    40007248:	54000680 	b.eq	40007318 <shell_process+0x1f8>  // b.none
    4000724c:	54000448 	b.hi	400072d4 <shell_process+0x1b4>  // b.pmore
    40007250:	34fff901 	cbz	w1, 40007170 <shell_process+0x50>
    40007254:	7100203f 	cmp	w1, #0x8
    40007258:	54002840 	b.eq	40007760 <shell_process+0x640>  // b.none
    4000725c:	51008022 	sub	w2, w1, #0x20
				if (isprint((int) data)) {
    40007260:	7101785f 	cmp	w2, #0x5e
    40007264:	540028c8 	b.hi	4000777c <shell_process+0x65c>  // b.pmore
					z_flag_history_exit_set(shell, true);
    40007268:	52800021 	mov	w1, #0x1                   	// #1
    4000726c:	97fffe06 	bl	40006a84 <z_flag_history_exit_set.isra.0>
					z_shell_op_char_insert(shell, data);
    40007270:	39429fe1 	ldrb	w1, [sp, #167]
    40007274:	140000a4 	b	40007504 <shell_process+0x3e4>
	return sh->ctx->ctx.flags.last_nl;
    40007278:	b942a002 	ldr	w2, [x0, #672]
	if ((z_flag_last_nl_get(shell) == 0U) ||
    4000727c:	f27d1c5f 	tst	x2, #0x7f8
    40007280:	540000a0 	b.eq	40007294 <shell_process+0x174>  // b.none
    40007284:	b942a002 	ldr	w2, [x0, #672]
    40007288:	d3432842 	ubfx	x2, x2, #3, #8
    4000728c:	6b02003f 	cmp	w1, w2
    40007290:	54fffda1 	b.ne	40007244 <shell_process+0x124>  // b.any
	sh->ctx->ctx.flags.last_nl = val;
    40007294:	79454002 	ldrh	w2, [x0, #672]
    40007298:	331d1c22 	bfi	w2, w1, #3, #8
				if (!shell->ctx->cmd_buff_len) {
    4000729c:	7940e001 	ldrh	w1, [x0, #112]
    400072a0:	79054002 	strh	w2, [x0, #672]
    400072a4:	35000121 	cbnz	w1, 400072c8 <shell_process+0x1a8>
	z_flag_history_exit_set(shell, false);
    400072a8:	97fffdf7 	bl	40006a84 <z_flag_history_exit_set.isra.0>
	z_shell_history_mode_exit(shell->history);
    400072ac:	f9400e60 	ldr	x0, [x19, #24]
    400072b0:	94000b79 	bl	4000a094 <z_shell_history_mode_exit>
					z_cursor_next_line_move(shell);
    400072b4:	f9401660 	ldr	x0, [x19, #40]
    400072b8:	97fffdf0 	bl	40006a78 <z_cursor_next_line_move.isra.0>
		state_set(shell, SHELL_STATE_ACTIVE);
    400072bc:	aa1303e0 	mov	x0, x19
    400072c0:	97ffff7c 	bl	400070b0 <state_set.constprop.0>
		break;
    400072c4:	17ffffab 	b	40007170 <shell_process+0x50>
					(void)execute(shell);
    400072c8:	aa1303e0 	mov	x0, x19
    400072cc:	97fffe60 	bl	40006c4c <execute>
				state_set(shell, SHELL_STATE_ACTIVE);
    400072d0:	17fffffb 	b	400072bc <shell_process+0x19c>
    400072d4:	71006c3f 	cmp	w1, #0x1b
    400072d8:	540001a0 	b.eq	4000730c <shell_process+0x1ec>  // b.none
    400072dc:	7101fc3f 	cmp	w1, #0x7f
    400072e0:	54fffbe1 	b.ne	4000725c <shell_process+0x13c>  // b.any
	return sh->ctx->cfg.flags.echo == 1;
    400072e4:	b9429801 	ldr	w1, [x0, #664]
				if (z_flag_echo_get(shell)) {
    400072e8:	360ff441 	tbz	w1, #1, 40007170 <shell_process+0x50>
					z_flag_history_exit_set(shell, true);
    400072ec:	52800021 	mov	w1, #0x1                   	// #1
    400072f0:	97fffde5 	bl	40006a84 <z_flag_history_exit_set.isra.0>
	return sh->ctx->cfg.flags.mode_delete == 1;
    400072f4:	f9400a60 	ldr	x0, [x19, #16]
    400072f8:	b9429800 	ldr	w0, [x0, #664]
					if (z_flag_mode_delete_get(shell)) {
    400072fc:	371823a0 	tbnz	w0, #3, 40007770 <shell_process+0x650>
		z_shell_op_char_delete(shell);
    40007300:	aa1303e0 	mov	x0, x19
    40007304:	940007be 	bl	400091fc <z_shell_op_char_delete>
		break;
    40007308:	17ffff9a 	b	40007170 <shell_process+0x50>
	shell->ctx->receive_state = state;
    4000730c:	52800021 	mov	w1, #0x1                   	// #1
    40007310:	b9000c01 	str	w1, [x0, #12]
}
    40007314:	17ffff97 	b	40007170 <shell_process+0x50>
	return sh->ctx->cfg.flags.echo == 1;
    40007318:	b9429801 	ldr	w1, [x0, #664]
				if (z_flag_echo_get(shell) &&
    4000731c:	360ff2a1 	tbz	w1, #1, 40007170 <shell_process+0x50>
					z_flag_history_exit_set(shell, true);
    40007320:	52800021 	mov	w1, #0x1                   	// #1
    40007324:	97fffdd8 	bl	40006a84 <z_flag_history_exit_set.isra.0>
			shell->ctx->cmd_buff_len;
    40007328:	f9400a60 	ldr	x0, [x19, #16]
	if (compl_space == 0U) {
    4000732c:	7940e001 	ldrh	w1, [x0, #112]
    40007330:	7103fc3f 	cmp	w1, #0xff
    40007334:	54fff1e0 	b.eq	40007170 <shell_process+0x50>  // b.none
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
    40007338:	7940e402 	ldrh	w2, [x0, #114]
    4000733c:	9101d801 	add	x1, x0, #0x76
    40007340:	9105d800 	add	x0, x0, #0x176
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    40007344:	9104e3f6 	add	x22, sp, #0x138
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
    40007348:	9400125d 	bl	4000bcbc <memcpy>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    4000734c:	f9400a62 	ldr	x2, [x19, #16]
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    40007350:	aa1603e1 	mov	x1, x22
    40007354:	52800183 	mov	w3, #0xc                   	// #12
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    40007358:	7940e440 	ldrh	w0, [x2, #114]
    4000735c:	8b000040 	add	x0, x2, x0
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    40007360:	9105d842 	add	x2, x2, #0x176
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
    40007364:	3905d81f 	strb	wzr, [x0, #374]
	(void)z_shell_make_argv(argc, *argv, shell->ctx->temp_buff,
    40007368:	9102e3e0 	add	x0, sp, #0xb8
    4000736c:	9400032f 	bl	40008028 <z_shell_make_argv>
	if (*argc > CONFIG_SHELL_ARGC_MAX) {
    40007370:	f9405fe1 	ldr	x1, [sp, #184]
    40007374:	f100303f 	cmp	x1, #0xc
    40007378:	54ffefc8 	b.hi	40007170 <shell_process+0x50>  // b.pmore
	(*argv)[*argc] = NULL;
    4000737c:	f8217adf 	str	xzr, [x22, x1, lsl #3]
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
    40007380:	b4000181 	cbz	x1, 400073b0 <shell_process+0x290>
	int space = isspace((int)shell->ctx->cmd_buff[
    40007384:	f9400a62 	ldr	x2, [x19, #16]
						shell->ctx->cmd_buff_pos - 1]);
    40007388:	7940e440 	ldrh	w0, [x2, #114]
    4000738c:	51000400 	sub	w0, w0, #0x1
	int space = isspace((int)shell->ctx->cmd_buff[
    40007390:	8b20c040 	add	x0, x2, w0, sxtw
    40007394:	3941d800 	ldrb	w0, [x0, #118]
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    40007398:	51002402 	sub	w2, w0, #0x9
    4000739c:	7100801f 	cmp	w0, #0x20
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
    400073a0:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    400073a4:	540007c9 	b.ls	4000749c <shell_process+0x37c>  // b.plast
    400073a8:	f100043f 	cmp	x1, #0x1
    400073ac:	54000761 	b.ne	40007498 <shell_process+0x378>  // b.any
		*cmd = selected_cmd_get(shell);
    400073b0:	d2800014 	mov	x20, #0x0                   	// #0
		*complete_arg_idx = Z_SHELL_CMD_ROOT_LVL;
    400073b4:	f9005bff 	str	xzr, [sp, #176]
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
    400073b8:	f9405be0 	ldr	x0, [sp, #176]
	*cnt = 0;
    400073bc:	d2800015 	mov	x21, #0x0                   	// #0
	*longest = 0U;
    400073c0:	5280001a 	mov	w26, #0x0                   	// #0
	size_t first = 0;
    400073c4:	d2800017 	mov	x23, #0x0                   	// #0
	size_t idx = 0;
    400073c8:	d2800018 	mov	x24, #0x0                   	// #0
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
    400073cc:	f8607adb 	ldr	x27, [x22, x0, lsl #3]
	incompl_cmd_len = z_shell_strlen(incompl_cmd);
    400073d0:	aa1b03e0 	mov	x0, x27
    400073d4:	97fffd4b 	bl	40006900 <z_shell_strlen>
    400073d8:	92403c19 	and	x25, x0, #0xffff
	while ((candidate = z_shell_cmd_get(cmd, idx, &dloc)) != NULL) {
    400073dc:	910443e2 	add	x2, sp, #0x110
    400073e0:	aa1803e1 	mov	x1, x24
    400073e4:	aa1403e0 	mov	x0, x20
    400073e8:	940003dc 	bl	40008358 <z_shell_cmd_get>
    400073ec:	aa0003fc 	mov	x28, x0
    400073f0:	b5000680 	cbnz	x0, 400074c0 <shell_process+0x3a0>
	if (cnt == 1) {
    400073f4:	f10006bf 	cmp	x21, #0x1
    400073f8:	54000941 	b.ne	40007520 <shell_process+0x400>  // b.any
	uint16_t arg_len = z_shell_strlen(arg);
    400073fc:	f9405be0 	ldr	x0, [sp, #176]
    40007400:	f8607ac0 	ldr	x0, [x22, x0, lsl #3]
    40007404:	97fffd3f 	bl	40006900 <z_shell_strlen>
    40007408:	12003c16 	and	w22, w0, #0xffff
	match = z_shell_cmd_get(cmd, subcmd_idx, &shell->ctx->active_cmd);
    4000740c:	f9400a62 	ldr	x2, [x19, #16]
    40007410:	aa1703e1 	mov	x1, x23
    40007414:	aa1403e0 	mov	x0, x20
    40007418:	91004042 	add	x2, x2, #0x10
    4000741c:	940003cf 	bl	40008358 <z_shell_cmd_get>
    40007420:	aa0003f4 	mov	x20, x0
	cmd_len = z_shell_strlen(match->syntax);
    40007424:	f9400000 	ldr	x0, [x0]
    40007428:	97fffd36 	bl	40006900 <z_shell_strlen>
    4000742c:	12003c02 	and	w2, w0, #0xffff
	if (cmd_len != arg_len) {
    40007430:	6b2022df 	cmp	w22, w0, uxth
    40007434:	540000c0 	b.eq	4000744c <shell_process+0x32c>  // b.none
		z_shell_op_completion_insert(shell,
    40007438:	f9400281 	ldr	x1, [x20]
    4000743c:	4b160042 	sub	w2, w2, w22
    40007440:	aa1303e0 	mov	x0, x19
    40007444:	8b362021 	add	x1, x1, w22, uxth
    40007448:	9400076c 	bl	400091f8 <z_shell_op_completion_insert>
	if (!isspace((int) shell->ctx->cmd_buff[
    4000744c:	f9400a60 	ldr	x0, [x19, #16]
    40007450:	7940e401 	ldrh	w1, [x0, #114]
    40007454:	8b010001 	add	x1, x0, x1
    40007458:	3941d821 	ldrb	w1, [x1, #118]
    4000745c:	51002422 	sub	w2, w1, #0x9
    40007460:	7100803f 	cmp	w1, #0x20
    40007464:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    40007468:	54000549 	b.ls	40007510 <shell_process+0x3f0>  // b.plast
	return sh->ctx->cfg.flags.insert_mode == 1;
    4000746c:	b9429801 	ldr	w1, [x0, #664]
		if (z_flag_insert_mode_get(shell)) {
    40007470:	36000481 	tbz	w1, #0, 40007500 <shell_process+0x3e0>
			z_flag_insert_mode_set(shell, false);
    40007474:	52800001 	mov	w1, #0x0                   	// #0
    40007478:	97fffdc8 	bl	40006b98 <z_flag_insert_mode_set.isra.0>
			z_shell_op_char_insert(shell, ' ');
    4000747c:	aa1303e0 	mov	x0, x19
    40007480:	52800401 	mov	w1, #0x20                  	// #32
    40007484:	94000734 	bl	40009154 <z_shell_op_char_insert>
			z_flag_insert_mode_set(shell, true);
    40007488:	f9400a60 	ldr	x0, [x19, #16]
    4000748c:	52800021 	mov	w1, #0x1                   	// #1
				z_flag_insert_mode_set(shell, !status);
    40007490:	97fffdc2 	bl	40006b98 <z_flag_insert_mode_set.isra.0>
				break;
    40007494:	17ffff37 	b	40007170 <shell_process+0x50>
	search_argc = space ? *argc : *argc - 1;
    40007498:	d1000421 	sub	x1, x1, #0x1
	*cmd = z_shell_get_last_command(selected_cmd_get(shell), search_argc,
    4000749c:	910303e4 	add	x4, sp, #0xc0
    400074a0:	9102c3e3 	add	x3, sp, #0xb0
    400074a4:	aa1603e2 	mov	x2, x22
    400074a8:	52800005 	mov	w5, #0x0                   	// #0
    400074ac:	d2800000 	mov	x0, #0x0                   	// #0
    400074b0:	940003f0 	bl	40008470 <z_shell_get_last_command>
    400074b4:	aa0003f4 	mov	x20, x0
	if ((*cmd == NULL) && (search_argc != 0)) {
    400074b8:	b5fff800 	cbnz	x0, 400073b8 <shell_process+0x298>
    400074bc:	17ffff2d 	b	40007170 <shell_process+0x50>
	return (strncmp(candidate, str, len) == 0) ? true : false;
    400074c0:	f9400380 	ldr	x0, [x28]
    400074c4:	aa1903e2 	mov	x2, x25
    400074c8:	aa1b03e1 	mov	x1, x27
    400074cc:	940011d2 	bl	4000bc14 <strncmp>
		if (is_candidate) {
    400074d0:	35000140 	cbnz	w0, 400074f8 <shell_process+0x3d8>
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
    400074d4:	f9400380 	ldr	x0, [x28]
    400074d8:	940011b6 	bl	4000bbb0 <strlen>
    400074dc:	eb3a201f 	cmp	x0, w26, uxth
    400074e0:	92403f41 	and	x1, x26, #0xffff
    400074e4:	9a809020 	csel	x0, x1, x0, ls  // ls = plast
				*first_idx = idx;
    400074e8:	f10002bf 	cmp	x21, #0x0
			*longest = Z_MAX(strlen(candidate->syntax), *longest);
    400074ec:	12003c1a 	and	w26, w0, #0xffff
				*first_idx = idx;
    400074f0:	9a9812f7 	csel	x23, x23, x24, ne  // ne = any
			(*cnt)++;
    400074f4:	910006b5 	add	x21, x21, #0x1
		idx++;
    400074f8:	91000718 	add	x24, x24, #0x1
    400074fc:	17ffffb8 	b	400073dc <shell_process+0x2bc>
			z_shell_op_char_insert(shell, ' ');
    40007500:	52800401 	mov	w1, #0x20                  	// #32
					z_shell_op_char_insert(shell, data);
    40007504:	aa1303e0 	mov	x0, x19
    40007508:	94000713 	bl	40009154 <z_shell_op_char_insert>
    4000750c:	17ffff19 	b	40007170 <shell_process+0x50>
		z_shell_op_cursor_move(shell, 1);
    40007510:	aa1303e0 	mov	x0, x19
    40007514:	52800021 	mov	w1, #0x1                   	// #1
    40007518:	94000510 	bl	40008958 <z_shell_op_cursor_move>
    4000751c:	17ffff15 	b	40007170 <shell_process+0x50>
	} else if (cnt > 1) {
    40007520:	54ffe289 	b.ls	40007170 <shell_process+0x50>  // b.plast
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
    40007524:	f9405be0 	ldr	x0, [sp, #176]
	longest_option += z_shell_strlen(tab);
    40007528:	b0000078 	adrp	x24, 40014000 <CSWTCH.135+0x90>
    4000752c:	91072318 	add	x24, x24, #0x1c8
		shell->ctx->vt100_ctx.printed_cmd = 0;
    40007530:	aa1703fb 	mov	x27, x23
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
    40007534:	f8607adc 	ldr	x28, [x22, x0, lsl #3]
	size_t str_len = z_shell_strlen(str);
    40007538:	aa1c03e0 	mov	x0, x28
    4000753c:	97fffcf1 	bl	40006900 <z_shell_strlen>
    40007540:	92403c00 	and	x0, x0, #0xffff
    40007544:	a90683f5 	stp	x21, x0, [sp, #104]
		shell->ctx->vt100_ctx.printed_cmd = 0;
    40007548:	f9400a60 	ldr	x0, [x19, #16]
    4000754c:	7900b01f 	strh	wzr, [x0, #88]
		z_shell_fprintf(shell, SHELL_OPTION, "%s", option);
    40007550:	b0000060 	adrp	x0, 40014000 <CSWTCH.135+0x90>
    40007554:	91205c00 	add	x0, x0, #0x817
    40007558:	f9003fe0 	str	x0, [sp, #120]
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
    4000755c:	f9400a62 	ldr	x2, [x19, #16]
    40007560:	aa1b03e1 	mov	x1, x27
    40007564:	aa1403e0 	mov	x0, x20
		idx++;
    40007568:	9100077b 	add	x27, x27, #0x1
		match = z_shell_cmd_get(cmd, idx, &shell->ctx->active_cmd);
    4000756c:	91004042 	add	x2, x2, #0x10
    40007570:	9400037a 	bl	40008358 <z_shell_cmd_get>
    40007574:	aa0003f9 	mov	x25, x0
		if (str && match->syntax &&
    40007578:	b50007dc 	cbnz	x28, 40007670 <shell_process+0x550>
		tab_item_print(shell, match->syntax, longest);
    4000757c:	f9400323 	ldr	x3, [x25]
	if (option == NULL) {
    40007580:	b5000863 	cbnz	x3, 4000768c <shell_process+0x56c>
		shell->ctx->vt100_ctx.printed_cmd = 0;
    40007584:	f9400a60 	ldr	x0, [x19, #16]
    40007588:	7900b01f 	strh	wzr, [x0, #88]
	while (cnt) {
    4000758c:	f94037e0 	ldr	x0, [sp, #104]
    40007590:	f1000400 	subs	x0, x0, #0x1
    40007594:	f90037e0 	str	x0, [sp, #104]
    40007598:	54fffe21 	b.ne	4000755c <shell_process+0x43c>  // b.any
	z_cursor_next_line_move(shell);
    4000759c:	f9401660 	ldr	x0, [x19, #40]
	size_t idx = first + 1;
    400075a0:	910006fa 	add	x26, x23, #0x1
	z_cursor_next_line_move(shell);
    400075a4:	97fffd35 	bl	40006a78 <z_cursor_next_line_move.isra.0>
	z_shell_print_prompt_and_cmd(shell);
    400075a8:	aa1303e0 	mov	x0, x19
    400075ac:	94000741 	bl	400092b0 <z_shell_print_prompt_and_cmd>
	uint16_t arg_len = z_shell_strlen(arg);
    400075b0:	f9405be0 	ldr	x0, [sp, #176]
    400075b4:	f8607ac0 	ldr	x0, [x22, x0, lsl #3]
	uint16_t common = UINT16_MAX;
    400075b8:	529ffff6 	mov	w22, #0xffff                	// #65535
	uint16_t arg_len = z_shell_strlen(arg);
    400075bc:	97fffcd1 	bl	40006900 <z_shell_strlen>
    400075c0:	12003c19 	and	w25, w0, #0xffff
	match = z_shell_cmd_get(cmd, first, &dynamic_entry);
    400075c4:	aa1703e1 	mov	x1, x23
    400075c8:	9103a3e2 	add	x2, sp, #0xe8
    400075cc:	aa1403e0 	mov	x0, x20
    400075d0:	94000362 	bl	40008358 <z_shell_cmd_get>
    400075d4:	aa0003f7 	mov	x23, x0
	strncpy(shell->ctx->temp_buff, match->syntax,
    400075d8:	d2801fe2 	mov	x2, #0xff                  	// #255
    400075dc:	f9400a60 	ldr	x0, [x19, #16]
	uint16_t arg_len = z_shell_strlen(arg);
    400075e0:	2a1903f8 	mov	w24, w25
	strncpy(shell->ctx->temp_buff, match->syntax,
    400075e4:	f94002e1 	ldr	x1, [x23]
    400075e8:	9105d800 	add	x0, x0, #0x176
    400075ec:	9400114e 	bl	4000bb24 <strncpy>
	*str = match->syntax;
    400075f0:	f94002f7 	ldr	x23, [x23]
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
    400075f4:	9100075b 	add	x27, x26, #0x1
    400075f8:	910443e2 	add	x2, sp, #0x110
    400075fc:	aa1a03e1 	mov	x1, x26
    40007600:	aa1403e0 	mov	x0, x20
    40007604:	94000355 	bl	40008358 <z_shell_cmd_get>
		if (match2 == NULL) {
    40007608:	b4000a00 	cbz	x0, 40007748 <shell_process+0x628>
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
    4000760c:	f9400a61 	ldr	x1, [x19, #16]
    40007610:	f9400003 	ldr	x3, [x0]
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    40007614:	9105d821 	add	x1, x1, #0x176
	size_t common = 0;
    40007618:	d2800000 	mov	x0, #0x0                   	// #0
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    4000761c:	38606824 	ldrb	w4, [x1, x0]
    40007620:	38606862 	ldrb	w2, [x3, x0]
    40007624:	6b04005f 	cmp	w2, w4
    40007628:	540000c1 	b.ne	40007640 <shell_process+0x520>  // b.any
    4000762c:	340000a2 	cbz	w2, 40007640 <shell_process+0x520>
		common++;
    40007630:	91000400 	add	x0, x0, #0x1
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    40007634:	d29fffe2 	mov	x2, #0xffff                	// #65535
    40007638:	eb02001f 	cmp	x0, x2
    4000763c:	54ffff01 	b.ne	4000761c <shell_process+0x4fc>  // b.any
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
    40007640:	2a0003e2 	mov	w2, w0
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
    40007644:	34000079 	cbz	w25, 40007650 <shell_process+0x530>
    40007648:	6b19001f 	cmp	w0, w25
    4000764c:	540000eb 	b.lt	40007668 <shell_process+0x548>  // b.tstop
			common = (curr_common < common) ? curr_common : common;
    40007650:	6b0202df 	cmp	w22, w2
			--cnt;
    40007654:	d10006b5 	sub	x21, x21, #0x1
			common = (curr_common < common) ? curr_common : common;
    40007658:	1a82d2d6 	csel	w22, w22, w2, le
	while (cnt > 1) {
    4000765c:	f10006bf 	cmp	x21, #0x1
			common = (curr_common < common) ? curr_common : common;
    40007660:	12003ed6 	and	w22, w22, #0xffff
	while (cnt > 1) {
    40007664:	54000720 	b.eq	40007748 <shell_process+0x628>  // b.none
		match2 = z_shell_cmd_get(cmd, idx++, &dynamic_entry2);
    40007668:	aa1b03fa 	mov	x26, x27
    4000766c:	17ffffe2 	b	400075f4 <shell_process+0x4d4>
		if (str && match->syntax &&
    40007670:	f9400000 	ldr	x0, [x0]
    40007674:	b4fff840 	cbz	x0, 4000757c <shell_process+0x45c>
	return (strncmp(candidate, str, len) == 0) ? true : false;
    40007678:	f9403be2 	ldr	x2, [sp, #112]
    4000767c:	aa1c03e1 	mov	x1, x28
    40007680:	94001165 	bl	4000bc14 <strncmp>
		if (str && match->syntax &&
    40007684:	34fff7c0 	cbz	w0, 4000757c <shell_process+0x45c>
    40007688:	17ffffb5 	b	4000755c <shell_process+0x43c>
	longest_option += z_shell_strlen(tab);
    4000768c:	aa1803e0 	mov	x0, x24
    40007690:	f90047e3 	str	x3, [sp, #136]
    40007694:	97fffc9b 	bl	40006900 <z_shell_strlen>
    40007698:	0b202340 	add	w0, w26, w0, uxth
    4000769c:	12003c02 	and	w2, w0, #0xffff
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
    400076a0:	f9400a60 	ldr	x0, [x19, #16]
    400076a4:	79409401 	ldrh	w1, [x0, #74]
			- z_shell_strlen(tab)) / longest_option;
    400076a8:	aa1803e0 	mov	x0, x24
	longest_option += z_shell_strlen(tab);
    400076ac:	29130be1 	stp	w1, w2, [sp, #152]
			- z_shell_strlen(tab)) / longest_option;
    400076b0:	97fffc94 	bl	40006900 <z_shell_strlen>
    400076b4:	12003c05 	and	w5, w0, #0xffff
	diff = longest_option - z_shell_strlen(option);
    400076b8:	f94047e3 	ldr	x3, [sp, #136]
			- z_shell_strlen(tab)) / longest_option;
    400076bc:	b90097e5 	str	w5, [sp, #148]
	diff = longest_option - z_shell_strlen(option);
    400076c0:	aa0303e0 	mov	x0, x3
    400076c4:	97fffc8f 	bl	40006900 <z_shell_strlen>
    400076c8:	b9409fe2 	ldr	w2, [sp, #156]
			- z_shell_strlen(tab)) / longest_option;
    400076cc:	295287e5 	ldp	w5, w1, [sp, #148]
	diff = longest_option - z_shell_strlen(option);
    400076d0:	4b202059 	sub	w25, w2, w0, uxth
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
    400076d4:	f9400a60 	ldr	x0, [x19, #16]
	diff = longest_option - z_shell_strlen(option);
    400076d8:	12003f39 	and	w25, w25, #0xffff
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
    400076dc:	f94047e3 	ldr	x3, [sp, #136]
    400076e0:	7940b004 	ldrh	w4, [x0, #88]
    400076e4:	11000486 	add	w6, w4, #0x1
    400076e8:	7900b006 	strh	w6, [x0, #88]
			- z_shell_strlen(tab)) / longest_option;
    400076ec:	4b050020 	sub	w0, w1, w5
    400076f0:	1ac20c00 	sdiv	w0, w0, w2
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
    400076f4:	12003c00 	and	w0, w0, #0xffff
    400076f8:	1ac00881 	udiv	w1, w4, w0
    400076fc:	1b009020 	msub	w0, w1, w0, w4
    40007700:	72003c1f 	tst	w0, #0xffff
    40007704:	54000181 	b.ne	40007734 <shell_process+0x614>  // b.any
		z_shell_fprintf(shell, SHELL_OPTION, "\n%s%s", tab, option);
    40007708:	aa0303e4 	mov	x4, x3
    4000770c:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40007710:	912e5842 	add	x2, x2, #0xb96
    40007714:	aa1803e3 	mov	x3, x24
    40007718:	aa1303e0 	mov	x0, x19
    4000771c:	528000c1 	mov	w1, #0x6                   	// #6
    40007720:	940005b6 	bl	40008df8 <z_shell_fprintf>
	z_shell_op_cursor_horiz_move(shell, diff);
    40007724:	2a1903e1 	mov	w1, w25
    40007728:	aa1303e0 	mov	x0, x19
    4000772c:	9400042e 	bl	400087e4 <z_shell_op_cursor_horiz_move>
    40007730:	17ffff97 	b	4000758c <shell_process+0x46c>
		z_shell_fprintf(shell, SHELL_OPTION, "%s", option);
    40007734:	f9403fe2 	ldr	x2, [sp, #120]
    40007738:	aa1303e0 	mov	x0, x19
    4000773c:	528000c1 	mov	w1, #0x6                   	// #6
    40007740:	940005ae 	bl	40008df8 <z_shell_fprintf>
    40007744:	17fffff8 	b	40007724 <shell_process+0x604>
	if (common) {
    40007748:	34ffd156 	cbz	w22, 40007170 <shell_process+0x50>
		z_shell_op_completion_insert(shell, &completion[arg_len],
    4000774c:	4b1902c2 	sub	w2, w22, w25
    40007750:	8b3822e1 	add	x1, x23, w24, uxth
    40007754:	aa1303e0 	mov	x0, x19
    40007758:	940006a8 	bl	400091f8 <z_shell_op_completion_insert>
    4000775c:	17fffe85 	b	40007170 <shell_process+0x50>
	return sh->ctx->cfg.flags.echo == 1;
    40007760:	b9429801 	ldr	w1, [x0, #664]
				if (z_flag_echo_get(shell)) {
    40007764:	360fd061 	tbz	w1, #1, 40007170 <shell_process+0x50>
					z_flag_history_exit_set(shell, true);
    40007768:	52800021 	mov	w1, #0x1                   	// #1
    4000776c:	97fffcc6 	bl	40006a84 <z_flag_history_exit_set.isra.0>
						z_shell_op_char_backspace(shell);
    40007770:	aa1303e0 	mov	x0, x19
    40007774:	940006bf 	bl	40009270 <z_shell_op_char_backspace>
    40007778:	17fffe7e 	b	40007170 <shell_process+0x50>
    4000777c:	b9429802 	ldr	w2, [x0, #664]
				} else if (z_flag_echo_get(shell)) {
    40007780:	360fcf82 	tbz	w2, #1, 40007170 <shell_process+0x50>
	switch (data) {
    40007784:	51000421 	sub	w1, w1, #0x1
    40007788:	7100583f 	cmp	w1, #0x16
    4000778c:	54ffcf28 	b.hi	40007170 <shell_process+0x50>  // b.pmore
    40007790:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40007794:	91012042 	add	x2, x2, #0x48
    40007798:	78615841 	ldrh	w1, [x2, w1, uxtw #1]
    4000779c:	10000062 	adr	x2, 400077a8 <shell_process+0x688>
    400077a0:	8b21a841 	add	x1, x2, w1, sxth #2
    400077a4:	d61f0020 	br	x1
		z_shell_op_left_arrow(shell);
    400077a8:	aa1303e0 	mov	x0, x19
    400077ac:	940004cd 	bl	40008ae0 <z_shell_op_left_arrow>
		break;
    400077b0:	17fffe70 	b	40007170 <shell_process+0x50>
		z_shell_op_cursor_end_move(shell);
    400077b4:	aa1303e0 	mov	x0, x19
    400077b8:	940004c5 	bl	40008acc <z_shell_op_cursor_end_move>
		if (!z_shell_cursor_in_empty_line(shell)) {
    400077bc:	aa1303e0 	mov	x0, x19
    400077c0:	94000419 	bl	40008824 <z_shell_cursor_in_empty_line>
    400077c4:	72001c1f 	tst	w0, #0xff
    400077c8:	54000061 	b.ne	400077d4 <shell_process+0x6b4>  // b.any
			z_cursor_next_line_move(shell);
    400077cc:	f9401660 	ldr	x0, [x19, #40]
    400077d0:	97fffcaa 	bl	40006a78 <z_cursor_next_line_move.isra.0>
		z_flag_history_exit_set(shell, true);
    400077d4:	f9400a60 	ldr	x0, [x19, #16]
    400077d8:	52800021 	mov	w1, #0x1                   	// #1
    400077dc:	97fffcaa 	bl	40006a84 <z_flag_history_exit_set.isra.0>
    400077e0:	17fffeb7 	b	400072bc <shell_process+0x19c>
		z_shell_op_right_arrow(shell);
    400077e4:	aa1303e0 	mov	x0, x19
    400077e8:	940004c4 	bl	40008af8 <z_shell_op_right_arrow>
		break;
    400077ec:	17fffe61 	b	40007170 <shell_process+0x50>
		z_shell_op_delete_from_cursor(shell);
    400077f0:	aa1303e0 	mov	x0, x19
    400077f4:	940004c9 	bl	40008b18 <z_shell_op_delete_from_cursor>
		break;
    400077f8:	17fffe5e 	b	40007170 <shell_process+0x50>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    400077fc:	b9429800 	ldr	w0, [x0, #664]
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
    40007800:	362800c0 	tbz	w0, #5, 40007818 <shell_process+0x6f8>
    40007804:	f9401660 	ldr	x0, [x19, #40]
    40007808:	90000061 	adrp	x1, 40013000 <shell_cmd_kernel>
    4000780c:	91014021 	add	x1, x1, #0x50
    40007810:	91001421 	add	x1, x1, #0x5
    40007814:	97fffc44 	bl	40006924 <z_shell_raw_fprintf>
    40007818:	f9400a60 	ldr	x0, [x19, #16]
    4000781c:	b9429800 	ldr	w0, [x0, #664]
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
    40007820:	362800c0 	tbz	w0, #5, 40007838 <shell_process+0x718>
    40007824:	f9401660 	ldr	x0, [x19, #40]
    40007828:	90000061 	adrp	x1, 40013000 <shell_cmd_kernel>
    4000782c:	91014021 	add	x1, x1, #0x50
    40007830:	91002821 	add	x1, x1, #0xa
    40007834:	97fffc3c 	bl	40006924 <z_shell_raw_fprintf>
		z_shell_print_prompt_and_cmd(shell);
    40007838:	aa1303e0 	mov	x0, x19
    4000783c:	9400069d 	bl	400092b0 <z_shell_print_prompt_and_cmd>
		break;
    40007840:	17fffe4c 	b	40007170 <shell_process+0x50>
		history_handle(shell, false);
    40007844:	52800001 	mov	w1, #0x0                   	// #0
		history_handle(shell, true);
    40007848:	aa1303e0 	mov	x0, x19
    4000784c:	97fffc95 	bl	40006aa0 <history_handle>
		break;
    40007850:	17fffe48 	b	40007170 <shell_process+0x50>
		history_handle(shell, true);
    40007854:	52800021 	mov	w1, #0x1                   	// #1
    40007858:	17fffffc 	b	40007848 <shell_process+0x728>
		z_shell_op_cursor_home_move(shell);
    4000785c:	aa1303e0 	mov	x0, x19
    40007860:	94000497 	bl	40008abc <z_shell_op_cursor_home_move>
		cmd_buffer_clear(shell);
    40007864:	f9400a60 	ldr	x0, [x19, #16]
		z_flag_history_exit_set(shell, true);
    40007868:	52800021 	mov	w1, #0x1                   	// #1
	shell->ctx->cmd_buff_len = 0;
    4000786c:	b900701f 	str	wzr, [x0, #112]
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
    40007870:	3901d81f 	strb	wzr, [x0, #118]
		z_flag_history_exit_set(shell, true);
    40007874:	97fffc84 	bl	40006a84 <z_flag_history_exit_set.isra.0>
    40007878:	f9400a60 	ldr	x0, [x19, #16]
    4000787c:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
    40007880:	362fc780 	tbz	w0, #5, 40007170 <shell_process+0x50>
    40007884:	f9401660 	ldr	x0, [x19, #40]
    40007888:	90000061 	adrp	x1, 40013000 <shell_cmd_kernel>
    4000788c:	91014021 	add	x1, x1, #0x50
    40007890:	97fffc25 	bl	40006924 <z_shell_raw_fprintf>
    40007894:	17fffe37 	b	40007170 <shell_process+0x50>
		z_shell_op_word_remove(shell);
    40007898:	aa1303e0 	mov	x0, x19
    4000789c:	94000574 	bl	40008e6c <z_shell_op_word_remove>
		z_flag_history_exit_set(shell, true);
    400078a0:	f9400a60 	ldr	x0, [x19, #16]
    400078a4:	52800021 	mov	w1, #0x1                   	// #1
    400078a8:	97fffc77 	bl	40006a84 <z_flag_history_exit_set.isra.0>
		break;
    400078ac:	17fffe31 	b	40007170 <shell_process+0x50>
			if (data == '[') {
    400078b0:	71016c3f 	cmp	w1, #0x5b
    400078b4:	54000061 	b.ne	400078c0 <shell_process+0x7a0>  // b.any
	shell->ctx->receive_state = state;
    400078b8:	52800041 	mov	w1, #0x2                   	// #2
    400078bc:	17fffe95 	b	40007310 <shell_process+0x1f0>
	return sh->ctx->cfg.flags.echo == 1;
    400078c0:	b9429800 	ldr	w0, [x0, #664]
			} else if (z_flag_echo_get(shell)) {
    400078c4:	360800c0 	tbz	w0, #1, 400078dc <shell_process+0x7bc>
	if (data == SHELL_VT100_ASCII_ALT_B) {
    400078c8:	7101883f 	cmp	w1, #0x62
    400078cc:	540000e1 	b.ne	400078e8 <shell_process+0x7c8>  // b.any
		z_shell_op_cursor_word_move(shell, -1);
    400078d0:	12800001 	mov	w1, #0xffffffff            	// #-1
		z_shell_op_cursor_word_move(shell, 1);
    400078d4:	aa1303e0 	mov	x0, x19
    400078d8:	94000445 	bl	400089ec <z_shell_op_cursor_word_move>
	shell->ctx->receive_state = state;
    400078dc:	f9400a60 	ldr	x0, [x19, #16]
    400078e0:	b9000c1f 	str	wzr, [x0, #12]
}
    400078e4:	17fffe23 	b	40007170 <shell_process+0x50>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
    400078e8:	7101983f 	cmp	w1, #0x66
    400078ec:	54ffff81 	b.ne	400078dc <shell_process+0x7bc>  // b.any
		z_shell_op_cursor_word_move(shell, 1);
    400078f0:	52800021 	mov	w1, #0x1                   	// #1
    400078f4:	17fffff8 	b	400078d4 <shell_process+0x7b4>
    400078f8:	b9429802 	ldr	w2, [x0, #664]
	shell->ctx->receive_state = state;
    400078fc:	b9000c1f 	str	wzr, [x0, #12]
			if (!z_flag_echo_get(shell)) {
    40007900:	360fc382 	tbz	w2, #1, 40007170 <shell_process+0x50>
			switch (data) {
    40007904:	5100c421 	sub	w1, w1, #0x31
    40007908:	71006c3f 	cmp	w1, #0x1b
    4000790c:	54ffc328 	b.hi	40007170 <shell_process+0x50>  // b.pmore
    40007910:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40007914:	9101e042 	add	x2, x2, #0x78
    40007918:	78615841 	ldrh	w1, [x2, w1, uxtw #1]
    4000791c:	10000062 	adr	x2, 40007928 <shell_process+0x808>
    40007920:	8b21a841 	add	x1, x2, w1, sxth #2
    40007924:	d61f0020 	br	x1
	shell->ctx->receive_state = state;
    40007928:	52800061 	mov	w1, #0x3                   	// #3
    4000792c:	b9000c01 	str	w1, [x0, #12]
		z_shell_op_cursor_end_move(shell);
    40007930:	aa1303e0 	mov	x0, x19
    40007934:	94000466 	bl	40008acc <z_shell_op_cursor_end_move>
		break;
    40007938:	17fffe0e 	b	40007170 <shell_process+0x50>
	shell->ctx->receive_state = state;
    4000793c:	52800061 	mov	w1, #0x3                   	// #3
    40007940:	b9000c01 	str	w1, [x0, #12]
		z_shell_op_cursor_home_move(shell);
    40007944:	aa1303e0 	mov	x0, x19
    40007948:	9400045d 	bl	40008abc <z_shell_op_cursor_home_move>
		break;
    4000794c:	17fffe09 	b	40007170 <shell_process+0x50>
	shell->ctx->receive_state = state;
    40007950:	52800061 	mov	w1, #0x3                   	// #3
    40007954:	b9000c01 	str	w1, [x0, #12]
	return sh->ctx->cfg.flags.insert_mode == 1;
    40007958:	b9429801 	ldr	w1, [x0, #664]
    4000795c:	12000021 	and	w1, w1, #0x1
				z_flag_insert_mode_set(shell, !status);
    40007960:	52000021 	eor	w1, w1, #0x1
    40007964:	17fffecb 	b	40007490 <shell_process+0x370>
	shell->ctx->receive_state = state;
    40007968:	52800061 	mov	w1, #0x3                   	// #3
    4000796c:	b9000c01 	str	w1, [x0, #12]
	return sh->ctx->cfg.flags.echo == 1;
    40007970:	b9429800 	ldr	w0, [x0, #664]
				if (z_flag_echo_get(shell)) {
    40007974:	360fbfe0 	tbz	w0, #1, 40007170 <shell_process+0x50>
    40007978:	17fffe62 	b	40007300 <shell_process+0x1e0>

000000004000797c <shell_init>:
{
    4000797c:	d10183ff 	sub	sp, sp, #0x60
    40007980:	a9017bfd 	stp	x29, x30, [sp, #16]
    40007984:	910043fd 	add	x29, sp, #0x10
    40007988:	a90253f3 	stp	x19, x20, [sp, #32]
    4000798c:	aa0003f3 	mov	x19, x0
	if (shell->ctx->tid) {
    40007990:	f9400800 	ldr	x0, [x0, #16]
{
    40007994:	a90463f7 	stp	x23, x24, [sp, #64]
    40007998:	aa0103f7 	mov	x23, x1
    4000799c:	a9035bf5 	stp	x21, x22, [sp, #48]
	if (shell->ctx->tid) {
    400079a0:	f941e401 	ldr	x1, [x0, #968]
{
    400079a4:	f9002bf9 	str	x25, [sp, #80]
	if (shell->ctx->tid) {
    400079a8:	b5000a21 	cbnz	x1, 40007aec <shell_init+0x170>
    400079ac:	12001c79 	and	w25, w3, #0xff
    400079b0:	2a0403f6 	mov	w22, w4
static int instance_init(const struct shell *sh,
    400079b4:	2a0203f4 	mov	w20, w2
	memset(sh->ctx, 0, sizeof(*sh->ctx));
    400079b8:	d2807a02 	mov	x2, #0x3d0                 	// #976
    400079bc:	940010c8 	bl	4000bcdc <memset>
	sh->ctx->prompt = sh->default_prompt;
    400079c0:	f9400a60 	ldr	x0, [x19, #16]
    400079c4:	f9400261 	ldr	x1, [x19]
    400079c8:	f9000001 	str	x1, [x0]
	z_shell_history_init(shell->history);
    400079cc:	f9400e60 	ldr	x0, [x19, #24]
    400079d0:	94000a47 	bl	4000a2ec <z_shell_history_init>
	k_mutex_init(&sh->ctx->wr_mtx);
    400079d4:	f9400a60 	ldr	x0, [x19, #16]
    400079d8:	910ea000 	add	x0, x0, #0x3a8
	return z_impl_k_mutex_init(mutex);
    400079dc:	d2806118 	mov	x24, #0x308                 	// #776
    400079e0:	d2805515 	mov	x21, #0x2a8                 	// #680
    400079e4:	94001d5d 	bl	4000ef58 <z_impl_k_mutex_init>
		k_poll_signal_init(&sh->ctx->signals[i]);
    400079e8:	f9400a60 	ldr	x0, [x19, #16]
    400079ec:	8b150000 	add	x0, x0, x21
	z_impl_k_poll_signal_init(sig);
    400079f0:	9400252b 	bl	40010e9c <z_impl_k_poll_signal_init>
		k_poll_event_init(&sh->ctx->events[i],
    400079f4:	f9400a60 	ldr	x0, [x19, #16]
    400079f8:	52800002 	mov	w2, #0x0                   	// #0
    400079fc:	52800021 	mov	w1, #0x1                   	// #1
    40007a00:	8b150003 	add	x3, x0, x21
    40007a04:	8b180000 	add	x0, x0, x24
	for (int i = 0; i < SHELL_SIGNALS; i++) {
    40007a08:	910062b5 	add	x21, x21, #0x18
		k_poll_event_init(&sh->ctx->events[i],
    40007a0c:	940024db 	bl	40010d78 <k_poll_event_init>
	for (int i = 0; i < SHELL_SIGNALS; i++) {
    40007a10:	9100a318 	add	x24, x24, #0x28
    40007a14:	f10c22bf 	cmp	x21, #0x308
    40007a18:	54fffe81 	b.ne	400079e8 <shell_init+0x6c>  // b.any
		sh->stats->log_lost_cnt = 0;
    40007a1c:	f9401a60 	ldr	x0, [x19, #48]
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, tx_rdy, val, ret);
    40007a20:	d2800041 	mov	x1, #0x2                   	// #2
	sh->ctx->cfg.flags = cfg_flags;
    40007a24:	121d7a94 	and	w20, w20, #0xfffffffb
		sh->stats->log_lost_cnt = 0;
    40007a28:	f900001f 	str	xzr, [x0]
    40007a2c:	f9400a60 	ldr	x0, [x19, #16]
    40007a30:	910a8000 	add	x0, x0, #0x2a0
    40007a34:	97fffb89 	bl	40006858 <atomic_or>
	sh->ctx->vt100_ctx.cons.terminal_wid =
    40007a38:	f9400a60 	ldr	x0, [x19, #16]
	sh->ctx->vt100_ctx.cons.terminal_hei =
    40007a3c:	52800301 	mov	w1, #0x18                  	// #24
    40007a40:	72a00a01 	movk	w1, #0x50, lsl #16
    40007a44:	b9004801 	str	w1, [x0, #72]
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
    40007a48:	f9400000 	ldr	x0, [x0]
    40007a4c:	97fffbad 	bl	40006900 <z_shell_strlen>
    40007a50:	f9400a61 	ldr	x1, [x19, #16]
	int ret = sh->iface->api->init(sh->iface, transport_config,
    40007a54:	aa1303e3 	mov	x3, x19
    40007a58:	f0ffffe2 	adrp	x2, 40006000 <cmd_devmem+0x14c>
    40007a5c:	91276042 	add	x2, x2, #0x9d8
	sh->ctx->vt100_ctx.cons.name_len = z_shell_strlen(sh->ctx->prompt);
    40007a60:	39013020 	strb	w0, [x1, #76]
	int ret = sh->iface->api->init(sh->iface, transport_config,
    40007a64:	f9400660 	ldr	x0, [x19, #8]
	sh->ctx->cfg.flags = cfg_flags;
    40007a68:	b9029834 	str	w20, [x1, #664]
	int ret = sh->iface->api->init(sh->iface, transport_config,
    40007a6c:	f9400001 	ldr	x1, [x0]
    40007a70:	f9400024 	ldr	x4, [x1]
    40007a74:	aa1703e1 	mov	x1, x23
    40007a78:	d63f0080 	blr	x4
    40007a7c:	2a0003f4 	mov	w20, w0
	if (ret == 0) {
    40007a80:	35000260 	cbnz	w0, 40007acc <shell_init+0x150>
	shell->ctx->state = state;
    40007a84:	f9400a60 	ldr	x0, [x19, #16]
    40007a88:	52800021 	mov	w1, #0x1                   	// #1
    40007a8c:	b9000801 	str	w1, [x0, #8]
	k_tid_t tid = k_thread_create(shell->thread,
    40007a90:	a9450660 	ldp	x0, x1, [x19, #80]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    40007a94:	b90003ff 	str	wzr, [sp]
    40007a98:	2a1603e6 	mov	w6, w22
    40007a9c:	f90007ff 	str	xzr, [sp, #8]
    40007aa0:	92401f25 	and	x5, x25, #0xff
    40007aa4:	aa1303e4 	mov	x4, x19
    40007aa8:	528001c7 	mov	w7, #0xe                   	// #14
    40007aac:	d2810002 	mov	x2, #0x800                 	// #2048
    40007ab0:	90000003 	adrp	x3, 40007000 <execute+0x3b4>
    40007ab4:	912da063 	add	x3, x3, #0xb68
    40007ab8:	94001c18 	bl	4000eb18 <z_impl_k_thread_create>
	shell->ctx->tid = tid;
    40007abc:	f9400a61 	ldr	x1, [x19, #16]
    40007ac0:	f901e420 	str	x0, [x1, #968]
	k_thread_name_set(tid, shell->thread_name);
    40007ac4:	f9402661 	ldr	x1, [x19, #72]
	return z_impl_k_thread_name_set(thread, str);
    40007ac8:	94001b8f 	bl	4000e904 <z_impl_k_thread_name_set>
}
    40007acc:	2a1403e0 	mov	w0, w20
    40007ad0:	a9417bfd 	ldp	x29, x30, [sp, #16]
    40007ad4:	a94253f3 	ldp	x19, x20, [sp, #32]
    40007ad8:	a9435bf5 	ldp	x21, x22, [sp, #48]
    40007adc:	a94463f7 	ldp	x23, x24, [sp, #64]
    40007ae0:	f9402bf9 	ldr	x25, [sp, #80]
    40007ae4:	910183ff 	add	sp, sp, #0x60
    40007ae8:	d65f03c0 	ret
		return -EALREADY;
    40007aec:	12800ef4 	mov	w20, #0xffffff88            	// #-120
    40007af0:	17fffff7 	b	40007acc <shell_init+0x150>

0000000040007af4 <shell_start>:
{
    40007af4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40007af8:	910003fd 	mov	x29, sp
    40007afc:	f9000bf3 	str	x19, [sp, #16]
    40007b00:	aa0003f3 	mov	x19, x0
	return shell->ctx->state;
    40007b04:	f9400800 	ldr	x0, [x0, #16]
	if (state_get(shell) != SHELL_STATE_INITIALIZED) {
    40007b08:	b9400801 	ldr	w1, [x0, #8]
    40007b0c:	7100043f 	cmp	w1, #0x1
    40007b10:	54000281 	b.ne	40007b60 <shell_start+0x6c>  // b.any
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40007b14:	910ea000 	add	x0, x0, #0x3a8
    40007b18:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40007b1c:	97fffbae 	bl	400069d4 <k_mutex_lock.constprop.0.isra.0>
		z_shell_vt100_color_set(shell, SHELL_NORMAL);
    40007b20:	aa1303e0 	mov	x0, x19
    40007b24:	52800101 	mov	w1, #0x8                   	// #8
    40007b28:	94000456 	bl	40008c80 <z_shell_vt100_color_set>
	z_shell_raw_fprintf(shell->fprintf_ctx, "\n\n");
    40007b2c:	f9401660 	ldr	x0, [x19, #40]
    40007b30:	b0000061 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40007b34:	911bdc21 	add	x1, x1, #0x6f7
    40007b38:	97fffb7b 	bl	40006924 <z_shell_raw_fprintf>
	state_set(shell, SHELL_STATE_ACTIVE);
    40007b3c:	aa1303e0 	mov	x0, x19
    40007b40:	97fffd5c 	bl	400070b0 <state_set.constprop.0>
	k_mutex_unlock(&shell->ctx->wr_mtx);
    40007b44:	f9400a60 	ldr	x0, [x19, #16]
    40007b48:	910ea000 	add	x0, x0, #0x3a8
    40007b4c:	97fffc20 	bl	40006bcc <k_mutex_unlock.isra.0>
	return 0;
    40007b50:	52800000 	mov	w0, #0x0                   	// #0
}
    40007b54:	f9400bf3 	ldr	x19, [sp, #16]
    40007b58:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40007b5c:	d65f03c0 	ret
		return -ENOTSUP;
    40007b60:	128010a0 	mov	w0, #0xffffff7a            	// #-134
    40007b64:	17fffffc 	b	40007b54 <shell_start+0x60>

0000000040007b68 <shell_thread>:
{
    40007b68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40007b6c:	910003fd 	mov	x29, sp
    40007b70:	a90153f3 	stp	x19, x20, [sp, #16]
    40007b74:	aa0003f3 	mov	x19, x0
    40007b78:	aa0203f4 	mov	x20, x2
	err = shell->iface->api->enable(shell->iface, false);
    40007b7c:	f9400400 	ldr	x0, [x0, #8]
{
    40007b80:	a9025bf5 	stp	x21, x22, [sp, #32]
    40007b84:	aa0103f5 	mov	x21, x1
	err = shell->iface->api->enable(shell->iface, false);
    40007b88:	f9400001 	ldr	x1, [x0]
    40007b8c:	f9400822 	ldr	x2, [x1, #16]
    40007b90:	52800001 	mov	w1, #0x0                   	// #0
    40007b94:	d63f0040 	blr	x2
	if (err != 0) {
    40007b98:	35000760 	cbnz	w0, 40007c84 <shell_thread+0x11c>
	if (IS_ENABLED(CONFIG_SHELL_LOG_BACKEND) && log_backend
    40007b9c:	b40000b5 	cbz	x21, 40007bb0 <shell_thread+0x48>
		z_shell_log_backend_enable(shell->log_backend, (void *)shell,
    40007ba0:	f9401e60 	ldr	x0, [x19, #56]
    40007ba4:	2a1403e2 	mov	w2, w20
    40007ba8:	aa1303e1 	mov	x1, x19
    40007bac:	9400064e 	bl	400094e4 <z_shell_log_backend_enable>
	err = shell_start(shell);
    40007bb0:	aa1303e0 	mov	x0, x19
    40007bb4:	97ffffd0 	bl	40007af4 <shell_start>
	if (err != 0) {
    40007bb8:	35000660 	cbnz	w0, 40007c84 <shell_thread+0x11c>
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
    40007bbc:	f0fffff6 	adrp	x22, 40006000 <cmd_devmem+0x14c>
    40007bc0:	9127d2d6 	add	x22, x22, #0x9f4
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
    40007bc4:	90000015 	adrp	x21, 40007000 <execute+0x3b4>
    40007bc8:	910482b5 	add	x21, x21, #0x120
		err = k_poll(shell->ctx->events, SHELL_SIGNAL_TXDONE,
    40007bcc:	f9400a60 	ldr	x0, [x19, #16]
    40007bd0:	910c2000 	add	x0, x0, #0x308
	return z_impl_k_poll(events, num_events, timeout);
    40007bd4:	52800061 	mov	w1, #0x3                   	// #3
    40007bd8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    40007bdc:	94002470 	bl	40010d9c <z_impl_k_poll>
    40007be0:	2a0003f4 	mov	w20, w0
		if (err != 0) {
    40007be4:	f9400a60 	ldr	x0, [x19, #16]
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40007be8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40007bec:	910ea000 	add	x0, x0, #0x3a8
		if (err != 0) {
    40007bf0:	340001d4 	cbz	w20, 40007c28 <shell_thread+0xc0>
			k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40007bf4:	97fffb78 	bl	400069d4 <k_mutex_lock.constprop.0.isra.0>
			z_shell_fprintf(shell, SHELL_ERROR,
    40007bf8:	2a1403e3 	mov	w3, w20
    40007bfc:	aa1303e0 	mov	x0, x19
    40007c00:	52800021 	mov	w1, #0x1                   	// #1
    40007c04:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40007c08:	912e7042 	add	x2, x2, #0xb9c
    40007c0c:	9400047b 	bl	40008df8 <z_shell_fprintf>
			k_mutex_unlock(&shell->ctx->wr_mtx);
    40007c10:	f9400a60 	ldr	x0, [x19, #16]
}
    40007c14:	a94153f3 	ldp	x19, x20, [sp, #16]
			k_mutex_unlock(&shell->ctx->wr_mtx);
    40007c18:	910ea000 	add	x0, x0, #0x3a8
}
    40007c1c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40007c20:	a8c37bfd 	ldp	x29, x30, [sp], #48
			k_mutex_unlock(&shell->ctx->wr_mtx);
    40007c24:	17fffbea 	b	40006bcc <k_mutex_unlock.isra.0>
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
    40007c28:	97fffb6b 	bl	400069d4 <k_mutex_lock.constprop.0.isra.0>
		if (shell->iface->api->update) {
    40007c2c:	f9400660 	ldr	x0, [x19, #8]
    40007c30:	f9400001 	ldr	x1, [x0]
    40007c34:	f9401421 	ldr	x1, [x1, #40]
    40007c38:	b4000041 	cbz	x1, 40007c40 <shell_thread+0xd8>
			shell->iface->api->update(shell->iface);
    40007c3c:	d63f0020 	blr	x1
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
    40007c40:	aa1603e2 	mov	x2, x22
    40007c44:	aa1303e0 	mov	x0, x19
    40007c48:	52800041 	mov	w1, #0x2                   	// #2
    40007c4c:	97fffb13 	bl	40006898 <shell_signal_handle>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
    40007c50:	aa1503e2 	mov	x2, x21
    40007c54:	aa1303e0 	mov	x0, x19
    40007c58:	52800001 	mov	w1, #0x0                   	// #0
    40007c5c:	97fffb0f 	bl	40006898 <shell_signal_handle>
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
    40007c60:	aa1303e0 	mov	x0, x19
    40007c64:	52800021 	mov	w1, #0x1                   	// #1
    40007c68:	f0ffffe2 	adrp	x2, 40006000 <cmd_devmem+0x14c>
    40007c6c:	912f4042 	add	x2, x2, #0xbd0
    40007c70:	97fffb0a 	bl	40006898 <shell_signal_handle>
		k_mutex_unlock(&shell->ctx->wr_mtx);
    40007c74:	f9400a60 	ldr	x0, [x19, #16]
    40007c78:	910ea000 	add	x0, x0, #0x3a8
    40007c7c:	97fffbd4 	bl	40006bcc <k_mutex_unlock.isra.0>
    40007c80:	17ffffd3 	b	40007bcc <shell_thread+0x64>
}
    40007c84:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007c88:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40007c8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40007c90:	d65f03c0 	ret

0000000040007c94 <shell_vfprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_vfprintf(const struct shell *sh, enum shell_vt100_color color,
		   const char *fmt, va_list args)
{
    40007c94:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40007c98:	910003fd 	mov	x29, sp
    40007c9c:	a90153f3 	stp	x19, x20, [sp, #16]
    40007ca0:	aa0003f3 	mov	x19, x0
	return shell->ctx->state;
    40007ca4:	f9400800 	ldr	x0, [x0, #16]
{
    40007ca8:	a9025bf5 	stp	x21, x22, [sp, #32]
    40007cac:	2a0103f5 	mov	w21, w1
			(k_current_get() != sh->ctx->tid));
	__ASSERT_NO_MSG(sh->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	/* Sending a message to a non-active shell leads to a dead lock. */
	if (state_get(sh) != SHELL_STATE_ACTIVE) {
    40007cb0:	b9400801 	ldr	w1, [x0, #8]
    40007cb4:	7100083f 	cmp	w1, #0x2
    40007cb8:	540000e0 	b.eq	40007cd4 <shell_vfprintf+0x40>  // b.none
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
		z_shell_print_prompt_and_cmd(sh);
	}
	z_transport_buffer_flush(sh);
	k_mutex_unlock(&sh->ctx->wr_mtx);
}
    40007cbc:	a94153f3 	ldp	x19, x20, [sp, #16]
	Z_SHELL_SET_FLAG_ATOMIC(sh, ctx, print_noinit, val, ret);
    40007cc0:	910a8000 	add	x0, x0, #0x2a0
    40007cc4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40007cc8:	d2820001 	mov	x1, #0x1000                	// #4096
    40007ccc:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40007cd0:	17fffae2 	b	40006858 <atomic_or>
	k_mutex_lock(&sh->ctx->wr_mtx, K_FOREVER);
    40007cd4:	910ea000 	add	x0, x0, #0x3a8
    40007cd8:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
    40007cdc:	aa0203f6 	mov	x22, x2
    40007ce0:	aa0303f4 	mov	x20, x3
    40007ce4:	97fffb3c 	bl	400069d4 <k_mutex_lock.constprop.0.isra.0>
	return sh->ctx->ctx.flags.cmd_ctx == 1;
    40007ce8:	f9400a60 	ldr	x0, [x19, #16]
    40007cec:	b942a001 	ldr	w1, [x0, #672]
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
    40007cf0:	375800a1 	tbnz	w1, #11, 40007d04 <shell_vfprintf+0x70>
    40007cf4:	f9403400 	ldr	x0, [x0, #104]
    40007cf8:	b5000060 	cbnz	x0, 40007d04 <shell_vfprintf+0x70>
		z_shell_cmd_line_erase(sh);
    40007cfc:	aa1303e0 	mov	x0, x19
    40007d00:	9400038c 	bl	40008b30 <z_shell_cmd_line_erase>
	z_shell_vfprintf(sh, color, fmt, args);
    40007d04:	a9400680 	ldp	x0, x1, [x20]
    40007d08:	a90307e0 	stp	x0, x1, [sp, #48]
    40007d0c:	9100c3e3 	add	x3, sp, #0x30
    40007d10:	a9410680 	ldp	x0, x1, [x20, #16]
    40007d14:	aa1603e2 	mov	x2, x22
    40007d18:	a90407e0 	stp	x0, x1, [sp, #64]
    40007d1c:	2a1503e1 	mov	w1, w21
    40007d20:	aa1303e0 	mov	x0, x19
    40007d24:	94000408 	bl	40008d44 <z_shell_vfprintf>
    40007d28:	f9400a60 	ldr	x0, [x19, #16]
    40007d2c:	b942a001 	ldr	w1, [x0, #672]
	if (!z_flag_cmd_ctx_get(sh) && !sh->ctx->bypass) {
    40007d30:	375800a1 	tbnz	w1, #11, 40007d44 <shell_vfprintf+0xb0>
    40007d34:	f9403400 	ldr	x0, [x0, #104]
    40007d38:	b5000060 	cbnz	x0, 40007d44 <shell_vfprintf+0xb0>
		z_shell_print_prompt_and_cmd(sh);
    40007d3c:	aa1303e0 	mov	x0, x19
    40007d40:	9400055c 	bl	400092b0 <z_shell_print_prompt_and_cmd>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
    40007d44:	f9401660 	ldr	x0, [x19, #40]
    40007d48:	94000047 	bl	40007e64 <z_shell_fprintf_buffer_flush>
	k_mutex_unlock(&sh->ctx->wr_mtx);
    40007d4c:	f9400a60 	ldr	x0, [x19, #16]
}
    40007d50:	a94153f3 	ldp	x19, x20, [sp, #16]
	k_mutex_unlock(&sh->ctx->wr_mtx);
    40007d54:	910ea000 	add	x0, x0, #0x3a8
}
    40007d58:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40007d5c:	a8c57bfd 	ldp	x29, x30, [sp], #80
	k_mutex_unlock(&sh->ctx->wr_mtx);
    40007d60:	17fffb9b 	b	40006bcc <k_mutex_unlock.isra.0>

0000000040007d64 <shell_fprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_fprintf(const struct shell *shell, enum shell_vt100_color color,
		   const char *fmt, ...)
{
    40007d64:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40007d68:	910003fd 	mov	x29, sp
    40007d6c:	a90d93e3 	stp	x3, x4, [sp, #216]
	va_list args;

	va_start(args, fmt);
    40007d70:	910403e3 	add	x3, sp, #0x100
    40007d74:	a9030fe3 	stp	x3, x3, [sp, #48]
    40007d78:	910343e3 	add	x3, sp, #0xd0
    40007d7c:	f90023e3 	str	x3, [sp, #64]
    40007d80:	128004e3 	mov	w3, #0xffffffd8            	// #-40
    40007d84:	b9004be3 	str	w3, [sp, #72]
    40007d88:	12800fe3 	mov	w3, #0xffffff80            	// #-128
    40007d8c:	b9004fe3 	str	w3, [sp, #76]
	shell_vfprintf(shell, color, fmt, args);
    40007d90:	910043e3 	add	x3, sp, #0x10
{
    40007d94:	a90e9be5 	stp	x5, x6, [sp, #232]
	shell_vfprintf(shell, color, fmt, args);
    40007d98:	a94317e4 	ldp	x4, x5, [sp, #48]
    40007d9c:	a90117e4 	stp	x4, x5, [sp, #16]
    40007da0:	a94417e4 	ldp	x4, x5, [sp, #64]
    40007da4:	a90217e4 	stp	x4, x5, [sp, #32]
{
    40007da8:	3d8017e0 	str	q0, [sp, #80]
    40007dac:	3d801be1 	str	q1, [sp, #96]
    40007db0:	3d801fe2 	str	q2, [sp, #112]
    40007db4:	3d8023e3 	str	q3, [sp, #128]
    40007db8:	3d8027e4 	str	q4, [sp, #144]
    40007dbc:	3d802be5 	str	q5, [sp, #160]
    40007dc0:	3d802fe6 	str	q6, [sp, #176]
    40007dc4:	3d8033e7 	str	q7, [sp, #192]
    40007dc8:	f9007fe7 	str	x7, [sp, #248]
	shell_vfprintf(shell, color, fmt, args);
    40007dcc:	97ffffb2 	bl	40007c94 <shell_vfprintf>
	va_end(args);
}
    40007dd0:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40007dd4:	d65f03c0 	ret

0000000040007dd8 <cmd_help>:
{
	sh->ctx->bypass = bypass;
}

static int cmd_help(const struct shell *shell, size_t argc, char **argv)
{
    40007dd8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

#if defined(CONFIG_SHELL_TAB)
	shell_print(shell, "Please press the <Tab> button to see all available "
    40007ddc:	52800101 	mov	w1, #0x8                   	// #8
    40007de0:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40007de4:	912ecc42 	add	x2, x2, #0xbb3
{
    40007de8:	910003fd 	mov	x29, sp
    40007dec:	f9000bf3 	str	x19, [sp, #16]
    40007df0:	aa0003f3 	mov	x19, x0
	shell_print(shell, "Please press the <Tab> button to see all available "
    40007df4:	97ffffdc 	bl	40007d64 <shell_fprintf>
			   "commands.");
#endif

#if defined(CONFIG_SHELL_TAB_AUTOCOMPLETION)
	shell_print(shell,
    40007df8:	aa1303e0 	mov	x0, x19
    40007dfc:	52800101 	mov	w1, #0x8                   	// #8
    40007e00:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40007e04:	912fc442 	add	x2, x2, #0xbf1
    40007e08:	97ffffd7 	bl	40007d64 <shell_fprintf>
		"You can also use the <Tab> button to prompt or auto-complete"
		" all commands or its subcommands.");
#endif

#if defined(CONFIG_SHELL_HELP)
	shell_print(shell,
    40007e0c:	aa1303e0 	mov	x0, x19
    40007e10:	52800101 	mov	w1, #0x8                   	// #8
    40007e14:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40007e18:	91314042 	add	x2, x2, #0xc50
    40007e1c:	97ffffd2 	bl	40007d64 <shell_fprintf>
		"You can try to call commands with <-h> or <--help> parameter"
		" for more information.");
#endif

#if defined(CONFIG_SHELL_METAKEYS)
	shell_print(shell,
    40007e20:	aa1303e0 	mov	x0, x19
    40007e24:	52800101 	mov	w1, #0x8                   	// #8
    40007e28:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40007e2c:	91329042 	add	x2, x2, #0xca4
    40007e30:	97ffffcd 	bl	40007d64 <shell_fprintf>
		"Please refer to shell documentation for more details.");
#endif

	if (IS_ENABLED(CONFIG_SHELL_HELP)) {
		/* For NULL argument function will print all root commands */
		z_shell_help_subcmd_print(shell, NULL,
    40007e34:	aa1303e0 	mov	x0, x19
    40007e38:	d2800001 	mov	x1, #0x0                   	// #0
    40007e3c:	b0000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40007e40:	9134f842 	add	x2, x2, #0xd3e
    40007e44:	940006a9 	bl	400098e8 <z_shell_help_subcmd_print>
			shell_print(shell, "  %s", entry->syntax);
		}
	}

	return 0;
}
    40007e48:	52800000 	mov	w0, #0x0                   	// #0
    40007e4c:	f9400bf3 	ldr	x19, [sp, #16]
    40007e50:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40007e54:	d65f03c0 	ret

0000000040007e58 <shell_set_bypass>:
	sh->ctx->bypass = bypass;
    40007e58:	f9400800 	ldr	x0, [x0, #16]
    40007e5c:	f9003401 	str	x1, [x0, #104]
}
    40007e60:	d65f03c0 	ret

0000000040007e64 <z_shell_fprintf_buffer_flush>:
	}
}


void z_shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
    40007e64:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40007e68:	910003fd 	mov	x29, sp
    40007e6c:	f9000bf3 	str	x19, [sp, #16]
    40007e70:	aa0003f3 	mov	x19, x0
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
    40007e74:	f9400001 	ldr	x1, [x0]
    40007e78:	f9400803 	ldr	x3, [x0, #16]
    40007e7c:	f9401000 	ldr	x0, [x0, #32]
    40007e80:	f9400002 	ldr	x2, [x0]
    40007e84:	f9400e60 	ldr	x0, [x19, #24]
    40007e88:	d63f0060 	blr	x3
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
    40007e8c:	f9401260 	ldr	x0, [x19, #32]
}
    40007e90:	f9400bf3 	ldr	x19, [sp, #16]
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
    40007e94:	f900001f 	str	xzr, [x0]
}
    40007e98:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40007e9c:	d65f03c0 	ret

0000000040007ea0 <z_shell_fprintf_fmt>:
{
    40007ea0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40007ea4:	910003fd 	mov	x29, sp
	(void)cbvprintf(out_func, (void *)sh_fprintf, fmt, args);
    40007ea8:	a9401444 	ldp	x4, x5, [x2]
    40007eac:	a90217e4 	stp	x4, x5, [sp, #32]
    40007eb0:	a9410c42 	ldp	x2, x3, [x2, #16]
{
    40007eb4:	f9000bf3 	str	x19, [sp, #16]
    40007eb8:	aa0003f3 	mov	x19, x0
	(void)cbvprintf(out_func, (void *)sh_fprintf, fmt, args);
    40007ebc:	a9030fe2 	stp	x2, x3, [sp, #48]
    40007ec0:	aa0103e2 	mov	x2, x1
    40007ec4:	910083e3 	add	x3, sp, #0x20
    40007ec8:	aa0003e1 	mov	x1, x0
    40007ecc:	90000000 	adrp	x0, 40007000 <execute+0x3b4>
    40007ed0:	913c0000 	add	x0, x0, #0xf00
    40007ed4:	97ffe736 	bl	40001bac <cbvprintf>
	if (sh_fprintf->ctrl_blk->autoflush) {
    40007ed8:	f9401260 	ldr	x0, [x19, #32]
    40007edc:	39402000 	ldrb	w0, [x0, #8]
    40007ee0:	340000a0 	cbz	w0, 40007ef4 <z_shell_fprintf_fmt+0x54>
		z_shell_fprintf_buffer_flush(sh_fprintf);
    40007ee4:	aa1303e0 	mov	x0, x19
}
    40007ee8:	f9400bf3 	ldr	x19, [sp, #16]
    40007eec:	a8c47bfd 	ldp	x29, x30, [sp], #64
		z_shell_fprintf_buffer_flush(sh_fprintf);
    40007ef0:	17ffffdd 	b	40007e64 <z_shell_fprintf_buffer_flush>
}
    40007ef4:	f9400bf3 	ldr	x19, [sp, #16]
    40007ef8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40007efc:	d65f03c0 	ret

0000000040007f00 <out_func>:
{
    40007f00:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40007f04:	910003fd 	mov	x29, sp
    40007f08:	a90153f3 	stp	x19, x20, [sp, #16]
    40007f0c:	2a0003f4 	mov	w20, w0
    40007f10:	aa0103f3 	mov	x19, x1
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
    40007f14:	f9400c20 	ldr	x0, [x1, #24]
    40007f18:	b9402000 	ldr	w0, [x0, #32]
    40007f1c:	7100081f 	cmp	w0, #0x2
    40007f20:	540000a1 	b.ne	40007f34 <out_func+0x34>  // b.any
    40007f24:	71002a9f 	cmp	w20, #0xa
    40007f28:	54000061 	b.ne	40007f34 <out_func+0x34>  // b.any
		(void)out_func('\r', ctx);
    40007f2c:	528001a0 	mov	w0, #0xd                   	// #13
    40007f30:	97fffff4 	bl	40007f00 <out_func>
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (uint8_t)c;
    40007f34:	f9401260 	ldr	x0, [x19, #32]
    40007f38:	f9400261 	ldr	x1, [x19]
    40007f3c:	f9400000 	ldr	x0, [x0]
    40007f40:	38206834 	strb	w20, [x1, x0]
	sh_fprintf->ctrl_blk->buffer_cnt++;
    40007f44:	f9401261 	ldr	x1, [x19, #32]
    40007f48:	f9400020 	ldr	x0, [x1]
    40007f4c:	91000400 	add	x0, x0, #0x1
    40007f50:	f9000020 	str	x0, [x1]
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
    40007f54:	f9400661 	ldr	x1, [x19, #8]
    40007f58:	eb01001f 	cmp	x0, x1
    40007f5c:	54000061 	b.ne	40007f68 <out_func+0x68>  // b.any
		z_shell_fprintf_buffer_flush(sh_fprintf);
    40007f60:	aa1303e0 	mov	x0, x19
    40007f64:	97ffffc0 	bl	40007e64 <z_shell_fprintf_buffer_flush>
}
    40007f68:	52800000 	mov	w0, #0x0                   	// #0
    40007f6c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40007f70:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40007f74:	d65f03c0 	ret

0000000040007f78 <z_shell_strlen>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40007f78:	b40000e0 	cbz	x0, 40007f94 <z_shell_strlen+0x1c>
{
    40007f7c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40007f80:	910003fd 	mov	x29, sp
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40007f84:	94000f0b 	bl	4000bbb0 <strlen>
    40007f88:	12003c00 	and	w0, w0, #0xffff
}
    40007f8c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40007f90:	d65f03c0 	ret
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40007f94:	52800000 	mov	w0, #0x0                   	// #0
}
    40007f98:	d65f03c0 	ret

0000000040007f9c <z_column_span_with_buffer_offsets_get>:
/* Calculates column number of given position in buffer */
static uint32_t col_num_with_buffer_offset_get(struct shell_multiline_cons *cons,
					    uint16_t buffer_pos)
{
	/* columns are counted from 1 */
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
    40007f9c:	39403003 	ldrb	w3, [x0, #12]
    40007fa0:	79401404 	ldrh	w4, [x0, #10]
    40007fa4:	0b222062 	add	w2, w3, w2, uxth
    40007fa8:	0b212061 	add	w1, w3, w1, uxth
    40007fac:	1ac40840 	udiv	w0, w2, w4
    40007fb0:	1ac40823 	udiv	w3, w1, w4
    40007fb4:	1b048800 	msub	w0, w0, w4, w2
    40007fb8:	1b048463 	msub	w3, w3, w4, w1
					      uint16_t offset1,
					      uint16_t offset2)
{
	return col_num_with_buffer_offset_get(cons, offset2)
			- col_num_with_buffer_offset_get(cons, offset1);
}
    40007fbc:	4b030000 	sub	w0, w0, w3
    40007fc0:	d65f03c0 	ret

0000000040007fc4 <z_row_span_with_buffer_offsets_get>:
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
    40007fc4:	39403003 	ldrb	w3, [x0, #12]
    40007fc8:	79401404 	ldrh	w4, [x0, #10]
    40007fcc:	0b212061 	add	w1, w3, w1, uxth
    40007fd0:	0b222060 	add	w0, w3, w2, uxth
    40007fd4:	1ac40821 	udiv	w1, w1, w4
    40007fd8:	1ac40800 	udiv	w0, w0, w4
					   uint16_t offset1,
					   uint16_t offset2)
{
	return line_num_with_buffer_offset_get(cons, offset2)
		- line_num_with_buffer_offset_get(cons, offset1);
}
    40007fdc:	4b010000 	sub	w0, w0, w1
    40007fe0:	d65f03c0 	ret

0000000040007fe4 <z_shell_multiline_data_calc>:
				 uint16_t buff_pos, uint16_t buff_len)
{
	/* Current cursor position in command.
	 * +1 -> because home position is (1, 1)
	 */
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    40007fe4:	39403004 	ldrb	w4, [x0, #12]
    40007fe8:	79401405 	ldrh	w5, [x0, #10]
    40007fec:	0b212081 	add	w1, w4, w1, uxth
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;

	/* Extreme position when cursor is at the end of command. */
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    40007ff0:	0b222082 	add	w2, w4, w2, uxth
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    40007ff4:	1ac50826 	udiv	w6, w1, w5
    40007ff8:	1b0584c3 	msub	w3, w6, w5, w1
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
    40007ffc:	110004c6 	add	w6, w6, #0x1
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    40008000:	1ac50841 	udiv	w1, w2, w5
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
    40008004:	79000806 	strh	w6, [x0, #4]
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
    40008008:	11000463 	add	w3, w3, #0x1
    4000800c:	79000003 	strh	w3, [x0]
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    40008010:	11000423 	add	w3, w1, #0x1
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
    40008014:	1b058821 	msub	w1, w1, w5, w2
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
    40008018:	79000c03 	strh	w3, [x0, #6]
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
    4000801c:	11000421 	add	w1, w1, #0x1
    40008020:	79000401 	strh	w1, [x0, #2]
}
    40008024:	d65f03c0 	ret

0000000040008028 <z_shell_make_argv>:
}


char z_shell_make_argv(size_t *argc, const char **argv, char *cmd,
		       uint8_t max_argc)
{
    40008028:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4000802c:	910003fd 	mov	x29, sp
    40008030:	a90153f3 	stp	x19, x20, [sp, #16]
    40008034:	aa0203f3 	mov	x19, x2
    40008038:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000803c:	aa0003f5 	mov	x21, x0
    40008040:	aa0103f6 	mov	x22, x1
    40008044:	a90363f7 	stp	x23, x24, [sp, #48]
    40008048:	12001c77 	and	w23, w3, #0xff
	char quote = 0;
    4000804c:	52800018 	mov	w24, #0x0                   	// #0
{
    40008050:	a9046bf9 	stp	x25, x26, [sp, #64]
	char c;

	*argc = 0;
    40008054:	f900001f 	str	xzr, [x0]
{
    40008058:	f9002bfb 	str	x27, [sp, #80]
	do {
		c = *cmd;
    4000805c:	39400260 	ldrb	w0, [x19]
		if (c == '\0') {
    40008060:	340011a0 	cbz	w0, 40008294 <z_shell_make_argv+0x26c>
    40008064:	51002401 	sub	w1, w0, #0x9
    40008068:	7100801f 	cmp	w0, #0x20
			break;
		}

		if (isspace((int) c)) {
    4000806c:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    40008070:	54000068 	b.hi	4000807c <z_shell_make_argv+0x54>  // b.pmore
			*cmd++ = '\0';
    40008074:	3800167f 	strb	wzr, [x19], #1
			continue;
    40008078:	17fffff9 	b	4000805c <z_shell_make_argv+0x34>
		}

		argv[(*argc)++] = cmd;
    4000807c:	f94002a1 	ldr	x1, [x21]
    40008080:	91000420 	add	x0, x1, #0x1
    40008084:	f90002a0 	str	x0, [x21]
    40008088:	f8217ad3 	str	x19, [x22, x1, lsl #3]
		if (*argc == max_argc) {
    4000808c:	eb37001f 	cmp	x0, w23, uxtb
    40008090:	54001020 	b.eq	40008294 <z_shell_make_argv+0x26c>  // b.none
	char quote = 0;
    40008094:	52800018 	mov	w24, #0x0                   	// #0
		c = *cmd;
    40008098:	39400274 	ldrb	w20, [x19]
		if (c == '\0') {
    4000809c:	34fffe14 	cbz	w20, 4000805c <z_shell_make_argv+0x34>
		if (!quote) {
    400080a0:	35000338 	cbnz	w24, 40008104 <z_shell_make_argv+0xdc>
			switch (c) {
    400080a4:	71009e9f 	cmp	w20, #0x27
    400080a8:	540000a0 	b.eq	400080bc <z_shell_make_argv+0x94>  // b.none
    400080ac:	7101729f 	cmp	w20, #0x5c
    400080b0:	540001a0 	b.eq	400080e4 <z_shell_make_argv+0xbc>  // b.none
    400080b4:	71008a9f 	cmp	w20, #0x22
    400080b8:	540003c1 	b.ne	40008130 <z_shell_make_argv+0x108>  // b.any
				continue;
    400080bc:	2a1403f8 	mov	w24, w20
    400080c0:	aa1303f4 	mov	x20, x19
						z_shell_strlen(cmd));
    400080c4:	aa1303e0 	mov	x0, x19
    400080c8:	97ffffac 	bl	40007f78 <z_shell_strlen>
				memmove(cmd, cmd + 1,
    400080cc:	91000661 	add	x1, x19, #0x1
    400080d0:	92403c02 	and	x2, x0, #0xffff
    400080d4:	aa1303e0 	mov	x0, x19
    400080d8:	94000eea 	bl	4000bc80 <memmove>
				continue;
    400080dc:	aa1403f3 	mov	x19, x20
    400080e0:	17ffffee 	b	40008098 <z_shell_make_argv+0x70>
				memmove(cmd, cmd + 1,
    400080e4:	91000674 	add	x20, x19, #0x1
						z_shell_strlen(cmd));
    400080e8:	aa1303e0 	mov	x0, x19
    400080ec:	97ffffa3 	bl	40007f78 <z_shell_strlen>
				memmove(cmd, cmd + 1,
    400080f0:	aa1403e1 	mov	x1, x20
    400080f4:	92403c02 	and	x2, x0, #0xffff
    400080f8:	aa1303e0 	mov	x0, x19
    400080fc:	94000ee1 	bl	4000bc80 <memmove>
				continue;
    40008100:	17fffff7 	b	400080dc <z_shell_make_argv+0xb4>
		if (quote == c) {
    40008104:	6b18029f 	cmp	w20, w24
    40008108:	54000141 	b.ne	40008130 <z_shell_make_argv+0x108>  // b.any
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
    4000810c:	aa1303e0 	mov	x0, x19
    40008110:	97ffff9a 	bl	40007f78 <z_shell_strlen>
    40008114:	91000661 	add	x1, x19, #0x1
    40008118:	92403c02 	and	x2, x0, #0xffff
			continue;
    4000811c:	aa1303f4 	mov	x20, x19
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
    40008120:	aa1303e0 	mov	x0, x19
			quote = 0;
    40008124:	52800018 	mov	w24, #0x0                   	// #0
			memmove(cmd, cmd + 1, z_shell_strlen(cmd));
    40008128:	94000ed6 	bl	4000bc80 <memmove>
			continue;
    4000812c:	17ffffec 	b	400080dc <z_shell_make_argv+0xb4>
		if (quote && c == '\\') {
    40008130:	7101729f 	cmp	w20, #0x5c
    40008134:	7a400b04 	ccmp	w24, #0x0, #0x4, eq  // eq = none
    40008138:	54000a00 	b.eq	40008278 <z_shell_make_argv+0x250>  // b.none
			char t = *(cmd + 1);
    4000813c:	aa1303f4 	mov	x20, x19
    40008140:	38401e81 	ldrb	w1, [x20, #1]!
			if (t == quote) {
    40008144:	6b01031f 	cmp	w24, w1
    40008148:	54fffd00 	b.eq	400080e8 <z_shell_make_argv+0xc0>  // b.none
			if (t == '0') {
    4000814c:	7100c03f 	cmp	w1, #0x30
    40008150:	540003c1 	b.ne	400081c8 <z_shell_make_argv+0x1a0>  // b.any
    40008154:	d2800040 	mov	x0, #0x2                   	// #2
				uint8_t v = 0U;
    40008158:	52800019 	mov	w25, #0x0                   	// #0
					t = *(cmd + i);
    4000815c:	38606a61 	ldrb	w1, [x19, x0]
    40008160:	12001c1a 	and	w26, w0, #0xff
					if (t >= '0' && t <= '7') {
    40008164:	5100c022 	sub	w2, w1, #0x30
    40008168:	12001c43 	and	w3, w2, #0xff
    4000816c:	71001c7f 	cmp	w3, #0x7
    40008170:	54000288 	b.hi	400081c0 <z_shell_make_argv+0x198>  // b.pmore
						v = (v << 3) | (t - '0');
    40008174:	2a190c59 	orr	w25, w2, w25, lsl #3
				for (i = 2U; i < (2 + 3); i++) {
    40008178:	91000400 	add	x0, x0, #0x1
						v = (v << 3) | (t - '0');
    4000817c:	12001f39 	and	w25, w25, #0xff
				for (i = 2U; i < (2 + 3); i++) {
    40008180:	f100141f 	cmp	x0, #0x5
    40008184:	54fffec1 	b.ne	4000815c <z_shell_make_argv+0x134>  // b.any
    40008188:	2a0003fa 	mov	w26, w0
						z_shell_strlen(cmd) - (i - 2));
    4000818c:	aa1303e0 	mov	x0, x19
    40008190:	97ffff7a 	bl	40007f78 <z_shell_strlen>
    40008194:	12003c02 	and	w2, w0, #0xffff
					memmove(cmd, cmd + (i - 1),
    40008198:	5100075b 	sub	w27, w26, #0x1
						z_shell_strlen(cmd) - (i - 2));
    4000819c:	11000842 	add	w2, w2, #0x2
    400081a0:	4b1a0042 	sub	w2, w2, w26
					memmove(cmd, cmd + (i - 1),
    400081a4:	8b3bc27b 	add	x27, x19, w27, sxtw
    400081a8:	aa1b03e1 	mov	x1, x27
    400081ac:	93407c42 	sxtw	x2, w2
					memmove(cmd, cmd + (i - 1),
    400081b0:	aa1303e0 	mov	x0, x19
    400081b4:	94000eb3 	bl	4000bc80 <memmove>
					*cmd++ = v;
    400081b8:	39000279 	strb	w25, [x19]
					continue;
    400081bc:	17ffffc8 	b	400080dc <z_shell_make_argv+0xb4>
				if (i > 2) {
    400081c0:	71000b5f 	cmp	w26, #0x2
    400081c4:	54fffe41 	b.ne	4000818c <z_shell_make_argv+0x164>  // b.any
			if (t == 'x') {
    400081c8:	7101e03f 	cmp	w1, #0x78
    400081cc:	54000601 	b.ne	4000828c <z_shell_make_argv+0x264>  // b.any
    400081d0:	d2800040 	mov	x0, #0x2                   	// #2
				uint8_t v = 0U;
    400081d4:	52800019 	mov	w25, #0x0                   	// #0
					t = *(cmd + i);
    400081d8:	38606a62 	ldrb	w2, [x19, x0]
    400081dc:	12001c03 	and	w3, w0, #0xff
					if (t >= '0' && t <= '9') {
    400081e0:	5100c041 	sub	w1, w2, #0x30
    400081e4:	12001c24 	and	w4, w1, #0xff
    400081e8:	7100249f 	cmp	w4, #0x9
    400081ec:	54000248 	b.hi	40008234 <z_shell_make_argv+0x20c>  // b.pmore
						v = (v << 4) | (t - '0');
    400081f0:	2a191022 	orr	w2, w1, w25, lsl #4
						v = (v << 4) | (t - 'A' + 10);
    400081f4:	12001c59 	and	w25, w2, #0xff
				for (i = 2U; i < (2 + 2); i++) {
    400081f8:	f1000c1f 	cmp	x0, #0x3
    400081fc:	54000181 	b.ne	4000822c <z_shell_make_argv+0x204>  // b.any
    40008200:	5280009b 	mov	w27, #0x4                   	// #4
						z_shell_strlen(cmd) - (i - 2));
    40008204:	aa1303e0 	mov	x0, x19
    40008208:	97ffff5c 	bl	40007f78 <z_shell_strlen>
    4000820c:	12003c02 	and	w2, w0, #0xffff
					memmove(cmd, cmd + (i - 1),
    40008210:	5100077a 	sub	w26, w27, #0x1
						z_shell_strlen(cmd) - (i - 2));
    40008214:	11000842 	add	w2, w2, #0x2
    40008218:	4b1b0042 	sub	w2, w2, w27
					memmove(cmd, cmd + (i - 1),
    4000821c:	8b3ac27a 	add	x26, x19, w26, sxtw
    40008220:	aa1a03e1 	mov	x1, x26
    40008224:	93407c42 	sxtw	x2, w2
    40008228:	17ffffe2 	b	400081b0 <z_shell_make_argv+0x188>
    4000822c:	d2800060 	mov	x0, #0x3                   	// #3
    40008230:	17ffffea 	b	400081d8 <z_shell_make_argv+0x1b0>
					} else if ((t >= 'a') &&
    40008234:	51018441 	sub	w1, w2, #0x61
    40008238:	12001c21 	and	w1, w1, #0xff
    4000823c:	7100143f 	cmp	w1, #0x5
    40008240:	54000088 	b.hi	40008250 <z_shell_make_argv+0x228>  // b.pmore
						v = (v << 4) | (t - 'a' + 10);
    40008244:	51015c42 	sub	w2, w2, #0x57
						v = (v << 4) | (t - 'A' + 10);
    40008248:	2a191042 	orr	w2, w2, w25, lsl #4
    4000824c:	17ffffea 	b	400081f4 <z_shell_make_argv+0x1cc>
					} else if ((t >= 'A') && (t <= 'F')) {
    40008250:	51010441 	sub	w1, w2, #0x41
    40008254:	12001c21 	and	w1, w1, #0xff
    40008258:	7100143f 	cmp	w1, #0x5
    4000825c:	54000068 	b.hi	40008268 <z_shell_make_argv+0x240>  // b.pmore
						v = (v << 4) | (t - 'A' + 10);
    40008260:	5100dc42 	sub	w2, w2, #0x37
    40008264:	17fffff9 	b	40008248 <z_shell_make_argv+0x220>
				if (i > 2) {
    40008268:	7100087f 	cmp	w3, #0x2
    4000826c:	54000100 	b.eq	4000828c <z_shell_make_argv+0x264>  // b.none
    40008270:	5280007b 	mov	w27, #0x3                   	// #3
    40008274:	17ffffe4 	b	40008204 <z_shell_make_argv+0x1dc>
		if (!quote && isspace((int) c)) {
    40008278:	350000b8 	cbnz	w24, 4000828c <z_shell_make_argv+0x264>
    4000827c:	51002680 	sub	w0, w20, #0x9
    40008280:	7100829f 	cmp	w20, #0x20
    40008284:	7a441800 	ccmp	w0, #0x4, #0x0, ne  // ne = any
    40008288:	54ffeea9 	b.ls	4000805c <z_shell_make_argv+0x34>  // b.plast
		cmd += 1;
    4000828c:	91000674 	add	x20, x19, #0x1
    40008290:	17ffff93 	b	400080dc <z_shell_make_argv+0xb4>
		}
		quote = make_argv(&cmd, c);
	} while (true);

	return quote;
}
    40008294:	2a1803e0 	mov	w0, w24
    40008298:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000829c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400082a0:	a94363f7 	ldp	x23, x24, [sp, #48]
    400082a4:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400082a8:	f9402bfb 	ldr	x27, [sp, #80]
    400082ac:	a8c67bfd 	ldp	x29, x30, [sp], #96
    400082b0:	d65f03c0 	ret

00000000400082b4 <z_shell_pattern_remove>:

void z_shell_pattern_remove(char *buff, uint16_t *buff_len, const char *pattern)
{
    400082b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400082b8:	910003fd 	mov	x29, sp
    400082bc:	a9025bf5 	stp	x21, x22, [sp, #32]
    400082c0:	aa0103f5 	mov	x21, x1
	char *pattern_addr = strstr(buff, pattern);
    400082c4:	aa0203e1 	mov	x1, x2
{
    400082c8:	aa0003f6 	mov	x22, x0
    400082cc:	a90153f3 	stp	x19, x20, [sp, #16]
    400082d0:	aa0203f4 	mov	x20, x2
	char *pattern_addr = strstr(buff, pattern);
    400082d4:	94000deb 	bl	4000ba80 <strstr>
    400082d8:	aa0003f3 	mov	x19, x0
	uint16_t shift;
	uint16_t pattern_len = z_shell_strlen(pattern);
    400082dc:	aa1403e0 	mov	x0, x20
    400082e0:	97ffff26 	bl	40007f78 <z_shell_strlen>

	if (!pattern_addr) {
    400082e4:	b4000333 	cbz	x19, 40008348 <z_shell_pattern_remove+0x94>
    400082e8:	12003c14 	and	w20, w0, #0xffff
		return;
	}

	if (pattern_addr > buff) {
    400082ec:	eb1302df 	cmp	x22, x19
    400082f0:	540000e2 	b.cs	4000830c <z_shell_pattern_remove+0x58>  // b.hs, b.nlast
		if (*(pattern_addr - 1) == ' ') {
    400082f4:	385ff260 	ldurb	w0, [x19, #-1]
    400082f8:	7100801f 	cmp	w0, #0x20
    400082fc:	54000081 	b.ne	4000830c <z_shell_pattern_remove+0x58>  // b.any
			pattern_len++; /* space needs to be removed as well */
    40008300:	11000694 	add	w20, w20, #0x1
			pattern_addr--; /* set pointer to space */
    40008304:	d1000673 	sub	x19, x19, #0x1
			pattern_len++; /* space needs to be removed as well */
    40008308:	12003e94 	and	w20, w20, #0xffff
		}
	}

	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    4000830c:	aa1303e0 	mov	x0, x19
    40008310:	97ffff1a 	bl	40007f78 <z_shell_strlen>
    40008314:	12003c02 	and	w2, w0, #0xffff
	*buff_len -= pattern_len;
    40008318:	794002a0 	ldrh	w0, [x21]
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    4000831c:	4b140042 	sub	w2, w2, w20

	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    40008320:	8b342261 	add	x1, x19, w20, uxth
	*buff_len -= pattern_len;
    40008324:	4b140000 	sub	w0, w0, w20
    40008328:	790002a0 	strh	w0, [x21]
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    4000832c:	aa1303e0 	mov	x0, x19
	shift = z_shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
    40008330:	11000442 	add	w2, w2, #0x1
}
    40008334:	a94153f3 	ldp	x19, x20, [sp, #16]
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    40008338:	92403c42 	and	x2, x2, #0xffff
}
    4000833c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008340:	a8c37bfd 	ldp	x29, x30, [sp], #48
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
    40008344:	14000e4f 	b	4000bc80 <memmove>
}
    40008348:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000834c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008350:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40008354:	d65f03c0 	ret

0000000040008358 <z_shell_cmd_get>:

const struct shell_static_entry *z_shell_cmd_get(
					const struct shell_static_entry *parent,
					size_t idx,
					struct shell_static_entry *dloc)
{
    40008358:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000835c:	aa0003e3 	mov	x3, x0
    40008360:	aa0103e0 	mov	x0, x1
    40008364:	910003fd 	mov	x29, sp
    40008368:	f9000bf3 	str	x19, [sp, #16]
	const struct shell_static_entry *res = NULL;

	if (parent == NULL) {
    4000836c:	b5000203 	cbnz	x3, 400083ac <z_shell_cmd_get+0x54>
	return ((uint8_t *)__shell_root_cmds_end -
    40008370:	d0000042 	adrp	x2, 40012000 <__rodata_region_start>
    40008374:	913e8042 	add	x2, x2, #0xfa0
    40008378:	f0000041 	adrp	x1, 40013000 <shell_cmd_kernel>
    4000837c:	91010021 	add	x1, x1, #0x40
    40008380:	cb020021 	sub	x1, x1, x2
		return  (idx < shell_root_cmd_count()) ?
				shell_root_cmd_get(idx)->u.entry : NULL;
    40008384:	d3448c21 	ubfx	x1, x1, #4, #32
    40008388:	eb00003f 	cmp	x1, x0
    4000838c:	54000249 	b.ls	400083d4 <z_shell_cmd_get+0x7c>  // b.plast
    40008390:	d37c7c00 	ubfiz	x0, x0, #4, #32
    40008394:	8b000040 	add	x0, x2, x0
    40008398:	f9400413 	ldr	x19, [x0, #8]
			}
		}
	}

	return res;
}
    4000839c:	aa1303e0 	mov	x0, x19
    400083a0:	f9400bf3 	ldr	x19, [sp, #16]
    400083a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400083a8:	d65f03c0 	ret
	if (parent->subcmd) {
    400083ac:	f9400861 	ldr	x1, [x3, #16]
    400083b0:	b4000121 	cbz	x1, 400083d4 <z_shell_cmd_get+0x7c>
    400083b4:	aa0203f3 	mov	x19, x2
			parent->subcmd->u.dynamic_get(idx, dloc);
    400083b8:	f9400422 	ldr	x2, [x1, #8]
		if (parent->subcmd->is_dynamic) {
    400083bc:	39400021 	ldrb	w1, [x1]
    400083c0:	340000e1 	cbz	w1, 400083dc <z_shell_cmd_get+0x84>
			parent->subcmd->u.dynamic_get(idx, dloc);
    400083c4:	aa1303e1 	mov	x1, x19
    400083c8:	d63f0040 	blr	x2
			if (dloc->syntax != NULL) {
    400083cc:	f9400260 	ldr	x0, [x19]
    400083d0:	b5fffe60 	cbnz	x0, 4000839c <z_shell_cmd_get+0x44>
	const struct shell_static_entry *res = NULL;
    400083d4:	d2800013 	mov	x19, #0x0                   	// #0
    400083d8:	17fffff1 	b	4000839c <z_shell_cmd_get+0x44>
			if (parent->subcmd->u.entry[idx].syntax != NULL) {
    400083dc:	d2800501 	mov	x1, #0x28                  	// #40
    400083e0:	9b017c00 	mul	x0, x0, x1
    400083e4:	8b000053 	add	x19, x2, x0
    400083e8:	f8606840 	ldr	x0, [x2, x0]
    400083ec:	17fffff9 	b	400083d0 <z_shell_cmd_get+0x78>

00000000400083f0 <z_shell_find_cmd>:
 */
const struct shell_static_entry *z_shell_find_cmd(
					const struct shell_static_entry *parent,
					const char *cmd_str,
					struct shell_static_entry *dloc)
{
    400083f0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    400083f4:	910003fd 	mov	x29, sp
    400083f8:	a90153f3 	stp	x19, x20, [sp, #16]
    400083fc:	aa0003f3 	mov	x19, x0
    40008400:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008404:	aa0203f6 	mov	x22, x2
    40008408:	f9001bf7 	str	x23, [sp, #48]
    4000840c:	aa0103f7 	mov	x23, x1
	 * dynamic commands at the same time (current and subcommand) they
	 * will operate on the same memory region what can cause undefined
	 * behaviour.
	 * Hence we need a separate memory for each of them.
	 */
	if (parent) {
    40008410:	b40000c0 	cbz	x0, 40008428 <z_shell_find_cmd+0x38>
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
		parent = &parent_cpy;
    40008414:	910123f3 	add	x19, sp, #0x48
		memcpy(&parent_cpy, parent, sizeof(struct shell_static_entry));
    40008418:	aa0003e1 	mov	x1, x0
    4000841c:	d2800502 	mov	x2, #0x28                  	// #40
    40008420:	910123e0 	add	x0, sp, #0x48
    40008424:	94000e26 	bl	4000bcbc <memcpy>
		parent = &parent_cpy;
    40008428:	d2800015 	mov	x21, #0x0                   	// #0
	}

	while ((entry = z_shell_cmd_get(parent, idx++, dloc)) != NULL) {
    4000842c:	aa1503e1 	mov	x1, x21
    40008430:	aa1603e2 	mov	x2, x22
    40008434:	aa1303e0 	mov	x0, x19
    40008438:	910006b5 	add	x21, x21, #0x1
    4000843c:	97ffffc7 	bl	40008358 <z_shell_cmd_get>
    40008440:	aa0003f4 	mov	x20, x0
    40008444:	b40000a0 	cbz	x0, 40008458 <z_shell_find_cmd+0x68>
		if (strcmp(cmd_str, entry->syntax) == 0) {
    40008448:	f9400281 	ldr	x1, [x20]
    4000844c:	aa1703e0 	mov	x0, x23
    40008450:	94000de8 	bl	4000bbf0 <strcmp>
    40008454:	35fffec0 	cbnz	w0, 4000842c <z_shell_find_cmd+0x3c>
			return entry;
		}
	}

	return NULL;
}
    40008458:	aa1403e0 	mov	x0, x20
    4000845c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008460:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008464:	f9401bf7 	ldr	x23, [sp, #48]
    40008468:	a8c77bfd 	ldp	x29, x30, [sp], #112
    4000846c:	d65f03c0 	ret

0000000040008470 <z_shell_get_last_command>:
					size_t argc,
					const char *argv[],
					size_t *match_arg,
					struct shell_static_entry *dloc,
					bool only_static)
{
    40008470:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40008474:	910003fd 	mov	x29, sp
    40008478:	a90153f3 	stp	x19, x20, [sp, #16]
    4000847c:	aa0303f3 	mov	x19, x3
    40008480:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008484:	aa0203f5 	mov	x21, x2
    40008488:	aa0403f6 	mov	x22, x4
    4000848c:	a90363f7 	stp	x23, x24, [sp, #48]
    40008490:	aa0103f7 	mov	x23, x1
    40008494:	12001cb8 	and	w24, w5, #0xff
	const struct shell_static_entry *prev_entry = NULL;

	*match_arg = Z_SHELL_CMD_ROOT_LVL;
    40008498:	f900007f 	str	xzr, [x3]

		if (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {
			/* ignore wildcard argument */
			if (z_shell_has_wildcard(argv[*match_arg])) {
				(*match_arg)++;
				continue;
    4000849c:	aa0003f4 	mov	x20, x0
	while (*match_arg < argc) {
    400084a0:	f9400260 	ldr	x0, [x19]
    400084a4:	eb17001f 	cmp	x0, x23
    400084a8:	540002e2 	b.cs	40008504 <z_shell_get_last_command+0x94>  // b.hs, b.nlast
			if (z_shell_has_wildcard(argv[*match_arg])) {
    400084ac:	f8607aa0 	ldr	x0, [x21, x0, lsl #3]
    400084b0:	94000793 	bl	4000a2fc <z_shell_has_wildcard>
    400084b4:	72001c1f 	tst	w0, #0xff
    400084b8:	f9400260 	ldr	x0, [x19]
    400084bc:	540000a0 	b.eq	400084d0 <z_shell_get_last_command+0x60>  // b.none
				(*match_arg)++;
    400084c0:	91000400 	add	x0, x0, #0x1
    400084c4:	f9000260 	str	x0, [x19]
				continue;
    400084c8:	aa1403e0 	mov	x0, x20
    400084cc:	17fffff4 	b	4000849c <z_shell_get_last_command+0x2c>
			}
		}

		prev_entry = entry;
		entry = z_shell_find_cmd(entry, argv[*match_arg], dloc);
    400084d0:	f8607aa1 	ldr	x1, [x21, x0, lsl #3]
    400084d4:	aa1603e2 	mov	x2, x22
    400084d8:	aa1403e0 	mov	x0, x20
    400084dc:	97ffffc5 	bl	400083f0 <z_shell_find_cmd>
		if (entry) {
    400084e0:	b4000120 	cbz	x0, 40008504 <z_shell_get_last_command+0x94>
			(*match_arg)++;
    400084e4:	f9400261 	ldr	x1, [x19]
		} else {
			entry = prev_entry;
			break;
		}

		if (only_static && (entry == dloc)) {
    400084e8:	7100031f 	cmp	w24, #0x0
    400084ec:	fa4012c0 	ccmp	x22, x0, #0x0, ne  // ne = any
			(*match_arg)++;
    400084f0:	91000422 	add	x2, x1, #0x1
    400084f4:	f9000262 	str	x2, [x19]
		if (only_static && (entry == dloc)) {
    400084f8:	54fffd21 	b.ne	4000849c <z_shell_get_last_command+0x2c>  // b.any
			(*match_arg)--;
			return NULL;
    400084fc:	d2800014 	mov	x20, #0x0                   	// #0
			(*match_arg)--;
    40008500:	f9000261 	str	x1, [x19]
		}
	}

	return entry;
}
    40008504:	aa1403e0 	mov	x0, x20
    40008508:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000850c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008510:	a94363f7 	ldp	x23, x24, [sp, #48]
    40008514:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40008518:	d65f03c0 	ret

000000004000851c <z_shell_spaces_trim>:




void z_shell_spaces_trim(char *str)
{
    4000851c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40008520:	910003fd 	mov	x29, sp
    40008524:	a90153f3 	stp	x19, x20, [sp, #16]
    40008528:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000852c:	aa0003f6 	mov	x22, x0
	uint16_t len = z_shell_strlen(str);
    40008530:	97fffe92 	bl	40007f78 <z_shell_strlen>
	uint16_t shift = 0U;

	if (!str) {
    40008534:	b50004f6 	cbnz	x22, 400085d0 <z_shell_spaces_trim+0xb4>

				break;
			}
		}
	}
}
    40008538:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000853c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008540:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40008544:	d65f03c0 	ret
				if (shift > 0) {
    40008548:	34000135 	cbz	w21, 4000856c <z_shell_spaces_trim+0x50>
						len - j + 1);
    4000854c:	11000662 	add	w2, w19, #0x1
					len -= shift;
    40008550:	4b150273 	sub	w19, w19, w21
    40008554:	12003e73 	and	w19, w19, #0xffff
						len - j + 1);
    40008558:	4b040042 	sub	w2, w2, w4
					shift = 0U;
    4000855c:	52800015 	mov	w21, #0x0                   	// #0
					memmove(&str[i + 1],
    40008560:	8b34c2c0 	add	x0, x22, w20, sxtw
    40008564:	93407c42 	sxtw	x2, w2
    40008568:	94000dc6 	bl	4000bc80 <memmove>
	for (uint16_t i = 0; i < len - 1; i++) {
    4000856c:	12003e81 	and	w1, w20, #0xffff
    40008570:	51000660 	sub	w0, w19, #0x1
    40008574:	6b00003f 	cmp	w1, w0
    40008578:	54fffe0a 	b.ge	40008538 <z_shell_spaces_trim+0x1c>  // b.tcont
		if (isspace((int)str[i])) {
    4000857c:	92403c20 	and	x0, x1, #0xffff
    40008580:	11000434 	add	w20, w1, #0x1
    40008584:	38606ac0 	ldrb	w0, [x22, x0]
    40008588:	51002402 	sub	w2, w0, #0x9
    4000858c:	7100801f 	cmp	w0, #0x20
    40008590:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    40008594:	54fffec8 	b.hi	4000856c <z_shell_spaces_trim+0x50>  // b.pmore
			for (uint16_t j = i + 1; j < len; j++) {
    40008598:	92403e80 	and	x0, x20, #0xffff
    4000859c:	12003c04 	and	w4, w0, #0xffff
    400085a0:	6b20227f 	cmp	w19, w0, uxth
    400085a4:	54fffe49 	b.ls	4000856c <z_shell_spaces_trim+0x50>  // b.plast
				if (isspace((int)str[j])) {
    400085a8:	38606ac3 	ldrb	w3, [x22, x0]
    400085ac:	8b0002c1 	add	x1, x22, x0
    400085b0:	91000400 	add	x0, x0, #0x1
    400085b4:	51002462 	sub	w2, w3, #0x9
    400085b8:	7100807f 	cmp	w3, #0x20
    400085bc:	7a441840 	ccmp	w2, #0x4, #0x0, ne  // ne = any
    400085c0:	54fffc48 	b.hi	40008548 <z_shell_spaces_trim+0x2c>  // b.pmore
					shift++;
    400085c4:	110006b5 	add	w21, w21, #0x1
    400085c8:	12003eb5 	and	w21, w21, #0xffff
			for (uint16_t j = i + 1; j < len; j++) {
    400085cc:	17fffff4 	b	4000859c <z_shell_spaces_trim+0x80>
    400085d0:	12003c13 	and	w19, w0, #0xffff
	for (uint16_t i = 0; i < len - 1; i++) {
    400085d4:	52800001 	mov	w1, #0x0                   	// #0
	uint16_t shift = 0U;
    400085d8:	52800015 	mov	w21, #0x0                   	// #0
    400085dc:	17ffffe5 	b	40008570 <z_shell_spaces_trim+0x54>

00000000400085e0 <z_shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void z_shell_cmd_trim(const struct shell *shell)
{
    400085e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400085e4:	910003fd 	mov	x29, sp
    400085e8:	a90153f3 	stp	x19, x20, [sp, #16]
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
    400085ec:	f9400813 	ldr	x19, [x0, #16]
{
    400085f0:	f90013f5 	str	x21, [sp, #32]
    400085f4:	aa0003f5 	mov	x21, x0
	if (buff[0] == '\0') {
    400085f8:	3941da60 	ldrb	w0, [x19, #118]
    400085fc:	350001a0 	cbnz	w0, 40008630 <z_shell_cmd_trim+0x50>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    40008600:	f9400aa0 	ldr	x0, [x21, #16]
}
    40008604:	a94153f3 	ldp	x19, x20, [sp, #16]
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    40008608:	7940e001 	ldrh	w1, [x0, #112]
    4000860c:	7900e401 	strh	w1, [x0, #114]
}
    40008610:	f94013f5 	ldr	x21, [sp, #32]
    40008614:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40008618:	d65f03c0 	ret
		*buff_len -= 1U;
    4000861c:	12003c41 	and	w1, w2, #0xffff
    40008620:	7900e261 	strh	w1, [x19, #112]
		if (*buff_len == 0U) {
    40008624:	35000081 	cbnz	w1, 40008634 <z_shell_cmd_trim+0x54>
			buff[0] = '\0';
    40008628:	3901da7f 	strb	wzr, [x19, #118]
			return;
    4000862c:	17fffff5 	b	40008600 <z_shell_cmd_trim+0x20>
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
    40008630:	9101da60 	add	x0, x19, #0x76
	while (isspace((int) buff[*buff_len - 1U])) {
    40008634:	7940e261 	ldrh	w1, [x19, #112]
    40008638:	51000423 	sub	w3, w1, #0x1
    4000863c:	51000422 	sub	w2, w1, #0x1
    40008640:	38636803 	ldrb	w3, [x0, x3]
    40008644:	51002464 	sub	w4, w3, #0x9
    40008648:	7100807f 	cmp	w3, #0x20
    4000864c:	7a441880 	ccmp	w4, #0x4, #0x0, ne  // ne = any
    40008650:	54fffe69 	b.ls	4000861c <z_shell_cmd_trim+0x3c>  // b.plast
	buff[*buff_len] = '\0';
    40008654:	92403c21 	and	x1, x1, #0xffff
	uint16_t i = 0U;
    40008658:	52800002 	mov	w2, #0x0                   	// #0
	buff[*buff_len] = '\0';
    4000865c:	3821681f 	strb	wzr, [x0, x1]
	while (isspace((int) buff[i++])) {
    40008660:	2a0203f4 	mov	w20, w2
    40008664:	11000442 	add	w2, w2, #0x1
    40008668:	92403e83 	and	x3, x20, #0xffff
    4000866c:	12003c42 	and	w2, w2, #0xffff
    40008670:	8b342001 	add	x1, x0, w20, uxth
    40008674:	38636803 	ldrb	w3, [x0, x3]
    40008678:	51002464 	sub	w4, w3, #0x9
    4000867c:	7100807f 	cmp	w3, #0x20
    40008680:	7a441880 	ccmp	w4, #0x4, #0x0, ne  // ne = any
    40008684:	54fffee9 	b.ls	40008660 <z_shell_cmd_trim+0x80>  // b.plast
	if (--i > 0) {
    40008688:	34fffbd4 	cbz	w20, 40008600 <z_shell_cmd_trim+0x20>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
    4000868c:	7940e262 	ldrh	w2, [x19, #112]
    40008690:	11000442 	add	w2, w2, #0x1
    40008694:	4b140042 	sub	w2, w2, w20
    40008698:	94000d7a 	bl	4000bc80 <memmove>
		*buff_len = *buff_len - i;
    4000869c:	7940e260 	ldrh	w0, [x19, #112]
    400086a0:	4b140014 	sub	w20, w0, w20
    400086a4:	7900e274 	strh	w20, [x19, #112]
    400086a8:	17ffffd6 	b	40008600 <z_shell_cmd_trim+0x20>

00000000400086ac <z_shell_raw_fprintf>:
{
    400086ac:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    400086b0:	910003fd 	mov	x29, sp
    400086b4:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    400086b8:	910403e2 	add	x2, sp, #0x100
    400086bc:	a9030be2 	stp	x2, x2, [sp, #48]
    400086c0:	910343e2 	add	x2, sp, #0xd0
    400086c4:	f90023e2 	str	x2, [sp, #64]
    400086c8:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    400086cc:	b9004be2 	str	w2, [sp, #72]
    400086d0:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    400086d4:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    400086d8:	a9430fe2 	ldp	x2, x3, [sp, #48]
    400086dc:	a9010fe2 	stp	x2, x3, [sp, #16]
    400086e0:	a9440fe2 	ldp	x2, x3, [sp, #64]
    400086e4:	a9020fe2 	stp	x2, x3, [sp, #32]
    400086e8:	910043e2 	add	x2, sp, #0x10
{
    400086ec:	3d8017e0 	str	q0, [sp, #80]
    400086f0:	3d801be1 	str	q1, [sp, #96]
    400086f4:	3d801fe2 	str	q2, [sp, #112]
    400086f8:	3d8023e3 	str	q3, [sp, #128]
    400086fc:	3d8027e4 	str	q4, [sp, #144]
    40008700:	3d802be5 	str	q5, [sp, #160]
    40008704:	3d802fe6 	str	q6, [sp, #176]
    40008708:	3d8033e7 	str	q7, [sp, #192]
    4000870c:	a90e17e4 	stp	x4, x5, [sp, #224]
    40008710:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40008714:	97fffde3 	bl	40007ea0 <z_shell_fprintf_fmt>
}
    40008718:	a8d07bfd 	ldp	x29, x30, [sp], #256
    4000871c:	d65f03c0 	ret

0000000040008720 <z_clear_eos>:
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40008720:	f9400801 	ldr	x1, [x0, #16]
    40008724:	b9429821 	ldr	w1, [x1, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_CLEAREOS);
    40008728:	362800a1 	tbz	w1, #5, 4000873c <z_clear_eos+0x1c>
    4000872c:	f9401400 	ldr	x0, [x0, #40]
    40008730:	f0000041 	adrp	x1, 40013000 <shell_cmd_kernel>
    40008734:	91018021 	add	x1, x1, #0x60
    40008738:	17ffffdd 	b	400086ac <z_shell_raw_fprintf>
}
    4000873c:	d65f03c0 	ret

0000000040008740 <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
    40008740:	90000061 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40008744:	911be021 	add	x1, x1, #0x6f8
    40008748:	17ffffd9 	b	400086ac <z_shell_raw_fprintf>

000000004000874c <full_line_cmd>:

/* Function returns true if command length is equal to multiplicity of terminal
 * width.
 */
static inline bool full_line_cmd(const struct shell *shell)
{
    4000874c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40008750:	910003fd 	mov	x29, sp
    40008754:	a90153f3 	stp	x19, x20, [sp, #16]
    40008758:	aa0003f3 	mov	x19, x0
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
    4000875c:	f9400800 	ldr	x0, [x0, #16]
    40008760:	7940e014 	ldrh	w20, [x0, #112]
    40008764:	f9400000 	ldr	x0, [x0]
	return str == NULL ? 0U : (uint16_t)strlen(str);
    40008768:	b40001a0 	cbz	x0, 4000879c <full_line_cmd+0x50>
    4000876c:	94000d11 	bl	4000bbb0 <strlen>
    40008770:	12003c01 	and	w1, w0, #0xffff
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40008774:	f9400a60 	ldr	x0, [x19, #16]
	return ((shell->ctx->cmd_buff_len + z_shell_strlen(shell->ctx->prompt))
    40008778:	0b140021 	add	w1, w1, w20
}
    4000877c:	a94153f3 	ldp	x19, x20, [sp, #16]
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40008780:	79409402 	ldrh	w2, [x0, #74]
}
    40008784:	a8c27bfd 	ldp	x29, x30, [sp], #32
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40008788:	1ac20820 	udiv	w0, w1, w2
    4000878c:	1b028401 	msub	w1, w0, w2, w1
    40008790:	7100003f 	cmp	w1, #0x0
}
    40008794:	1a9f17e0 	cset	w0, eq  // eq = none
    40008798:	d65f03c0 	ret
    4000879c:	52800001 	mov	w1, #0x0                   	// #0
    400087a0:	17fffff5 	b	40008774 <full_line_cmd+0x28>

00000000400087a4 <z_shell_op_cursor_vert_move>:
	char dir = delta > 0 ? 'A' : 'B';
    400087a4:	7100003f 	cmp	w1, #0x0
    400087a8:	5400018c 	b.gt	400087d8 <z_shell_op_cursor_vert_move+0x34>
	if (delta == 0) {
    400087ac:	540001a0 	b.eq	400087e0 <z_shell_op_cursor_vert_move+0x3c>  // b.none
	char dir = delta > 0 ? 'A' : 'B';
    400087b0:	52800843 	mov	w3, #0x42                  	// #66
	return sh->ctx->cfg.flags.use_vt100 == 1;
    400087b4:	f9400802 	ldr	x2, [x0, #16]
    400087b8:	b9429842 	ldr	w2, [x2, #664]
	Z_SHELL_VT100_CMD(shell, "\e[%d%c", delta, dir);
    400087bc:	36280122 	tbz	w2, #5, 400087e0 <z_shell_op_cursor_vert_move+0x3c>
    400087c0:	f9401400 	ldr	x0, [x0, #40]
    400087c4:	7100003f 	cmp	w1, #0x0
    400087c8:	5a81a422 	cneg	w2, w1, lt  // lt = tstop
    400087cc:	90000061 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    400087d0:	9135b421 	add	x1, x1, #0xd6d
    400087d4:	17ffffb6 	b	400086ac <z_shell_raw_fprintf>
	char dir = delta > 0 ? 'A' : 'B';
    400087d8:	52800823 	mov	w3, #0x41                  	// #65
    400087dc:	17fffff6 	b	400087b4 <z_shell_op_cursor_vert_move+0x10>
}
    400087e0:	d65f03c0 	ret

00000000400087e4 <z_shell_op_cursor_horiz_move>:
	char dir = delta > 0 ? 'C' : 'D';
    400087e4:	7100003f 	cmp	w1, #0x0
    400087e8:	5400018c 	b.gt	40008818 <z_shell_op_cursor_horiz_move+0x34>
	if (delta == 0) {
    400087ec:	540001a0 	b.eq	40008820 <z_shell_op_cursor_horiz_move+0x3c>  // b.none
	char dir = delta > 0 ? 'C' : 'D';
    400087f0:	52800883 	mov	w3, #0x44                  	// #68
    400087f4:	f9400802 	ldr	x2, [x0, #16]
    400087f8:	b9429842 	ldr	w2, [x2, #664]
	Z_SHELL_VT100_CMD(shell, "\e[%d%c", delta, dir);
    400087fc:	36280122 	tbz	w2, #5, 40008820 <z_shell_op_cursor_horiz_move+0x3c>
    40008800:	f9401400 	ldr	x0, [x0, #40]
    40008804:	7100003f 	cmp	w1, #0x0
    40008808:	5a81a422 	cneg	w2, w1, lt  // lt = tstop
    4000880c:	90000061 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40008810:	9135b421 	add	x1, x1, #0xd6d
    40008814:	17ffffa6 	b	400086ac <z_shell_raw_fprintf>
	char dir = delta > 0 ? 'C' : 'D';
    40008818:	52800863 	mov	w3, #0x43                  	// #67
    4000881c:	17fffff6 	b	400087f4 <z_shell_op_cursor_horiz_move+0x10>
}
    40008820:	d65f03c0 	ret

0000000040008824 <z_shell_cursor_in_empty_line>:

/* Function returns true if cursor is at beginning of an empty line. */
bool z_shell_cursor_in_empty_line(const struct shell *shell)
{
    40008824:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40008828:	910003fd 	mov	x29, sp
    4000882c:	a90153f3 	stp	x19, x20, [sp, #16]
    40008830:	aa0003f3 	mov	x19, x0
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
    40008834:	f9400800 	ldr	x0, [x0, #16]
    40008838:	7940e414 	ldrh	w20, [x0, #114]
    4000883c:	f9400000 	ldr	x0, [x0]
    40008840:	b40001a0 	cbz	x0, 40008874 <z_shell_cursor_in_empty_line+0x50>
    40008844:	94000cdb 	bl	4000bbb0 <strlen>
    40008848:	12003c01 	and	w1, w0, #0xffff
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    4000884c:	f9400a60 	ldr	x0, [x19, #16]
	return ((shell->ctx->cmd_buff_pos + z_shell_strlen(shell->ctx->prompt))
    40008850:	0b140021 	add	w1, w1, w20
}
    40008854:	a94153f3 	ldp	x19, x20, [sp, #16]
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40008858:	79409402 	ldrh	w2, [x0, #74]
}
    4000885c:	a8c27bfd 	ldp	x29, x30, [sp], #32
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
    40008860:	1ac20820 	udiv	w0, w1, w2
    40008864:	1b028401 	msub	w1, w0, w2, w1
    40008868:	7100003f 	cmp	w1, #0x0
}
    4000886c:	1a9f17e0 	cset	w0, eq  // eq = none
    40008870:	d65f03c0 	ret
    40008874:	52800001 	mov	w1, #0x0                   	// #0
    40008878:	17fffff5 	b	4000884c <z_shell_cursor_in_empty_line+0x28>

000000004000887c <z_shell_op_cond_next_line>:

void z_shell_op_cond_next_line(const struct shell *shell)
{
    4000887c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40008880:	910003fd 	mov	x29, sp
    40008884:	f9000bf3 	str	x19, [sp, #16]
    40008888:	aa0003f3 	mov	x19, x0
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
    4000888c:	97ffffe6 	bl	40008824 <z_shell_cursor_in_empty_line>
    40008890:	72001c1f 	tst	w0, #0xff
    40008894:	540000a0 	b.eq	400088a8 <z_shell_op_cond_next_line+0x2c>  // b.none
		z_cursor_next_line_move(shell);
    40008898:	f9401660 	ldr	x0, [x19, #40]
	}
}
    4000889c:	f9400bf3 	ldr	x19, [sp, #16]
    400088a0:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_cursor_next_line_move(shell);
    400088a4:	17ffffa7 	b	40008740 <z_cursor_next_line_move.isra.0>
	if (z_shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
    400088a8:	aa1303e0 	mov	x0, x19
    400088ac:	97ffffa8 	bl	4000874c <full_line_cmd>
    400088b0:	72001c1f 	tst	w0, #0xff
    400088b4:	54ffff21 	b.ne	40008898 <z_shell_op_cond_next_line+0x1c>  // b.any
}
    400088b8:	f9400bf3 	ldr	x19, [sp, #16]
    400088bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400088c0:	d65f03c0 	ret

00000000400088c4 <z_shell_op_cursor_position_synchronize>:

void z_shell_op_cursor_position_synchronize(const struct shell *shell)
{
    400088c4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400088c8:	910003fd 	mov	x29, sp
    400088cc:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    400088d0:	f9400815 	ldr	x21, [x0, #16]
{
    400088d4:	a90153f3 	stp	x19, x20, [sp, #16]
    400088d8:	aa0003f3 	mov	x19, x0
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    400088dc:	910102b4 	add	x20, x21, #0x40
	bool last_line;

	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    400088e0:	7940e2a2 	ldrh	w2, [x21, #112]
    400088e4:	aa1403e0 	mov	x0, x20
    400088e8:	7940e6a1 	ldrh	w1, [x21, #114]
{
    400088ec:	f9001bf7 	str	x23, [sp, #48]
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    400088f0:	97fffdbd 	bl	40007fe4 <z_shell_multiline_data_calc>
				    shell->ctx->cmd_buff_len);
	last_line = (cons->cur_y == cons->cur_y_end);
    400088f4:	79400a97 	ldrh	w23, [x20, #4]
    400088f8:	79400e96 	ldrh	w22, [x20, #6]

	/* In case cursor reaches the bottom line of a terminal, it will
	 * be moved to the next line.
	 */
	if (full_line_cmd(shell)) {
    400088fc:	aa1303e0 	mov	x0, x19
    40008900:	97ffff93 	bl	4000874c <full_line_cmd>
    40008904:	72001c1f 	tst	w0, #0xff
    40008908:	54000060 	b.eq	40008914 <z_shell_op_cursor_position_synchronize+0x50>  // b.none
		z_cursor_next_line_move(shell);
    4000890c:	f9401660 	ldr	x0, [x19, #40]
    40008910:	97ffff8c 	bl	40008740 <z_cursor_next_line_move.isra.0>
	}

	if (last_line) {
    40008914:	6b1602ff 	cmp	w23, w22
    40008918:	54000141 	b.ne	40008940 <z_shell_op_cursor_position_synchronize+0x7c>  // b.any
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
	} else {
		z_shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
    4000891c:	79400680 	ldrh	w0, [x20, #2]
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
    40008920:	794082a1 	ldrh	w1, [x21, #64]
	}
}
    40008924:	a9425bf5 	ldp	x21, x22, [sp, #32]
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
    40008928:	4b000021 	sub	w1, w1, w0
    4000892c:	aa1303e0 	mov	x0, x19
}
    40008930:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008934:	f9401bf7 	ldr	x23, [sp, #48]
    40008938:	a8c47bfd 	ldp	x29, x30, [sp], #64
		z_shell_op_cursor_horiz_move(shell, cons->cur_x -
    4000893c:	17ffffaa 	b	400087e4 <z_shell_op_cursor_horiz_move>
		z_shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
    40008940:	79400a80 	ldrh	w0, [x20, #4]
    40008944:	79400e81 	ldrh	w1, [x20, #6]
    40008948:	4b000021 	sub	w1, w1, w0
    4000894c:	aa1303e0 	mov	x0, x19
    40008950:	97ffff95 	bl	400087a4 <z_shell_op_cursor_vert_move>
    40008954:	17fffff2 	b	4000891c <z_shell_op_cursor_position_synchronize+0x58>

0000000040008958 <z_shell_op_cursor_move>:

void z_shell_op_cursor_move(const struct shell *shell, int16_t val)
{
    40008958:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000895c:	910003fd 	mov	x29, sp
    40008960:	a90153f3 	stp	x19, x20, [sp, #16]
    40008964:	aa0003f3 	mov	x19, x0
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
    40008968:	f9400800 	ldr	x0, [x0, #16]
{
    4000896c:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
	int32_t row_span;
	int32_t col_span;

	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    40008970:	91010000 	add	x0, x0, #0x40
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
    40008974:	79406403 	ldrh	w3, [x0, #50]
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    40008978:	79406002 	ldrh	w2, [x0, #48]
	uint16_t new_pos = shell->ctx->cmd_buff_pos + val;
    4000897c:	0b21a061 	add	w1, w3, w1, sxth
    40008980:	12003c34 	and	w20, w1, #0xffff
	z_shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
    40008984:	2a0303e1 	mov	w1, w3
    40008988:	97fffd97 	bl	40007fe4 <z_shell_multiline_data_calc>
				    shell->ctx->cmd_buff_len);

	/* Calculate the new cursor. */
	row_span = z_row_span_with_buffer_offsets_get(
						&shell->ctx->vt100_ctx.cons,
    4000898c:	f9400a60 	ldr	x0, [x19, #16]
	row_span = z_row_span_with_buffer_offsets_get(
    40008990:	2a1403e2 	mov	w2, w20
    40008994:	91010000 	add	x0, x0, #0x40
    40008998:	79406401 	ldrh	w1, [x0, #50]
    4000899c:	97fffd8a 	bl	40007fc4 <z_row_span_with_buffer_offsets_get>
    400089a0:	2a0003f6 	mov	w22, w0
						shell->ctx->cmd_buff_pos,
						new_pos);
	col_span = z_column_span_with_buffer_offsets_get(
						&shell->ctx->vt100_ctx.cons,
    400089a4:	f9400a60 	ldr	x0, [x19, #16]
	col_span = z_column_span_with_buffer_offsets_get(
    400089a8:	2a1403e2 	mov	w2, w20
    400089ac:	91010000 	add	x0, x0, #0x40
    400089b0:	79406401 	ldrh	w1, [x0, #50]
    400089b4:	97fffd7a 	bl	40007f9c <z_column_span_with_buffer_offsets_get>
    400089b8:	2a0003f5 	mov	w21, w0
						shell->ctx->cmd_buff_pos,
						new_pos);

	z_shell_op_cursor_vert_move(shell, -row_span);
    400089bc:	4b1603e1 	neg	w1, w22
    400089c0:	aa1303e0 	mov	x0, x19
    400089c4:	97ffff78 	bl	400087a4 <z_shell_op_cursor_vert_move>
	z_shell_op_cursor_horiz_move(shell, col_span);
    400089c8:	2a1503e1 	mov	w1, w21
    400089cc:	aa1303e0 	mov	x0, x19
    400089d0:	97ffff85 	bl	400087e4 <z_shell_op_cursor_horiz_move>
	shell->ctx->cmd_buff_pos = new_pos;
    400089d4:	f9400a60 	ldr	x0, [x19, #16]
}
    400089d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
	shell->ctx->cmd_buff_pos = new_pos;
    400089dc:	7900e414 	strh	w20, [x0, #114]
}
    400089e0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400089e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400089e8:	d65f03c0 	ret

00000000400089ec <z_shell_op_cursor_word_move>:

	return ret;
}

void z_shell_op_cursor_word_move(const struct shell *shell, int16_t val)
{
    400089ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400089f0:	13003c21 	sxth	w1, w1
    400089f4:	910003fd 	mov	x29, sp
    400089f8:	a90153f3 	stp	x19, x20, [sp, #16]
    400089fc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008a00:	aa0003f5 	mov	x21, x0
	int16_t shift;
	int16_t sign;

	if (val < 0) {
    40008a04:	36f80581 	tbz	w1, #31, 40008ab4 <z_shell_op_cursor_word_move+0xc8>
		val = -val;
    40008a08:	4b0103e1 	neg	w1, w1
		sign = -1;
    40008a0c:	12800014 	mov	w20, #0xffffffff            	// #-1
		val = -val;
    40008a10:	13003c21 	sxth	w1, w1
		sign = -1;
    40008a14:	12003c33 	and	w19, w1, #0xffff
    40008a18:	12003e96 	and	w22, w20, #0xffff
    40008a1c:	1400001d 	b	40008a90 <z_shell_op_cursor_word_move+0xa4>
	} else {
		sign = 1;
	}

	while (val--) {
		shift = shift_calc(shell->ctx->cmd_buff,
    40008a20:	f9400aa0 	ldr	x0, [x21, #16]
	bool found = false;
    40008a24:	52800003 	mov	w3, #0x0                   	// #0
		shift = shift_calc(shell->ctx->cmd_buff,
    40008a28:	9101d806 	add	x6, x0, #0x76
    40008a2c:	7940e405 	ldrh	w5, [x0, #114]
    40008a30:	7940e007 	ldrh	w7, [x0, #112]
    40008a34:	2a0503e2 	mov	w2, w5
		idx = pos + ret * sign;
    40008a38:	4b050041 	sub	w1, w2, w5
		if (((idx == 0U) && (sign < 0)) ||
    40008a3c:	7100005f 	cmp	w2, #0x0
    40008a40:	7a400a80 	ccmp	w20, #0x0, #0x0, eq  // eq = none
    40008a44:	13003c21 	sxth	w1, w1
    40008a48:	540001cb 	b.lt	40008a80 <z_shell_op_cursor_word_move+0x94>  // b.tstop
		    ((idx == len) && (sign > 0))) {
    40008a4c:	7100029f 	cmp	w20, #0x0
		if (((idx == 0U) && (sign < 0)) ||
    40008a50:	7a42c0e0 	ccmp	w7, w2, #0x0, gt
    40008a54:	54000160 	b.eq	40008a80 <z_shell_op_cursor_word_move+0x94>  // b.none
		if (isalnum((int)str[idx]) != 0) {
    40008a58:	92403c40 	and	x0, x2, #0xffff
    40008a5c:	386068c0 	ldrb	w0, [x6, x0]
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    40008a60:	321b0004 	orr	w4, w0, #0x20
    40008a64:	51018484 	sub	w4, w4, #0x61
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
    40008a68:	7100649f 	cmp	w4, #0x19
    40008a6c:	540001c9 	b.ls	40008aa4 <z_shell_op_cursor_word_move+0xb8>  // b.plast
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    40008a70:	5100c000 	sub	w0, w0, #0x30
	return (int)(isalpha(chr) || isdigit(chr));
    40008a74:	7100241f 	cmp	w0, #0x9
    40008a78:	54000169 	b.ls	40008aa4 <z_shell_op_cursor_word_move+0xb8>  // b.plast
			if (found) {
    40008a7c:	34000163 	cbz	w3, 40008aa8 <z_shell_op_cursor_word_move+0xbc>
				   shell->ctx->cmd_buff_pos,
				   shell->ctx->cmd_buff_len, sign);
		z_shell_op_cursor_move(shell, sign * shift);
    40008a80:	aa1503e0 	mov	x0, x21
    40008a84:	97ffffb5 	bl	40008958 <z_shell_op_cursor_move>
    40008a88:	51000661 	sub	w1, w19, #0x1
    40008a8c:	12003c33 	and	w19, w1, #0xffff
	while (val--) {
    40008a90:	35fffc93 	cbnz	w19, 40008a20 <z_shell_op_cursor_word_move+0x34>
	}
}
    40008a94:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008a98:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008a9c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40008aa0:	d65f03c0 	ret
			found = true;
    40008aa4:	52800023 	mov	w3, #0x1                   	// #1
	while (1) {
    40008aa8:	0b0202c2 	add	w2, w22, w2
    40008aac:	12003c42 	and	w2, w2, #0xffff
		idx = pos + ret * sign;
    40008ab0:	17ffffe2 	b	40008a38 <z_shell_op_cursor_word_move+0x4c>
		sign = 1;
    40008ab4:	52800034 	mov	w20, #0x1                   	// #1
    40008ab8:	17ffffd7 	b	40008a14 <z_shell_op_cursor_word_move+0x28>

0000000040008abc <z_shell_op_cursor_home_move>:
	z_cursor_restore(shell);
}

void z_shell_op_cursor_home_move(const struct shell *shell)
{
	z_shell_op_cursor_move(shell, -shell->ctx->cmd_buff_pos);
    40008abc:	f9400801 	ldr	x1, [x0, #16]
    40008ac0:	7940e421 	ldrh	w1, [x1, #114]
    40008ac4:	4b0103e1 	neg	w1, w1
    40008ac8:	17ffffa4 	b	40008958 <z_shell_op_cursor_move>

0000000040008acc <z_shell_op_cursor_end_move>:
}

void z_shell_op_cursor_end_move(const struct shell *shell)
{
	z_shell_op_cursor_move(shell, shell->ctx->cmd_buff_len -
    40008acc:	f9400802 	ldr	x2, [x0, #16]
    40008ad0:	7940e041 	ldrh	w1, [x2, #112]
    40008ad4:	7940e442 	ldrh	w2, [x2, #114]
    40008ad8:	4b020021 	sub	w1, w1, w2
    40008adc:	17ffff9f 	b	40008958 <z_shell_op_cursor_move>

0000000040008ae0 <z_shell_op_left_arrow>:
						shell->ctx->cmd_buff_pos);
}

void z_shell_op_left_arrow(const struct shell *shell)
{
	if (shell->ctx->cmd_buff_pos > 0) {
    40008ae0:	f9400801 	ldr	x1, [x0, #16]
    40008ae4:	7940e421 	ldrh	w1, [x1, #114]
    40008ae8:	34000061 	cbz	w1, 40008af4 <z_shell_op_left_arrow+0x14>
		z_shell_op_cursor_move(shell, -1);
    40008aec:	12800001 	mov	w1, #0xffffffff            	// #-1
    40008af0:	17ffff9a 	b	40008958 <z_shell_op_cursor_move>
	}
}
    40008af4:	d65f03c0 	ret

0000000040008af8 <z_shell_op_right_arrow>:

void z_shell_op_right_arrow(const struct shell *shell)
{
	if (shell->ctx->cmd_buff_pos < shell->ctx->cmd_buff_len) {
    40008af8:	f9400801 	ldr	x1, [x0, #16]
    40008afc:	7940e422 	ldrh	w2, [x1, #114]
    40008b00:	7940e021 	ldrh	w1, [x1, #112]
    40008b04:	6b01005f 	cmp	w2, w1
    40008b08:	54000062 	b.cs	40008b14 <z_shell_op_right_arrow+0x1c>  // b.hs, b.nlast
		z_shell_op_cursor_move(shell, 1);
    40008b0c:	52800021 	mov	w1, #0x1                   	// #1
    40008b10:	17ffff92 	b	40008958 <z_shell_op_cursor_move>
	}
}
    40008b14:	d65f03c0 	ret

0000000040008b18 <z_shell_op_delete_from_cursor>:
	reprint_from_cursor(shell, --diff, true);
}

void z_shell_op_delete_from_cursor(const struct shell *shell)
{
	shell->ctx->cmd_buff_len = shell->ctx->cmd_buff_pos;
    40008b18:	f9400802 	ldr	x2, [x0, #16]
    40008b1c:	7940e441 	ldrh	w1, [x2, #114]
    40008b20:	7900e041 	strh	w1, [x2, #112]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos] = '\0';
    40008b24:	8b21c041 	add	x1, x2, w1, sxtw
    40008b28:	3901d83f 	strb	wzr, [x1, #118]

	z_clear_eos(shell);
    40008b2c:	17fffefd 	b	40008720 <z_clear_eos>

0000000040008b30 <z_shell_cmd_line_erase>:
{
	data_insert(shell, compl, compl_len);
}

void z_shell_cmd_line_erase(const struct shell *shell)
{
    40008b30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40008b34:	910003fd 	mov	x29, sp
    40008b38:	f9000bf3 	str	x19, [sp, #16]
    40008b3c:	aa0003f3 	mov	x19, x0
	z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
    40008b40:	f9400800 	ldr	x0, [x0, #16]
    40008b44:	91010000 	add	x0, x0, #0x40
    40008b48:	79406002 	ldrh	w2, [x0, #48]
    40008b4c:	79406401 	ldrh	w1, [x0, #50]
    40008b50:	97fffd25 	bl	40007fe4 <z_shell_multiline_data_calc>
				    shell->ctx->cmd_buff_pos,
				    shell->ctx->cmd_buff_len);
	z_shell_op_cursor_horiz_move(shell,
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
    40008b54:	f9400a60 	ldr	x0, [x19, #16]
	z_shell_op_cursor_horiz_move(shell,
    40008b58:	52800021 	mov	w1, #0x1                   	// #1
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
    40008b5c:	79408000 	ldrh	w0, [x0, #64]
	z_shell_op_cursor_horiz_move(shell,
    40008b60:	4b000021 	sub	w1, w1, w0
    40008b64:	aa1303e0 	mov	x0, x19
    40008b68:	97ffff1f 	bl	400087e4 <z_shell_op_cursor_horiz_move>
	z_shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
    40008b6c:	f9400a60 	ldr	x0, [x19, #16]
    40008b70:	79408801 	ldrh	w1, [x0, #68]
    40008b74:	aa1303e0 	mov	x0, x19
    40008b78:	51000421 	sub	w1, w1, #0x1
    40008b7c:	97ffff0a 	bl	400087a4 <z_shell_op_cursor_vert_move>

	z_clear_eos(shell);
    40008b80:	aa1303e0 	mov	x0, x19
}
    40008b84:	f9400bf3 	ldr	x19, [sp, #16]
    40008b88:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_clear_eos(shell);
    40008b8c:	17fffee5 	b	40008720 <z_clear_eos>

0000000040008b90 <z_shell_print_cmd>:
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
}

void z_shell_print_cmd(const struct shell *shell)
{
	z_shell_raw_fprintf(shell->fprintf_ctx, "%s", shell->ctx->cmd_buff);
    40008b90:	f9400802 	ldr	x2, [x0, #16]
    40008b94:	90000061 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40008b98:	91205c21 	add	x1, x1, #0x817
    40008b9c:	f9401400 	ldr	x0, [x0, #40]
    40008ba0:	9101d842 	add	x2, x2, #0x76
    40008ba4:	17fffec2 	b	400086ac <z_shell_raw_fprintf>

0000000040008ba8 <z_shell_write>:
	}
}

void z_shell_write(const struct shell *shell, const void *data,
		 size_t length)
{
    40008ba8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40008bac:	910003fd 	mov	x29, sp
    40008bb0:	a90153f3 	stp	x19, x20, [sp, #16]
    40008bb4:	aa0003f4 	mov	x20, x0
    40008bb8:	aa0203f3 	mov	x19, x2
    40008bbc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008bc0:	aa0103f6 	mov	x22, x1
	__ASSERT_NO_MSG(shell && data);

	size_t offset = 0;
    40008bc4:	d2800015 	mov	x21, #0x0                   	// #0
{
    40008bc8:	f9001bf7 	str	x23, [sp, #48]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    40008bcc:	929fffb7 	mov	x23, #0xffffffffffff0002    	// #-65534
    40008bd0:	f2a00017 	movk	x23, #0x0, lsl #16
	size_t tmp_cnt;

	while (length) {
    40008bd4:	b50000d3 	cbnz	x19, 40008bec <z_shell_write+0x44>
		if (tmp_cnt == 0 &&
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
			shell_pend_on_txdone(shell);
		}
	}
}
    40008bd8:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008bdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008be0:	f9401bf7 	ldr	x23, [sp, #48]
    40008be4:	a8c77bfd 	ldp	x29, x30, [sp], #112
    40008be8:	d65f03c0 	ret
		int err = shell->iface->api->write(shell->iface,
    40008bec:	f9400680 	ldr	x0, [x20, #8]
    40008bf0:	aa1303e2 	mov	x2, x19
    40008bf4:	910103e3 	add	x3, sp, #0x40
    40008bf8:	f9400001 	ldr	x1, [x0]
    40008bfc:	f9400c24 	ldr	x4, [x1, #24]
    40008c00:	8b1502c1 	add	x1, x22, x21
    40008c04:	d63f0080 	blr	x4
		offset += tmp_cnt;
    40008c08:	f94023e0 	ldr	x0, [sp, #64]
    40008c0c:	8b0002b5 	add	x21, x21, x0
		length -= tmp_cnt;
    40008c10:	cb000273 	sub	x19, x19, x0
		if (tmp_cnt == 0 &&
    40008c14:	b5fffe00 	cbnz	x0, 40008bd4 <z_shell_write+0x2c>
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
    40008c18:	f9400a83 	ldr	x3, [x20, #16]
    40008c1c:	b9400860 	ldr	w0, [x3, #8]
		if (tmp_cnt == 0 &&
    40008c20:	71000c1f 	cmp	w0, #0x3
    40008c24:	54fffd80 	b.eq	40008bd4 <z_shell_write+0x2c>  // b.none
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
    40008c28:	7100081f 	cmp	w0, #0x2
    40008c2c:	540001c8 	b.hi	40008c64 <z_shell_write+0xbc>  // b.pmore
		k_poll_event_init(&event,
    40008c30:	910bc063 	add	x3, x3, #0x2f0
    40008c34:	910123e0 	add	x0, sp, #0x48
    40008c38:	52800002 	mov	w2, #0x0                   	// #0
    40008c3c:	52800021 	mov	w1, #0x1                   	// #1
    40008c40:	9400204e 	bl	40010d78 <k_poll_event_init>
    40008c44:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
    40008c48:	910123e0 	add	x0, sp, #0x48
    40008c4c:	52800021 	mov	w1, #0x1                   	// #1
    40008c50:	94002053 	bl	40010d9c <z_impl_k_poll>
		k_poll_signal_reset(&shell->ctx->signals[SHELL_SIGNAL_TXDONE]);
    40008c54:	f9400a80 	ldr	x0, [x20, #16]
    40008c58:	910bc000 	add	x0, x0, #0x2f0
	z_impl_k_poll_signal_reset(sig);
    40008c5c:	94002093 	bl	40010ea8 <z_impl_k_poll_signal_reset>
    40008c60:	17ffffdd 	b	40008bd4 <z_shell_write+0x2c>
	return sh->ctx->ctx.flags.tx_rdy == 1;
    40008c64:	b942a060 	ldr	w0, [x3, #672]
		while (!z_flag_tx_rdy_get(shell)) {
    40008c68:	360fffe0 	tbz	w0, #1, 40008c64 <z_shell_write+0xbc>
    40008c6c:	910a8061 	add	x1, x3, #0x2a0
    40008c70:	aa1703e0 	mov	x0, x23
    40008c74:	97ffe0df 	bl	40000ff0 <__aarch64_ldclr8_acq_rel>
	return ret;
    40008c78:	17ffffd7 	b	40008bd4 <z_shell_write+0x2c>

0000000040008c7c <z_shell_print_stream>:

/* Function shall be only used by the fprintf module. */
void z_shell_print_stream(const void *user_ctx, const char *data, size_t len)
{
	z_shell_write((const struct shell *) user_ctx, data, len);
    40008c7c:	17ffffcb 	b	40008ba8 <z_shell_write>

0000000040008c80 <z_shell_vt100_color_set>:
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
}

void z_shell_vt100_color_set(const struct shell *shell,
			     enum shell_vt100_color color)
{
    40008c80:	2a0103e2 	mov	w2, w1
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	if (color >= VT100_COLOR_END) {
    40008c84:	7100203f 	cmp	w1, #0x8
    40008c88:	54000288 	b.hi	40008cd8 <z_shell_vt100_color_set+0x58>  // b.pmore
		return;
	}

	if (shell->ctx->vt100_ctx.col.col == color) {
    40008c8c:	f9400801 	ldr	x1, [x0, #16]
    40008c90:	b9405023 	ldr	w3, [x1, #80]
    40008c94:	6b02007f 	cmp	w3, w2
    40008c98:	54000200 	b.eq	40008cd8 <z_shell_vt100_color_set+0x58>  // b.none
		return;
	}

	shell->ctx->vt100_ctx.col.col = color;
    40008c9c:	b9005022 	str	w2, [x1, #80]

	if (color != SHELL_NORMAL) {
    40008ca0:	7100205f 	cmp	w2, #0x8
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40008ca4:	b9429821 	ldr	w1, [x1, #664]
    40008ca8:	540000c0 	b.eq	40008cc0 <z_shell_vt100_color_set+0x40>  // b.none
		Z_SHELL_VT100_CMD(shell, "\e[1;3%dm", color);
    40008cac:	36280161 	tbz	w1, #5, 40008cd8 <z_shell_vt100_color_set+0x58>
    40008cb0:	f9401400 	ldr	x0, [x0, #40]
    40008cb4:	90000061 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40008cb8:	9135d021 	add	x1, x1, #0xd74
    40008cbc:	17fffe7c 	b	400086ac <z_shell_raw_fprintf>
	} else {
		Z_SHELL_VT100_CMD(shell, SHELL_VT100_MODESOFF);
    40008cc0:	362800c1 	tbz	w1, #5, 40008cd8 <z_shell_vt100_color_set+0x58>
    40008cc4:	f9401400 	ldr	x0, [x0, #40]
    40008cc8:	f0000041 	adrp	x1, 40013000 <shell_cmd_kernel>
    40008ccc:	91018021 	add	x1, x1, #0x60
    40008cd0:	91001421 	add	x1, x1, #0x5
    40008cd4:	17fffe76 	b	400086ac <z_shell_raw_fprintf>
	}
}
    40008cd8:	d65f03c0 	ret

0000000040008cdc <z_shell_vt100_colors_restore>:

void z_shell_vt100_colors_restore(const struct shell *shell,
				  const struct shell_vt100_colors *color)
{
    40008cdc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40008ce0:	910003fd 	mov	x29, sp
    40008ce4:	a90153f3 	stp	x19, x20, [sp, #16]
    40008ce8:	aa0103f4 	mov	x20, x1
	if (!IS_ENABLED(CONFIG_SHELL_VT100_COLORS)) {
		return;
	}

	z_shell_vt100_color_set(shell, color->col);
    40008cec:	b9400021 	ldr	w1, [x1]
{
    40008cf0:	aa0003f3 	mov	x19, x0
	z_shell_vt100_color_set(shell, color->col);
    40008cf4:	97ffffe3 	bl	40008c80 <z_shell_vt100_color_set>
	vt100_bgcolor_set(shell, color->bgcol);
    40008cf8:	b9400682 	ldr	w2, [x20, #4]
	if ((bgcolor == SHELL_NORMAL) ||
    40008cfc:	71001c5f 	cmp	w2, #0x7
    40008d00:	540001c8 	b.hi	40008d38 <z_shell_vt100_colors_restore+0x5c>  // b.pmore
	    (shell->ctx->vt100_ctx.col.bgcol == bgcolor)) {
    40008d04:	f9400a60 	ldr	x0, [x19, #16]
	if ((bgcolor == SHELL_NORMAL) ||
    40008d08:	b9405401 	ldr	w1, [x0, #84]
    40008d0c:	6b01005f 	cmp	w2, w1
    40008d10:	54000140 	b.eq	40008d38 <z_shell_vt100_colors_restore+0x5c>  // b.none
	shell->ctx->vt100_ctx.col.bgcol = bgcolor;
    40008d14:	b9005402 	str	w2, [x0, #84]
    40008d18:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
    40008d1c:	362800e0 	tbz	w0, #5, 40008d38 <z_shell_vt100_colors_restore+0x5c>
    40008d20:	f9401660 	ldr	x0, [x19, #40]
    40008d24:	90000061 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40008d28:	9135f421 	add	x1, x1, #0xd7d
}
    40008d2c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008d30:	a8c27bfd 	ldp	x29, x30, [sp], #32
	Z_SHELL_VT100_CMD(shell, "\e[403%dm", bgcolor);
    40008d34:	17fffe5e 	b	400086ac <z_shell_raw_fprintf>
}
    40008d38:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008d3c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40008d40:	d65f03c0 	ret

0000000040008d44 <z_shell_vfprintf>:

void z_shell_vfprintf(const struct shell *shell, enum shell_vt100_color color,
		      const char *fmt, va_list args)
{
    40008d44:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40008d48:	910003fd 	mov	x29, sp
    40008d4c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008d50:	2a0103f6 	mov	w22, w1
    40008d54:	aa0203f5 	mov	x21, x2
	return sh->ctx->cfg.flags.use_colors == 1;
    40008d58:	f9400801 	ldr	x1, [x0, #16]
    40008d5c:	a90153f3 	stp	x19, x20, [sp, #16]
    40008d60:	aa0003f3 	mov	x19, x0
    40008d64:	aa0303f4 	mov	x20, x3
    40008d68:	b9429820 	ldr	w0, [x1, #664]
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
    40008d6c:	36200340 	tbz	w0, #4, 40008dd4 <z_shell_vfprintf+0x90>
	    z_flag_use_colors_get(shell)	  &&
    40008d70:	b9405020 	ldr	w0, [x1, #80]
    40008d74:	6b16001f 	cmp	w0, w22
    40008d78:	540002e0 	b.eq	40008dd4 <z_shell_vfprintf+0x90>  // b.none
			     enum shell_vt100_color color);

static inline void z_shell_vt100_colors_store(const struct shell *sh,
					      struct shell_vt100_colors *color)
{
	memcpy(color, &sh->ctx->vt100_ctx.col, sizeof(*color));
    40008d7c:	d2800102 	mov	x2, #0x8                   	// #8
    40008d80:	91014021 	add	x1, x1, #0x50
    40008d84:	910163e0 	add	x0, sp, #0x58
    40008d88:	94000bcd 	bl	4000bcbc <memcpy>
	    (color != shell->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		z_shell_vt100_colors_store(shell, &col);
		z_shell_vt100_color_set(shell, color);
    40008d8c:	2a1603e1 	mov	w1, w22
    40008d90:	aa1303e0 	mov	x0, x19
    40008d94:	97ffffbb 	bl	40008c80 <z_shell_vt100_color_set>

		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
    40008d98:	a9400680 	ldp	x0, x1, [x20]
    40008d9c:	a90307e0 	stp	x0, x1, [sp, #48]
    40008da0:	9100c3e2 	add	x2, sp, #0x30
    40008da4:	a9410680 	ldp	x0, x1, [x20, #16]
    40008da8:	a90407e0 	stp	x0, x1, [sp, #64]
    40008dac:	f9401660 	ldr	x0, [x19, #40]
    40008db0:	aa1503e1 	mov	x1, x21
    40008db4:	97fffc3b 	bl	40007ea0 <z_shell_fprintf_fmt>

		z_shell_vt100_colors_restore(shell, &col);
    40008db8:	910163e1 	add	x1, sp, #0x58
    40008dbc:	aa1303e0 	mov	x0, x19
    40008dc0:	97ffffc7 	bl	40008cdc <z_shell_vt100_colors_restore>
	} else {
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
	}
}
    40008dc4:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008dc8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40008dcc:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40008dd0:	d65f03c0 	ret
		z_shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
    40008dd4:	a9400680 	ldp	x0, x1, [x20]
    40008dd8:	a90307e0 	stp	x0, x1, [sp, #48]
    40008ddc:	9100c3e2 	add	x2, sp, #0x30
    40008de0:	a9410680 	ldp	x0, x1, [x20, #16]
    40008de4:	a90407e0 	stp	x0, x1, [sp, #64]
    40008de8:	f9401660 	ldr	x0, [x19, #40]
    40008dec:	aa1503e1 	mov	x1, x21
    40008df0:	97fffc2c 	bl	40007ea0 <z_shell_fprintf_fmt>
}
    40008df4:	17fffff4 	b	40008dc4 <z_shell_vfprintf+0x80>

0000000040008df8 <z_shell_fprintf>:

void z_shell_fprintf(const struct shell *sh,
		     enum shell_vt100_color color,
		     const char *fmt, ...)
{
    40008df8:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40008dfc:	910003fd 	mov	x29, sp
    40008e00:	a90d93e3 	stp	x3, x4, [sp, #216]
	__ASSERT(z_flag_panic_mode_get(sh) || !k_is_in_isr(),
		 "Thread context required.");

	va_list args;

	va_start(args, fmt);
    40008e04:	910403e3 	add	x3, sp, #0x100
    40008e08:	a9030fe3 	stp	x3, x3, [sp, #48]
    40008e0c:	910343e3 	add	x3, sp, #0xd0
    40008e10:	f90023e3 	str	x3, [sp, #64]
    40008e14:	128004e3 	mov	w3, #0xffffffd8            	// #-40
    40008e18:	b9004be3 	str	w3, [sp, #72]
    40008e1c:	12800fe3 	mov	w3, #0xffffff80            	// #-128
    40008e20:	b9004fe3 	str	w3, [sp, #76]
	z_shell_vfprintf(sh, color, fmt, args);
    40008e24:	910043e3 	add	x3, sp, #0x10
{
    40008e28:	a90e9be5 	stp	x5, x6, [sp, #232]
	z_shell_vfprintf(sh, color, fmt, args);
    40008e2c:	a94317e4 	ldp	x4, x5, [sp, #48]
    40008e30:	a90117e4 	stp	x4, x5, [sp, #16]
    40008e34:	a94417e4 	ldp	x4, x5, [sp, #64]
    40008e38:	a90217e4 	stp	x4, x5, [sp, #32]
{
    40008e3c:	3d8017e0 	str	q0, [sp, #80]
    40008e40:	3d801be1 	str	q1, [sp, #96]
    40008e44:	3d801fe2 	str	q2, [sp, #112]
    40008e48:	3d8023e3 	str	q3, [sp, #128]
    40008e4c:	3d8027e4 	str	q4, [sp, #144]
    40008e50:	3d802be5 	str	q5, [sp, #160]
    40008e54:	3d802fe6 	str	q6, [sp, #176]
    40008e58:	3d8033e7 	str	q7, [sp, #192]
    40008e5c:	f9007fe7 	str	x7, [sp, #248]
	z_shell_vfprintf(sh, color, fmt, args);
    40008e60:	97ffffb9 	bl	40008d44 <z_shell_vfprintf>
	va_end(args);
}
    40008e64:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40008e68:	d65f03c0 	ret

0000000040008e6c <z_shell_op_word_remove>:
{
    40008e6c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40008e70:	910003fd 	mov	x29, sp
    40008e74:	a90153f3 	stp	x19, x20, [sp, #16]
    40008e78:	aa0003f3 	mov	x19, x0
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    40008e7c:	f9400800 	ldr	x0, [x0, #16]
	if ((shell->ctx->cmd_buff_len == 0) ||
    40008e80:	7940e002 	ldrh	w2, [x0, #112]
{
    40008e84:	f90013f5 	str	x21, [sp, #32]
	if ((shell->ctx->cmd_buff_len == 0) ||
    40008e88:	340008a2 	cbz	w2, 40008f9c <z_shell_op_word_remove+0x130>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    40008e8c:	7940e403 	ldrh	w3, [x0, #114]
	if ((shell->ctx->cmd_buff_len == 0) ||
    40008e90:	34000863 	cbz	w3, 40008f9c <z_shell_op_word_remove+0x130>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    40008e94:	1101d463 	add	w3, w3, #0x75
	char *str_start = &shell->ctx->cmd_buff[0];
    40008e98:	9101d801 	add	x1, x0, #0x76
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
    40008e9c:	8b23c003 	add	x3, x0, w3, sxtw
    40008ea0:	aa0303e0 	mov	x0, x3
    40008ea4:	4b000074 	sub	w20, w3, w0
	while ((str >= str_start) && (*str == ' ')) {
    40008ea8:	eb01001f 	cmp	x0, x1
    40008eac:	12003e94 	and	w20, w20, #0xffff
    40008eb0:	54000183 	b.cc	40008ee0 <z_shell_op_word_remove+0x74>  // b.lo, b.ul, b.last
    40008eb4:	39400004 	ldrb	w4, [x0]
    40008eb8:	7100809f 	cmp	w4, #0x20
    40008ebc:	540006c0 	b.eq	40008f94 <z_shell_op_word_remove+0x128>  // b.none
	while ((str >= str_start) && (*str != ' ')) {
    40008ec0:	39400003 	ldrb	w3, [x0]
    40008ec4:	7100807f 	cmp	w3, #0x20
    40008ec8:	540000c0 	b.eq	40008ee0 <z_shell_op_word_remove+0x74>  // b.none
		++chars_to_delete;
    40008ecc:	11000694 	add	w20, w20, #0x1
		--str;
    40008ed0:	d1000400 	sub	x0, x0, #0x1
		++chars_to_delete;
    40008ed4:	12003e94 	and	w20, w20, #0xffff
	while ((str >= str_start) && (*str != ' ')) {
    40008ed8:	eb00003f 	cmp	x1, x0
    40008edc:	54ffff29 	b.ls	40008ec0 <z_shell_op_word_remove+0x54>  // b.plast
		shell->ctx->cmd_buff_len - chars_to_delete);
    40008ee0:	4b140042 	sub	w2, w2, w20
	memmove(str + 1, str + 1 + chars_to_delete,
    40008ee4:	92403e81 	and	x1, x20, #0xffff
    40008ee8:	91000415 	add	x21, x0, #0x1
    40008eec:	91000421 	add	x1, x1, #0x1
    40008ef0:	8b010001 	add	x1, x0, x1
    40008ef4:	93407c42 	sxtw	x2, w2
    40008ef8:	aa1503e0 	mov	x0, x21
    40008efc:	94000b61 	bl	4000bc80 <memmove>
	shell->ctx->cmd_buff_len -= chars_to_delete;
    40008f00:	f9400a61 	ldr	x1, [x19, #16]
    40008f04:	7940e020 	ldrh	w0, [x1, #112]
    40008f08:	4b140000 	sub	w0, w0, w20
    40008f0c:	12003c00 	and	w0, w0, #0xffff
    40008f10:	7900e020 	strh	w0, [x1, #112]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    40008f14:	8b20c020 	add	x0, x1, w0, sxtw
	z_shell_op_cursor_move(shell, -chars_to_delete);
    40008f18:	4b1403e1 	neg	w1, w20
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    40008f1c:	3901d81f 	strb	wzr, [x0, #118]
	z_shell_op_cursor_move(shell, -chars_to_delete);
    40008f20:	aa1303e0 	mov	x0, x19
    40008f24:	97fffe8d 	bl	40008958 <z_shell_op_cursor_move>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40008f28:	f9400a60 	ldr	x0, [x19, #16]
    40008f2c:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
    40008f30:	362800c0 	tbz	w0, #5, 40008f48 <z_shell_op_word_remove+0xdc>
    40008f34:	f9401660 	ldr	x0, [x19, #40]
    40008f38:	f0000041 	adrp	x1, 40013000 <shell_cmd_kernel>
    40008f3c:	91018021 	add	x1, x1, #0x60
    40008f40:	91002821 	add	x1, x1, #0xa
    40008f44:	97fffdda 	bl	400086ac <z_shell_raw_fprintf>
	z_shell_fprintf(shell, SHELL_NORMAL, "%s", str + 1);
    40008f48:	aa1503e3 	mov	x3, x21
    40008f4c:	90000062 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40008f50:	91205c42 	add	x2, x2, #0x817
    40008f54:	52800101 	mov	w1, #0x8                   	// #8
    40008f58:	aa1303e0 	mov	x0, x19
    40008f5c:	97ffffa7 	bl	40008df8 <z_shell_fprintf>
	z_clear_eos(shell);
    40008f60:	aa1303e0 	mov	x0, x19
    40008f64:	97fffdef 	bl	40008720 <z_clear_eos>
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40008f68:	f9400a60 	ldr	x0, [x19, #16]
    40008f6c:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
    40008f70:	36280160 	tbz	w0, #5, 40008f9c <z_shell_op_word_remove+0x130>
}
    40008f74:	f94013f5 	ldr	x21, [sp, #32]
    40008f78:	f0000041 	adrp	x1, 40013000 <shell_cmd_kernel>
    40008f7c:	91018021 	add	x1, x1, #0x60
    40008f80:	f9401660 	ldr	x0, [x19, #40]
    40008f84:	91003821 	add	x1, x1, #0xe
    40008f88:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008f8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40008f90:	17fffdc7 	b	400086ac <z_shell_raw_fprintf>
		--str;
    40008f94:	d1000400 	sub	x0, x0, #0x1
    40008f98:	17ffffc3 	b	40008ea4 <z_shell_op_word_remove+0x38>
}
    40008f9c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40008fa0:	f94013f5 	ldr	x21, [sp, #32]
    40008fa4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40008fa8:	d65f03c0 	ret

0000000040008fac <reprint_from_cursor>:
{
    40008fac:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40008fb0:	910003fd 	mov	x29, sp
    40008fb4:	a90153f3 	stp	x19, x20, [sp, #16]
    40008fb8:	aa0003f3 	mov	x19, x0
    40008fbc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40008fc0:	12003c36 	and	w22, w1, #0xffff
    40008fc4:	f9001bf7 	str	x23, [sp, #48]
	if (data_removed) {
    40008fc8:	72001c57 	ands	w23, w2, #0xff
    40008fcc:	54000040 	b.eq	40008fd4 <reprint_from_cursor+0x28>  // b.none
		z_clear_eos(shell);
    40008fd0:	97fffdd4 	bl	40008720 <z_clear_eos>
	return sh->ctx->cfg.flags.obscure == 1;
    40008fd4:	f9400a60 	ldr	x0, [x19, #16]
    40008fd8:	b9429801 	ldr	w1, [x0, #664]
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
    40008fdc:	7940e403 	ldrh	w3, [x0, #114]
    40008fe0:	9101d863 	add	x3, x3, #0x76
    40008fe4:	8b030000 	add	x0, x0, x3
	if (z_flag_obscure_get(shell)) {
    40008fe8:	361003e1 	tbz	w1, #2, 40009064 <reprint_from_cursor+0xb8>
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
    40008fec:	90000075 	adrp	x21, 40014000 <CSWTCH.135+0x90>
    40008ff0:	91190ab5 	add	x21, x21, #0x642
		int len = strlen(&shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
    40008ff4:	94000aef 	bl	4000bbb0 <strlen>
		while (len--) {
    40008ff8:	2a0003f4 	mov	w20, w0
    40008ffc:	350002b4 	cbnz	w20, 40009050 <reprint_from_cursor+0xa4>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
    40009000:	f9400a60 	ldr	x0, [x19, #16]
    40009004:	7940e001 	ldrh	w1, [x0, #112]
    40009008:	7900e401 	strh	w1, [x0, #114]
	if (full_line_cmd(shell)) {
    4000900c:	aa1303e0 	mov	x0, x19
    40009010:	97fffdcf 	bl	4000874c <full_line_cmd>
    40009014:	72001c1f 	tst	w0, #0xff
    40009018:	540000e0 	b.eq	40009034 <reprint_from_cursor+0x88>  // b.none
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
    4000901c:	710002df 	cmp	w22, #0x0
    40009020:	7a401ae4 	ccmp	w23, #0x0, #0x4, ne  // ne = any
    40009024:	54000041 	b.ne	4000902c <reprint_from_cursor+0x80>  // b.any
    40009028:	35000077 	cbnz	w23, 40009034 <reprint_from_cursor+0x88>
			z_cursor_next_line_move(shell);
    4000902c:	f9401660 	ldr	x0, [x19, #40]
    40009030:	97fffdc4 	bl	40008740 <z_cursor_next_line_move.isra.0>
	z_shell_op_cursor_move(shell, -diff);
    40009034:	4b1603e1 	neg	w1, w22
    40009038:	aa1303e0 	mov	x0, x19
}
    4000903c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009040:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009044:	f9401bf7 	ldr	x23, [sp, #48]
    40009048:	a8c47bfd 	ldp	x29, x30, [sp], #64
	z_shell_op_cursor_move(shell, -diff);
    4000904c:	17fffe43 	b	40008958 <z_shell_op_cursor_move>
			z_shell_raw_fprintf(shell->fprintf_ctx, "*");
    40009050:	f9401660 	ldr	x0, [x19, #40]
    40009054:	aa1503e1 	mov	x1, x21
    40009058:	51000694 	sub	w20, w20, #0x1
    4000905c:	97fffd94 	bl	400086ac <z_shell_raw_fprintf>
    40009060:	17ffffe7 	b	40008ffc <reprint_from_cursor+0x50>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s",
    40009064:	aa0003e3 	mov	x3, x0
    40009068:	f0000042 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    4000906c:	91205c42 	add	x2, x2, #0x817
    40009070:	aa1303e0 	mov	x0, x19
    40009074:	52800101 	mov	w1, #0x8                   	// #8
    40009078:	97ffff60 	bl	40008df8 <z_shell_fprintf>
    4000907c:	17ffffe1 	b	40009000 <reprint_from_cursor+0x54>

0000000040009080 <data_insert>:
{
    40009080:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40009084:	910003fd 	mov	x29, sp
    40009088:	a90153f3 	stp	x19, x20, [sp, #16]
    4000908c:	12003c54 	and	w20, w2, #0xffff
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    40009090:	f9400813 	ldr	x19, [x0, #16]
{
    40009094:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009098:	aa0003f5 	mov	x21, x0
    4000909c:	a90363f7 	stp	x23, x24, [sp, #48]
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    400090a0:	7940e260 	ldrh	w0, [x19, #112]
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
    400090a4:	0b222002 	add	w2, w0, w2, uxth
    400090a8:	7103fc5f 	cmp	w2, #0xff
    400090ac:	540003ac 	b.gt	40009120 <data_insert+0xa0>
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    400090b0:	7940e663 	ldrh	w3, [x19, #114]
    400090b4:	aa0103f6 	mov	x22, x1
	memmove(curr_pos + len, curr_pos, after);
    400090b8:	92403e97 	and	x23, x20, #0xffff
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    400090bc:	4b030000 	sub	w0, w0, w3
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    400090c0:	92403c63 	and	x3, x3, #0xffff
    400090c4:	9101d863 	add	x3, x3, #0x76
	memmove(curr_pos + len, curr_pos, after);
    400090c8:	92403c02 	and	x2, x0, #0xffff
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    400090cc:	8b030273 	add	x19, x19, x3
	uint16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    400090d0:	12003c18 	and	w24, w0, #0xffff
	memmove(curr_pos + len, curr_pos, after);
    400090d4:	aa1303e1 	mov	x1, x19
    400090d8:	8b342260 	add	x0, x19, w20, uxth
    400090dc:	94000ae9 	bl	4000bc80 <memmove>
	memcpy(curr_pos, data, len);
    400090e0:	aa1703e2 	mov	x2, x23
    400090e4:	aa1603e1 	mov	x1, x22
    400090e8:	aa1303e0 	mov	x0, x19
    400090ec:	94000af4 	bl	4000bcbc <memcpy>
	shell->ctx->cmd_buff_len += len;
    400090f0:	f9400aa2 	ldr	x2, [x21, #16]
    400090f4:	7940e041 	ldrh	w1, [x2, #112]
    400090f8:	0b010281 	add	w1, w20, w1
    400090fc:	12003c21 	and	w1, w1, #0xffff
    40009100:	7900e041 	strh	w1, [x2, #112]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
    40009104:	8b21c041 	add	x1, x2, w1, sxtw
    40009108:	3901d83f 	strb	wzr, [x1, #118]
	return sh->ctx->cfg.flags.echo == 1;
    4000910c:	b9429840 	ldr	w0, [x2, #664]
	if (!z_flag_echo_get(shell)) {
    40009110:	37080120 	tbnz	w0, #1, 40009134 <data_insert+0xb4>
		shell->ctx->cmd_buff_pos += len;
    40009114:	7940e440 	ldrh	w0, [x2, #114]
    40009118:	0b000294 	add	w20, w20, w0
    4000911c:	7900e454 	strh	w20, [x2, #114]
}
    40009120:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009124:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009128:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000912c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40009130:	d65f03c0 	ret
	reprint_from_cursor(shell, after, false);
    40009134:	2a1803e1 	mov	w1, w24
    40009138:	aa1503e0 	mov	x0, x21
}
    4000913c:	a94153f3 	ldp	x19, x20, [sp, #16]
	reprint_from_cursor(shell, after, false);
    40009140:	52800002 	mov	w2, #0x0                   	// #0
}
    40009144:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009148:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000914c:	a8c47bfd 	ldp	x29, x30, [sp], #64
	reprint_from_cursor(shell, after, false);
    40009150:	17ffff97 	b	40008fac <reprint_from_cursor>

0000000040009154 <z_shell_op_char_insert>:
{
    40009154:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40009158:	910003fd 	mov	x29, sp
    4000915c:	f9000bf3 	str	x19, [sp, #16]
    40009160:	aa0003f3 	mov	x19, x0
	return sh->ctx->cfg.flags.insert_mode == 1;
    40009164:	f9400800 	ldr	x0, [x0, #16]
    40009168:	3900bfe1 	strb	w1, [sp, #47]
    4000916c:	b9429801 	ldr	w1, [x0, #664]
	if (z_flag_insert_mode_get(shell) &&
    40009170:	360003a1 	tbz	w1, #0, 400091e4 <z_shell_op_char_insert+0x90>
	    (shell->ctx->cmd_buff_len != shell->ctx->cmd_buff_pos)) {
    40009174:	7940e401 	ldrh	w1, [x0, #114]
	if (z_flag_insert_mode_get(shell) &&
    40009178:	7940e002 	ldrh	w2, [x0, #112]
    4000917c:	6b01005f 	cmp	w2, w1
    40009180:	54000320 	b.eq	400091e4 <z_shell_op_char_insert+0x90>  // b.none
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
    40009184:	11000423 	add	w3, w1, #0x1
    40009188:	8b21c001 	add	x1, x0, w1, sxtw
		char_replace(shell, data);
    4000918c:	3940bfe2 	ldrb	w2, [sp, #47]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
    40009190:	7900e403 	strh	w3, [x0, #114]
    40009194:	3901d822 	strb	w2, [x1, #118]
	return sh->ctx->cfg.flags.echo == 1;
    40009198:	b9429801 	ldr	w1, [x0, #664]
	if (!z_flag_echo_get(shell)) {
    4000919c:	360801e1 	tbz	w1, #1, 400091d8 <z_shell_op_char_insert+0x84>
	return sh->ctx->cfg.flags.obscure == 1;
    400091a0:	b9429800 	ldr	w0, [x0, #664]
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
    400091a4:	f0000041 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    400091a8:	9135c421 	add	x1, x1, #0xd71
		data = '*';
    400091ac:	f27e001f 	tst	x0, #0x4
	z_shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
    400091b0:	52800540 	mov	w0, #0x2a                  	// #42
    400091b4:	1a800042 	csel	w2, w2, w0, eq  // eq = none
    400091b8:	f9401660 	ldr	x0, [x19, #40]
    400091bc:	97fffd3c 	bl	400086ac <z_shell_raw_fprintf>
	if (z_shell_cursor_in_empty_line(shell)) {
    400091c0:	aa1303e0 	mov	x0, x19
    400091c4:	97fffd98 	bl	40008824 <z_shell_cursor_in_empty_line>
    400091c8:	72001c1f 	tst	w0, #0xff
    400091cc:	54000060 	b.eq	400091d8 <z_shell_op_char_insert+0x84>  // b.none
		z_cursor_next_line_move(shell);
    400091d0:	f9401660 	ldr	x0, [x19, #40]
    400091d4:	97fffd5b 	bl	40008740 <z_cursor_next_line_move.isra.0>
}
    400091d8:	f9400bf3 	ldr	x19, [sp, #16]
    400091dc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400091e0:	d65f03c0 	ret
		data_insert(shell, &data, 1);
    400091e4:	9100bfe1 	add	x1, sp, #0x2f
    400091e8:	aa1303e0 	mov	x0, x19
    400091ec:	52800022 	mov	w2, #0x1                   	// #1
    400091f0:	97ffffa4 	bl	40009080 <data_insert>
}
    400091f4:	17fffff9 	b	400091d8 <z_shell_op_char_insert+0x84>

00000000400091f8 <z_shell_op_completion_insert>:
	data_insert(shell, compl, compl_len);
    400091f8:	17ffffa2 	b	40009080 <data_insert>

00000000400091fc <z_shell_op_char_delete>:
{
    400091fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009200:	910003fd 	mov	x29, sp
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    40009204:	f9400801 	ldr	x1, [x0, #16]
{
    40009208:	a90153f3 	stp	x19, x20, [sp, #16]
	uint16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
    4000920c:	7940e422 	ldrh	w2, [x1, #114]
    40009210:	7940e033 	ldrh	w19, [x1, #112]
    40009214:	4b020273 	sub	w19, w19, w2
	if (diff == 0U) {
    40009218:	72003e73 	ands	w19, w19, #0xffff
    4000921c:	54000240 	b.eq	40009264 <z_shell_op_char_delete+0x68>  // b.none
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
    40009220:	92403c42 	and	x2, x2, #0xffff
    40009224:	aa0003f4 	mov	x20, x0
    40009228:	9101d842 	add	x2, x2, #0x76
    4000922c:	8b020020 	add	x0, x1, x2
	memmove(str, str + 1, diff);
    40009230:	92403e62 	and	x2, x19, #0xffff
    40009234:	91000401 	add	x1, x0, #0x1
    40009238:	94000a92 	bl	4000bc80 <memmove>
	--shell->ctx->cmd_buff_len;
    4000923c:	f9400a81 	ldr	x1, [x20, #16]
	reprint_from_cursor(shell, --diff, true);
    40009240:	52800022 	mov	w2, #0x1                   	// #1
	--shell->ctx->cmd_buff_len;
    40009244:	7940e020 	ldrh	w0, [x1, #112]
    40009248:	51000400 	sub	w0, w0, #0x1
    4000924c:	7900e020 	strh	w0, [x1, #112]
	reprint_from_cursor(shell, --diff, true);
    40009250:	51000661 	sub	w1, w19, #0x1
    40009254:	aa1403e0 	mov	x0, x20
}
    40009258:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000925c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	reprint_from_cursor(shell, --diff, true);
    40009260:	17ffff53 	b	40008fac <reprint_from_cursor>
}
    40009264:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009268:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000926c:	d65f03c0 	ret

0000000040009270 <z_shell_op_char_backspace>:
	if ((shell->ctx->cmd_buff_len == 0) ||
    40009270:	f9400801 	ldr	x1, [x0, #16]
    40009274:	7940e022 	ldrh	w2, [x1, #112]
    40009278:	340001a2 	cbz	w2, 400092ac <z_shell_op_char_backspace+0x3c>
    4000927c:	7940e421 	ldrh	w1, [x1, #114]
    40009280:	34000161 	cbz	w1, 400092ac <z_shell_op_char_backspace+0x3c>
{
    40009284:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	z_shell_op_cursor_move(shell, -1);
    40009288:	12800001 	mov	w1, #0xffffffff            	// #-1
{
    4000928c:	910003fd 	mov	x29, sp
    40009290:	f9000bf3 	str	x19, [sp, #16]
    40009294:	aa0003f3 	mov	x19, x0
	z_shell_op_cursor_move(shell, -1);
    40009298:	97fffdb0 	bl	40008958 <z_shell_op_cursor_move>
	z_shell_op_char_delete(shell);
    4000929c:	aa1303e0 	mov	x0, x19
}
    400092a0:	f9400bf3 	ldr	x19, [sp, #16]
    400092a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_shell_op_char_delete(shell);
    400092a8:	17ffffd5 	b	400091fc <z_shell_op_char_delete>
    400092ac:	d65f03c0 	ret

00000000400092b0 <z_shell_print_prompt_and_cmd>:
{
    400092b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    400092b4:	f0000042 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    400092b8:	91205c42 	add	x2, x2, #0x817
{
    400092bc:	910003fd 	mov	x29, sp
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    400092c0:	f9400801 	ldr	x1, [x0, #16]
    400092c4:	f9400023 	ldr	x3, [x1]
{
    400092c8:	f9000bf3 	str	x19, [sp, #16]
    400092cc:	aa0003f3 	mov	x19, x0
	z_shell_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
    400092d0:	52800041 	mov	w1, #0x2                   	// #2
    400092d4:	97fffec9 	bl	40008df8 <z_shell_fprintf>
	return sh->ctx->cfg.flags.echo == 1;
    400092d8:	f9400a60 	ldr	x0, [x19, #16]
    400092dc:	b9429800 	ldr	w0, [x0, #664]
	if (z_flag_echo_get(shell)) {
    400092e0:	360800e0 	tbz	w0, #1, 400092fc <z_shell_print_prompt_and_cmd+0x4c>
		z_shell_print_cmd(shell);
    400092e4:	aa1303e0 	mov	x0, x19
    400092e8:	97fffe2a 	bl	40008b90 <z_shell_print_cmd>
		z_shell_op_cursor_position_synchronize(shell);
    400092ec:	aa1303e0 	mov	x0, x19
}
    400092f0:	f9400bf3 	ldr	x19, [sp, #16]
    400092f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_shell_op_cursor_position_synchronize(shell);
    400092f8:	17fffd73 	b	400088c4 <z_shell_op_cursor_position_synchronize>
}
    400092fc:	f9400bf3 	ldr	x19, [sp, #16]
    40009300:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40009304:	d65f03c0 	ret

0000000040009308 <msg_from_fifo.isra.0>:
{
	z_shell_print_stream(ctx, data, length);
	return length;
}

static struct log_msg *msg_from_fifo(const struct shell_log_backend *backend)
    40009308:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000930c:	910003fd 	mov	x29, sp
	return z_impl_k_msgq_get(msgq, data, timeout);
    40009310:	d2800002 	mov	x2, #0x0                   	// #0
    40009314:	910043e1 	add	x1, sp, #0x10
    40009318:	940016ab 	bl	4000edc4 <z_impl_k_msgq_get>
	struct shell_log_backend_msg msg;
	int err;

	err = k_msgq_get(backend->msgq, &msg, K_NO_WAIT);

	return (err == 0) ? msg.msg : NULL;
    4000931c:	7100001f 	cmp	w0, #0x0
}
    40009320:	f9400be0 	ldr	x0, [sp, #16]
    40009324:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40009328:	9a9f0000 	csel	x0, x0, xzr, eq  // eq = none
    4000932c:	d65f03c0 	ret

0000000040009330 <put>:

	return true;
}

static void put(const struct log_backend *const backend, struct log_msg *msg)
{
    40009330:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40009334:	910003fd 	mov	x29, sp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    40009338:	f9400400 	ldr	x0, [x0, #8]
{
    4000933c:	a90153f3 	stp	x19, x20, [sp, #16]
    40009340:	aa0103f4 	mov	x20, x1
    40009344:	a9025bf5 	stp	x21, x22, [sp, #32]
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    40009348:	f9400013 	ldr	x19, [x0]
	return sh->ctx->cfg.flags.use_colors == 1;
    4000934c:	f9400a60 	ldr	x0, [x19, #16]
{
    40009350:	f9001bf7 	str	x23, [sp, #48]
    40009354:	b9429815 	ldr	w21, [x0, #664]
	bool colors = IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
			z_flag_use_colors_get(shell);
	struct k_poll_signal *signal;

	log_msg_get(msg);
    40009358:	aa0103e0 	mov	x0, x1
    4000935c:	97ffebc5 	bl	40004270 <log_msg_get>

	switch (shell->log_backend->control_block->state) {
    40009360:	f9401e60 	ldr	x0, [x19, #56]
    40009364:	d34412b5 	ubfx	x21, x21, #4, #1
    40009368:	f9400c00 	ldr	x0, [x0, #24]
    4000936c:	b9400800 	ldr	w0, [x0, #8]
    40009370:	7100041f 	cmp	w0, #0x1
    40009374:	54000120 	b.eq	40009398 <put+0x68>  // b.none
    40009378:	71000c1f 	cmp	w0, #0x3
    4000937c:	540006c0 	b.eq	40009454 <put+0x124>  // b.none

	case SHELL_LOG_BACKEND_DISABLED:
		__fallthrough;
	default:
		/* Discard message. */
		log_msg_put(msg);
    40009380:	aa1403e0 	mov	x0, x20
	}
}
    40009384:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009388:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000938c:	f9401bf7 	ldr	x23, [sp, #48]
    40009390:	a8c67bfd 	ldp	x29, x30, [sp], #96
		log_msg_put(msg);
    40009394:	17ffec37 	b	40004470 <log_msg_put>
	struct shell_log_backend_msg t_msg = {
    40009398:	f90023f4 	str	x20, [sp, #64]
		}
	} else if (mul_ratio) {
		if (result32) {
			return ((uint32_t)t) * (to_hz / from_hz);
		} else {
			return t * ((uint64_t)to_hz / from_hz);
    4000939c:	d2800155 	mov	x21, #0xa                   	// #10
	return z_impl_k_uptime_ticks();
    400093a0:	94001c0b 	bl	400103cc <z_impl_k_uptime_ticks>
    400093a4:	9b157c00 	mul	x0, x0, x21
	return (uint32_t)k_uptime_get();
    400093a8:	b9004be0 	str	w0, [sp, #72]
		err = k_msgq_put(shell->log_backend->msgq, &t_msg,
    400093ac:	f9401e61 	ldr	x1, [x19, #56]
				 K_MSEC(shell->log_backend->timeout));
    400093b0:	b9402022 	ldr	w2, [x1, #32]
		err = k_msgq_put(shell->log_backend->msgq, &t_msg,
    400093b4:	f9400420 	ldr	x0, [x1, #8]
		t += off;
    400093b8:	91002442 	add	x2, x2, #0x9
			return t / ((uint64_t)from_hz / to_hz);
    400093bc:	9ad50842 	udiv	x2, x2, x21
	return z_impl_k_msgq_put(msgq, data, timeout);
    400093c0:	910103e1 	add	x1, sp, #0x40
    400093c4:	9400163b 	bl	4000ecb0 <z_impl_k_msgq_put>
		switch (err) {
    400093c8:	31008c1f 	cmn	w0, #0x23
    400093cc:	54000160 	b.eq	400093f8 <put+0xc8>  // b.none
    400093d0:	31002c1f 	cmn	w0, #0xb
    400093d4:	54000120 	b.eq	400093f8 <put+0xc8>  // b.none
			signal = &shell->ctx->signals[SHELL_SIGNAL_LOG_MSG];
    400093d8:	f9400a60 	ldr	x0, [x19, #16]
    400093dc:	910b0000 	add	x0, x0, #0x2c0
}
    400093e0:	a94153f3 	ldp	x19, x20, [sp, #16]
	return z_impl_k_poll_signal_raise(sig, result);
    400093e4:	52800001 	mov	w1, #0x0                   	// #0
    400093e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400093ec:	f9401bf7 	ldr	x23, [sp, #48]
    400093f0:	a8c67bfd 	ldp	x29, x30, [sp], #96
    400093f4:	14001eb4 	b	40010ec4 <z_impl_k_poll_signal_raise>
	struct k_msgq *msgq = shell->log_backend->msgq;
    400093f8:	f9401e60 	ldr	x0, [x19, #56]
	uint32_t timeout = shell->log_backend->timeout;
    400093fc:	b9402017 	ldr	w23, [x0, #32]
	struct k_msgq *msgq = shell->log_backend->msgq;
    40009400:	f9400416 	ldr	x22, [x0, #8]
	return z_impl_k_uptime_ticks();
    40009404:	94001bf2 	bl	400103cc <z_impl_k_uptime_ticks>
    40009408:	1b157c14 	mul	w20, w0, w21
	return z_impl_k_msgq_peek(msgq, data);
    4000940c:	910143e1 	add	x1, sp, #0x50
    40009410:	aa1603e0 	mov	x0, x22
    40009414:	940016b7 	bl	4000eef0 <z_impl_k_msgq_peek>
		if (err == 0 && ((now - msg.timestamp) > timeout)) {
    40009418:	35fffca0 	cbnz	w0, 400093ac <put+0x7c>
    4000941c:	b9405be0 	ldr	w0, [sp, #88]
    40009420:	4b000280 	sub	w0, w20, w0
    40009424:	6b0002ff 	cmp	w23, w0
    40009428:	54fffc22 	b.cs	400093ac <put+0x7c>  // b.hs, b.nlast
	return z_impl_k_msgq_get(msgq, data, timeout);
    4000942c:	d2800002 	mov	x2, #0x0                   	// #0
    40009430:	910143e1 	add	x1, sp, #0x50
    40009434:	aa1603e0 	mov	x0, x22
    40009438:	94001663 	bl	4000edc4 <z_impl_k_msgq_get>
			log_msg_put(msg.msg);
    4000943c:	f9402be0 	ldr	x0, [sp, #80]
    40009440:	97ffec0c 	bl	40004470 <log_msg_put>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    40009444:	f9401a61 	ldr	x1, [x19, #48]
    40009448:	d2800020 	mov	x0, #0x1                   	// #1
    4000944c:	97ffdedd 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
		err = k_msgq_peek(msgq, &msg);
    40009450:	17ffffef 	b	4000940c <put+0xdc>
		z_shell_cmd_line_erase(shell);
    40009454:	aa1303e0 	mov	x0, x19
    40009458:	97fffdb6 	bl	40008b30 <z_shell_cmd_line_erase>
		msg_process(shell->log_backend->log_output, msg, colors);
    4000945c:	f9401e60 	ldr	x0, [x19, #56]
	log_output_msg_process(log_output, msg, flags);
    40009460:	11003aa2 	add	w2, w21, #0xe
    40009464:	aa1403e1 	mov	x1, x20
    40009468:	f9400800 	ldr	x0, [x0, #16]
    4000946c:	97ffee40 	bl	40004d6c <log_output_msg_process>
	log_msg_put(msg);
    40009470:	17ffffc4 	b	40009380 <put+0x50>

0000000040009474 <dropped>:
		z_shell_log_backend_disable(shell->log_backend);
	}
}

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
    40009474:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009478:	910003fd 	mov	x29, sp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    4000947c:	f9400400 	ldr	x0, [x0, #8]
{
    40009480:	a90153f3 	stp	x19, x20, [sp, #16]
    40009484:	2a0103f3 	mov	w19, w1
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    40009488:	f9400000 	ldr	x0, [x0]
	const struct shell_log_backend *log_backend = shell->log_backend;
    4000948c:	a9435001 	ldp	x1, x20, [x0, #48]
    40009490:	aa1303e0 	mov	x0, x19
    40009494:	97ffdecb 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>
    40009498:	f9400e81 	ldr	x1, [x20, #24]
    4000949c:	aa1303e0 	mov	x0, x19
    400094a0:	97ffdec8 	bl	40000fc0 <__aarch64_ldadd8_acq_rel>

	atomic_add(&shell->stats->log_lost_cnt, cnt);
	atomic_add(&log_backend->control_block->dropped_cnt, cnt);
}
    400094a4:	a94153f3 	ldp	x19, x20, [sp, #16]
    400094a8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400094ac:	d65f03c0 	ret

00000000400094b0 <z_shell_log_backend_output_func>:
{
    400094b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400094b4:	aa0003e3 	mov	x3, x0
    400094b8:	aa0203e0 	mov	x0, x2
    400094bc:	910003fd 	mov	x29, sp
	z_shell_print_stream(ctx, data, length);
    400094c0:	aa0103e2 	mov	x2, x1
{
    400094c4:	f9000bf3 	str	x19, [sp, #16]
    400094c8:	aa0103f3 	mov	x19, x1
	z_shell_print_stream(ctx, data, length);
    400094cc:	aa0303e1 	mov	x1, x3
    400094d0:	97fffdeb 	bl	40008c7c <z_shell_print_stream>
}
    400094d4:	2a1303e0 	mov	w0, w19
    400094d8:	f9400bf3 	ldr	x19, [sp, #16]
    400094dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400094e0:	d65f03c0 	ret

00000000400094e4 <z_shell_log_backend_enable>:
{
    400094e4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400094e8:	910003fd 	mov	x29, sp
    400094ec:	a90153f3 	stp	x19, x20, [sp, #16]
    400094f0:	aa0003f3 	mov	x19, x0
    400094f4:	aa0103f4 	mov	x20, x1
    400094f8:	f90013f5 	str	x21, [sp, #32]
    400094fc:	2a0203f5 	mov	w21, w2
		while ((msg = msg_from_fifo(backend)) != NULL) {
    40009500:	f9400660 	ldr	x0, [x19, #8]
    40009504:	97ffff81 	bl	40009308 <msg_from_fifo.isra.0>
    40009508:	b5000200 	cbnz	x0, 40009548 <z_shell_log_backend_enable+0x64>
		log_backend_enable(backend->backend, ctx, init_log_level);
    4000950c:	f9400260 	ldr	x0, [x19]
    40009510:	2a1503e2 	mov	w2, w21
    40009514:	aa1403e1 	mov	x1, x20
    40009518:	97ffead0 	bl	40004058 <log_backend_enable>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *output,
				      void *ctx)
{
	output->control_block->ctx = ctx;
    4000951c:	f9400a60 	ldr	x0, [x19, #16]
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
    40009520:	52800021 	mov	w1, #0x1                   	// #1
}
    40009524:	f94013f5 	ldr	x21, [sp, #32]
    40009528:	f9400400 	ldr	x0, [x0, #8]
    4000952c:	f9000414 	str	x20, [x0, #8]
		backend->control_block->dropped_cnt = 0;
    40009530:	f9400e60 	ldr	x0, [x19, #24]
}
    40009534:	a94153f3 	ldp	x19, x20, [sp, #16]
		backend->control_block->dropped_cnt = 0;
    40009538:	f900001f 	str	xzr, [x0]
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
    4000953c:	b9000801 	str	w1, [x0, #8]
}
    40009540:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40009544:	d65f03c0 	ret
			log_msg_put(msg);
    40009548:	97ffebca 	bl	40004470 <log_msg_put>
    4000954c:	17ffffed 	b	40009500 <z_shell_log_backend_enable+0x1c>

0000000040009550 <z_shell_log_backend_disable>:
{
    40009550:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009554:	910003fd 	mov	x29, sp
    40009558:	f9000bf3 	str	x19, [sp, #16]
    4000955c:	aa0003f3 	mov	x19, x0
	log_backend_disable(backend->backend);
    40009560:	f9400000 	ldr	x0, [x0]
    40009564:	97ffead0 	bl	400040a4 <log_backend_disable>
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
    40009568:	f9400e60 	ldr	x0, [x19, #24]
    4000956c:	52800041 	mov	w1, #0x2                   	// #2
}
    40009570:	f9400bf3 	ldr	x19, [sp, #16]
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
    40009574:	b9000801 	str	w1, [x0, #8]
}
    40009578:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000957c:	d65f03c0 	ret

0000000040009580 <z_shell_log_backend_process>:
{
    40009580:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40009584:	910003fd 	mov	x29, sp
    40009588:	a90153f3 	stp	x19, x20, [sp, #16]
    4000958c:	aa0003f3 	mov	x19, x0
			(const struct shell *)backend->backend->cb->ctx;
    40009590:	f9400000 	ldr	x0, [x0]
{
    40009594:	a9025bf5 	stp	x21, x22, [sp, #32]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    40009598:	f9400e61 	ldr	x1, [x19, #24]
	const struct shell *shell =
    4000959c:	f9400400 	ldr	x0, [x0, #8]
    400095a0:	f9400015 	ldr	x21, [x0]
    400095a4:	f9400aa0 	ldr	x0, [x21, #16]
    400095a8:	b9429814 	ldr	w20, [x0, #664]
    400095ac:	d2800000 	mov	x0, #0x0                   	// #0
    400095b0:	d3441294 	ubfx	x20, x20, #4, #1
    400095b4:	97ffde77 	bl	40000f90 <__aarch64_swp8_acq_rel>
	if (dropped) {
    400095b8:	34000240 	cbz	w0, 40009600 <z_shell_log_backend_process+0x80>
    400095bc:	aa0003f6 	mov	x22, x0
		if (colors) {
    400095c0:	34000134 	cbz	w20, 400095e4 <z_shell_log_backend_process+0x64>
	memcpy(color, &sh->ctx->vt100_ctx.col, sizeof(*color));
    400095c4:	f9400aa1 	ldr	x1, [x21, #16]
    400095c8:	d2800102 	mov	x2, #0x8                   	// #8
    400095cc:	9100e3e0 	add	x0, sp, #0x38
    400095d0:	91014021 	add	x1, x1, #0x50
    400095d4:	940009ba 	bl	4000bcbc <memcpy>
			z_shell_vt100_color_set(shell, SHELL_VT100_COLOR_RED);
    400095d8:	aa1503e0 	mov	x0, x21
    400095dc:	52800021 	mov	w1, #0x1                   	// #1
    400095e0:	97fffda8 	bl	40008c80 <z_shell_vt100_color_set>
		log_output_dropped_process(backend->log_output, dropped);
    400095e4:	f9400a60 	ldr	x0, [x19, #16]
    400095e8:	2a1603e1 	mov	w1, w22
    400095ec:	97ffee42 	bl	40004ef4 <log_output_dropped_process>
		if (colors) {
    400095f0:	34000094 	cbz	w20, 40009600 <z_shell_log_backend_process+0x80>
			z_shell_vt100_colors_restore(shell, &col);
    400095f4:	9100e3e1 	add	x1, sp, #0x38
    400095f8:	aa1503e0 	mov	x0, x21
    400095fc:	97fffdb8 	bl	40008cdc <z_shell_vt100_colors_restore>
	struct log_msg *msg = msg_from_fifo(backend);
    40009600:	f9400660 	ldr	x0, [x19, #8]
    40009604:	97ffff41 	bl	40009308 <msg_from_fifo.isra.0>
    40009608:	aa0003f3 	mov	x19, x0
	if (!msg) {
    4000960c:	b40001a0 	cbz	x0, 40009640 <z_shell_log_backend_process+0xc0>
	log_output_msg_process(log_output, msg, flags);
    40009610:	aa0003e1 	mov	x1, x0
    40009614:	11003a82 	add	w2, w20, #0xe
	msg_process(shell->log_backend->log_output, msg, colors);
    40009618:	f9401ea0 	ldr	x0, [x21, #56]
	log_output_msg_process(log_output, msg, flags);
    4000961c:	f9400800 	ldr	x0, [x0, #16]
    40009620:	97ffedd3 	bl	40004d6c <log_output_msg_process>
	log_msg_put(msg);
    40009624:	aa1303e0 	mov	x0, x19
    40009628:	97ffeb92 	bl	40004470 <log_msg_put>
	return true;
    4000962c:	52800020 	mov	w0, #0x1                   	// #1
}
    40009630:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009634:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009638:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000963c:	d65f03c0 	ret
		return false;
    40009640:	52800000 	mov	w0, #0x0                   	// #0
    40009644:	17fffffb 	b	40009630 <z_shell_log_backend_process+0xb0>

0000000040009648 <panic>:
{
    40009648:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000964c:	910003fd 	mov	x29, sp
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    40009650:	f9400400 	ldr	x0, [x0, #8]
{
    40009654:	f9000bf3 	str	x19, [sp, #16]
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
    40009658:	f9400013 	ldr	x19, [x0]
	err = shell->iface->api->enable(shell->iface, true);
    4000965c:	f9400660 	ldr	x0, [x19, #8]
    40009660:	f9400001 	ldr	x1, [x0]
    40009664:	f9400822 	ldr	x2, [x1, #16]
    40009668:	52800021 	mov	w1, #0x1                   	// #1
    4000966c:	d63f0040 	blr	x2
	if (err == 0) {
    40009670:	350003a0 	cbnz	w0, 400096e4 <panic+0x9c>
		shell->log_backend->control_block->state =
    40009674:	f9401e60 	ldr	x0, [x19, #56]
    40009678:	52800061 	mov	w1, #0x3                   	// #3
    4000967c:	f9400c00 	ldr	x0, [x0, #24]
    40009680:	b9000801 	str	w1, [x0, #8]
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    40009684:	d2840000 	mov	x0, #0x2000                	// #8192
    40009688:	f9400a61 	ldr	x1, [x19, #16]
    4000968c:	910a8021 	add	x1, x1, #0x2a0
    40009690:	97ffde64 	bl	40001020 <__aarch64_ldset8_acq_rel>
		z_shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
    40009694:	f9400a60 	ldr	x0, [x19, #16]
    40009698:	91010000 	add	x0, x0, #0x40
    4000969c:	79406002 	ldrh	w2, [x0, #48]
    400096a0:	79406401 	ldrh	w1, [x0, #50]
    400096a4:	97fffa50 	bl	40007fe4 <z_shell_multiline_data_calc>
		z_shell_op_cursor_vert_move(shell, -1);
    400096a8:	aa1303e0 	mov	x0, x19
    400096ac:	12800001 	mov	w1, #0xffffffff            	// #-1
    400096b0:	97fffc3d 	bl	400087a4 <z_shell_op_cursor_vert_move>
					   -shell->ctx->vt100_ctx.cons.cur_x);
    400096b4:	f9400a60 	ldr	x0, [x19, #16]
    400096b8:	79408001 	ldrh	w1, [x0, #64]
		z_shell_op_cursor_horiz_move(shell,
    400096bc:	aa1303e0 	mov	x0, x19
    400096c0:	4b0103e1 	neg	w1, w1
    400096c4:	97fffc48 	bl	400087e4 <z_shell_op_cursor_horiz_move>
			while (z_shell_log_backend_process(
    400096c8:	f9401e60 	ldr	x0, [x19, #56]
    400096cc:	97ffffad 	bl	40009580 <z_shell_log_backend_process>
    400096d0:	72001c1f 	tst	w0, #0xff
    400096d4:	54ffffa1 	b.ne	400096c8 <panic+0x80>  // b.any
}
    400096d8:	f9400bf3 	ldr	x19, [sp, #16]
    400096dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400096e0:	d65f03c0 	ret
		z_shell_log_backend_disable(shell->log_backend);
    400096e4:	f9401e60 	ldr	x0, [x19, #56]
}
    400096e8:	f9400bf3 	ldr	x19, [sp, #16]
    400096ec:	a8c27bfd 	ldp	x29, x30, [sp], #32
		z_shell_log_backend_disable(shell->log_backend);
    400096f0:	17ffff98 	b	40009550 <z_shell_log_backend_disable>

00000000400096f4 <z_shell_raw_fprintf>:
{
    400096f4:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    400096f8:	910003fd 	mov	x29, sp
    400096fc:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    40009700:	910403e2 	add	x2, sp, #0x100
    40009704:	a9030be2 	stp	x2, x2, [sp, #48]
    40009708:	910343e2 	add	x2, sp, #0xd0
    4000970c:	f90023e2 	str	x2, [sp, #64]
    40009710:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    40009714:	b9004be2 	str	w2, [sp, #72]
    40009718:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    4000971c:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40009720:	a9430fe2 	ldp	x2, x3, [sp, #48]
    40009724:	a9010fe2 	stp	x2, x3, [sp, #16]
    40009728:	a9440fe2 	ldp	x2, x3, [sp, #64]
    4000972c:	a9020fe2 	stp	x2, x3, [sp, #32]
    40009730:	910043e2 	add	x2, sp, #0x10
{
    40009734:	3d8017e0 	str	q0, [sp, #80]
    40009738:	3d801be1 	str	q1, [sp, #96]
    4000973c:	3d801fe2 	str	q2, [sp, #112]
    40009740:	3d8023e3 	str	q3, [sp, #128]
    40009744:	3d8027e4 	str	q4, [sp, #144]
    40009748:	3d802be5 	str	q5, [sp, #160]
    4000974c:	3d802fe6 	str	q6, [sp, #176]
    40009750:	3d8033e7 	str	q7, [sp, #192]
    40009754:	a90e17e4 	stp	x4, x5, [sp, #224]
    40009758:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    4000975c:	97fff9d1 	bl	40007ea0 <z_shell_fprintf_fmt>
}
    40009760:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40009764:	d65f03c0 	ret

0000000040009768 <z_cursor_next_line_move.isra.0>:
	z_shell_raw_fprintf(sh->fprintf_ctx, "\n");
    40009768:	f0000041 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    4000976c:	911be021 	add	x1, x1, #0x6f8
    40009770:	17ffffe1 	b	400096f4 <z_shell_raw_fprintf>

0000000040009774 <formatted_text_print.constprop.0>:
				 size_t terminal_offset, bool offset_first_line)
{
	size_t offset = 0;
	size_t length;

	if (str == NULL) {
    40009774:	b4000b81 	cbz	x1, 400098e4 <formatted_text_print.constprop.0+0x170>
static void formatted_text_print(const struct shell *shell, const char *str,
    40009778:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000977c:	910003fd 	mov	x29, sp
    40009780:	a90153f3 	stp	x19, x20, [sp, #16]
    40009784:	aa0003f3 	mov	x19, x0
    40009788:	d2800014 	mov	x20, #0x0                   	// #0
    4000978c:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009790:	aa0103f5 	mov	x21, x1
    40009794:	a90363f7 	stp	x23, x24, [sp, #48]
    40009798:	aa0203f7 	mov	x23, x2
    4000979c:	f90023f9 	str	x25, [sp, #64]
		z_shell_op_cursor_horiz_move(shell, terminal_offset);
	}


	/* Skipping whitespace. */
	while (isspace((int) *(str + offset))) {
    400097a0:	38746aa0 	ldrb	w0, [x21, x20]
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    400097a4:	51002401 	sub	w1, w0, #0x9
    400097a8:	7100801f 	cmp	w0, #0x20
    400097ac:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    400097b0:	54000329 	b.ls	40009814 <formatted_text_print.constprop.0+0xa0>  // b.plast
    400097b4:	aa1503e0 	mov	x0, x21
    400097b8:	940008fe 	bl	4000bbb0 <strlen>
		size_t idx = 0;

		length = z_shell_strlen(str) - offset;

		if (length <=
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
    400097bc:	f9400a61 	ldr	x1, [x19, #16]
		length = z_shell_strlen(str) - offset;
    400097c0:	92403c00 	and	x0, x0, #0xffff
    400097c4:	cb140000 	sub	x0, x0, x20
		if (length <=
    400097c8:	8b1402b8 	add	x24, x21, x20
			for (idx = 0; idx < length; idx++) {
    400097cc:	d2800016 	mov	x22, #0x0                   	// #0
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
    400097d0:	79409422 	ldrh	w2, [x1, #74]
    400097d4:	cb170041 	sub	x1, x2, x23
		if (length <=
    400097d8:	eb01001f 	cmp	x0, x1
    400097dc:	54000229 	b.ls	40009820 <formatted_text_print.constprop.0+0xac>  // b.plast
		length = shell->ctx->vt100_ctx.cons.terminal_wid
				- terminal_offset;

		while (true) {
			/* Determining line break. */
			if (isspace((int) (*(str + offset + idx)))) {
    400097e0:	38766b00 	ldrb	w0, [x24, x22]
    400097e4:	51002403 	sub	w3, w0, #0x9
    400097e8:	7100801f 	cmp	w0, #0x20
    400097ec:	7a441860 	ccmp	w3, #0x4, #0x0, ne  // ne = any
    400097f0:	54000088 	b.hi	40009800 <formatted_text_print.constprop.0+0x8c>  // b.pmore
				length = idx;
				if (*(str + offset + idx) == '\n') {
    400097f4:	7100281f 	cmp	w0, #0xa
    400097f8:	540004e0 	b.eq	40009894 <formatted_text_print.constprop.0+0x120>  // b.none
    400097fc:	aa1603e1 	mov	x1, x22
					break;
				}
			}

			if ((idx + terminal_offset) >=
    40009800:	8b1602e0 	add	x0, x23, x22
    40009804:	eb00005f 	cmp	x2, x0
    40009808:	54000449 	b.ls	40009890 <formatted_text_print.constprop.0+0x11c>  // b.plast
			    shell->ctx->vt100_ctx.cons.terminal_wid) {
				/* End of line reached. */
				break;
			}

			++idx;
    4000980c:	910006d6 	add	x22, x22, #0x1
			if (isspace((int) (*(str + offset + idx)))) {
    40009810:	17fffff4 	b	400097e0 <formatted_text_print.constprop.0+0x6c>
		++offset;
    40009814:	91000694 	add	x20, x20, #0x1
    40009818:	17ffffe2 	b	400097a0 <formatted_text_print.constprop.0+0x2c>
			for (idx = 0; idx < length; idx++) {
    4000981c:	910006d6 	add	x22, x22, #0x1
    40009820:	eb16001f 	cmp	x0, x22
    40009824:	54000220 	b.eq	40009868 <formatted_text_print.constprop.0+0xf4>  // b.none
				if (*(str + offset + idx) == '\n') {
    40009828:	38766b01 	ldrb	w1, [x24, x22]
    4000982c:	8b160299 	add	x25, x20, x22
    40009830:	7100283f 	cmp	w1, #0xa
    40009834:	54ffff41 	b.ne	4000981c <formatted_text_print.constprop.0+0xa8>  // b.any
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
    40009838:	f9401660 	ldr	x0, [x19, #40]
					offset += idx + 1;
    4000983c:	91000734 	add	x20, x25, #0x1
    40009840:	97fff989 	bl	40007e64 <z_shell_fprintf_buffer_flush>
					z_shell_write(shell, str + offset, idx);
    40009844:	aa1803e1 	mov	x1, x24
    40009848:	aa1603e2 	mov	x2, x22
    4000984c:	aa1303e0 	mov	x0, x19
    40009850:	97fffcd6 	bl	40008ba8 <z_shell_write>
					z_cursor_next_line_move(shell);
    40009854:	f9401660 	ldr	x0, [x19, #40]
    40009858:	97ffffc4 	bl	40009768 <z_cursor_next_line_move.isra.0>
					z_shell_op_cursor_horiz_move(shell,
    4000985c:	2a1703e1 	mov	w1, w23
    40009860:	aa1303e0 	mov	x0, x19
    40009864:	97fffbe0 	bl	400087e4 <z_shell_op_cursor_horiz_move>
			z_shell_raw_fprintf(shell->fprintf_ctx, str + offset);
    40009868:	f9401660 	ldr	x0, [x19, #40]
    4000986c:	8b1402a1 	add	x1, x21, x20
    40009870:	97ffffa1 	bl	400096f4 <z_shell_raw_fprintf>
		z_cursor_next_line_move(shell);
		z_shell_op_cursor_horiz_move(shell, terminal_offset);

	}
	z_cursor_next_line_move(shell);
}
    40009874:	a9425bf5 	ldp	x21, x22, [sp, #32]
	z_cursor_next_line_move(shell);
    40009878:	f9401660 	ldr	x0, [x19, #40]
}
    4000987c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009880:	a94363f7 	ldp	x23, x24, [sp, #48]
    40009884:	f94023f9 	ldr	x25, [sp, #64]
    40009888:	a8c57bfd 	ldp	x29, x30, [sp], #80
	z_cursor_next_line_move(shell);
    4000988c:	17ffffb7 	b	40009768 <z_cursor_next_line_move.isra.0>
    40009890:	aa0103f6 	mov	x22, x1
    40009894:	f9401660 	ldr	x0, [x19, #40]
		offset += length;
    40009898:	8b160294 	add	x20, x20, x22
    4000989c:	97fff972 	bl	40007e64 <z_shell_fprintf_buffer_flush>
		z_shell_write(shell, str + offset, length);
    400098a0:	aa1603e2 	mov	x2, x22
    400098a4:	aa1803e1 	mov	x1, x24
    400098a8:	aa1303e0 	mov	x0, x19
    400098ac:	97fffcbf 	bl	40008ba8 <z_shell_write>
		while (isspace((int) (*(str + offset)))) {
    400098b0:	38746aa0 	ldrb	w0, [x21, x20]
    400098b4:	51002401 	sub	w1, w0, #0x9
    400098b8:	7100801f 	cmp	w0, #0x20
    400098bc:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    400098c0:	540000e9 	b.ls	400098dc <formatted_text_print.constprop.0+0x168>  // b.plast
		z_cursor_next_line_move(shell);
    400098c4:	f9401660 	ldr	x0, [x19, #40]
    400098c8:	97ffffa8 	bl	40009768 <z_cursor_next_line_move.isra.0>
		z_shell_op_cursor_horiz_move(shell, terminal_offset);
    400098cc:	2a1703e1 	mov	w1, w23
    400098d0:	aa1303e0 	mov	x0, x19
    400098d4:	97fffbc4 	bl	400087e4 <z_shell_op_cursor_horiz_move>
	while (true) {
    400098d8:	17ffffb7 	b	400097b4 <formatted_text_print.constprop.0+0x40>
			++offset;
    400098dc:	91000694 	add	x20, x20, #0x1
    400098e0:	17fffff4 	b	400098b0 <formatted_text_print.constprop.0+0x13c>
    400098e4:	d65f03c0 	ret

00000000400098e8 <z_shell_help_subcmd_print>:
 * help string
 */
void z_shell_help_subcmd_print(const struct shell *shell,
			       const struct shell_static_entry *parent,
			       const char *description)
{
    400098e8:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    400098ec:	910003fd 	mov	x29, sp
    400098f0:	a90153f3 	stp	x19, x20, [sp, #16]
    400098f4:	aa0003f4 	mov	x20, x0
	const struct shell_static_entry *entry = NULL;
	struct shell_static_entry dloc;
	uint16_t longest = 0U;
    400098f8:	52800013 	mov	w19, #0x0                   	// #0
{
    400098fc:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009900:	aa0203f5 	mov	x21, x2
    40009904:	a90363f7 	stp	x23, x24, [sp, #48]
    40009908:	aa0103f7 	mov	x23, x1
	size_t idx = 0;
    4000990c:	d2800001 	mov	x1, #0x0                   	// #0
{
    40009910:	a9046bf9 	stp	x25, x26, [sp, #64]
    40009914:	f9002bfb 	str	x27, [sp, #80]

	/* Searching for the longest subcommand to print. */
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    40009918:	91000436 	add	x22, x1, #0x1
    4000991c:	9101a3e2 	add	x2, sp, #0x68
    40009920:	aa1703e0 	mov	x0, x23
    40009924:	97fffa8d 	bl	40008358 <z_shell_cmd_get>
    40009928:	b5000300 	cbnz	x0, 40009988 <z_shell_help_subcmd_print+0xa0>
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
	}

	/* No help to print */
	if (longest == 0) {
    4000992c:	34000213 	cbz	w19, 4000996c <z_shell_help_subcmd_print+0x84>
		return;
	}

	if (description != NULL) {
    40009930:	b40000b5 	cbz	x21, 40009944 <z_shell_help_subcmd_print+0x5c>
		z_shell_fprintf(shell, SHELL_NORMAL, description);
    40009934:	aa1503e2 	mov	x2, x21
    40009938:	aa1403e0 	mov	x0, x20
    4000993c:	52800101 	mov	w1, #0x8                   	// #8
    40009940:	97fffd2e 	bl	40008df8 <z_shell_fprintf>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    40009944:	f0000055 	adrp	x21, 40014000 <CSWTCH.135+0x90>
    40009948:	91367ab5 	add	x21, x21, #0xd9e
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
    4000994c:	f0000058 	adrp	x24, 40014000 <CSWTCH.135+0x90>
    40009950:	91361b18 	add	x24, x24, #0xd86
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    40009954:	d2800001 	mov	x1, #0x0                   	// #0
	}

	/* Printing subcommands and help string (if exists). */
	idx = 0;

	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    40009958:	91000439 	add	x25, x1, #0x1
    4000995c:	9101a3e2 	add	x2, sp, #0x68
    40009960:	aa1703e0 	mov	x0, x23
    40009964:	97fffa7d 	bl	40008358 <z_shell_cmd_get>
    40009968:	b5000260 	cbnz	x0, 400099b4 <z_shell_help_subcmd_print+0xcc>
		help_item_print(shell, entry->syntax, longest, entry->help);
	}
}
    4000996c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009970:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009974:	a94363f7 	ldp	x23, x24, [sp, #48]
    40009978:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000997c:	f9402bfb 	ldr	x27, [sp, #80]
    40009980:	a8c97bfd 	ldp	x29, x30, [sp], #144
    40009984:	d65f03c0 	ret
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
    40009988:	f9400000 	ldr	x0, [x0]
	return str == NULL ? 0U : (uint16_t)strlen(str);
    4000998c:	b4000100 	cbz	x0, 400099ac <z_shell_help_subcmd_print+0xc4>
    40009990:	94000888 	bl	4000bbb0 <strlen>
    40009994:	12003c03 	and	w3, w0, #0xffff
    40009998:	6b13007f 	cmp	w3, w19
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    4000999c:	aa1603e1 	mov	x1, x22
		longest = Z_MAX(longest, z_shell_strlen(entry->syntax));
    400099a0:	1a938063 	csel	w3, w3, w19, hi  // hi = pmore
    400099a4:	12003c73 	and	w19, w3, #0xffff
    400099a8:	17ffffdc 	b	40009918 <z_shell_help_subcmd_print+0x30>
    400099ac:	52800003 	mov	w3, #0x0                   	// #0
    400099b0:	17fffffa 	b	40009998 <z_shell_help_subcmd_print+0xb0>
		help_item_print(shell, entry->syntax, longest, entry->help);
    400099b4:	a940681b 	ldp	x27, x26, [x0]
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    400099b8:	aa1503e0 	mov	x0, x21
    400099bc:	9400087d 	bl	4000bbb0 <strlen>
    400099c0:	aa0003f6 	mov	x22, x0
	if ((item_name == NULL) || (item_name[0] == '\0')) {
    400099c4:	b40001db 	cbz	x27, 400099fc <z_shell_help_subcmd_print+0x114>
    400099c8:	39400360 	ldrb	w0, [x27]
    400099cc:	34000180 	cbz	w0, 400099fc <z_shell_help_subcmd_print+0x114>
		z_shell_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:", tabulator,
    400099d0:	aa1503e6 	mov	x6, x21
    400099d4:	aa1b03e5 	mov	x5, x27
    400099d8:	2a1303e4 	mov	w4, w19
    400099dc:	aa1503e3 	mov	x3, x21
    400099e0:	aa1803e2 	mov	x2, x24
    400099e4:	aa1403e0 	mov	x0, x20
    400099e8:	52800101 	mov	w1, #0x8                   	// #8
    400099ec:	97fffd03 	bl	40008df8 <z_shell_fprintf>
	if (item_help == NULL) {
    400099f0:	b50000ba 	cbnz	x26, 40009a04 <z_shell_help_subcmd_print+0x11c>
		z_cursor_next_line_move(shell);
    400099f4:	f9401680 	ldr	x0, [x20, #40]
    400099f8:	97ffff5c 	bl	40009768 <z_cursor_next_line_move.isra.0>
	while ((entry = z_shell_cmd_get(parent, idx++, &dloc)) != NULL) {
    400099fc:	aa1903e1 	mov	x1, x25
    40009a00:	17ffffd6 	b	40009958 <z_shell_help_subcmd_print+0x70>
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    40009a04:	11000662 	add	w2, w19, #0x1
	formatted_text_print(shell, item_help, offset, false);
    40009a08:	aa1a03e1 	mov	x1, x26
	const uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
    40009a0c:	0b160442 	add	w2, w2, w22, lsl #1
	formatted_text_print(shell, item_help, offset, false);
    40009a10:	aa1403e0 	mov	x0, x20
    40009a14:	92403c42 	and	x2, x2, #0xffff
    40009a18:	97ffff57 	bl	40009774 <formatted_text_print.constprop.0>
    40009a1c:	17fffff8 	b	400099fc <z_shell_help_subcmd_print+0x114>

0000000040009a20 <z_shell_help_cmd_print>:

void z_shell_help_cmd_print(const struct shell *shell,
			    const struct shell_static_entry *cmd)
{
    40009a20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40009a24:	910003fd 	mov	x29, sp
    40009a28:	a9025bf5 	stp	x21, x22, [sp, #32]
    40009a2c:	aa0003f5 	mov	x21, x0
	static const char cmd_sep[] = " - "; /* commands separator */
	uint16_t field_width;

	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
    40009a30:	f9400020 	ldr	x0, [x1]
{
    40009a34:	a90153f3 	stp	x19, x20, [sp, #16]
    40009a38:	aa0103f4 	mov	x20, x1
    40009a3c:	b40002e0 	cbz	x0, 40009a98 <z_shell_help_cmd_print+0x78>
    40009a40:	9400085c 	bl	4000bbb0 <strlen>
    40009a44:	12003c13 	and	w19, w0, #0xffff
    40009a48:	f0000056 	adrp	x22, 40014000 <CSWTCH.135+0x90>
    40009a4c:	91366ad6 	add	x22, x22, #0xd9a
    40009a50:	aa1603e0 	mov	x0, x22
    40009a54:	94000857 	bl	4000bbb0 <strlen>

	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
    40009a58:	f9400283 	ldr	x3, [x20]
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
    40009a5c:	0b000273 	add	w19, w19, w0
	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
    40009a60:	aa1603e4 	mov	x4, x22
    40009a64:	aa1503e0 	mov	x0, x21
	field_width = z_shell_strlen(cmd->syntax) + z_shell_strlen(cmd_sep);
    40009a68:	12003e73 	and	w19, w19, #0xffff
	z_shell_fprintf(shell, SHELL_NORMAL, "%s%s", cmd->syntax, cmd_sep);
    40009a6c:	52800101 	mov	w1, #0x8                   	// #8
    40009a70:	f0000042 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40009a74:	912e5c42 	add	x2, x2, #0xb97
    40009a78:	97fffce0 	bl	40008df8 <z_shell_fprintf>

	formatted_text_print(shell, cmd->help, field_width, false);
    40009a7c:	92403e62 	and	x2, x19, #0xffff
    40009a80:	aa1503e0 	mov	x0, x21
    40009a84:	f9400681 	ldr	x1, [x20, #8]
}
    40009a88:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009a8c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40009a90:	a8c37bfd 	ldp	x29, x30, [sp], #48
	formatted_text_print(shell, cmd->help, field_width, false);
    40009a94:	17ffff38 	b	40009774 <formatted_text_print.constprop.0>
    40009a98:	52800013 	mov	w19, #0x0                   	// #0
    40009a9c:	17ffffeb 	b	40009a48 <z_shell_help_cmd_print+0x28>

0000000040009aa0 <z_shell_help_request>:

bool z_shell_help_request(const char *str)
{
    40009aa0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (!IS_ENABLED(CONFIG_SHELL_HELP_OPT_PARSE)) {
		return false;
	}

	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
    40009aa4:	f0000041 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40009aa8:	91364021 	add	x1, x1, #0xd90
{
    40009aac:	910003fd 	mov	x29, sp
    40009ab0:	f9000bf3 	str	x19, [sp, #16]
    40009ab4:	aa0003f3 	mov	x19, x0
	if (!strcmp(str, "-h") || !strcmp(str, "--help")) {
    40009ab8:	9400084e 	bl	4000bbf0 <strcmp>
    40009abc:	34000140 	cbz	w0, 40009ae4 <z_shell_help_request+0x44>
    40009ac0:	aa1303e0 	mov	x0, x19
    40009ac4:	f0000041 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40009ac8:	91364c21 	add	x1, x1, #0xd93
    40009acc:	94000849 	bl	4000bbf0 <strcmp>
    40009ad0:	7100001f 	cmp	w0, #0x0
    40009ad4:	1a9f17e0 	cset	w0, eq  // eq = none
		return true;
	}

	return false;
}
    40009ad8:	f9400bf3 	ldr	x19, [sp, #16]
    40009adc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40009ae0:	d65f03c0 	ret
		return true;
    40009ae4:	52800020 	mov	w0, #0x1                   	// #1
    40009ae8:	17fffffc 	b	40009ad8 <z_shell_help_request+0x38>

0000000040009aec <cmd_shell_stats_reset>:
				 size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell->stats->log_lost_cnt = 0;
    40009aec:	f9401800 	ldr	x0, [x0, #48]
    40009af0:	f900001f 	str	xzr, [x0]

	return 0;
}
    40009af4:	52800000 	mov	w0, #0x0                   	// #0
    40009af8:	d65f03c0 	ret

0000000040009afc <z_shell_raw_fprintf>:
{
    40009afc:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
    40009b00:	910003fd 	mov	x29, sp
    40009b04:	a90d0fe2 	stp	x2, x3, [sp, #208]
	va_start(args, fmt);
    40009b08:	910403e2 	add	x2, sp, #0x100
    40009b0c:	a9030be2 	stp	x2, x2, [sp, #48]
    40009b10:	910343e2 	add	x2, sp, #0xd0
    40009b14:	f90023e2 	str	x2, [sp, #64]
    40009b18:	128005e2 	mov	w2, #0xffffffd0            	// #-48
    40009b1c:	b9004be2 	str	w2, [sp, #72]
    40009b20:	12800fe2 	mov	w2, #0xffffff80            	// #-128
    40009b24:	b9004fe2 	str	w2, [sp, #76]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40009b28:	a9430fe2 	ldp	x2, x3, [sp, #48]
    40009b2c:	a9010fe2 	stp	x2, x3, [sp, #16]
    40009b30:	a9440fe2 	ldp	x2, x3, [sp, #64]
    40009b34:	a9020fe2 	stp	x2, x3, [sp, #32]
    40009b38:	910043e2 	add	x2, sp, #0x10
{
    40009b3c:	3d8017e0 	str	q0, [sp, #80]
    40009b40:	3d801be1 	str	q1, [sp, #96]
    40009b44:	3d801fe2 	str	q2, [sp, #112]
    40009b48:	3d8023e3 	str	q3, [sp, #128]
    40009b4c:	3d8027e4 	str	q4, [sp, #144]
    40009b50:	3d802be5 	str	q5, [sp, #160]
    40009b54:	3d802fe6 	str	q6, [sp, #176]
    40009b58:	3d8033e7 	str	q7, [sp, #192]
    40009b5c:	a90e17e4 	stp	x4, x5, [sp, #224]
    40009b60:	a90f1fe6 	stp	x6, x7, [sp, #240]
	z_shell_fprintf_fmt(ctx, fmt, args);
    40009b64:	97fff8cf 	bl	40007ea0 <z_shell_fprintf_fmt>
}
    40009b68:	a8d07bfd 	ldp	x29, x30, [sp], #256
    40009b6c:	d65f03c0 	ret

0000000040009b70 <cmd_resize_default>:

static int cmd_resize_default(const struct shell *shell,
			      size_t argc, char **argv)
{
    40009b70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009b74:	910003fd 	mov	x29, sp
    40009b78:	f9000bf3 	str	x19, [sp, #16]
    40009b7c:	aa0003f3 	mov	x19, x0
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40009b80:	f9400800 	ldr	x0, [x0, #16]
    40009b84:	b9429800 	ldr	w0, [x0, #664]
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	Z_SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
    40009b88:	362800a0 	tbz	w0, #5, 40009b9c <cmd_resize_default+0x2c>
    40009b8c:	f9401660 	ldr	x0, [x19, #40]
    40009b90:	d0000041 	adrp	x1, 40013000 <shell_cmd_kernel>
    40009b94:	9101c821 	add	x1, x1, #0x72
    40009b98:	97ffffd9 	bl	40009afc <z_shell_raw_fprintf>
	shell->ctx->vt100_ctx.cons.terminal_wid = SHELL_DEFAULT_TERMINAL_WIDTH;
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
    40009b9c:	f9400a60 	ldr	x0, [x19, #16]
    40009ba0:	52800301 	mov	w1, #0x18                  	// #24
    40009ba4:	72a00a01 	movk	w1, #0x50, lsl #16

	return 0;
}
    40009ba8:	f9400bf3 	ldr	x19, [sp, #16]
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
    40009bac:	b9004801 	str	w1, [x0, #72]
}
    40009bb0:	52800000 	mov	w0, #0x0                   	// #0
    40009bb4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40009bb8:	d65f03c0 	ret

0000000040009bbc <cmd_shell_stats_show>:
{
    40009bbc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_print(shell, "Lost logs: %lu", shell->stats->log_lost_cnt);
    40009bc0:	f0000042 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40009bc4:	91368442 	add	x2, x2, #0xda1
{
    40009bc8:	910003fd 	mov	x29, sp
	shell_print(shell, "Lost logs: %lu", shell->stats->log_lost_cnt);
    40009bcc:	f9401801 	ldr	x1, [x0, #48]
    40009bd0:	f9400023 	ldr	x3, [x1]
    40009bd4:	52800101 	mov	w1, #0x8                   	// #8
    40009bd8:	97fff863 	bl	40007d64 <shell_fprintf>
}
    40009bdc:	52800000 	mov	w0, #0x0                   	// #0
    40009be0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40009be4:	d65f03c0 	ret

0000000040009be8 <cmd_history>:
{
    40009be8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40009bec:	910003fd 	mov	x29, sp
    40009bf0:	a90153f3 	stp	x19, x20, [sp, #16]
    40009bf4:	aa0003f3 	mov	x19, x0
    40009bf8:	52800014 	mov	w20, #0x0                   	// #0
    40009bfc:	f90013f5 	str	x21, [sp, #32]
			shell_print(shell, "[%3d] %s",
    40009c00:	f0000055 	adrp	x21, 40014000 <CSWTCH.135+0x90>
    40009c04:	9136c6b5 	add	x21, x21, #0xdb1
		z_shell_history_get(shell->history, true,
    40009c08:	a9410262 	ldp	x2, x0, [x19, #16]
    40009c0c:	9100fbe3 	add	x3, sp, #0x3e
    40009c10:	52800021 	mov	w1, #0x1                   	// #1
    40009c14:	9105d842 	add	x2, x2, #0x176
    40009c18:	94000121 	bl	4000a09c <z_shell_history_get>
		if (len) {
    40009c1c:	79407fe0 	ldrh	w0, [sp, #62]
    40009c20:	f9400a64 	ldr	x4, [x19, #16]
    40009c24:	34000120 	cbz	w0, 40009c48 <cmd_history+0x60>
			shell_print(shell, "[%3d] %s",
    40009c28:	2a1403e3 	mov	w3, w20
    40009c2c:	9105d884 	add	x4, x4, #0x176
    40009c30:	aa1503e2 	mov	x2, x21
    40009c34:	aa1303e0 	mov	x0, x19
    40009c38:	52800101 	mov	w1, #0x8                   	// #8
    40009c3c:	11000694 	add	w20, w20, #0x1
    40009c40:	97fff849 	bl	40007d64 <shell_fprintf>
		z_shell_history_get(shell->history, true,
    40009c44:	17fffff1 	b	40009c08 <cmd_history+0x20>
	shell->ctx->temp_buff[0] = '\0';
    40009c48:	3905d89f 	strb	wzr, [x4, #374]
}
    40009c4c:	52800000 	mov	w0, #0x0                   	// #0
    40009c50:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009c54:	f94013f5 	ldr	x21, [sp, #32]
    40009c58:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40009c5c:	d65f03c0 	ret

0000000040009c60 <cmd_echo>:
{
    40009c60:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	if (argc == 2) {
    40009c64:	f100083f 	cmp	x1, #0x2
{
    40009c68:	910003fd 	mov	x29, sp
	if (argc == 2) {
    40009c6c:	54000161 	b.ne	40009c98 <cmd_echo+0x38>  // b.any
		shell_error(shell, "%s:%s%s", argv[0],
    40009c70:	a9401443 	ldp	x3, x5, [x2]
    40009c74:	f0000044 	adrp	x4, 40014000 <CSWTCH.135+0x90>
    40009c78:	9136fc84 	add	x4, x4, #0xdbf
    40009c7c:	52800021 	mov	w1, #0x1                   	// #1
    40009c80:	f0000042 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40009c84:	91375042 	add	x2, x2, #0xdd4
    40009c88:	97fff837 	bl	40007d64 <shell_fprintf>
    40009c8c:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
    40009c90:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40009c94:	d65f03c0 	ret
	return sh->ctx->cfg.flags.echo == 1;
    40009c98:	f9400801 	ldr	x1, [x0, #16]
	shell_print(shell, "Echo status: %s",
    40009c9c:	f0000043 	adrp	x3, 40014000 <CSWTCH.135+0x90>
    40009ca0:	911f5063 	add	x3, x3, #0x7d4
    40009ca4:	b9429822 	ldr	w2, [x1, #664]
    40009ca8:	f0000041 	adrp	x1, 40014000 <CSWTCH.135+0x90>
    40009cac:	9136ec21 	add	x1, x1, #0xdbb
    40009cb0:	f27f005f 	tst	x2, #0x2
    40009cb4:	f0000042 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40009cb8:	91377442 	add	x2, x2, #0xddd
    40009cbc:	9a811063 	csel	x3, x3, x1, ne  // ne = any
    40009cc0:	52800101 	mov	w1, #0x8                   	// #8
    40009cc4:	97fff828 	bl	40007d64 <shell_fprintf>
	return 0;
    40009cc8:	52800000 	mov	w0, #0x0                   	// #0
    40009ccc:	17fffff1 	b	40009c90 <cmd_echo+0x30>

0000000040009cd0 <cmd_clear>:
{
    40009cd0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40009cd4:	910003fd 	mov	x29, sp
    40009cd8:	f9000bf3 	str	x19, [sp, #16]
    40009cdc:	aa0003f3 	mov	x19, x0
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40009ce0:	f9400800 	ldr	x0, [x0, #16]
    40009ce4:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
    40009ce8:	362800c0 	tbz	w0, #5, 40009d00 <cmd_clear+0x30>
    40009cec:	f9401660 	ldr	x0, [x19, #40]
    40009cf0:	d0000041 	adrp	x1, 40013000 <shell_cmd_kernel>
    40009cf4:	9101c821 	add	x1, x1, #0x72
    40009cf8:	91001c21 	add	x1, x1, #0x7
    40009cfc:	97ffff80 	bl	40009afc <z_shell_raw_fprintf>
    40009d00:	f9400a60 	ldr	x0, [x19, #16]
    40009d04:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
    40009d08:	362800c0 	tbz	w0, #5, 40009d20 <cmd_clear+0x50>
    40009d0c:	f9401660 	ldr	x0, [x19, #40]
    40009d10:	d0000041 	adrp	x1, 40013000 <shell_cmd_kernel>
    40009d14:	9101c821 	add	x1, x1, #0x72
    40009d18:	91003021 	add	x1, x1, #0xc
    40009d1c:	97ffff78 	bl	40009afc <z_shell_raw_fprintf>
}
    40009d20:	52800000 	mov	w0, #0x0                   	// #0
    40009d24:	f9400bf3 	ldr	x19, [sp, #16]
    40009d28:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40009d2c:	d65f03c0 	ret

0000000040009d30 <cmd_resize>:

static int cmd_resize(const struct shell *shell, size_t argc, char **argv)
{
    40009d30:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	int err;

	if (argc != 1) {
    40009d34:	f100043f 	cmp	x1, #0x1
{
    40009d38:	910003fd 	mov	x29, sp
    40009d3c:	a90153f3 	stp	x19, x20, [sp, #16]
    40009d40:	f90013f5 	str	x21, [sp, #32]
	if (argc != 1) {
    40009d44:	540001c0 	b.eq	40009d7c <cmd_resize+0x4c>  // b.none
		shell_error(shell, "%s:%s%s", argv[0],
    40009d48:	a9401443 	ldp	x3, x5, [x2]
    40009d4c:	f0000044 	adrp	x4, 40014000 <CSWTCH.135+0x90>
    40009d50:	9136fc84 	add	x4, x4, #0xdbf
    40009d54:	f0000042 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40009d58:	91375042 	add	x2, x2, #0xdd4
    40009d5c:	52800021 	mov	w1, #0x1                   	// #1
			    SHELL_MSG_UNKNOWN_PARAMETER, argv[1]);
		return -EINVAL;
    40009d60:	128002b4 	mov	w20, #0xffffffea            	// #-22
		shell_error(shell, "%s:%s%s", argv[0],
    40009d64:	97fff800 	bl	40007d64 <shell_fprintf>
			   " screen size");
		return -ENOEXEC;
	}

	return 0;
}
    40009d68:	2a1403e0 	mov	w0, w20
    40009d6c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40009d70:	f94013f5 	ldr	x21, [sp, #32]
    40009d74:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40009d78:	d65f03c0 	ret
    40009d7c:	aa0003f3 	mov	x19, x0
    40009d80:	f9400800 	ldr	x0, [x0, #16]
    40009d84:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_SAVECURSOR);
    40009d88:	362800c0 	tbz	w0, #5, 40009da0 <cmd_resize+0x70>
    40009d8c:	f9401660 	ldr	x0, [x19, #40]
    40009d90:	d0000041 	adrp	x1, 40013000 <shell_cmd_kernel>
    40009d94:	9101c821 	add	x1, x1, #0x72
    40009d98:	91004821 	add	x1, x1, #0x12
    40009d9c:	97ffff58 	bl	40009afc <z_shell_raw_fprintf>
	z_shell_op_cursor_vert_move(shell, -SHELL_MAX_TERMINAL_SIZE);
    40009da0:	aa1303e0 	mov	x0, x19
    40009da4:	12801f21 	mov	w1, #0xffffff06            	// #-250
    40009da8:	97fffa7f 	bl	400087a4 <z_shell_op_cursor_vert_move>
	z_shell_fprintf_buffer_flush(shell->fprintf_ctx);
    40009dac:	52807d15 	mov	w21, #0x3e8                 	// #1000
	z_shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
    40009db0:	aa1303e0 	mov	x0, x19
    40009db4:	52801f41 	mov	w1, #0xfa                  	// #250
    40009db8:	97fffa8b 	bl	400087e4 <z_shell_op_cursor_horiz_move>
	char c = 0;
    40009dbc:	3900dfff 	strb	wzr, [sp, #55]
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    40009dc0:	f9400a60 	ldr	x0, [x19, #16]
    40009dc4:	d2802002 	mov	x2, #0x100                 	// #256
    40009dc8:	52800001 	mov	w1, #0x0                   	// #0
	uint16_t buff_idx = 0U;
    40009dcc:	52800014 	mov	w20, #0x0                   	// #0
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    40009dd0:	9105d800 	add	x0, x0, #0x176
    40009dd4:	940007c2 	bl	4000bcdc <memset>
	z_shell_raw_fprintf(shell->fprintf_ctx, cmd_get_terminal_size);
    40009dd8:	f9401660 	ldr	x0, [x19, #40]
    40009ddc:	90000061 	adrp	x1, 40015000 <tabulator.1+0x262>
    40009de0:	9107b021 	add	x1, x1, #0x1ec
    40009de4:	97ffff46 	bl	40009afc <z_shell_raw_fprintf>
    40009de8:	f9401660 	ldr	x0, [x19, #40]
    40009dec:	97fff81e 	bl	40007e64 <z_shell_fprintf_buffer_flush>
			(void)shell->iface->api->read(shell->iface, &c,
    40009df0:	f9400660 	ldr	x0, [x19, #8]
    40009df4:	9100e3e3 	add	x3, sp, #0x38
    40009df8:	d2800022 	mov	x2, #0x1                   	// #1
    40009dfc:	f9400001 	ldr	x1, [x0]
    40009e00:	f9401024 	ldr	x4, [x1, #32]
    40009e04:	9100dfe1 	add	x1, sp, #0x37
    40009e08:	d63f0080 	blr	x4
			if (cnt == 0) {
    40009e0c:	f9401fe0 	ldr	x0, [sp, #56]
    40009e10:	b5000100 	cbnz	x0, 40009e30 <cmd_resize+0x100>
	z_impl_k_busy_wait(usec_to_wait);
    40009e14:	52807d00 	mov	w0, #0x3e8                 	// #1000
	for (uint16_t i = 0; i < 1000; i++) {
    40009e18:	510006b5 	sub	w21, w21, #0x1
    40009e1c:	9400196d 	bl	400103d0 <z_impl_k_busy_wait>
    40009e20:	72003eb5 	ands	w21, w21, #0xffff
    40009e24:	54fffe61 	b.ne	40009df0 <cmd_resize+0xc0>  // b.any
		ret_val = -ENOTSUP;
    40009e28:	128010b4 	mov	w20, #0xffffff7a            	// #-134
    40009e2c:	1400002c 	b	40009edc <cmd_resize+0x1ac>
			if ((c != SHELL_VT100_ASCII_ESC) &&
    40009e30:	3940dfe1 	ldrb	w1, [sp, #55]
			    (shell->ctx->temp_buff[0] !=
    40009e34:	f9400a60 	ldr	x0, [x19, #16]
			if ((c != SHELL_VT100_ASCII_ESC) &&
    40009e38:	71006c3f 	cmp	w1, #0x1b
    40009e3c:	54000920 	b.eq	40009f60 <cmd_resize+0x230>  // b.none
    40009e40:	3945d802 	ldrb	w2, [x0, #374]
    40009e44:	71006c5f 	cmp	w2, #0x1b
    40009e48:	54fffd41 	b.ne	40009df0 <cmd_resize+0xc0>  // b.any
			if (c == 'R') { /* End of response from the terminal. */
    40009e4c:	7101483f 	cmp	w1, #0x52
    40009e50:	54000881 	b.ne	40009f60 <cmd_resize+0x230>  // b.any
				shell->ctx->temp_buff[buff_idx] = '\0';
    40009e54:	8b34c014 	add	x20, x0, w20, sxtw
    40009e58:	3905da9f 	strb	wzr, [x20, #374]
				if (shell->ctx->temp_buff[1] != '[') {
    40009e5c:	3945dc01 	ldrb	w1, [x0, #375]
    40009e60:	71016c3f 	cmp	w1, #0x5b
    40009e64:	54000640 	b.eq	40009f2c <cmd_resize+0x1fc>  // b.none
				shell->ctx->temp_buff[0] = 0;
    40009e68:	3905d81f 	strb	wzr, [x0, #374]
				return -ENOMEM;
    40009e6c:	17ffffef 	b	40009e28 <cmd_resize+0xf8>
					*y = *y * 10U +
    40009e70:	1b061042 	madd	w2, w2, w6, w4
					if (buff_idx >=
    40009e74:	91000421 	add	x1, x1, #0x1
    40009e78:	f103f83f 	cmp	x1, #0xfe
					*y = *y * 10U +
    40009e7c:	5100c042 	sub	w2, w2, #0x30
    40009e80:	12003c42 	and	w2, w2, #0xffff
					if (buff_idx >=
    40009e84:	54fffd20 	b.eq	40009e28 <cmd_resize+0xf8>  // b.none
				while (shell->ctx->temp_buff[buff_idx] != ';') {
    40009e88:	386168a4 	ldrb	w4, [x5, x1]
					(shell->ctx->temp_buff[buff_idx++] -
    40009e8c:	11000c23 	add	w3, w1, #0x3
    40009e90:	12003c63 	and	w3, w3, #0xffff
				while (shell->ctx->temp_buff[buff_idx] != ';') {
    40009e94:	7100ec9f 	cmp	w4, #0x3b
    40009e98:	54fffec1 	b.ne	40009e70 <cmd_resize+0x140>  // b.any
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
    40009e9c:	7104007f 	cmp	w3, #0x100
    40009ea0:	54fffc40 	b.eq	40009e28 <cmd_resize+0xf8>  // b.none
	*x = 0U;
    40009ea4:	52800001 	mov	w1, #0x0                   	// #0
					*x = *x * 10U +
    40009ea8:	52800145 	mov	w5, #0xa                   	// #10
				while (shell->ctx->temp_buff[buff_idx]
    40009eac:	8b23c004 	add	x4, x0, w3, sxtw
    40009eb0:	3945d884 	ldrb	w4, [x4, #374]
    40009eb4:	35000464 	cbnz	w4, 40009f40 <cmd_resize+0x210>
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
    40009eb8:	7103e83f 	cmp	w1, #0xfa
    40009ebc:	52801f43 	mov	w3, #0xfa                  	// #250
    40009ec0:	1a839021 	csel	w1, w1, w3, ls  // ls = plast
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
    40009ec4:	7103e85f 	cmp	w2, #0xfa
    40009ec8:	1a839042 	csel	w2, w2, w3, ls  // ls = plast
	int ret_val = 0;
    40009ecc:	52800014 	mov	w20, #0x0                   	// #0
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
    40009ed0:	79009002 	strh	w2, [x0, #72]
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
    40009ed4:	79009401 	strh	w1, [x0, #74]
				shell->ctx->temp_buff[0] = 0;
    40009ed8:	3905d81f 	strb	wzr, [x0, #374]
	return sh->ctx->cfg.flags.use_vt100 == 1;
    40009edc:	f9400a60 	ldr	x0, [x19, #16]
    40009ee0:	b9429800 	ldr	w0, [x0, #664]
	Z_SHELL_VT100_CMD(sh, SHELL_VT100_RESTORECURSOR);
    40009ee4:	362800c0 	tbz	w0, #5, 40009efc <cmd_resize+0x1cc>
    40009ee8:	f9401660 	ldr	x0, [x19, #40]
    40009eec:	d0000041 	adrp	x1, 40013000 <shell_cmd_kernel>
    40009ef0:	9101c821 	add	x1, x1, #0x72
    40009ef4:	91005821 	add	x1, x1, #0x16
    40009ef8:	97ffff01 	bl	40009afc <z_shell_raw_fprintf>
	if (err != 0) {
    40009efc:	34fff374 	cbz	w20, 40009d68 <cmd_resize+0x38>
		shell->ctx->vt100_ctx.cons.terminal_hei =
    40009f00:	f9400a60 	ldr	x0, [x19, #16]
    40009f04:	52800301 	mov	w1, #0x18                  	// #24
    40009f08:	72a00a01 	movk	w1, #0x50, lsl #16
		shell_warn(shell, "No response from the terminal, assumed 80x24"
    40009f0c:	f0000042 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40009f10:	9137b842 	add	x2, x2, #0xdee
    40009f14:	128000f4 	mov	w20, #0xfffffff8            	// #-8
		shell->ctx->vt100_ctx.cons.terminal_hei =
    40009f18:	b9004801 	str	w1, [x0, #72]
		shell_warn(shell, "No response from the terminal, assumed 80x24"
    40009f1c:	aa1303e0 	mov	x0, x19
    40009f20:	52800061 	mov	w1, #0x3                   	// #3
    40009f24:	97fff790 	bl	40007d64 <shell_fprintf>
		return -ENOEXEC;
    40009f28:	17ffff90 	b	40009d68 <cmd_resize+0x38>
				while (shell->ctx->temp_buff[buff_idx] != ';') {
    40009f2c:	9105e005 	add	x5, x0, #0x178
    40009f30:	d2800001 	mov	x1, #0x0                   	// #0
	*y = 0U;
    40009f34:	52800002 	mov	w2, #0x0                   	// #0
					*y = *y * 10U +
    40009f38:	52800146 	mov	w6, #0xa                   	// #10
    40009f3c:	17ffffd3 	b	40009e88 <cmd_resize+0x158>
					*x = *x * 10U +
    40009f40:	1b051021 	madd	w1, w1, w5, w4
					if (buff_idx >=
    40009f44:	11000463 	add	w3, w3, #0x1
    40009f48:	12003c64 	and	w4, w3, #0xffff
					*x = *x * 10U +
    40009f4c:	5100c021 	sub	w1, w1, #0x30
					if (buff_idx >=
    40009f50:	7103fc9f 	cmp	w4, #0xff
					*x = *x * 10U +
    40009f54:	12003c21 	and	w1, w1, #0xffff
					if (buff_idx >=
    40009f58:	54fffaa9 	b.ls	40009eac <cmd_resize+0x17c>  // b.plast
    40009f5c:	17ffffb3 	b	40009e28 <cmd_resize+0xf8>
			shell->ctx->temp_buff[buff_idx] = c;
    40009f60:	8b34c002 	add	x2, x0, w20, sxtw
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
    40009f64:	11000694 	add	w20, w20, #0x1
    40009f68:	12003e94 	and	w20, w20, #0xffff
    40009f6c:	7100269f 	cmp	w20, #0x9
			shell->ctx->temp_buff[buff_idx] = c;
    40009f70:	3905d841 	strb	w1, [x2, #374]
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
    40009f74:	54fff3e9 	b.ls	40009df0 <cmd_resize+0xc0>  // b.plast
    40009f78:	17ffffbc 	b	40009e68 <cmd_resize+0x138>

0000000040009f7c <cmd_bacskpace_mode_backspace>:
{
    40009f7c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009f80:	910003fd 	mov	x29, sp
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    40009f84:	f9400801 	ldr	x1, [x0, #16]
    40009f88:	d2800100 	mov	x0, #0x8                   	// #8
    40009f8c:	910a6021 	add	x1, x1, #0x298
    40009f90:	97ffdc18 	bl	40000ff0 <__aarch64_ldclr8_acq_rel>
}
    40009f94:	52800000 	mov	w0, #0x0                   	// #0
    40009f98:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40009f9c:	d65f03c0 	ret

0000000040009fa0 <cmd_bacskpace_mode_delete>:
{
    40009fa0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009fa4:	910003fd 	mov	x29, sp
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    40009fa8:	f9400801 	ldr	x1, [x0, #16]
    40009fac:	d2800100 	mov	x0, #0x8                   	// #8
    40009fb0:	910a6021 	add	x1, x1, #0x298
    40009fb4:	97ffdc1b 	bl	40001020 <__aarch64_ldset8_acq_rel>
}
    40009fb8:	52800000 	mov	w0, #0x0                   	// #0
    40009fbc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40009fc0:	d65f03c0 	ret

0000000040009fc4 <cmd_echo_off>:
{
    40009fc4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009fc8:	910003fd 	mov	x29, sp
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    40009fcc:	f9400801 	ldr	x1, [x0, #16]
    40009fd0:	d2800040 	mov	x0, #0x2                   	// #2
    40009fd4:	910a6021 	add	x1, x1, #0x298
    40009fd8:	97ffdc06 	bl	40000ff0 <__aarch64_ldclr8_acq_rel>
}
    40009fdc:	52800000 	mov	w0, #0x0                   	// #0
    40009fe0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40009fe4:	d65f03c0 	ret

0000000040009fe8 <cmd_colors_off>:
{
    40009fe8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40009fec:	910003fd 	mov	x29, sp
    40009ff0:	f9400801 	ldr	x1, [x0, #16]
    40009ff4:	d2800200 	mov	x0, #0x10                  	// #16
    40009ff8:	910a6021 	add	x1, x1, #0x298
    40009ffc:	97ffdbfd 	bl	40000ff0 <__aarch64_ldclr8_acq_rel>
}
    4000a000:	52800000 	mov	w0, #0x0                   	// #0
    4000a004:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000a008:	d65f03c0 	ret

000000004000a00c <cmd_colors_on>:
{
    4000a00c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000a010:	910003fd 	mov	x29, sp
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4000a014:	f9400801 	ldr	x1, [x0, #16]
    4000a018:	d2800200 	mov	x0, #0x10                  	// #16
    4000a01c:	910a6021 	add	x1, x1, #0x298
    4000a020:	97ffdc00 	bl	40001020 <__aarch64_ldset8_acq_rel>
}
    4000a024:	52800000 	mov	w0, #0x0                   	// #0
    4000a028:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000a02c:	d65f03c0 	ret

000000004000a030 <cmd_echo_on>:
{
    4000a030:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000a034:	910003fd 	mov	x29, sp
    4000a038:	f9400801 	ldr	x1, [x0, #16]
    4000a03c:	d2800040 	mov	x0, #0x2                   	// #2
    4000a040:	910a6021 	add	x1, x1, #0x298
    4000a044:	97ffdbf7 	bl	40001020 <__aarch64_ldset8_acq_rel>
}
    4000a048:	52800000 	mov	w0, #0x0                   	// #0
    4000a04c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000a050:	d65f03c0 	ret

000000004000a054 <remove_from_tail.part.0>:
	memcpy(item->data, src, len);
	sys_dlist_prepend(&history->list, &item->dnode);
}

/* Returns true if element was removed. */
static bool remove_from_tail(struct shell_history *history)
    4000a054:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000a058:	910003fd 	mov	x29, sp
 * @return a pointer to the tail element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_tail(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    4000a05c:	f9400802 	ldr	x2, [x0, #16]

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	total_len = offsetof(struct shell_history_item, data) +
			h_item->len + h_item->padding;
	ring_buf_get_finish(history->ring_buf, total_len);
    4000a060:	f9400000 	ldr	x0, [x0]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    4000a064:	a9400c41 	ldp	x1, x3, [x2]
	sys_dnode_t *const next = node->next;

	prev->next = next;
    4000a068:	f9000061 	str	x1, [x3]
	next->prev = prev;
    4000a06c:	f9000423 	str	x3, [x1, #8]
			h_item->len + h_item->padding;
    4000a070:	79402041 	ldrh	w1, [x2, #16]
	node->prev = NULL;
    4000a074:	a9007c5f 	stp	xzr, xzr, [x2]
    4000a078:	79402442 	ldrh	w2, [x2, #18]
    4000a07c:	0b020021 	add	w1, w1, w2
	ring_buf_get_finish(history->ring_buf, total_len);
    4000a080:	11005021 	add	w1, w1, #0x14
    4000a084:	97ffe3c4 	bl	40002f94 <ring_buf_get_finish>

	return true;
}
    4000a088:	52800020 	mov	w0, #0x1                   	// #1
    4000a08c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000a090:	d65f03c0 	ret

000000004000a094 <z_shell_history_mode_exit>:
	history->current = NULL;
    4000a094:	f9000c1f 	str	xzr, [x0, #24]
}
    4000a098:	d65f03c0 	ret

000000004000a09c <z_shell_history_get>:
{
    4000a09c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000a0a0:	910003fd 	mov	x29, sp
    4000a0a4:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a0a8:	aa0203f4 	mov	x20, x2
	return list->head == list;
    4000a0ac:	aa0003e2 	mov	x2, x0
    4000a0b0:	f8408c53 	ldr	x19, [x2, #8]!
    4000a0b4:	f90013f5 	str	x21, [sp, #32]
    4000a0b8:	aa0303f5 	mov	x21, x3
	if (sys_dlist_is_empty(&history->list)) {
    4000a0bc:	eb02027f 	cmp	x19, x2
    4000a0c0:	540000e1 	b.ne	4000a0dc <z_shell_history_get+0x40>  // b.any
		return false;
    4000a0c4:	52800000 	mov	w0, #0x0                   	// #0
		*len = 0U;
    4000a0c8:	790002bf 	strh	wzr, [x21]
}
    4000a0cc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a0d0:	f94013f5 	ldr	x21, [sp, #32]
    4000a0d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000a0d8:	d65f03c0 	ret
    4000a0dc:	12001c21 	and	w1, w1, #0xff
		if (history->current == NULL) {
    4000a0e0:	f9400c04 	ldr	x4, [x0, #24]
	if (!up) { /* button down */
    4000a0e4:	35000261 	cbnz	w1, 4000a130 <z_shell_history_get+0x94>
		if (history->current == NULL) {
    4000a0e8:	b4fffee4 	cbz	x4, 4000a0c4 <z_shell_history_get+0x28>
	return (node == list->head) ? NULL : node->prev;
    4000a0ec:	eb04027f 	cmp	x19, x4
    4000a0f0:	54000061 	b.ne	4000a0fc <z_shell_history_get+0x60>  // b.any
	history->current = l_item;
    4000a0f4:	f9000c1f 	str	xzr, [x0, #24]
	if (l_item) {
    4000a0f8:	17fffff3 	b	4000a0c4 <z_shell_history_get+0x28>
    4000a0fc:	f9400493 	ldr	x19, [x4, #8]
	history->current = l_item;
    4000a100:	f9000c13 	str	x19, [x0, #24]
	if (l_item) {
    4000a104:	b4fffe13 	cbz	x19, 4000a0c4 <z_shell_history_get+0x28>
		memcpy(dst, h_item->data, h_item->len);
    4000a108:	79402262 	ldrh	w2, [x19, #16]
    4000a10c:	91005261 	add	x1, x19, #0x14
    4000a110:	aa1403e0 	mov	x0, x20
    4000a114:	940006ea 	bl	4000bcbc <memcpy>
		*len = h_item->len;
    4000a118:	79402261 	ldrh	w1, [x19, #16]
		return true;
    4000a11c:	52800020 	mov	w0, #0x1                   	// #1
		*len = h_item->len;
    4000a120:	790002a1 	strh	w1, [x21]
		dst[*len] = '\0';
    4000a124:	92403c21 	and	x1, x1, #0xffff
    4000a128:	38216a9f 	strb	wzr, [x20, x1]
		return true;
    4000a12c:	17ffffe8 	b	4000a0cc <z_shell_history_get+0x30>
		sys_dlist_peek_head_not_empty(&history->list) :
    4000a130:	b4fffe84 	cbz	x4, 4000a100 <z_shell_history_get+0x64>
	return (node == list->tail) ? NULL : node->next;
    4000a134:	f9400801 	ldr	x1, [x0, #16]
    4000a138:	eb04003f 	cmp	x1, x4
    4000a13c:	54fffdc0 	b.eq	4000a0f4 <z_shell_history_get+0x58>  // b.none
    4000a140:	f9400093 	ldr	x19, [x4]
    4000a144:	17ffffef 	b	4000a100 <z_shell_history_get+0x64>

000000004000a148 <z_shell_history_purge>:

void z_shell_history_purge(struct shell_history *history)
{
    4000a148:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a14c:	910003fd 	mov	x29, sp
    4000a150:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a154:	aa0003f3 	mov	x19, x0
	if (sys_dlist_is_empty(&history->list)) {
    4000a158:	91002014 	add	x20, x0, #0x8
    4000a15c:	f9400660 	ldr	x0, [x19, #8]
    4000a160:	eb14001f 	cmp	x0, x20
    4000a164:	540000a0 	b.eq	4000a178 <z_shell_history_purge+0x30>  // b.none
    4000a168:	aa1303e0 	mov	x0, x19
    4000a16c:	97ffffba 	bl	4000a054 <remove_from_tail.part.0>
	while (remove_from_tail(history)) {
    4000a170:	72001c1f 	tst	w0, #0xff
    4000a174:	54ffff41 	b.ne	4000a15c <z_shell_history_purge+0x14>  // b.any
	}
}
    4000a178:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a17c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a180:	d65f03c0 	ret

000000004000a184 <z_shell_history_put>:

void z_shell_history_put(struct shell_history *history, uint8_t *line,
			 size_t len)
{
    4000a184:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4000a188:	910003fd 	mov	x29, sp
    4000a18c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a190:	aa0003f3 	mov	x19, x0
	sys_dnode_t *l_item; /* list item */
	struct shell_history_item *h_item;
	uint32_t total_len = len + offsetof(struct shell_history_item, data);
    4000a194:	11005054 	add	w20, w2, #0x14
 *
 * @return Ring buffer capacity (in 32-bit words or bytes).
 */
static inline uint32_t ring_buf_capacity_get(struct ring_buf *buf)
{
	return buf->size;
    4000a198:	f9400000 	ldr	x0, [x0]
{
    4000a19c:	a9025bf5 	stp	x21, x22, [sp, #32]
	uint32_t claim_len;
	uint32_t claim2_len;
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
    4000a1a0:	4b1403f5 	neg	w21, w20
{
    4000a1a4:	a90363f7 	stp	x23, x24, [sp, #48]
	uint16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
    4000a1a8:	12000ab7 	and	w23, w21, #0x7

	/* align to word. */
	total_len += padding;

	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
    4000a1ac:	b9401000 	ldr	w0, [x0, #16]
{
    4000a1b0:	f90023f9 	str	x25, [sp, #64]
	total_len += padding;
    4000a1b4:	0b1402f4 	add	w20, w23, w20
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
    4000a1b8:	6b00029f 	cmp	w20, w0
    4000a1bc:	54000688 	b.hi	4000a28c <z_shell_history_put+0x108>  // b.pmore
	history->current = NULL;
    4000a1c0:	f9000e7f 	str	xzr, [x19, #24]
    4000a1c4:	aa0203f6 	mov	x22, x2
		return;
	}

	z_shell_history_mode_exit(history);

	if (len == 0) {
    4000a1c8:	b4000622 	cbz	x2, 4000a28c <z_shell_history_put+0x108>
	return list->head == list;
    4000a1cc:	f9400660 	ldr	x0, [x19, #8]
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
    4000a1d0:	91002278 	add	x24, x19, #0x8
    4000a1d4:	aa0103f9 	mov	x25, x1
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000a1d8:	eb00031f 	cmp	x24, x0
    4000a1dc:	54000481 	b.ne	4000a26c <z_shell_history_put+0xe8>  // b.any
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
    4000a1e0:	f9002fff 	str	xzr, [sp, #88]
		/* Same command as before, do not store */
		return;
	}

	do {
		claim_len = ring_buf_put_claim(history->ring_buf,
    4000a1e4:	f9400260 	ldr	x0, [x19]
    4000a1e8:	2a1403e2 	mov	w2, w20
    4000a1ec:	910163e1 	add	x1, sp, #0x58
    4000a1f0:	97ffe2f1 	bl	40002db4 <ring_buf_put_claim>
    4000a1f4:	2a0003f5 	mov	w21, w0
						(uint8_t **)&h_item, total_len);
		/* second allocation may succeed if we were at the end of the
		 * buffer.
		 */
		if (claim_len < total_len) {
    4000a1f8:	6b00029f 	cmp	w20, w0
    4000a1fc:	54000549 	b.ls	4000a2a4 <z_shell_history_put+0x120>  // b.plast
			claim2_len =
				ring_buf_put_claim(history->ring_buf,
    4000a200:	f9400260 	ldr	x0, [x19]
    4000a204:	2a1403e2 	mov	w2, w20
    4000a208:	910163e1 	add	x1, sp, #0x58
    4000a20c:	97ffe2ea 	bl	40002db4 <ring_buf_put_claim>
						   (uint8_t **)&h_item, total_len);
			if (claim2_len == total_len) {
    4000a210:	6b00029f 	cmp	w20, w0
    4000a214:	540004a1 	b.ne	4000a2a8 <z_shell_history_put+0x124>  // b.any
				ring_buf_put_finish(history->ring_buf,
    4000a218:	f9400260 	ldr	x0, [x19]
    4000a21c:	2a1503e1 	mov	w1, w21
						    claim_len);
				padding += claim_len;
    4000a220:	0b1502f5 	add	w21, w23, w21
    4000a224:	12003eb7 	and	w23, w21, #0xffff
    4000a228:	2a1403f5 	mov	w21, w20
				ring_buf_put_finish(history->ring_buf,
    4000a22c:	97ffe2f9 	bl	40002e10 <ring_buf_put_finish>
				claim_len = total_len;
			}
		}

		if (claim_len == total_len) {
			add_to_head(history, h_item, line, len, padding);
    4000a230:	f9402ff4 	ldr	x20, [sp, #88]
	memcpy(item->data, src, len);
    4000a234:	aa1903e1 	mov	x1, x25
    4000a238:	aa1603e2 	mov	x2, x22
    4000a23c:	91005280 	add	x0, x20, #0x14
	item->len = len;
    4000a240:	79002296 	strh	w22, [x20, #16]
	item->padding = padding;
    4000a244:	79002697 	strh	w23, [x20, #18]
	memcpy(item->data, src, len);
    4000a248:	9400069d 	bl	4000bcbc <memcpy>
	sys_dnode_t *const head = list->head;
    4000a24c:	f9400660 	ldr	x0, [x19, #8]
	node->prev = list;
    4000a250:	a9006280 	stp	x0, x24, [x20]
			ring_buf_put_finish(history->ring_buf, claim_len);
    4000a254:	2a1503e1 	mov	w1, w21
	head->prev = node;
    4000a258:	f9000414 	str	x20, [x0, #8]
    4000a25c:	f9400260 	ldr	x0, [x19]
	list->head = node;
    4000a260:	f9000674 	str	x20, [x19, #8]
    4000a264:	97ffe2eb 	bl	40002e10 <ring_buf_put_finish>
			break;
    4000a268:	14000009 	b	4000a28c <z_shell_history_put+0x108>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
    4000a26c:	f9002fe0 	str	x0, [sp, #88]
	if (l_item &&
    4000a270:	b4fffba0 	cbz	x0, 4000a1e4 <z_shell_history_put+0x60>
	   (h_item->len == len) &&
    4000a274:	79402003 	ldrh	w3, [x0, #16]
	if (l_item &&
    4000a278:	eb02007f 	cmp	x3, x2
    4000a27c:	54fffb41 	b.ne	4000a1e4 <z_shell_history_put+0x60>  // b.any
	   (memcmp(h_item->data, line, len) == 0)) {
    4000a280:	91005000 	add	x0, x0, #0x14
    4000a284:	94000671 	bl	4000bc48 <memcmp>
	   (h_item->len == len) &&
    4000a288:	35fffae0 	cbnz	w0, 4000a1e4 <z_shell_history_put+0x60>
			 * of ring buffer capacity length.
			 */
			ring_buf_reset(history->ring_buf);
		}
	} while (1);
}
    4000a28c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a290:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a294:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000a298:	f94023f9 	ldr	x25, [sp, #64]
    4000a29c:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000a2a0:	d65f03c0 	ret
		if (claim_len == total_len) {
    4000a2a4:	54fffc60 	b.eq	4000a230 <z_shell_history_put+0xac>  // b.none
		ring_buf_put_finish(history->ring_buf, 0);
    4000a2a8:	f9400260 	ldr	x0, [x19]
    4000a2ac:	52800001 	mov	w1, #0x0                   	// #0
    4000a2b0:	97ffe2d8 	bl	40002e10 <ring_buf_put_finish>
	if (sys_dlist_is_empty(&history->list)) {
    4000a2b4:	f9400660 	ldr	x0, [x19, #8]
    4000a2b8:	eb00031f 	cmp	x24, x0
    4000a2bc:	540000e1 	b.ne	4000a2d8 <z_shell_history_put+0x154>  // b.any
	buf->head = 0;
    4000a2c0:	f9400260 	ldr	x0, [x19]
	memset(&buf->misc, 0, sizeof(buf->misc));
    4000a2c4:	d2800102 	mov	x2, #0x8                   	// #8
    4000a2c8:	52800001 	mov	w1, #0x0                   	// #0
	buf->head = 0;
    4000a2cc:	f800841f 	str	xzr, [x0], #8
	memset(&buf->misc, 0, sizeof(buf->misc));
    4000a2d0:	94000683 	bl	4000bcdc <memset>
}
    4000a2d4:	17ffffc4 	b	4000a1e4 <z_shell_history_put+0x60>
    4000a2d8:	aa1303e0 	mov	x0, x19
    4000a2dc:	97ffff5e 	bl	4000a054 <remove_from_tail.part.0>
		if (remove_from_tail(history) == false) {
    4000a2e0:	72001c1f 	tst	w0, #0xff
    4000a2e4:	54fff801 	b.ne	4000a1e4 <z_shell_history_put+0x60>  // b.any
    4000a2e8:	17fffff6 	b	4000a2c0 <z_shell_history_put+0x13c>

000000004000a2ec <z_shell_history_init>:

void z_shell_history_init(struct shell_history *history)
{
	sys_dlist_init(&history->list);
    4000a2ec:	91002001 	add	x1, x0, #0x8
	list->tail = (sys_dnode_t *)list;
    4000a2f0:	a9008401 	stp	x1, x1, [x0, #8]
	history->current = NULL;
    4000a2f4:	f9000c1f 	str	xzr, [x0, #24]
}
    4000a2f8:	d65f03c0 	ret

000000004000a2fc <z_shell_has_wildcard>:
	return str == NULL ? 0U : (uint16_t)strlen(str);
    4000a2fc:	b5000060 	cbnz	x0, 4000a308 <z_shell_has_wildcard+0xc>
		if ((str[i] == '?') || (str[i] == '*')) {
			return true;
		}
	}

	return false;
    4000a300:	52800000 	mov	w0, #0x0                   	// #0
}
    4000a304:	d65f03c0 	ret
{
    4000a308:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a30c:	910003fd 	mov	x29, sp
    4000a310:	f9000bf3 	str	x19, [sp, #16]
    4000a314:	aa0003f3 	mov	x19, x0
    4000a318:	94000626 	bl	4000bbb0 <strlen>
	for (size_t i = 0; i < str_len; i++) {
    4000a31c:	92403c03 	and	x3, x0, #0xffff
    4000a320:	d2800002 	mov	x2, #0x0                   	// #0
    4000a324:	eb03005f 	cmp	x2, x3
    4000a328:	540000a3 	b.cc	4000a33c <z_shell_has_wildcard+0x40>  // b.lo, b.ul, b.last
	return false;
    4000a32c:	52800000 	mov	w0, #0x0                   	// #0
}
    4000a330:	f9400bf3 	ldr	x19, [sp, #16]
    4000a334:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a338:	d65f03c0 	ret
		if ((str[i] == '?') || (str[i] == '*')) {
    4000a33c:	38626a60 	ldrb	w0, [x19, x2]
    4000a340:	7100fc1f 	cmp	w0, #0x3f
    4000a344:	1a9f17e1 	cset	w1, eq  // eq = none
    4000a348:	7100a81f 	cmp	w0, #0x2a
    4000a34c:	1a9f17e0 	cset	w0, eq  // eq = none
    4000a350:	2a000020 	orr	w0, w1, w0
    4000a354:	35fffee0 	cbnz	w0, 4000a330 <z_shell_has_wildcard+0x34>
	for (size_t i = 0; i < str_len; i++) {
    4000a358:	91000442 	add	x2, x2, #0x1
    4000a35c:	17fffff2 	b	4000a324 <z_shell_has_wildcard+0x28>

000000004000a360 <z_shell_wildcard_prepare>:

void z_shell_wildcard_prepare(const struct shell *shell)
{
    4000a360:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	 *    buffer with all expanded commands is copied to Command buffer.
	 * 7. Deepest found handler is executed and all lower level commands,
	 *    including expanded commands, are passed as arguments.
	 */

	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    4000a364:	d2802002 	mov	x2, #0x100                 	// #256
    4000a368:	52800001 	mov	w1, #0x0                   	// #0
{
    4000a36c:	910003fd 	mov	x29, sp
    4000a370:	f9000bf3 	str	x19, [sp, #16]
    4000a374:	aa0003f3 	mov	x19, x0
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
    4000a378:	f9400800 	ldr	x0, [x0, #16]
    4000a37c:	9105d800 	add	x0, x0, #0x176
    4000a380:	94000657 	bl	4000bcdc <memset>
	memcpy(shell->ctx->temp_buff,
    4000a384:	f9400a60 	ldr	x0, [x19, #16]
    4000a388:	9101d801 	add	x1, x0, #0x76
    4000a38c:	7940e002 	ldrh	w2, [x0, #112]
    4000a390:	9105d800 	add	x0, x0, #0x176
    4000a394:	9400064a 	bl	4000bcbc <memcpy>

	/* Function shell_spaces_trim must be used instead of shell_make_argv.
	 * At this point it is important to keep temp_buff as one string.
	 * It will allow to find wildcard commands easily with strstr function.
	 */
	z_shell_spaces_trim(shell->ctx->temp_buff);
    4000a398:	f9400a60 	ldr	x0, [x19, #16]
    4000a39c:	9105d800 	add	x0, x0, #0x176
    4000a3a0:	97fff85f 	bl	4000851c <z_shell_spaces_trim>

	/* +1 for EOS*/
	shell->ctx->cmd_tmp_buff_len = z_shell_strlen(shell->ctx->temp_buff) + 1;
    4000a3a4:	f9400a60 	ldr	x0, [x19, #16]
    4000a3a8:	b105d800 	adds	x0, x0, #0x176
    4000a3ac:	54000120 	b.eq	4000a3d0 <z_shell_wildcard_prepare+0x70>  // b.none
    4000a3b0:	94000600 	bl	4000bbb0 <strlen>
    4000a3b4:	12003c00 	and	w0, w0, #0xffff
    4000a3b8:	f9400a61 	ldr	x1, [x19, #16]
    4000a3bc:	11000400 	add	w0, w0, #0x1
}
    4000a3c0:	f9400bf3 	ldr	x19, [sp, #16]
	shell->ctx->cmd_tmp_buff_len = z_shell_strlen(shell->ctx->temp_buff) + 1;
    4000a3c4:	7900e820 	strh	w0, [x1, #116]
}
    4000a3c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a3cc:	d65f03c0 	ret
    4000a3d0:	52800000 	mov	w0, #0x0                   	// #0
    4000a3d4:	17fffff9 	b	4000a3b8 <z_shell_wildcard_prepare+0x58>

000000004000a3d8 <z_shell_wildcard_process>:


enum shell_wildcard_status z_shell_wildcard_process(const struct shell *shell,
					const struct shell_static_entry *cmd,
					const char *pattern)
{
    4000a3d8:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    4000a3dc:	910003fd 	mov	x29, sp
    4000a3e0:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a3e4:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000a3e8:	a90363f7 	stp	x23, x24, [sp, #48]
    4000a3ec:	a9046bf9 	stp	x25, x26, [sp, #64]
    4000a3f0:	a90573fb 	stp	x27, x28, [sp, #80]
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
    4000a3f4:	b5000141 	cbnz	x1, 4000a41c <z_shell_wildcard_process+0x44>
		return ret_val;
    4000a3f8:	52800073 	mov	w19, #0x3                   	// #3
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(shell, cmd, pattern);

	return ret_val;
}
    4000a3fc:	2a1303e0 	mov	w0, w19
    4000a400:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000a404:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000a408:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000a40c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000a410:	a94573fb 	ldp	x27, x28, [sp, #80]
    4000a414:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    4000a418:	d65f03c0 	ret
    4000a41c:	aa0003f5 	mov	x21, x0
    4000a420:	aa0103f6 	mov	x22, x1
    4000a424:	aa0203f4 	mov	x20, x2
	if (!z_shell_has_wildcard(pattern)) {
    4000a428:	aa0203e0 	mov	x0, x2
    4000a42c:	97ffffb4 	bl	4000a2fc <z_shell_has_wildcard>
    4000a430:	72001c1f 	tst	w0, #0xff
    4000a434:	54fffe20 	b.eq	4000a3f8 <z_shell_wildcard_process+0x20>  // b.none
	size_t cnt = 0;
    4000a438:	d2800018 	mov	x24, #0x0                   	// #0
	size_t cmd_idx = 0;
    4000a43c:	d2800001 	mov	x1, #0x0                   	// #0
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
    4000a440:	52800053 	mov	w19, #0x2                   	// #2
	completion_addr[cmd_len] = ' ';
    4000a444:	5280041a 	mov	w26, #0x20                  	// #32
    4000a448:	1400001c 	b	4000a4b8 <z_shell_wildcard_process+0xe0>
    4000a44c:	52800013 	mov	w19, #0x0                   	// #0
    4000a450:	1400002c 	b	4000a500 <z_shell_wildcard_process+0x128>
	completion_addr = strstr(buff, pattern);
    4000a454:	aa1403e1 	mov	x1, x20
    4000a458:	9105dae0 	add	x0, x23, #0x176
    4000a45c:	94000589 	bl	4000ba80 <strstr>
    4000a460:	aa0003fb 	mov	x27, x0
	if (!completion_addr) {
    4000a464:	b4000740 	cbz	x0, 4000a54c <z_shell_wildcard_process+0x174>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
    4000a468:	92403e79 	and	x25, x19, #0xffff
    4000a46c:	940005d1 	bl	4000bbb0 <strlen>
    4000a470:	92403c02 	and	x2, x0, #0xffff
    4000a474:	91000720 	add	x0, x25, #0x1
    4000a478:	91000442 	add	x2, x2, #0x1
    4000a47c:	aa1b03e1 	mov	x1, x27
    4000a480:	8b000360 	add	x0, x27, x0
    4000a484:	940005ff 	bl	4000bc80 <memmove>
	memcpy(completion_addr, cmd, cmd_len);
    4000a488:	aa1903e2 	mov	x2, x25
    4000a48c:	aa1c03e1 	mov	x1, x28
    4000a490:	aa1b03e0 	mov	x0, x27
    4000a494:	9400060a 	bl	4000bcbc <memcpy>
	completion_addr[cmd_len] = ' ';
    4000a498:	38396b7a 	strb	w26, [x27, x25]
			cnt++;
    4000a49c:	91000718 	add	x24, x24, #0x1
	*buff_len += cmd_len + 1; /* + 1 for space */
    4000a4a0:	7940eae0 	ldrh	w0, [x23, #116]
    4000a4a4:	0b000273 	add	w19, w19, w0
    4000a4a8:	11000673 	add	w19, w19, #0x1
    4000a4ac:	7900eaf3 	strh	w19, [x23, #116]
			ret_val = command_add(shell->ctx->temp_buff,
    4000a4b0:	52800013 	mov	w19, #0x0                   	// #0
    4000a4b4:	f94037e1 	ldr	x1, [sp, #104]
	while ((entry = z_shell_cmd_get(cmd, cmd_idx++, &dloc)) != NULL) {
    4000a4b8:	91000420 	add	x0, x1, #0x1
    4000a4bc:	9101e3e2 	add	x2, sp, #0x78
    4000a4c0:	f90037e0 	str	x0, [sp, #104]
    4000a4c4:	aa1603e0 	mov	x0, x22
    4000a4c8:	97fff7a4 	bl	40008358 <z_shell_cmd_get>
    4000a4cc:	aa0003fb 	mov	x27, x0
    4000a4d0:	b4000300 	cbz	x0, 4000a530 <z_shell_wildcard_process+0x158>
		if (fnmatch(pattern, entry->syntax, 0) == 0) {
    4000a4d4:	f9400361 	ldr	x1, [x27]
    4000a4d8:	aa1403e0 	mov	x0, x20
    4000a4dc:	52800002 	mov	w2, #0x0                   	// #0
    4000a4e0:	97ffe3d2 	bl	40003428 <fnmatch>
    4000a4e4:	35fffe80 	cbnz	w0, 4000a4b4 <z_shell_wildcard_process+0xdc>
			ret_val = command_add(shell->ctx->temp_buff,
    4000a4e8:	f940037c 	ldr	x28, [x27]
    4000a4ec:	f9400ab7 	ldr	x23, [x21, #16]
    4000a4f0:	b4fffafc 	cbz	x28, 4000a44c <z_shell_wildcard_process+0x74>
    4000a4f4:	aa1c03e0 	mov	x0, x28
    4000a4f8:	940005ae 	bl	4000bbb0 <strlen>
    4000a4fc:	12003c13 	and	w19, w0, #0xffff
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
    4000a500:	7940eae0 	ldrh	w0, [x23, #116]
    4000a504:	11000400 	add	w0, w0, #0x1
    4000a508:	0b130000 	add	w0, w0, w19
    4000a50c:	7104001f 	cmp	w0, #0x100
    4000a510:	54fffa2d 	b.le	4000a454 <z_shell_wildcard_process+0x7c>
			ret_val = command_add(shell->ctx->temp_buff,
    4000a514:	52800033 	mov	w19, #0x1                   	// #1
				z_shell_fprintf(shell, SHELL_WARNING,
    4000a518:	aa1403e3 	mov	x3, x20
    4000a51c:	aa1503e0 	mov	x0, x21
    4000a520:	f0000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000a524:	9107c442 	add	x2, x2, #0x1f1
    4000a528:	52800061 	mov	w1, #0x3                   	// #3
    4000a52c:	97fffa33 	bl	40008df8 <z_shell_fprintf>
	if (cnt > 0) {
    4000a530:	b4fff678 	cbz	x24, 4000a3fc <z_shell_wildcard_process+0x24>
		z_shell_pattern_remove(shell->ctx->temp_buff,
    4000a534:	f9400aa0 	ldr	x0, [x21, #16]
    4000a538:	aa1403e2 	mov	x2, x20
    4000a53c:	9101d001 	add	x1, x0, #0x74
    4000a540:	9105d800 	add	x0, x0, #0x176
    4000a544:	97fff75c 	bl	400082b4 <z_shell_pattern_remove>
	return ret_val;
    4000a548:	17ffffad 	b	4000a3fc <z_shell_wildcard_process+0x24>
		return SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
    4000a54c:	52800053 	mov	w19, #0x2                   	// #2
    4000a550:	17fffff8 	b	4000a530 <z_shell_wildcard_process+0x158>

000000004000a554 <z_shell_wildcard_finalize>:

void z_shell_wildcard_finalize(const struct shell *shell)
{
    4000a554:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000a558:	910003fd 	mov	x29, sp
    4000a55c:	f9000bf3 	str	x19, [sp, #16]
    4000a560:	aa0003f3 	mov	x19, x0
	memcpy(shell->ctx->cmd_buff,
    4000a564:	f9400800 	ldr	x0, [x0, #16]
    4000a568:	9105d801 	add	x1, x0, #0x176
    4000a56c:	9101d800 	add	x0, x0, #0x76
    4000a570:	785fe002 	ldurh	w2, [x0, #-2]
    4000a574:	940005d2 	bl	4000bcbc <memcpy>
	       shell->ctx->temp_buff,
	       shell->ctx->cmd_tmp_buff_len);
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
    4000a578:	f9400a60 	ldr	x0, [x19, #16]
}
    4000a57c:	f9400bf3 	ldr	x19, [sp, #16]
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
    4000a580:	7940e801 	ldrh	w1, [x0, #116]
    4000a584:	7900e001 	strh	w1, [x0, #112]
}
    4000a588:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000a58c:	d65f03c0 	ret

000000004000a590 <arch_cpu_idle>:
#ifdef CONFIG_TRACING
	stp	xzr, x30, [sp, #-16]!
	bl	sys_trace_idle
	ldp	xzr, x30, [sp], #16
#endif
	dsb	sy
    4000a590:	d5033f9f 	dsb	sy
	wfi
    4000a594:	d503207f 	wfi
	msr	daifclr, #(DAIFCLR_IRQ_BIT)
    4000a598:	d50342ff 	msr	daifclr, #0x2
	ret
    4000a59c:	d65f03c0 	ret

000000004000a5a0 <z_arm64_fatal_error>:

	return false;
}

void z_arm64_fatal_error(unsigned int reason, z_arch_esf_t *esf)
{
    4000a5a0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	uint64_t esr = 0;
	uint64_t elr = 0;
	uint64_t far = 0;
	uint64_t el;

	if (reason != K_ERR_SPURIOUS_IRQ) {
    4000a5a4:	7100041f 	cmp	w0, #0x1
{
    4000a5a8:	910003fd 	mov	x29, sp
    4000a5ac:	a90153f3 	stp	x19, x20, [sp, #16]
    4000a5b0:	aa0103f4 	mov	x20, x1
    4000a5b4:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000a5b8:	a90363f7 	stp	x23, x24, [sp, #48]
    4000a5bc:	a9046bf9 	stp	x25, x26, [sp, #64]
    4000a5c0:	2a0003f9 	mov	w25, w0
    4000a5c4:	a90573fb 	stp	x27, x28, [sp, #80]
	if (reason != K_ERR_SPURIOUS_IRQ) {
    4000a5c8:	54000e20 	b.eq	4000a78c <z_arm64_fatal_error+0x1ec>  // b.none
MAKE_REG_HELPER(currentel);
    4000a5cc:	d5384240 	mrs	x0, currentel
		el = read_currentel();

		switch (GET_EL(el)) {
    4000a5d0:	d3420c00 	ubfx	x0, x0, #2, #2
    4000a5d4:	f100041f 	cmp	x0, #0x1
    4000a5d8:	54000100 	b.eq	4000a5f8 <z_arm64_fatal_error+0x58>  // b.none
    4000a5dc:	f1000c1f 	cmp	x0, #0x3
    4000a5e0:	54000440 	b.eq	4000a668 <z_arm64_fatal_error+0xc8>  // b.none
			far = read_far_el3();
			elr = read_elr_el3();
			break;
		}

		if (GET_EL(el) != MODE_EL0) {
    4000a5e4:	b4000d40 	cbz	x0, 4000a78c <z_arm64_fatal_error+0x1ec>
	uint64_t esr = 0;
    4000a5e8:	d2800017 	mov	x23, #0x0                   	// #0
	uint64_t elr = 0;
    4000a5ec:	d2800001 	mov	x1, #0x0                   	// #0
	uint64_t far = 0;
    4000a5f0:	d2800018 	mov	x24, #0x0                   	// #0
    4000a5f4:	14000004 	b	4000a604 <z_arm64_fatal_error+0x64>
MAKE_REG_HELPER_EL123(esr)
    4000a5f8:	d5385217 	mrs	x23, esr_el1
MAKE_REG_HELPER_EL123(far)
    4000a5fc:	d5386018 	mrs	x24, far_el1
MAKE_REG_HELPER_EL123(elr)
    4000a600:	d5384021 	mrs	x1, elr_el1
#ifdef CONFIG_EXCEPTION_DEBUG
			bool dump_far = false;

			LOG_ERR("ELR_ELn: 0x%016llx", elr);
    4000a604:	b0000336 	adrp	x22, 4006f000 <sys_work_q_stack+0xf20>
    4000a608:	912932d5 	add	x21, x22, #0xa4c
    4000a60c:	b94a4ec0 	ldr	w0, [x22, #2636]
    4000a610:	f240081f 	tst	x0, #0x7
    4000a614:	54000140 	b.eq	4000a63c <z_arm64_fatal_error+0x9c>  // b.none
    4000a618:	b0000322 	adrp	x2, 4006f000 <sys_work_q_stack+0xf20>
    4000a61c:	91290042 	add	x2, x2, #0xa40
    4000a620:	cb0202a2 	sub	x2, x21, x2
    4000a624:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a628:	9123c000 	add	x0, x0, #0x8f0
    4000a62c:	d342fc42 	lsr	x2, x2, #2
    4000a630:	531a2442 	ubfiz	w2, w2, #6, #10
    4000a634:	32000042 	orr	w2, w2, #0x1
    4000a638:	97ffe589 	bl	40003c5c <log_1>
	switch (GET_ESR_EC(esr)) {
    4000a63c:	531a7efb 	lsr	w27, w23, #26
    4000a640:	f100f37f 	cmp	x27, #0x3c
    4000a644:	540023c8 	b.hi	4000aabc <z_arm64_fatal_error+0x51c>  // b.pmore
    4000a648:	7100f37f 	cmp	w27, #0x3c
    4000a64c:	54002388 	b.hi	4000aabc <z_arm64_fatal_error+0x51c>  // b.pmore
    4000a650:	d0000040 	adrp	x0, 40014000 <CSWTCH.135+0x90>
    4000a654:	9102c000 	add	x0, x0, #0xb0
    4000a658:	787b5800 	ldrh	w0, [x0, w27, uxtw #1]
    4000a65c:	10000061 	adr	x1, 4000a668 <z_arm64_fatal_error+0xc8>
    4000a660:	8b20a820 	add	x0, x1, w0, sxth #2
    4000a664:	d61f0000 	br	x0
MAKE_REG_HELPER_EL123(esr)
    4000a668:	d53e5217 	mrs	x23, esr_el3
MAKE_REG_HELPER_EL123(far)
    4000a66c:	d53e6018 	mrs	x24, far_el3
MAKE_REG_HELPER_EL123(elr)
    4000a670:	d53e4021 	mrs	x1, elr_el3
			break;
    4000a674:	17ffffe4 	b	4000a604 <z_arm64_fatal_error+0x64>
		err = "Trapped WFI or WFE instruction execution";
    4000a678:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a67c:	91231e73 	add	x19, x19, #0x8c7
			bool dump_far = false;
    4000a680:	5280001a 	mov	w26, #0x0                   	// #0
	LOG_ERR("ESR_ELn: 0x%016llx", esr);
    4000a684:	b94a4ec0 	ldr	w0, [x22, #2636]
    4000a688:	f240081f 	tst	x0, #0x7
    4000a68c:	540004a0 	b.eq	4000a720 <z_arm64_fatal_error+0x180>  // b.none
    4000a690:	b000033c 	adrp	x28, 4006f000 <sys_work_q_stack+0xf20>
    4000a694:	9129039c 	add	x28, x28, #0xa40
    4000a698:	cb1c02bc 	sub	x28, x21, x28
    4000a69c:	aa1703e1 	mov	x1, x23
    4000a6a0:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a6a4:	91240c00 	add	x0, x0, #0x903
    4000a6a8:	d342ff9c 	lsr	x28, x28, #2
    4000a6ac:	531a279c 	ubfiz	w28, w28, #6, #10
    4000a6b0:	3200039c 	orr	w28, w28, #0x1
    4000a6b4:	2a1c03e2 	mov	w2, w28
    4000a6b8:	97ffe569 	bl	40003c5c <log_1>
	LOG_ERR("  EC:  0x%llx (%s)", GET_ESR_EC(esr), err);
    4000a6bc:	b94a4ec0 	ldr	w0, [x22, #2636]
    4000a6c0:	f240081f 	tst	x0, #0x7
    4000a6c4:	540002e0 	b.eq	4000a720 <z_arm64_fatal_error+0x180>  // b.none
    4000a6c8:	2a1c03e3 	mov	w3, w28
    4000a6cc:	aa1303e2 	mov	x2, x19
    4000a6d0:	aa1b03e1 	mov	x1, x27
    4000a6d4:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a6d8:	91245800 	add	x0, x0, #0x916
    4000a6dc:	97ffe577 	bl	40003cb8 <log_2>
	LOG_ERR("  IL:  0x%llx", GET_ESR_IL(esr));
    4000a6e0:	b94a4ec0 	ldr	w0, [x22, #2636]
    4000a6e4:	f240081f 	tst	x0, #0x7
    4000a6e8:	540001c0 	b.eq	4000a720 <z_arm64_fatal_error+0x180>  // b.none
    4000a6ec:	2a1c03e2 	mov	w2, w28
    4000a6f0:	d35966e1 	ubfx	x1, x23, #25, #1
    4000a6f4:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a6f8:	9124a400 	add	x0, x0, #0x929
    4000a6fc:	97ffe558 	bl	40003c5c <log_1>
	LOG_ERR("  ISS: 0x%llx", GET_ESR_ISS(esr));
    4000a700:	b94a4ec0 	ldr	w0, [x22, #2636]
    4000a704:	f240081f 	tst	x0, #0x7
    4000a708:	540000c0 	b.eq	4000a720 <z_arm64_fatal_error+0x180>  // b.none
    4000a70c:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a710:	9124dc00 	add	x0, x0, #0x937
    4000a714:	2a1c03e2 	mov	w2, w28
    4000a718:	924062e1 	and	x1, x23, #0x1ffffff
    4000a71c:	97ffe550 	bl	40003c5c <log_1>

			dump_esr(esr, &dump_far);

			if (dump_far)
    4000a720:	340001da 	cbz	w26, 4000a758 <z_arm64_fatal_error+0x1b8>
				LOG_ERR("FAR_ELn: 0x%016llx", far);
    4000a724:	b94a4ec0 	ldr	w0, [x22, #2636]
    4000a728:	f240081f 	tst	x0, #0x7
    4000a72c:	54000300 	b.eq	4000a78c <z_arm64_fatal_error+0x1ec>  // b.none
    4000a730:	b0000322 	adrp	x2, 4006f000 <sys_work_q_stack+0xf20>
    4000a734:	91290042 	add	x2, x2, #0xa40
    4000a738:	cb0202a2 	sub	x2, x21, x2
    4000a73c:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a740:	91251400 	add	x0, x0, #0x945
    4000a744:	aa1803e1 	mov	x1, x24
    4000a748:	d342fc42 	lsr	x2, x2, #2
    4000a74c:	531a2442 	ubfiz	w2, w2, #6, #10
    4000a750:	32000042 	orr	w2, w2, #0x1
    4000a754:	97ffe542 	bl	40003c5c <log_1>

			LOG_ERR("TPIDRRO: 0x%016llx", read_tpidrro_el0());
    4000a758:	b94a4ec0 	ldr	w0, [x22, #2636]
    4000a75c:	f240081f 	tst	x0, #0x7
    4000a760:	54000160 	b.eq	4000a78c <z_arm64_fatal_error+0x1ec>  // b.none
    4000a764:	b0000322 	adrp	x2, 4006f000 <sys_work_q_stack+0xf20>
    4000a768:	91290042 	add	x2, x2, #0xa40
    4000a76c:	cb0202a2 	sub	x2, x21, x2
    4000a770:	d342fc42 	lsr	x2, x2, #2
    4000a774:	531a2442 	ubfiz	w2, w2, #6, #10
    4000a778:	32000042 	orr	w2, w2, #0x1
MAKE_REG_HELPER(tpidrro_el0);
    4000a77c:	d53bd061 	mrs	x1, tpidrro_el0
    4000a780:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a784:	91256000 	add	x0, x0, #0x958
    4000a788:	97ffe535 	bl	40003c5c <log_1>
				return;
		}
	}

#ifdef CONFIG_EXCEPTION_DEBUG
	if (esf != NULL) {
    4000a78c:	b4000b34 	cbz	x20, 4000a8f0 <z_arm64_fatal_error+0x350>
	LOG_ERR("x0:  0x%016llx  x1:  0x%016llx", esf->x0, esf->x1);
    4000a790:	b0000333 	adrp	x19, 4006f000 <sys_work_q_stack+0xf20>
    4000a794:	91293275 	add	x21, x19, #0xa4c
    4000a798:	b94a4e60 	ldr	w0, [x19, #2636]
    4000a79c:	f240081f 	tst	x0, #0x7
    4000a7a0:	54000a80 	b.eq	4000a8f0 <z_arm64_fatal_error+0x350>  // b.none
    4000a7a4:	b0000320 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000a7a8:	91290000 	add	x0, x0, #0xa40
    4000a7ac:	cb0002b5 	sub	x21, x21, x0
    4000a7b0:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a7b4:	9125ac00 	add	x0, x0, #0x96b
    4000a7b8:	a9400a81 	ldp	x1, x2, [x20]
    4000a7bc:	d342feb5 	lsr	x21, x21, #2
    4000a7c0:	531a26b5 	ubfiz	w21, w21, #6, #10
    4000a7c4:	320002b6 	orr	w22, w21, #0x1
    4000a7c8:	2a1603e3 	mov	w3, w22
    4000a7cc:	97ffe53b 	bl	40003cb8 <log_2>
	LOG_ERR("x2:  0x%016llx  x3:  0x%016llx", esf->x2, esf->x3);
    4000a7d0:	b94a4e60 	ldr	w0, [x19, #2636]
    4000a7d4:	f240081f 	tst	x0, #0x7
    4000a7d8:	540008c0 	b.eq	4000a8f0 <z_arm64_fatal_error+0x350>  // b.none
    4000a7dc:	a9410a81 	ldp	x1, x2, [x20, #16]
    4000a7e0:	2a1603e3 	mov	w3, w22
    4000a7e4:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a7e8:	91262800 	add	x0, x0, #0x98a
    4000a7ec:	97ffe533 	bl	40003cb8 <log_2>
	LOG_ERR("x4:  0x%016llx  x5:  0x%016llx", esf->x4, esf->x5);
    4000a7f0:	b94a4e60 	ldr	w0, [x19, #2636]
    4000a7f4:	f240081f 	tst	x0, #0x7
    4000a7f8:	540007c0 	b.eq	4000a8f0 <z_arm64_fatal_error+0x350>  // b.none
    4000a7fc:	a9420a81 	ldp	x1, x2, [x20, #32]
    4000a800:	2a1603e3 	mov	w3, w22
    4000a804:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a808:	9126a400 	add	x0, x0, #0x9a9
    4000a80c:	97ffe52b 	bl	40003cb8 <log_2>
	LOG_ERR("x6:  0x%016llx  x7:  0x%016llx", esf->x6, esf->x7);
    4000a810:	b94a4e60 	ldr	w0, [x19, #2636]
    4000a814:	f240081f 	tst	x0, #0x7
    4000a818:	540006c0 	b.eq	4000a8f0 <z_arm64_fatal_error+0x350>  // b.none
    4000a81c:	a9430a81 	ldp	x1, x2, [x20, #48]
    4000a820:	2a1603e3 	mov	w3, w22
    4000a824:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a828:	91272000 	add	x0, x0, #0x9c8
    4000a82c:	97ffe523 	bl	40003cb8 <log_2>
	LOG_ERR("x8:  0x%016llx  x9:  0x%016llx", esf->x8, esf->x9);
    4000a830:	b94a4e60 	ldr	w0, [x19, #2636]
    4000a834:	f240081f 	tst	x0, #0x7
    4000a838:	540005c0 	b.eq	4000a8f0 <z_arm64_fatal_error+0x350>  // b.none
    4000a83c:	a9440a81 	ldp	x1, x2, [x20, #64]
    4000a840:	2a1603e3 	mov	w3, w22
    4000a844:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a848:	91279c00 	add	x0, x0, #0x9e7
    4000a84c:	97ffe51b 	bl	40003cb8 <log_2>
	LOG_ERR("x10: 0x%016llx  x11: 0x%016llx", esf->x10, esf->x11);
    4000a850:	b94a4e60 	ldr	w0, [x19, #2636]
    4000a854:	f240081f 	tst	x0, #0x7
    4000a858:	540004c0 	b.eq	4000a8f0 <z_arm64_fatal_error+0x350>  // b.none
    4000a85c:	a9450a81 	ldp	x1, x2, [x20, #80]
    4000a860:	2a1603e3 	mov	w3, w22
    4000a864:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a868:	91281800 	add	x0, x0, #0xa06
    4000a86c:	97ffe513 	bl	40003cb8 <log_2>
	LOG_ERR("x12: 0x%016llx  x13: 0x%016llx", esf->x12, esf->x13);
    4000a870:	b94a4e60 	ldr	w0, [x19, #2636]
    4000a874:	f240081f 	tst	x0, #0x7
    4000a878:	540003c0 	b.eq	4000a8f0 <z_arm64_fatal_error+0x350>  // b.none
    4000a87c:	a9460a81 	ldp	x1, x2, [x20, #96]
    4000a880:	2a1603e3 	mov	w3, w22
    4000a884:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a888:	91289400 	add	x0, x0, #0xa25
    4000a88c:	97ffe50b 	bl	40003cb8 <log_2>
	LOG_ERR("x14: 0x%016llx  x15: 0x%016llx", esf->x14, esf->x15);
    4000a890:	b94a4e60 	ldr	w0, [x19, #2636]
    4000a894:	f240081f 	tst	x0, #0x7
    4000a898:	540002c0 	b.eq	4000a8f0 <z_arm64_fatal_error+0x350>  // b.none
    4000a89c:	a9470a81 	ldp	x1, x2, [x20, #112]
    4000a8a0:	2a1603e3 	mov	w3, w22
    4000a8a4:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a8a8:	91291000 	add	x0, x0, #0xa44
    4000a8ac:	97ffe503 	bl	40003cb8 <log_2>
	LOG_ERR("x16: 0x%016llx  x17: 0x%016llx", esf->x16, esf->x17);
    4000a8b0:	b94a4e60 	ldr	w0, [x19, #2636]
    4000a8b4:	f240081f 	tst	x0, #0x7
    4000a8b8:	540001c0 	b.eq	4000a8f0 <z_arm64_fatal_error+0x350>  // b.none
    4000a8bc:	a9480a81 	ldp	x1, x2, [x20, #128]
    4000a8c0:	2a1603e3 	mov	w3, w22
    4000a8c4:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a8c8:	91298c00 	add	x0, x0, #0xa63
    4000a8cc:	97ffe4fb 	bl	40003cb8 <log_2>
	LOG_ERR("x18: 0x%016llx  x30: 0x%016llx", esf->x18, esf->x30);
    4000a8d0:	b94a4e60 	ldr	w0, [x19, #2636]
    4000a8d4:	f240081f 	tst	x0, #0x7
    4000a8d8:	540000c0 	b.eq	4000a8f0 <z_arm64_fatal_error+0x350>  // b.none
    4000a8dc:	a9490a81 	ldp	x1, x2, [x20, #144]
    4000a8e0:	f0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000a8e4:	912a0800 	add	x0, x0, #0xa82
    4000a8e8:	2a1603e3 	mov	w3, w22
    4000a8ec:	97ffe4f3 	bl	40003cb8 <log_2>
		esf_dump(esf);
	}
#endif /* CONFIG_EXCEPTION_DEBUG */

	z_fatal_error(reason, esf);
    4000a8f0:	aa1403e1 	mov	x1, x20
    4000a8f4:	2a1903e0 	mov	w0, w25
    4000a8f8:	94000e92 	bl	4000e340 <z_fatal_error>
		err = "Trapped MCR or MRC access with (coproc==0b1111) that "
    4000a8fc:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a900:	91096a73 	add	x19, x19, #0x25a
			bool dump_far = false;
    4000a904:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a908:	17ffff5f 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Trapped MCRR or MRRC access with (coproc==0b1111) "
    4000a90c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a910:	910ac673 	add	x19, x19, #0x2b1
			bool dump_far = false;
    4000a914:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a918:	17ffff5b 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Trapped MCR or MRC access with (coproc==0b1110)";
    4000a91c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a920:	910c2a73 	add	x19, x19, #0x30a
			bool dump_far = false;
    4000a924:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a928:	17ffff57 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Trapped LDC or STC access";
    4000a92c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a930:	910cea73 	add	x19, x19, #0x33a
			bool dump_far = false;
    4000a934:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a938:	17ffff53 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Trapped access to SVE, Advanced SIMD, or "
    4000a93c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a940:	910d5273 	add	x19, x19, #0x354
			bool dump_far = false;
    4000a944:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a948:	17ffff4f 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Trapped MRRC access with (coproc==0b1110)";
    4000a94c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a950:	910e6a73 	add	x19, x19, #0x39a
			bool dump_far = false;
    4000a954:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a958:	17ffff4b 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Branch Target Exception";
    4000a95c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a960:	910f1273 	add	x19, x19, #0x3c4
			bool dump_far = false;
    4000a964:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a968:	17ffff47 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Illegal Execution state";
    4000a96c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a970:	910f7273 	add	x19, x19, #0x3dc
			bool dump_far = false;
    4000a974:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a978:	17ffff43 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "SVC instruction execution in AArch32 state";
    4000a97c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a980:	910fd273 	add	x19, x19, #0x3f4
			bool dump_far = false;
    4000a984:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a988:	17ffff3f 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Trapped MSR, MRS or System instruction execution in "
    4000a98c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a990:	91107e73 	add	x19, x19, #0x41f
			bool dump_far = false;
    4000a994:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a998:	17ffff3b 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Trapped access to SVE functionality";
    4000a99c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a9a0:	91127e73 	add	x19, x19, #0x49f
			bool dump_far = false;
    4000a9a4:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000a9a8:	17ffff37 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Instruction Abort from a lower Exception level, that "
    4000a9ac:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a9b0:	91130e73 	add	x19, x19, #0x4c3
		*dump_far = true;
    4000a9b4:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000a9b8:	17ffff33 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Instruction Abort taken without a change in Exception "
    4000a9bc:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a9c0:	91146a73 	add	x19, x19, #0x51a
		*dump_far = true;
    4000a9c4:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000a9c8:	17ffff2f 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "PC alignment fault exception.";
    4000a9cc:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a9d0:	91155e73 	add	x19, x19, #0x557
		*dump_far = true;
    4000a9d4:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000a9d8:	17ffff2b 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Data Abort from a lower Exception level, that might "
    4000a9dc:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a9e0:	9115d673 	add	x19, x19, #0x575
		*dump_far = true;
    4000a9e4:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000a9e8:	17ffff27 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Data Abort taken without a change in Exception level";
    4000a9ec:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000a9f0:	91171673 	add	x19, x19, #0x5c5
		*dump_far = true;
    4000a9f4:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000a9f8:	17ffff23 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "SP alignment fault exception";
    4000a9fc:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aa00:	9117ea73 	add	x19, x19, #0x5fa
			bool dump_far = false;
    4000aa04:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000aa08:	17ffff1f 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Trapped floating-point exception taken from AArch32 "
    4000aa0c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aa10:	91185e73 	add	x19, x19, #0x617
			bool dump_far = false;
    4000aa14:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000aa18:	17ffff1b 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Trapped floating-point exception taken from AArch64 "
    4000aa1c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aa20:	91194673 	add	x19, x19, #0x651
			bool dump_far = false;
    4000aa24:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000aa28:	17ffff17 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "SError interrupt";
    4000aa2c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aa30:	911a3273 	add	x19, x19, #0x68c
			bool dump_far = false;
    4000aa34:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000aa38:	17ffff13 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Breakpoint exception from a lower Exception level, "
    4000aa3c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aa40:	911a7673 	add	x19, x19, #0x69d
			bool dump_far = false;
    4000aa44:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000aa48:	17ffff0f 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Breakpoint exception taken without a change in "
    4000aa4c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aa50:	911bde73 	add	x19, x19, #0x6f7
			bool dump_far = false;
    4000aa54:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000aa58:	17ffff0b 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Software Step exception from a lower Exception level, "
    4000aa5c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aa60:	911cda73 	add	x19, x19, #0x736
			bool dump_far = false;
    4000aa64:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000aa68:	17ffff07 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Software Step exception taken without a change in "
    4000aa6c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aa70:	911e4e73 	add	x19, x19, #0x793
			bool dump_far = false;
    4000aa74:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000aa78:	17ffff03 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Watchpoint exception from a lower Exception level, "
    4000aa7c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aa80:	911f5673 	add	x19, x19, #0x7d5
		*dump_far = true;
    4000aa84:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000aa88:	17fffeff 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Watchpoint exception taken without a change in "
    4000aa8c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aa90:	9120be73 	add	x19, x19, #0x82f
		*dump_far = true;
    4000aa94:	5280003a 	mov	w26, #0x1                   	// #1
		break;
    4000aa98:	17fffefb 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "BKPT instruction execution in AArch32 state";
    4000aa9c:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aaa0:	9121be73 	add	x19, x19, #0x86f
			bool dump_far = false;
    4000aaa4:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000aaa8:	17fffef7 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "BRK instruction execution in AArch64 state.";
    4000aaac:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aab0:	91226e73 	add	x19, x19, #0x89b
			bool dump_far = false;
    4000aab4:	5280001a 	mov	w26, #0x0                   	// #0
		break;
    4000aab8:	17fffef3 	b	4000a684 <z_arm64_fatal_error+0xe4>
		err = "Unknown";
    4000aabc:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aac0:	91090e73 	add	x19, x19, #0x243
			bool dump_far = false;
    4000aac4:	5280001a 	mov	w26, #0x0                   	// #0
    4000aac8:	17fffeef 	b	4000a684 <z_arm64_fatal_error+0xe4>
	switch (GET_ESR_EC(esr)) {
    4000aacc:	f0000053 	adrp	x19, 40015000 <tabulator.1+0x262>
    4000aad0:	91092e73 	add	x19, x19, #0x24b
    4000aad4:	5280001a 	mov	w26, #0x0                   	// #0
    4000aad8:	17fffeeb 	b	4000a684 <z_arm64_fatal_error+0xe4>

000000004000aadc <z_arm64_do_kernel_oops>:
 * (e.g. kernel oops, panic, etc.).
 *
 * @param esf exception frame
 */
void z_arm64_do_kernel_oops(z_arch_esf_t *esf)
{
    4000aadc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000aae0:	aa0003e1 	mov	x1, x0
    4000aae4:	910003fd 	mov	x29, sp
		reason != K_ERR_STACK_CHK_FAIL) {
		reason = K_ERR_KERNEL_OOPS;
	}
#endif

	z_arm64_fatal_error(reason, esf);
    4000aae8:	b9404000 	ldr	w0, [x0, #64]
    4000aaec:	97fffead 	bl	4000a5a0 <z_arm64_fatal_error>

000000004000aaf0 <z_arm64_interrupt_init>:
{
#ifdef CONFIG_ARM_CUSTOM_INTERRUPT_CONTROLLER
	/* Invoke SoC-specific interrupt controller initialisation */
	z_soc_irq_init();
#endif
}
    4000aaf0:	d65f03c0 	ret

000000004000aaf4 <arch_irq_enable>:
 * `include/arch/arm64/irq.h`.
 */

void arch_irq_enable(unsigned int irq)
{
	arm_gic_irq_enable(irq);
    4000aaf4:	14000be2 	b	4000da7c <arm_gic_irq_enable>

000000004000aaf8 <z_arm64_irq_priority_set>:
	return arm_gic_irq_is_enabled(irq);
}

void z_arm64_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
	arm_gic_irq_set_priority(irq, prio, flags);
    4000aaf8:	14000bb2 	b	4000d9c0 <arm_gic_irq_set_priority>

000000004000aafc <z_irq_spurious>:

void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm64_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    4000aafc:	d2800001 	mov	x1, #0x0                   	// #0
    4000ab00:	52800020 	mov	w0, #0x1                   	// #1
    4000ab04:	17fffea7 	b	4000a5a0 <z_arm64_fatal_error>

000000004000ab08 <z_arm64_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm64_prep_c(void)
{
    4000ab08:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000ab0c:	f00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000ab10:	911c0000 	add	x0, x0, #0x700
    4000ab14:	910003fd 	mov	x29, sp
    4000ab18:	d51bd060 	msr	tpidrro_el0, x0
	uint64_t *p = (uint64_t *)__bss_start;
    4000ab1c:	b0000060 	adrp	x0, 40017000 <__aarch64_have_lse_atomics>
    4000ab20:	91000000 	add	x0, x0, #0x0
	while (p < end) {
    4000ab24:	f00002e1 	adrp	x1, 40069000 <z_page_frames+0x47725>
    4000ab28:	91237021 	add	x1, x1, #0x8dc
    4000ab2c:	eb01001f 	cmp	x0, x1
    4000ab30:	540000a3 	b.cc	4000ab44 <z_arm64_prep_c+0x3c>  // b.lo, b.ul, b.last

	z_arm64_bss_zero();
#ifdef CONFIG_XIP
	z_data_copy();
#endif
	z_arm64_mm_init(true);
    4000ab34:	52800020 	mov	w0, #0x1                   	// #1
    4000ab38:	9400024e 	bl	4000b470 <z_arm64_mm_init>
	z_arm64_interrupt_init();
    4000ab3c:	97ffffed 	bl	4000aaf0 <z_arm64_interrupt_init>
	z_cstart();
    4000ab40:	94000e85 	bl	4000e554 <z_cstart>
		*p++ = 0U;
    4000ab44:	f800841f 	str	xzr, [x0], #8
    4000ab48:	17fffff9 	b	4000ab2c <z_arm64_prep_c+0x24>

000000004000ab4c <z_arm64_el3_plat_prep_c>:
	ret
    4000ab4c:	d65f03c0 	ret

000000004000ab50 <z_arm64_el2_plat_prep_c>:
	ret
    4000ab50:	d65f03c0 	ret

000000004000ab54 <z_arm64_el1_plat_prep_c>:
	ret
    4000ab54:	d65f03c0 	ret

000000004000ab58 <el3_get_next_el>:
MAKE_REG_HELPER(id_aa64pfr0_el1);
    4000ab58:	d5380400 	mrs	x0, id_aa64pfr0_el1
	EL3_TO_EL1_SKIP_EL2
};

static inline enum el3_next_el el3_get_next_el(void)
{
	if (!is_el_implemented(2)) {
    4000ab5c:	f2780c1f 	tst	x0, #0xf00
    4000ab60:	540000c0 	b.eq	4000ab78 <el3_get_next_el+0x20>  // b.none
    4000ab64:	d5380400 	mrs	x0, id_aa64pfr0_el1
		 * implemented and the value of the SCR_EL3.NS bit is 0 if
		 * ARMv8.4-SecEL2 is not implemented" (D1.11.2 from ARM DDI 0487E.a)
		 */
		return EL3_TO_EL1_SKIP_EL2;
	} else {
		return EL3_TO_EL2;
    4000ab68:	f25c0c1f 	tst	x0, #0xf000000000
    4000ab6c:	1a9f17e0 	cset	w0, eq  // eq = none
    4000ab70:	531f7800 	lsl	w0, w0, #1
	}
}
    4000ab74:	d65f03c0 	ret
		return EL3_TO_EL1_NO_EL2;
    4000ab78:	52800020 	mov	w0, #0x1                   	// #1
    4000ab7c:	17fffffe 	b	4000ab74 <el3_get_next_el+0x1c>

000000004000ab80 <z_arm64_el_highest_plat_init>:
}
    4000ab80:	d65f03c0 	ret

000000004000ab84 <z_arm64_el2_plat_init>:
    4000ab84:	d65f03c0 	ret

000000004000ab88 <z_arm64_el1_plat_init>:
    4000ab88:	d65f03c0 	ret

000000004000ab8c <z_arm64_el_highest_init>:
{
    4000ab8c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000ab90:	910003fd 	mov	x29, sp
    4000ab94:	d5380400 	mrs	x0, id_aa64pfr0_el1
static inline bool is_el_highest_implemented(void)
{
	uint32_t el_highest;
	uint32_t curr_el;

	el_highest = read_id_aa64pfr0_el1() & 0xFFFF;
    4000ab98:	12003c00 	and	w0, w0, #0xffff
	el_highest = (31U - __builtin_clz(el_highest)) / 4;
    4000ab9c:	5ac01000 	clz	w0, w0
MAKE_REG_HELPER(currentel);
    4000aba0:	d5384241 	mrs	x1, currentel
	el_highest = (31U - __builtin_clz(el_highest)) / 4;
    4000aba4:	528003e2 	mov	w2, #0x1f                  	// #31
    4000aba8:	4b000040 	sub	w0, w2, w0

	curr_el = GET_EL(read_currentel());
    4000abac:	53020c21 	ubfx	w1, w1, #2, #2

	if (curr_el < el_highest)
    4000abb0:	6b40083f 	cmp	w1, w0, lsr #2
    4000abb4:	54000083 	b.cc	4000abc4 <z_arm64_el_highest_init+0x38>  // b.lo, b.ul, b.last
MAKE_REG_HELPER(cntfrq_el0);
    4000abb8:	d2959400 	mov	x0, #0xaca0                	// #44192
    4000abbc:	f2a07720 	movk	x0, #0x3b9, lsl #16
    4000abc0:	d51be000 	msr	cntfrq_el0, x0
	z_arm64_el_highest_plat_init();
    4000abc4:	97ffffef 	bl	4000ab80 <z_arm64_el_highest_plat_init>
	isb();
    4000abc8:	d5033fdf 	isb
}
    4000abcc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000abd0:	d65f03c0 	ret

000000004000abd4 <z_arm64_el2_init>:
		z_arm64_el2_init();
	}
}

void z_arm64_el2_init(void)
{
    4000abd4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000abd8:	910003fd 	mov	x29, sp
MAKE_REG_HELPER_EL123(sctlr)
    4000abdc:	d53c1000 	mrs	x0, sctlr_el2
	uint64_t reg;

	reg = read_sctlr_el2();
	reg |= (SCTLR_EL2_RES1 |	/* RES1 */
    4000abe0:	d2830701 	mov	x1, #0x1838                	// #6200
    4000abe4:	f2a618a1 	movk	x1, #0x30c5, lsl #16
    4000abe8:	aa010000 	orr	x0, x0, x1
    4000abec:	d51c1000 	msr	sctlr_el2, x0
MAKE_REG_HELPER(hcr_el2);
    4000abf0:	d53c1100 	mrs	x0, hcr_el2
		SCTLR_I_BIT |		/* Enable i-cache */
		SCTLR_SA_BIT);		/* Enable SP alignment check */
	write_sctlr_el2(reg);

	reg = read_hcr_el2();
	reg |= HCR_RW_BIT;		/* EL1 Execution state is AArch64 */
    4000abf4:	b2610000 	orr	x0, x0, #0x80000000
    4000abf8:	d51c1100 	msr	hcr_el2, x0
MAKE_REG_HELPER_EL123(cptr)
    4000abfc:	d2865fe0 	mov	x0, #0x32ff                	// #13055
    4000ac00:	d51c1140 	msr	cptr_el2, x0
MAKE_REG_HELPER(cntvoff_el2);
    4000ac04:	d51ce07f 	msr	cntvoff_el2, xzr
MAKE_REG_HELPER(cnthctl_el2);
    4000ac08:	d51ce11f 	msr	cnthctl_el2, xzr
MAKE_REG_HELPER(cnthp_ctl_el2);
    4000ac0c:	d51ce23f 	msr	cnthp_ctl_el2, xzr
	/*
	 * Enable this if/when we use the hypervisor timer.
	 * write_cnthp_cval_el2(~(uint64_t)0);
	 */

	z_arm64_el2_plat_init();
    4000ac10:	97ffffdd 	bl	4000ab84 <z_arm64_el2_plat_init>

	isb();
    4000ac14:	d5033fdf 	isb
}
    4000ac18:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000ac1c:	d65f03c0 	ret

000000004000ac20 <z_arm64_el3_init>:
{
    4000ac20:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER_EL123(vbar)
    4000ac24:	d0ffffa0 	adrp	x0, 40000000 <__text_region_start>
    4000ac28:	91200000 	add	x0, x0, #0x800
    4000ac2c:	910003fd 	mov	x29, sp
    4000ac30:	d51ec000 	msr	vbar_el3, x0
	isb();
    4000ac34:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(cptr)
    4000ac38:	d2800000 	mov	x0, #0x0                   	// #0
    4000ac3c:	d51e1140 	msr	cptr_el3, x0
MAKE_REG_HELPER(scr_el3);
    4000ac40:	d281b600 	mov	x0, #0xdb0                 	// #3504
    4000ac44:	d51e1100 	msr	scr_el3, x0
	reg = read_sysreg(ICC_SRE_EL3);
    4000ac48:	d53ecca0 	mrs	x0, s3_6_c12_c12_5
	write_sysreg(reg, ICC_SRE_EL3);
    4000ac4c:	d2800120 	mov	x0, #0x9                   	// #9
    4000ac50:	d51ecca0 	msr	s3_6_c12_c12_5, x0
	z_arm64_el3_plat_init();
    4000ac54:	97ffe1f8 	bl	40003434 <z_arm64_el3_plat_init>
	isb();
    4000ac58:	d5033fdf 	isb
	if (el3_get_next_el() == EL3_TO_EL1_SKIP_EL2) {
    4000ac5c:	97ffffbf 	bl	4000ab58 <el3_get_next_el>
    4000ac60:	7100081f 	cmp	w0, #0x2
    4000ac64:	54000061 	b.ne	4000ac70 <z_arm64_el3_init+0x50>  // b.any
}
    4000ac68:	a8c17bfd 	ldp	x29, x30, [sp], #16
		z_arm64_el2_init();
    4000ac6c:	17ffffda 	b	4000abd4 <z_arm64_el2_init>
}
    4000ac70:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000ac74:	d65f03c0 	ret

000000004000ac78 <z_arm64_el1_init>:

void z_arm64_el1_init(void)
{
    4000ac78:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER_EL123(vbar)
    4000ac7c:	d0ffffa0 	adrp	x0, 40000000 <__text_region_start>
    4000ac80:	91200000 	add	x0, x0, #0x800
    4000ac84:	910003fd 	mov	x29, sp
    4000ac88:	d518c000 	msr	vbar_el1, x0
	uint64_t reg;

	/* Setup vector table */
	write_vbar_el1((uint64_t)_vector_table);
	isb();
    4000ac8c:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(cpacr)
    4000ac90:	d2a00600 	mov	x0, #0x300000              	// #3145728
    4000ac94:	d5181040 	msr	cpacr_el1, x0
MAKE_REG_HELPER_EL123(sctlr)
    4000ac98:	d5381000 	mrs	x0, sctlr_el1
	reg |= CPACR_EL1_FPEN_NOTRAP;	/* Do not trap NEON/SIMD/FP initially */
					/* TODO: CONFIG_FLOAT_*_FORBIDDEN */
	write_cpacr_el1(reg);

	reg = read_sctlr_el1();
	reg |= (SCTLR_EL1_RES1 |	/* RES1 */
    4000ac9c:	d2830101 	mov	x1, #0x1808                	// #6152
    4000aca0:	f2a61a01 	movk	x1, #0x30d0, lsl #16
    4000aca4:	aa010000 	orr	x0, x0, x1
    4000aca8:	d5181000 	msr	sctlr_el1, x0
MAKE_REG_HELPER(cntv_cval_el0)
    4000acac:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4000acb0:	d51be340 	msr	cntv_cval_el0, x0
	 * Enable these if/when we use the corresponding timers.
	 * write_cntp_cval_el0(~(uint64_t)0);
	 * write_cntps_cval_el1(~(uint64_t)0);
	 */

	z_arm64_el1_plat_init();
    4000acb4:	97ffffb5 	bl	4000ab88 <z_arm64_el1_plat_init>

	isb();
    4000acb8:	d5033fdf 	isb
}
    4000acbc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000acc0:	d65f03c0 	ret

000000004000acc4 <z_arm64_el3_get_next_el>:

void z_arm64_el3_get_next_el(uint64_t switch_addr)
{
    4000acc4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000acc8:	910003fd 	mov	x29, sp
MAKE_REG_HELPER_EL123(elr)
    4000accc:	d51e4020 	msr	elr_el3, x0
	write_elr_el3(switch_addr);

	/* Mask the DAIF */
	spsr = SPSR_DAIF_MASK;

	if (el3_get_next_el() == EL3_TO_EL2) {
    4000acd0:	97ffffa2 	bl	4000ab58 <el3_get_next_el>
		/* Dropping into EL2 */
		spsr |= SPSR_MODE_EL2T;
	} else {
		/* Dropping into EL1 */
		spsr |= SPSR_MODE_EL1T;
    4000acd4:	7100001f 	cmp	w0, #0x0
    4000acd8:	d2807881 	mov	x1, #0x3c4                 	// #964
    4000acdc:	d2807900 	mov	x0, #0x3c8                 	// #968
    4000ace0:	9a810000 	csel	x0, x0, x1, eq  // eq = none
MAKE_REG_HELPER_EL123(spsr)
    4000ace4:	d51e4000 	msr	spsr_el3, x0
	}

	write_spsr_el3(spsr);
}
    4000ace8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000acec:	d65f03c0 	ret

000000004000acf0 <z_arm64_context_switch>:

GTEXT(z_arm64_context_switch)
SECTION_FUNC(TEXT, z_arm64_context_switch)

	/* Save the current SP_EL0 */
	mrs	x4, sp_el0
    4000acf0:	d5384104 	mrs	x4, sp_el0

	stp	x19, x20, [x1, #_thread_offset_to_callee_saved_x19_x20]
    4000acf4:	a904d033 	stp	x19, x20, [x1, #72]
	stp	x21, x22, [x1, #_thread_offset_to_callee_saved_x21_x22]
    4000acf8:	a905d835 	stp	x21, x22, [x1, #88]
	stp	x23, x24, [x1, #_thread_offset_to_callee_saved_x23_x24]
    4000acfc:	a906e037 	stp	x23, x24, [x1, #104]
	stp	x25, x26, [x1, #_thread_offset_to_callee_saved_x25_x26]
    4000ad00:	a907e839 	stp	x25, x26, [x1, #120]
	stp	x27, x28, [x1, #_thread_offset_to_callee_saved_x27_x28]
    4000ad04:	a908f03b 	stp	x27, x28, [x1, #136]
	stp	x29, x4,  [x1, #_thread_offset_to_callee_saved_x29_sp_el0]
    4000ad08:	a909903d 	stp	x29, x4, [x1, #152]

	/* Save the current SP_ELx */
	mov	x4, sp
    4000ad0c:	910003e4 	mov	x4, sp
	str	x4, [x1, #_thread_offset_to_callee_saved_sp_elx]
    4000ad10:	f9005424 	str	x4, [x1, #168]

	/* save current thread's exception depth */
	mrs	x4, tpidrro_el0
    4000ad14:	d53bd064 	mrs	x4, tpidrro_el0
	lsr	x2, x4, #TPIDRROEL0_EXC_SHIFT
    4000ad18:	d378fc82 	lsr	x2, x4, #56
	strb	w2, [x1, #_thread_offset_to_exception_depth]
    4000ad1c:	390d8022 	strb	w2, [x1, #864]

	/* retrieve next thread's exception depth */
	ldrb	w2, [x0, #_thread_offset_to_exception_depth]
    4000ad20:	394d8002 	ldrb	w2, [x0, #864]
	bic	x4, x4, #TPIDRROEL0_EXC_DEPTH
    4000ad24:	9240dc84 	and	x4, x4, #0xffffffffffffff
	orr	x4, x4, x2, lsl #TPIDRROEL0_EXC_SHIFT
    4000ad28:	aa02e084 	orr	x4, x4, x2, lsl #56
	msr	tpidrro_el0, x4
    4000ad2c:	d51bd064 	msr	tpidrro_el0, x4
	 * thread variables with offsets added by toolchain.
	 */
	msr	tpidr_el0, x2
#endif

	ldp	x19, x20, [x0, #_thread_offset_to_callee_saved_x19_x20]
    4000ad30:	a944d013 	ldp	x19, x20, [x0, #72]
	ldp	x21, x22, [x0, #_thread_offset_to_callee_saved_x21_x22]
    4000ad34:	a945d815 	ldp	x21, x22, [x0, #88]
	ldp	x23, x24, [x0, #_thread_offset_to_callee_saved_x23_x24]
    4000ad38:	a946e017 	ldp	x23, x24, [x0, #104]
	ldp	x25, x26, [x0, #_thread_offset_to_callee_saved_x25_x26]
    4000ad3c:	a947e819 	ldp	x25, x26, [x0, #120]
	ldp	x27, x28, [x0, #_thread_offset_to_callee_saved_x27_x28]
    4000ad40:	a948f01b 	ldp	x27, x28, [x0, #136]
	ldp	x29, x4,  [x0, #_thread_offset_to_callee_saved_x29_sp_el0]
    4000ad44:	a949901d 	ldp	x29, x4, [x0, #152]

	/* Restore SP_EL0 */
	msr	sp_el0, x4
    4000ad48:	d5184104 	msr	sp_el0, x4

	/* Restore SP_EL1 */
	ldr	x4, [x0, #_thread_offset_to_callee_saved_sp_elx]
    4000ad4c:	f9405404 	ldr	x4, [x0, #168]
	mov	sp, x4
    4000ad50:	9100009f 	mov	sp, x4
	bl	z_thread_mark_switched_in
	ldp	xzr, x30, [sp], #16
#endif

	/* Return to z_arm64_sync_exc() or _isr_wrapper() */
	ret
    4000ad54:	d65f03c0 	ret

000000004000ad58 <z_arm64_sync_exc>:
 */

GTEXT(z_arm64_sync_exc)
SECTION_FUNC(TEXT, z_arm64_sync_exc)

	mrs	x0, esr_el1
    4000ad58:	d5385200 	mrs	x0, esr_el1
	lsr	x1, x0, #26
    4000ad5c:	d35afc01 	lsr	x1, x0, #26

#ifdef CONFIG_FPU_SHARING
	cmp	x1, #0x07 /*Access to SIMD or floating-point */
    4000ad60:	f1001c3f 	cmp	x1, #0x7
	bne	1f
    4000ad64:	54000081 	b.ne	4000ad74 <z_arm64_sync_exc+0x1c>  // b.any
	mov	x0, sp
    4000ad68:	910003e0 	mov	x0, sp
	bl	z_arm64_fpu_trap
    4000ad6c:	94000048 	bl	4000ae8c <z_arm64_fpu_trap>
	b	z_arm64_exit_exc_fpu_done
    4000ad70:	1400002c 	b	4000ae20 <z_arm64_exit_exc_fpu_done>
1:
#endif

	cmp	x1, #0x15 /* 0x15 = SVC */
    4000ad74:	f100543f 	cmp	x1, #0x15
	bne	inv
    4000ad78:	540001a1 	b.ne	4000adac <inv>  // b.any

	/* Demux the SVC call */
	and	x1, x0, #0xff
    4000ad7c:	92401c01 	and	x1, x0, #0xff

	cmp	x1, #_SVC_CALL_CONTEXT_SWITCH
    4000ad80:	f100003f 	cmp	x1, #0x0
	beq	context_switch
    4000ad84:	540000c0 	b.eq	4000ad9c <context_switch>  // b.none

	cmp	x1, #_SVC_CALL_RUNTIME_EXCEPT
    4000ad88:	f100083f 	cmp	x1, #0x2
	beq	oops
    4000ad8c:	54000040 	b.eq	4000ad94 <oops>  // b.none

	/* --(_kernel->nested) */
	dec_nest_counter x0, x1
	b	z_arm64_exit_exc
#endif
	b	inv
    4000ad90:	14000007 	b	4000adac <inv>

000000004000ad94 <oops>:

oops:
	mov	x0, sp
    4000ad94:	910003e0 	mov	x0, sp
	b	z_arm64_do_kernel_oops
    4000ad98:	17ffff51 	b	4000aadc <z_arm64_do_kernel_oops>

000000004000ad9c <context_switch>:
	 * Retrieve x0 and x1 from the stack:
	 *
	 *  - x0 = new_thread->switch_handle = switch_to thread
	 *  - x1 = &old_thread->switch_handle = current thread
	 */
	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    4000ad9c:	a94007e0 	ldp	x0, x1, [sp]

	/* Get old thread from x1 */
	sub	x1, x1, ___thread_t_switch_handle_OFFSET
    4000ada0:	d1050021 	sub	x1, x1, #0x140

	/* Switch thread */
	bl	z_arm64_context_switch
    4000ada4:	97ffffd3 	bl	4000acf0 <z_arm64_context_switch>
	b	z_arm64_exit_exc
    4000ada8:	1400001d 	b	4000ae1c <z_arm64_exit_exc>

000000004000adac <inv>:

inv:
	mov	x0, #0 /* K_ERR_CPU_EXCEPTION */
    4000adac:	d2800000 	mov	x0, #0x0                   	// #0
	mov	x1, sp
    4000adb0:	910003e1 	mov	x1, sp
	bl	z_arm64_fatal_error
    4000adb4:	97fffdfb 	bl	4000a5a0 <z_arm64_fatal_error>

	/* Return here only in case of recoverable error */
	b	z_arm64_exit_exc
    4000adb8:	14000019 	b	4000ae1c <z_arm64_exit_exc>

000000004000adbc <z_arm64_call_svc>:

GTEXT(z_arm64_call_svc)
SECTION_FUNC(TEXT, z_arm64_call_svc)
	svc	#_SVC_CALL_CONTEXT_SWITCH
    4000adbc:	d4000001 	svc	#0x0
	ret
    4000adc0:	d65f03c0 	ret

000000004000adc4 <arch_new_thread>:
	 * dropping into EL0.
	 */

	pInitCtx = Z_STACK_PTR_TO_FRAME(struct __esf, stack_ptr);

	pInitCtx->x0 = (uint64_t)entry;
    4000adc4:	d102c041 	sub	x1, x2, #0xb0
	pInitCtx->x1 = (uint64_t)p1;
    4000adc8:	a9351043 	stp	x3, x4, [x2, #-176]
	pInitCtx->x2 = (uint64_t)p2;
	pInitCtx->x3 = (uint64_t)p3;
    4000adcc:	a9361845 	stp	x5, x6, [x2, #-160]
		pInitCtx->elr = (uint64_t)arch_user_mode_enter;
	} else {
		pInitCtx->elr = (uint64_t)z_thread_entry;
	}
#else
	pInitCtx->elr = (uint64_t)z_thread_entry;
    4000add0:	f0ffffa2 	adrp	x2, 40001000 <__aarch64_ldclr8_acq_rel+0x10>
    4000add4:	910fa042 	add	x2, x2, #0x3e8
    4000add8:	f9005422 	str	x2, [x1, #168]
#endif
	/* Keep using SP_EL1 */
	pInitCtx->spsr = SPSR_MODE_EL1H | DAIF_FIQ_BIT;
    4000addc:	d28008a2 	mov	x2, #0x45                  	// #69
    4000ade0:	f9005022 	str	x2, [x1, #160]

	/* thread birth happens through the exception return path */
	thread->arch.exception_depth = 1;
    4000ade4:	52800022 	mov	w2, #0x1                   	// #1
	 * We are saving SP_EL1 to pop out entry and parameters when going
	 * through z_arm64_exit_exc(). For user threads the definitive location
	 * of SP_EL1 will be set implicitly when going through
	 * z_arm64_userspace_enter() (see comments there)
	 */
	thread->callee_saved.sp_elx = (uint64_t)pInitCtx;
    4000ade8:	f9005401 	str	x1, [x0, #168]

	thread->switch_handle = thread;
    4000adec:	f900a000 	str	x0, [x0, #320]
	thread->arch.exception_depth = 1;
    4000adf0:	390d8002 	strb	w2, [x0, #864]
}
    4000adf4:	d65f03c0 	ret

000000004000adf8 <z_arch_get_next_switch_handle>:

void *z_arch_get_next_switch_handle(struct k_thread **old_thread)
{
    4000adf8:	aa0003e1 	mov	x1, x0
	*old_thread =  _current;
    4000adfc:	f00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000ae00:	f9438800 	ldr	x0, [x0, #1808]
    4000ae04:	f9000020 	str	x0, [x1]

	return z_get_next_switch_handle(*old_thread);
    4000ae08:	140011cb 	b	4000f534 <z_get_next_switch_handle>

000000004000ae0c <z_arm64_serror>:

GTEXT(z_arm64_serror)
SECTION_FUNC(TEXT, z_arm64_serror)

	mov	x1, sp
    4000ae0c:	910003e1 	mov	x1, sp
	mov	x0, #0 /* K_ERR_CPU_EXCEPTION */
    4000ae10:	d2800000 	mov	x0, #0x0                   	// #0

	bl	z_arm64_fatal_error
    4000ae14:	97fffde3 	bl	4000a5a0 <z_arm64_fatal_error>
	/* Return here only in case of recoverable error */
	b	z_arm64_exit_exc
    4000ae18:	14000001 	b	4000ae1c <z_arm64_exit_exc>

000000004000ae1c <z_arm64_exit_exc>:

GTEXT(z_arm64_exit_exc)
SECTION_FUNC(TEXT, z_arm64_exit_exc)

#ifdef CONFIG_FPU_SHARING
	bl	z_arm64_fpu_exit_exc
    4000ae1c:	94000055 	bl	4000af70 <z_arm64_fpu_exit_exc>

000000004000ae20 <z_arm64_exit_exc_fpu_done>:

 GTEXT(z_arm64_exit_exc_fpu_done)
 z_arm64_exit_exc_fpu_done:
#endif

	ldp	x0, x1, [sp, ___esf_t_spsr_elr_OFFSET]
    4000ae20:	a94a07e0 	ldp	x0, x1, [sp, #160]
	msr	spsr_el1, x0
    4000ae24:	d5184000 	msr	spsr_el1, x0
	msr	elr_el1, x1
    4000ae28:	d5184021 	msr	elr_el1, x1

	/* Restore the kernel/user mode flag and decrement exception depth */
	tst	x0, #SPSR_MODE_MASK	/* EL0 == 0 */
    4000ae2c:	f2400c1f 	tst	x0, #0xf
	mrs	x0, tpidrro_el0
    4000ae30:	d53bd060 	mrs	x0, tpidrro_el0
	mov	x1, #TPIDRROEL0_EXC_UNIT
    4000ae34:	d2e02001 	mov	x1, #0x100000000000000     	// #72057594037927936
	orr	x2, x0, #TPIDRROEL0_IN_EL0
    4000ae38:	b2400002 	orr	x2, x0, #0x1
	csel	x0, x2, x0, eq
    4000ae3c:	9a800040 	csel	x0, x2, x0, eq  // eq = none
	sub	x0, x0, x1
    4000ae40:	cb010000 	sub	x0, x0, x1
	msr	tpidrro_el0, x0
    4000ae44:	d51bd060 	msr	tpidrro_el0, x0

	ldp	x0, x1, [sp, ___esf_t_x0_x1_OFFSET]
    4000ae48:	a94007e0 	ldp	x0, x1, [sp]
	ldp	x2, x3, [sp, ___esf_t_x2_x3_OFFSET]
    4000ae4c:	a9410fe2 	ldp	x2, x3, [sp, #16]
	ldp	x4, x5, [sp, ___esf_t_x4_x5_OFFSET]
    4000ae50:	a94217e4 	ldp	x4, x5, [sp, #32]
	ldp	x6, x7, [sp, ___esf_t_x6_x7_OFFSET]
    4000ae54:	a9431fe6 	ldp	x6, x7, [sp, #48]
	ldp	x8, x9, [sp, ___esf_t_x8_x9_OFFSET]
    4000ae58:	a94427e8 	ldp	x8, x9, [sp, #64]
	ldp	x10, x11, [sp, ___esf_t_x10_x11_OFFSET]
    4000ae5c:	a9452fea 	ldp	x10, x11, [sp, #80]
	ldp	x12, x13, [sp, ___esf_t_x12_x13_OFFSET]
    4000ae60:	a94637ec 	ldp	x12, x13, [sp, #96]
	ldp	x14, x15, [sp, ___esf_t_x14_x15_OFFSET]
    4000ae64:	a9473fee 	ldp	x14, x15, [sp, #112]
	ldp	x16, x17, [sp, ___esf_t_x16_x17_OFFSET]
    4000ae68:	a94847f0 	ldp	x16, x17, [sp, #128]
	ldp	x18, x30, [sp, ___esf_t_x18_x30_OFFSET]
    4000ae6c:	a9497bf2 	ldp	x18, x30, [sp, #144]

	add	sp, sp, ___esf_t_SIZEOF
    4000ae70:	9102c3ff 	add	sp, sp, #0xb0
	 * - The address of ret in z_arm64_call_svc()
	 * - The address of the next instruction at the time of the IRQ when the
	 *   thread was switched out.
	 * - The address of z_thread_entry() for new threads (see thread.c).
	 */
	eret
    4000ae74:	d69f03e0 	eret

000000004000ae78 <z_arm64_fpu_enter_exc>:
MAKE_REG_HELPER_EL123(cpacr)
    4000ae78:	d5381040 	mrs	x0, cpacr_el1
void z_arm64_fpu_enter_exc(void)
{
	__ASSERT(read_daif() & DAIF_IRQ_BIT, "must be called with IRQs disabled");

	/* always deny FPU access whenever an exception is entered */
	write_cpacr_el1(read_cpacr_el1() & ~CPACR_EL1_FPEN_NOTRAP);
    4000ae7c:	926af400 	and	x0, x0, #0xffffffffffcfffff
    4000ae80:	d5181040 	msr	cpacr_el1, x0
	isb();
    4000ae84:	d5033fdf 	isb
}
    4000ae88:	d65f03c0 	ret

000000004000ae8c <z_arm64_fpu_trap>:
 * there is nothing to save/restore for that context... as long as we
 * don't get interrupted that is. To ensure that we mask interrupts to
 * the triggering exception context.
 */
void z_arm64_fpu_trap(z_arch_esf_t *esf)
{
    4000ae8c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000ae90:	910003fd 	mov	x29, sp
    4000ae94:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ae98:	aa0003f3 	mov	x19, x0
MAKE_REG_HELPER(tpidrro_el0);
    4000ae9c:	d53bd060 	mrs	x0, tpidrro_el0
	return (_cpu_t *)(read_tpidrro_el0() & TPIDRROEL0_CURR_CPU);
}

static ALWAYS_INLINE int arch_exception_depth(void)
{
	return (read_tpidrro_el0() & TPIDRROEL0_EXC_DEPTH) / TPIDRROEL0_EXC_UNIT;
    4000aea0:	d378fc00 	lsr	x0, x0, #56
	if (arch_exception_depth() <= 1) {
    4000aea4:	f100041f 	cmp	x0, #0x1
    4000aea8:	54000309 	b.ls	4000af08 <z_arm64_fpu_trap+0x7c>  // b.plast
	uint32_t *pc = (uint32_t *)esf->elr;
    4000aeac:	f9405662 	ldr	x2, [x19, #168]
	uintptr_t sp = (uintptr_t)esf + sizeof(*esf);
    4000aeb0:	9102c263 	add	x3, x19, #0xb0
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    4000aeb4:	52807f04 	mov	w4, #0x3f8                 	// #1016
    4000aeb8:	72bff804 	movk	w4, #0xffc0, lsl #16
	uint32_t *pc = (uint32_t *)esf->elr;
    4000aebc:	aa0203e0 	mov	x0, x2
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    4000aec0:	52807c05 	mov	w5, #0x3e0                 	// #992
    4000aec4:	72a7b005 	movk	w5, #0x3d80, lsl #16
		uint32_t insn = *pc;
    4000aec8:	b9400001 	ldr	w1, [x0]
		if ((insn & 0xffc003f8) != 0x3d8003e0)
    4000aecc:	0a040026 	and	w6, w1, w4
    4000aed0:	6b0500df 	cmp	w6, w5
    4000aed4:	540000e1 	b.ne	4000aef0 <z_arm64_fpu_trap+0x64>  // b.any
		uint32_t pimm = (insn >> 10) & 0xfff;
    4000aed8:	d34a5421 	ubfx	x1, x1, #10, #12
		pc++;
    4000aedc:	91001000 	add	x0, x0, #0x4
		*(__int128 *)(sp + pimm * 16) = 0;
    4000aee0:	d37c2c21 	ubfiz	x1, x1, #4, #12
    4000aee4:	8b030021 	add	x1, x1, x3
    4000aee8:	a9007c3f 	stp	xzr, xzr, [x1]
	for (;;) {
    4000aeec:	17fffff7 	b	4000aec8 <z_arm64_fpu_trap+0x3c>
	if (pc != (uint32_t *)esf->elr) {
    4000aef0:	eb00005f 	cmp	x2, x0
    4000aef4:	540000a0 	b.eq	4000af08 <z_arm64_fpu_trap+0x7c>  // b.none
		esf->elr = (uintptr_t)pc;
    4000aef8:	f9005660 	str	x0, [x19, #168]
	_current_cpu->arch.fpu_owner = _current;

	/* restore our content */
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
	DBG("restore", _current);
}
    4000aefc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000af00:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000af04:	d65f03c0 	ret
MAKE_REG_HELPER_EL123(cpacr)
    4000af08:	d5381040 	mrs	x0, cpacr_el1
	write_cpacr_el1(read_cpacr_el1() | CPACR_EL1_FPEN_NOTRAP);
    4000af0c:	b26c0400 	orr	x0, x0, #0x300000
    4000af10:	d5181040 	msr	cpacr_el1, x0
	isb();
    4000af14:	d5033fdf 	isb
	struct k_thread *owner = _current_cpu->arch.fpu_owner;
    4000af18:	f00000b4 	adrp	x20, 40021000 <k_sys_work_q+0x240>
    4000af1c:	911c0294 	add	x20, x20, #0x700
    4000af20:	f9401680 	ldr	x0, [x20, #40]
	if (owner) {
    4000af24:	b40000a0 	cbz	x0, 4000af38 <z_arm64_fpu_trap+0xac>
		z_arm64_fpu_save(&owner->arch.saved_fp_context);
    4000af28:	91054000 	add	x0, x0, #0x150
    4000af2c:	94000021 	bl	4000afb0 <z_arm64_fpu_save>
		dsb();
    4000af30:	d5033f9f 	dsb	sy
		_current_cpu->arch.fpu_owner = NULL;
    4000af34:	f900169f 	str	xzr, [x20, #40]
MAKE_REG_HELPER(tpidrro_el0);
    4000af38:	d53bd060 	mrs	x0, tpidrro_el0
    4000af3c:	d378fc00 	lsr	x0, x0, #56
	if (arch_exception_depth() > 1) {
    4000af40:	f100041f 	cmp	x0, #0x1
    4000af44:	540000a9 	b.ls	4000af58 <z_arm64_fpu_trap+0xcc>  // b.plast
		esf->spsr |= DAIF_IRQ_BIT;
    4000af48:	f9405260 	ldr	x0, [x19, #160]
    4000af4c:	b2790000 	orr	x0, x0, #0x80
    4000af50:	f9005260 	str	x0, [x19, #160]
		return;
    4000af54:	17ffffea 	b	4000aefc <z_arm64_fpu_trap+0x70>
	_current_cpu->arch.fpu_owner = _current;
    4000af58:	f9400a80 	ldr	x0, [x20, #16]
    4000af5c:	f9001680 	str	x0, [x20, #40]
}
    4000af60:	a94153f3 	ldp	x19, x20, [sp, #16]
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
    4000af64:	91054000 	add	x0, x0, #0x150
}
    4000af68:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_arm64_fpu_restore(&_current->arch.saved_fp_context);
    4000af6c:	14000026 	b	4000b004 <z_arm64_fpu_restore>

000000004000af70 <z_arm64_fpu_exit_exc>:
MAKE_REG_HELPER_EL123(cpacr)
    4000af70:	d5381040 	mrs	x0, cpacr_el1
MAKE_REG_HELPER(tpidrro_el0);
    4000af74:	d53bd061 	mrs	x1, tpidrro_el0
    4000af78:	d378fc21 	lsr	x1, x1, #56
{
	__ASSERT(read_daif() & DAIF_IRQ_BIT, "must be called with IRQs disabled");

	uint64_t cpacr = read_cpacr_el1();

	if (arch_exception_depth() == 1) {
    4000af7c:	f100043f 	cmp	x1, #0x1
    4000af80:	54000141 	b.ne	4000afa8 <z_arm64_fpu_exit_exc+0x38>  // b.any
		/* We're about to leave exception mode */
		if (_current_cpu->arch.fpu_owner == _current) {
    4000af84:	f00000a1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000af88:	911c0021 	add	x1, x1, #0x700
    4000af8c:	f9401422 	ldr	x2, [x1, #40]
    4000af90:	f9400821 	ldr	x1, [x1, #16]
    4000af94:	eb01005f 	cmp	x2, x1
    4000af98:	54000081 	b.ne	4000afa8 <z_arm64_fpu_exit_exc+0x38>  // b.any
			/* turn on FPU access */
			write_cpacr_el1(cpacr | CPACR_EL1_FPEN_NOTRAP);
    4000af9c:	b26c0400 	orr	x0, x0, #0x300000
MAKE_REG_HELPER_EL123(cpacr)
    4000afa0:	d5181040 	msr	cpacr_el1, x0
		 * access as we want to make sure IRQs are disabled before
		 * granting them access.
		 */
		write_cpacr_el1(cpacr & ~CPACR_EL1_FPEN_NOTRAP);
	}
}
    4000afa4:	d65f03c0 	ret
		write_cpacr_el1(cpacr & ~CPACR_EL1_FPEN_NOTRAP);
    4000afa8:	926af400 	and	x0, x0, #0xffffffffffcfffff
    4000afac:	17fffffd 	b	4000afa0 <z_arm64_fpu_exit_exc+0x30>

000000004000afb0 <z_arm64_fpu_save>:
_ASM_FILE_PROLOGUE

GTEXT(z_arm64_fpu_save)
SECTION_FUNC(TEXT, z_arm64_fpu_save)

	stp	q0,  q1,  [x0, #(16 *  0)]
    4000afb0:	ad000400 	stp	q0, q1, [x0]
	stp	q2,  q3,  [x0, #(16 *  2)]
    4000afb4:	ad010c02 	stp	q2, q3, [x0, #32]
	stp	q4,  q5,  [x0, #(16 *  4)]
    4000afb8:	ad021404 	stp	q4, q5, [x0, #64]
	stp	q6,  q7,  [x0, #(16 *  6)]
    4000afbc:	ad031c06 	stp	q6, q7, [x0, #96]
	stp	q8,  q9,  [x0, #(16 *  8)]
    4000afc0:	ad042408 	stp	q8, q9, [x0, #128]
	stp	q10, q11, [x0, #(16 * 10)]
    4000afc4:	ad052c0a 	stp	q10, q11, [x0, #160]
	stp	q12, q13, [x0, #(16 * 12)]
    4000afc8:	ad06340c 	stp	q12, q13, [x0, #192]
	stp	q14, q15, [x0, #(16 * 14)]
    4000afcc:	ad073c0e 	stp	q14, q15, [x0, #224]
	stp	q16, q17, [x0, #(16 * 16)]
    4000afd0:	ad084410 	stp	q16, q17, [x0, #256]
	stp	q18, q19, [x0, #(16 * 18)]
    4000afd4:	ad094c12 	stp	q18, q19, [x0, #288]
	stp	q20, q21, [x0, #(16 * 20)]
    4000afd8:	ad0a5414 	stp	q20, q21, [x0, #320]
	stp	q22, q23, [x0, #(16 * 22)]
    4000afdc:	ad0b5c16 	stp	q22, q23, [x0, #352]
	stp	q24, q25, [x0, #(16 * 24)]
    4000afe0:	ad0c6418 	stp	q24, q25, [x0, #384]
	stp	q26, q27, [x0, #(16 * 26)]
    4000afe4:	ad0d6c1a 	stp	q26, q27, [x0, #416]
	stp	q28, q29, [x0, #(16 * 28)]
    4000afe8:	ad0e741c 	stp	q28, q29, [x0, #448]
	stp	q30, q31, [x0, #(16 * 30)]
    4000afec:	ad0f7c1e 	stp	q30, q31, [x0, #480]

	mrs	x1, fpsr
    4000aff0:	d53b4421 	mrs	x1, fpsr
	mrs	x2, fpcr
    4000aff4:	d53b4402 	mrs	x2, fpcr
	str	w1, [x0, #(16 * 32 + 0)]
    4000aff8:	b9020001 	str	w1, [x0, #512]
	str	w2, [x0, #(16 * 32 + 4)]
    4000affc:	b9020402 	str	w2, [x0, #516]

	ret
    4000b000:	d65f03c0 	ret

000000004000b004 <z_arm64_fpu_restore>:

GTEXT(z_arm64_fpu_restore)
SECTION_FUNC(TEXT, z_arm64_fpu_restore)

	ldp	q0,  q1,  [x0, #(16 *  0)]
    4000b004:	ad400400 	ldp	q0, q1, [x0]
	ldp	q2,  q3,  [x0, #(16 *  2)]
    4000b008:	ad410c02 	ldp	q2, q3, [x0, #32]
	ldp	q4,  q5,  [x0, #(16 *  4)]
    4000b00c:	ad421404 	ldp	q4, q5, [x0, #64]
	ldp	q6,  q7,  [x0, #(16 *  6)]
    4000b010:	ad431c06 	ldp	q6, q7, [x0, #96]
	ldp	q8,  q9,  [x0, #(16 *  8)]
    4000b014:	ad442408 	ldp	q8, q9, [x0, #128]
	ldp	q10, q11, [x0, #(16 * 10)]
    4000b018:	ad452c0a 	ldp	q10, q11, [x0, #160]
	ldp	q12, q13, [x0, #(16 * 12)]
    4000b01c:	ad46340c 	ldp	q12, q13, [x0, #192]
	ldp	q14, q15, [x0, #(16 * 14)]
    4000b020:	ad473c0e 	ldp	q14, q15, [x0, #224]
	ldp	q16, q17, [x0, #(16 * 16)]
    4000b024:	ad484410 	ldp	q16, q17, [x0, #256]
	ldp	q18, q19, [x0, #(16 * 18)]
    4000b028:	ad494c12 	ldp	q18, q19, [x0, #288]
	ldp	q20, q21, [x0, #(16 * 20)]
    4000b02c:	ad4a5414 	ldp	q20, q21, [x0, #320]
	ldp	q22, q23, [x0, #(16 * 22)]
    4000b030:	ad4b5c16 	ldp	q22, q23, [x0, #352]
	ldp	q24, q25, [x0, #(16 * 24)]
    4000b034:	ad4c6418 	ldp	q24, q25, [x0, #384]
	ldp	q26, q27, [x0, #(16 * 26)]
    4000b038:	ad4d6c1a 	ldp	q26, q27, [x0, #416]
	ldp	q28, q29, [x0, #(16 * 28)]
    4000b03c:	ad4e741c 	ldp	q28, q29, [x0, #448]
	ldp	q30, q31, [x0, #(16 * 30)]
    4000b040:	ad4f7c1e 	ldp	q30, q31, [x0, #480]

	ldr	w1, [x0, #(16 * 32 + 0)]
    4000b044:	b9420001 	ldr	w1, [x0, #512]
	ldr	w2, [x0, #(16 * 32 + 4)]
    4000b048:	b9420402 	ldr	w2, [x0, #516]
	msr	fpsr, x1
    4000b04c:	d51b4421 	msr	fpsr, x1
	msr	fpcr, x2
    4000b050:	d51b4402 	msr	fpcr, x2

	ret
    4000b054:	d65f03c0 	ret

000000004000b058 <table_usage>:
	return NULL;
}

static inline unsigned int table_index(uint64_t *pte)
{
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    4000b058:	b0000062 	adrp	x2, 40018000 <xlat_tables>
    4000b05c:	91000042 	add	x2, x2, #0x0
    4000b060:	cb020002 	sub	x2, x0, x2
    4000b064:	d2804000 	mov	x0, #0x200                 	// #512
/* Adjusts usage count and returns current count. */
static int table_usage(uint64_t *table, int adjustment)
{
	unsigned int i = table_index(table);

	xlat_use_count[i] += adjustment;
    4000b068:	d00000a3 	adrp	x3, 40021000 <k_sys_work_q+0x240>
    4000b06c:	91229063 	add	x3, x3, #0x8a4
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    4000b070:	9343fc42 	asr	x2, x2, #3
    4000b074:	9ac00c42 	sdiv	x2, x2, x0
	xlat_use_count[i] += adjustment;
    4000b078:	2a0203e2 	mov	w2, w2
    4000b07c:	78627860 	ldrh	w0, [x3, x2, lsl #1]
    4000b080:	0b000020 	add	w0, w1, w0
    4000b084:	12003c00 	and	w0, w0, #0xffff
    4000b088:	78227860 	strh	w0, [x3, x2, lsl #1]
	__ASSERT(xlat_use_count[i] > 0, "usage count underflow");
	return xlat_use_count[i];
}
    4000b08c:	d65f03c0 	ret

000000004000b090 <new_table>:
		if (xlat_use_count[i] == 0U) {
    4000b090:	d00000a2 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    4000b094:	91229042 	add	x2, x2, #0x8a4
{
    4000b098:	d2800001 	mov	x1, #0x0                   	// #0
		if (xlat_use_count[i] == 0U) {
    4000b09c:	78617843 	ldrh	w3, [x2, x1, lsl #1]
    4000b0a0:	2a0103e0 	mov	w0, w1
    4000b0a4:	35000103 	cbnz	w3, 4000b0c4 <new_table+0x34>
			xlat_use_count[i] = 1U;
    4000b0a8:	52800021 	mov	w1, #0x1                   	// #1
    4000b0ac:	78205841 	strh	w1, [x2, w0, uxtw #1]
			return &xlat_tables[i * Ln_XLAT_NUM_ENTRIES];
    4000b0b0:	d3745800 	ubfiz	x0, x0, #12, #23
    4000b0b4:	b0000061 	adrp	x1, 40018000 <xlat_tables>
    4000b0b8:	91000021 	add	x1, x1, #0x0
    4000b0bc:	8b010000 	add	x0, x0, x1
    4000b0c0:	d65f03c0 	ret
	for (i = 0U; i < CONFIG_MAX_XLAT_TABLES; i++) {
    4000b0c4:	91000421 	add	x1, x1, #0x1
    4000b0c8:	f100203f 	cmp	x1, #0x8
    4000b0cc:	54fffe81 	b.ne	4000b09c <new_table+0xc>  // b.any
	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
    4000b0d0:	90000320 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000b0d4:	91293001 	add	x1, x0, #0xa4c
    4000b0d8:	b94a4c00 	ldr	w0, [x0, #2636]
    4000b0dc:	f240081f 	tst	x0, #0x7
    4000b0e0:	540001e0 	b.eq	4000b11c <new_table+0x8c>  // b.none
    4000b0e4:	90000320 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000b0e8:	91290000 	add	x0, x0, #0xa40
    4000b0ec:	cb000021 	sub	x1, x1, x0
{
    4000b0f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
    4000b0f4:	d0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000b0f8:	912a8400 	add	x0, x0, #0xaa1
    4000b0fc:	d342fc21 	lsr	x1, x1, #2
{
    4000b100:	910003fd 	mov	x29, sp
	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
    4000b104:	531a2421 	ubfiz	w1, w1, #6, #10
    4000b108:	32000021 	orr	w1, w1, #0x1
    4000b10c:	97ffe2c5 	bl	40003c20 <log_0>
    4000b110:	d2800000 	mov	x0, #0x0                   	// #0
}
    4000b114:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000b118:	d65f03c0 	ret
	LOG_ERR("CONFIG_MAX_XLAT_TABLES, too small");
    4000b11c:	d2800000 	mov	x0, #0x0                   	// #0
}
    4000b120:	d65f03c0 	ret

000000004000b124 <set_mapping.constprop.0>:
	table_usage(table, 1);

	return table;
}

static int set_mapping(struct arm_mmu_ptables *ptables,
    4000b124:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    4000b128:	910003fd 	mov	x29, sp
    4000b12c:	a90363f7 	stp	x23, x24, [sp, #48]
		       uintptr_t virt, size_t size,
		       uint64_t desc, bool may_overwrite)
{
	uint64_t *pte, *ptes[XLAT_LAST_LEVEL + 1];
	uint64_t level_size;
	uint64_t *table = ptables->base_xlat_table;
    4000b130:	d00000b8 	adrp	x24, 40021000 <k_sys_work_q+0x240>
    4000b134:	f9435b04 	ldr	x4, [x24, #1712]
static int set_mapping(struct arm_mmu_ptables *ptables,
    4000b138:	aa0003f7 	mov	x23, x0
    4000b13c:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000b140:	aa0103f6 	mov	x22, x1
    4000b144:	aa0203f5 	mov	x21, x2
    4000b148:	a9046bf9 	stp	x25, x26, [sp, #64]
	xlat_use_count[i] = 0U;
    4000b14c:	d00000b9 	adrp	x25, 40021000 <k_sys_work_q+0x240>
    4000b150:	91229339 	add	x25, x25, #0x8a4
static int set_mapping(struct arm_mmu_ptables *ptables,
    4000b154:	12001c7a 	and	w26, w3, #0xff
    4000b158:	a90573fb 	stp	x27, x28, [sp, #80]
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    4000b15c:	1281ff9b 	mov	w27, #0xfffff003            	// #-4093
    4000b160:	d281ff9c 	mov	x28, #0xffc                 	// #4092
    4000b164:	f2dffffb 	movk	x27, #0xffff, lsl #32
    4000b168:	f2ffff1c 	movk	x28, #0xfff8, lsl #48
static int set_mapping(struct arm_mmu_ptables *ptables,
    4000b16c:	a90153f3 	stp	x19, x20, [sp, #16]
	unsigned int level = BASE_XLAT_LEVEL;
    4000b170:	52800034 	mov	w20, #0x1                   	// #1
	int ret = 0;

	while (size) {
    4000b174:	b5000136 	cbnz	x22, 4000b198 <set_mapping.constprop.0+0x74>
	int ret = 0;
    4000b178:	52800000 	mov	w0, #0x0                   	// #0
		table = ptables->base_xlat_table;
		level = BASE_XLAT_LEVEL;
	}

	return ret;
}
    4000b17c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b180:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b184:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000b188:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000b18c:	a94573fb 	ldp	x27, x28, [sp, #80]
    4000b190:	a8c97bfd 	ldp	x29, x30, [sp], #144
    4000b194:	d65f03c0 	ret
		pte = &table[XLAT_TABLE_VA_IDX(virt, level)];
    4000b198:	12800102 	mov	w2, #0xfffffff7            	// #-9
		ptes[level] = pte;
    4000b19c:	9101c3e5 	add	x5, sp, #0x70
    4000b1a0:	2a1403e1 	mov	w1, w20
	return level != XLAT_LAST_LEVEL &&
    4000b1a4:	71000e9f 	cmp	w20, #0x3
		pte = &table[XLAT_TABLE_VA_IDX(virt, level)];
    4000b1a8:	1b027e82 	mul	w2, w20, w2
    4000b1ac:	11009c46 	add	w6, w2, #0x27
    4000b1b0:	9ac626e0 	lsr	x0, x23, x6
    4000b1b4:	d37d2000 	ubfiz	x0, x0, #3, #9
    4000b1b8:	8b000093 	add	x19, x4, x0
		ptes[level] = pte;
    4000b1bc:	f82178b3 	str	x19, [x5, x1, lsl #3]
		if (is_table_desc(*pte, level)) {
    4000b1c0:	f8606883 	ldr	x3, [x4, x0]
	return level != XLAT_LAST_LEVEL &&
    4000b1c4:	540000e0 	b.eq	4000b1e0 <set_mapping.constprop.0+0xbc>  // b.none
	       (desc & PTE_DESC_TYPE_MASK) == PTE_TABLE_DESC;
    4000b1c8:	92400460 	and	x0, x3, #0x3
		if (is_table_desc(*pte, level)) {
    4000b1cc:	f1000c1f 	cmp	x0, #0x3
    4000b1d0:	54000081 	b.ne	4000b1e0 <set_mapping.constprop.0+0xbc>  // b.any
			level++;
    4000b1d4:	11000694 	add	w20, w20, #0x1
	uint64_t address = desc & GENMASK(47, PAGE_SIZE_SHIFT);
    4000b1d8:	92748c64 	and	x4, x3, #0xfffffffff000
			continue;
    4000b1dc:	17ffffe6 	b	4000b174 <set_mapping.constprop.0+0x50>
		if (!may_overwrite && !is_free_desc(*pte)) {
    4000b1e0:	3500029a 	cbnz	w26, 4000b230 <set_mapping.constprop.0+0x10c>
    4000b1e4:	f240047f 	tst	x3, #0x3
    4000b1e8:	54000240 	b.eq	4000b230 <set_mapping.constprop.0+0x10c>  // b.none
			LOG_ERR("entry already in use: "
    4000b1ec:	90000320 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000b1f0:	91293004 	add	x4, x0, #0xa4c
    4000b1f4:	b94a4c00 	ldr	w0, [x0, #2636]
    4000b1f8:	f240081f 	tst	x0, #0x7
    4000b1fc:	54000160 	b.eq	4000b228 <set_mapping.constprop.0+0x104>  // b.none
    4000b200:	90000320 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000b204:	91290000 	add	x0, x0, #0xa40
    4000b208:	cb000084 	sub	x4, x4, x0
    4000b20c:	aa1303e2 	mov	x2, x19
    4000b210:	d0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000b214:	912b0c00 	add	x0, x0, #0xac3
    4000b218:	d342fc84 	lsr	x4, x4, #2
    4000b21c:	531a2484 	ubfiz	w4, w4, #6, #10
    4000b220:	32000084 	orr	w4, w4, #0x1
    4000b224:	97ffe2be 	bl	40003d1c <log_3>
			ret = -EBUSY;
    4000b228:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    4000b22c:	17ffffd4 	b	4000b17c <set_mapping.constprop.0+0x58>
		level_size = 1ULL << LEVEL_TO_VA_SIZE_SHIFT(level);
    4000b230:	d2800021 	mov	x1, #0x1                   	// #1
    4000b234:	9ac62024 	lsl	x4, x1, x6
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    4000b238:	cb0403e0 	neg	x0, x4
    4000b23c:	8a1b0000 	and	x0, x0, x27
	return (desc1 & mask) == (desc2 & mask);
    4000b240:	ca150066 	eor	x6, x3, x21
	uint64_t mask = DESC_ATTRS_MASK | GENMASK(47, LEVEL_TO_VA_SIZE_SHIFT(level));
    4000b244:	aa1c0000 	orr	x0, x0, x28
		if (is_desc_superset(*pte, desc, level)) {
    4000b248:	ea06001f 	tst	x0, x6
    4000b24c:	540001c1 	b.ne	4000b284 <set_mapping.constprop.0+0x160>  // b.any
			level_size -= (virt & (level_size - 1));
    4000b250:	d1000480 	sub	x0, x4, #0x1
    4000b254:	8a170000 	and	x0, x0, x23
    4000b258:	cb000084 	sub	x4, x4, x0
			if (level_size > size) {
    4000b25c:	eb16009f 	cmp	x4, x22
    4000b260:	9a969084 	csel	x4, x4, x22, ls  // ls = plast
		desc += desc ? level_size : 0;
    4000b264:	f10002bf 	cmp	x21, #0x0
		virt += level_size;
    4000b268:	8b0402f7 	add	x23, x23, x4
		desc += desc ? level_size : 0;
    4000b26c:	9a9f1080 	csel	x0, x4, xzr, ne  // ne = any
		size -= level_size;
    4000b270:	cb0402d6 	sub	x22, x22, x4
		desc += desc ? level_size : 0;
    4000b274:	8b0002b5 	add	x21, x21, x0
		level = BASE_XLAT_LEVEL;
    4000b278:	52800034 	mov	w20, #0x1                   	// #1
		table = ptables->base_xlat_table;
    4000b27c:	f9435b04 	ldr	x4, [x24, #1712]
		level = BASE_XLAT_LEVEL;
    4000b280:	17ffffbd 	b	4000b174 <set_mapping.constprop.0+0x50>
		if ((size < level_size) || (virt & (level_size - 1)) ||
    4000b284:	eb16009f 	cmp	x4, x22
    4000b288:	54000108 	b.hi	4000b2a8 <set_mapping.constprop.0+0x184>  // b.pmore
	bool aligned = !((desc & mask) & (level_size - 1));
    4000b28c:	51000480 	sub	w0, w4, #0x1
		if ((size < level_size) || (virt & (level_size - 1)) ||
    4000b290:	d1000486 	sub	x6, x4, #0x1
	bool aligned = !((desc & mask) & (level_size - 1));
    4000b294:	8a150000 	and	x0, x0, x21
		if ((size < level_size) || (virt & (level_size - 1)) ||
    4000b298:	8a1700c6 	and	x6, x6, x23
	bool aligned = !((desc & mask) & (level_size - 1));
    4000b29c:	92748c00 	and	x0, x0, #0xfffffffff000
		if ((size < level_size) || (virt & (level_size - 1)) ||
    4000b2a0:	aa060000 	orr	x0, x0, x6
    4000b2a4:	b4000400 	cbz	x0, 4000b324 <set_mapping.constprop.0+0x200>
    4000b2a8:	b9006fe2 	str	w2, [sp, #108]
	table = new_table();
    4000b2ac:	97ffff79 	bl	4000b090 <new_table>
    4000b2b0:	aa0003e4 	mov	x4, x0
	if (!table) {
    4000b2b4:	b4000760 	cbz	x0, 4000b3a0 <set_mapping.constprop.0+0x27c>
	if (!is_free_desc(*pte)) {
    4000b2b8:	f9400260 	ldr	x0, [x19]
    4000b2bc:	f240041f 	tst	x0, #0x3
    4000b2c0:	540002c0 	b.eq	4000b318 <set_mapping.constprop.0+0x1f4>  // b.none
		if (level + 1 == XLAT_LAST_LEVEL) {
    4000b2c4:	b9406fe2 	ldr	w2, [sp, #108]
    4000b2c8:	71000a9f 	cmp	w20, #0x2
    4000b2cc:	54000041 	b.ne	4000b2d4 <set_mapping.constprop.0+0x1b0>  // b.any
			desc |= PTE_PAGE_DESC;
    4000b2d0:	b2400400 	orr	x0, x0, #0x3
		stride_shift = LEVEL_TO_VA_SIZE_SHIFT(level + 1);
    4000b2d4:	11007842 	add	w2, w2, #0x1e
    4000b2d8:	d2800001 	mov	x1, #0x0                   	// #0
			table[i] = desc | (i << stride_shift);
    4000b2dc:	1ac22023 	lsl	w3, w1, w2
    4000b2e0:	aa000063 	orr	x3, x3, x0
    4000b2e4:	f8217883 	str	x3, [x4, x1, lsl #3]
		for (i = 0U; i < Ln_XLAT_NUM_ENTRIES; i++) {
    4000b2e8:	91000421 	add	x1, x1, #0x1
    4000b2ec:	f108003f 	cmp	x1, #0x200
    4000b2f0:	54ffff61 	b.ne	4000b2dc <set_mapping.constprop.0+0x1b8>  // b.any
		table_usage(table, Ln_XLAT_NUM_ENTRIES);
    4000b2f4:	aa0403e0 	mov	x0, x4
		table_usage(pte, 1);
    4000b2f8:	97ffff58 	bl	4000b058 <table_usage>
	table_usage(table, 1);
    4000b2fc:	52800021 	mov	w1, #0x1                   	// #1
	*pte = PTE_TABLE_DESC | (uint64_t)table;
    4000b300:	b2400480 	orr	x0, x4, #0x3
    4000b304:	f9000260 	str	x0, [x19]
			level++;
    4000b308:	0b010294 	add	w20, w20, w1
	table_usage(table, 1);
    4000b30c:	aa0403e0 	mov	x0, x4
    4000b310:	97ffff52 	bl	4000b058 <table_usage>
			continue;
    4000b314:	17ffff98 	b	4000b174 <set_mapping.constprop.0+0x50>
		table_usage(pte, 1);
    4000b318:	aa1303e0 	mov	x0, x19
    4000b31c:	52800021 	mov	w1, #0x1                   	// #1
    4000b320:	17fffff6 	b	4000b2f8 <set_mapping.constprop.0+0x1d4>
		if (is_free_desc(*pte)) {
    4000b324:	f240047f 	tst	x3, #0x3
    4000b328:	54000061 	b.ne	4000b334 <set_mapping.constprop.0+0x210>  // b.any
			table_usage(pte, 1);
    4000b32c:	aa1303e0 	mov	x0, x19
    4000b330:	97ffff4a 	bl	4000b058 <table_usage>
		if (!desc) {
    4000b334:	b50003b5 	cbnz	x21, 4000b3a8 <set_mapping.constprop.0+0x284>
			table_usage(pte, -1);
    4000b338:	aa1303e0 	mov	x0, x19
    4000b33c:	12800001 	mov	w1, #0xffffffff            	// #-1
    4000b340:	97ffff46 	bl	4000b058 <table_usage>
    4000b344:	d2800000 	mov	x0, #0x0                   	// #0
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    4000b348:	b0000066 	adrp	x6, 40018000 <xlat_tables>
    4000b34c:	910000c6 	add	x6, x6, #0x0
    4000b350:	d2804007 	mov	x7, #0x200                 	// #512
	*pte = desc;
    4000b354:	f9000260 	str	x0, [x19]
		while (level != BASE_XLAT_LEVEL &&
    4000b358:	7100069f 	cmp	w20, #0x1
    4000b35c:	54fff840 	b.eq	4000b264 <set_mapping.constprop.0+0x140>  // b.none
	return table_usage(table, 0) == 1;
    4000b360:	aa1303e0 	mov	x0, x19
    4000b364:	52800001 	mov	w1, #0x0                   	// #0
    4000b368:	97ffff3c 	bl	4000b058 <table_usage>
		while (level != BASE_XLAT_LEVEL &&
    4000b36c:	7100041f 	cmp	w0, #0x1
    4000b370:	54fff7a1 	b.ne	4000b264 <set_mapping.constprop.0+0x140>  // b.any
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    4000b374:	cb060273 	sub	x19, x19, x6
			pte = ptes[--level];
    4000b378:	51000694 	sub	w20, w20, #0x1
			table_usage(pte, -1);
    4000b37c:	12800001 	mov	w1, #0xffffffff            	// #-1
	unsigned int i = (pte - xlat_tables) / Ln_XLAT_NUM_ENTRIES;
    4000b380:	9343fe73 	asr	x19, x19, #3
    4000b384:	9ac70e73 	sdiv	x19, x19, x7
	xlat_use_count[i] = 0U;
    4000b388:	78335b3f 	strh	wzr, [x25, w19, uxtw #1]
			pte = ptes[--level];
    4000b38c:	f87458b3 	ldr	x19, [x5, w20, uxtw #3]
			table_usage(pte, -1);
    4000b390:	aa1303e0 	mov	x0, x19
	*pte = desc;
    4000b394:	f900027f 	str	xzr, [x19]
			table_usage(pte, -1);
    4000b398:	97ffff30 	bl	4000b058 <table_usage>
    4000b39c:	17ffffef 	b	4000b358 <set_mapping.constprop.0+0x234>
				ret = -ENOMEM;
    4000b3a0:	12800160 	mov	w0, #0xfffffff4            	// #-12
	return ret;
    4000b3a4:	17ffff76 	b	4000b17c <set_mapping.constprop.0+0x58>
		desc |= (level == XLAT_LAST_LEVEL) ? PTE_PAGE_DESC : PTE_BLOCK_DESC;
    4000b3a8:	71000e9f 	cmp	w20, #0x3
    4000b3ac:	d2800060 	mov	x0, #0x3                   	// #3
    4000b3b0:	9a9f0400 	csinc	x0, x0, xzr, eq  // eq = none
    4000b3b4:	aa0002a0 	orr	x0, x21, x0
    4000b3b8:	17ffffe4 	b	4000b348 <set_mapping.constprop.0+0x224>

000000004000b3bc <__add_map.constprop.0>:
{
	unsigned int mem_type;
	uint64_t desc = 0U;

	/* NS bit for security memory access from secure state */
	desc |= (attrs & MT_NS) ? PTE_BLOCK_DESC_NS : 0;
    4000b3bc:	d37f7c65 	ubfiz	x5, x3, #1, #32
	 *     10      RO   NA
	 *     11      RO   RO
	 */

	/* AP bits for Data access permission */
	desc |= (attrs & MT_RW) ? PTE_BLOCK_DESC_AP_RW : PTE_BLOCK_DESC_AP_RO;
    4000b3c0:	f27d007f 	tst	x3, #0x8
	desc |= (attrs & MT_NS) ? PTE_BLOCK_DESC_NS : 0;
    4000b3c4:	927b00a7 	and	x7, x5, #0x20

	/* Mirror permissions to EL0 */
	desc |= (attrs & MT_RW_AP_ELx) ?
		 PTE_BLOCK_DESC_AP_ELx : PTE_BLOCK_DESC_AP_EL_HIGHER;
    4000b3c8:	53017c65 	lsr	w5, w3, #1
	desc |= (attrs & MT_RW) ? PTE_BLOCK_DESC_AP_RW : PTE_BLOCK_DESC_AP_RO;
    4000b3cc:	9a9f17e4 	cset	x4, eq  // eq = none
		 PTE_BLOCK_DESC_AP_ELx : PTE_BLOCK_DESC_AP_EL_HIGHER;
    4000b3d0:	927a00a5 	and	x5, x5, #0x40
    4000b3d4:	aa0700a5 	orr	x5, x5, x7
	/* the access flag */
	desc |= PTE_BLOCK_DESC_AF;

	/* memory attribute index field */
	mem_type = MT_TYPE(attrs);
	desc |= PTE_BLOCK_DESC_MEMTYPE(mem_type);
    4000b3d8:	d37e0867 	ubfiz	x7, x3, #2, #3
    4000b3dc:	aa041ce4 	orr	x4, x7, x4, lsl #7
	}

	return desc;
}

static int __add_map(struct arm_mmu_ptables *ptables, const char *name,
    4000b3e0:	aa0003e6 	mov	x6, x0
    4000b3e4:	aa0400a5 	orr	x5, x5, x4
    4000b3e8:	aa0103e0 	mov	x0, x1
    4000b3ec:	aa0203e1 	mov	x1, x2
	mem_type = MT_TYPE(attrs);
    4000b3f0:	12000862 	and	w2, w3, #0x7
	desc |= PTE_BLOCK_DESC_MEMTYPE(mem_type);
    4000b3f4:	b27600a4 	orr	x4, x5, #0x400
	switch (mem_type) {
    4000b3f8:	7100085f 	cmp	w2, #0x2
    4000b3fc:	54000109 	b.ls	4000b41c <__add_map.constprop.0+0x60>  // b.plast
    4000b400:	51000c47 	sub	w7, w2, #0x3
    4000b404:	710004ff 	cmp	w7, #0x1
    4000b408:	54000129 	b.ls	4000b42c <__add_map.constprop.0+0x70>  // b.plast
		     uintptr_t phys, uintptr_t virt, size_t size, uint32_t attrs)
{
	uint64_t desc = get_region_desc(attrs);
	bool may_overwrite = !(attrs & MT_NO_OVERWRITE);
    4000b40c:	d2780063 	eor	x3, x3, #0x100
	MMU_DEBUG("mmap [%s]: virt %lx phys %lx size %lx attr %llx\n",
		  name, virt, phys, size, desc);
	__ASSERT(((virt | phys | size) & (CONFIG_MMU_PAGE_SIZE - 1)) == 0,
		 "address/size are not page aligned\n");
	desc |= phys;
	return set_mapping(ptables, virt, size, desc, may_overwrite);
    4000b410:	aa0400c2 	orr	x2, x6, x4
    4000b414:	53082063 	ubfx	w3, w3, #8, #1
    4000b418:	17ffff43 	b	4000b124 <set_mapping.constprop.0>
		desc |= PTE_BLOCK_DESC_UXN;
    4000b41c:	d280c004 	mov	x4, #0x600                 	// #1536
    4000b420:	f2e00c04 	movk	x4, #0x60, lsl #48
    4000b424:	aa0400a4 	orr	x4, x5, x4
		break;
    4000b428:	17fffff9 	b	4000b40c <__add_map.constprop.0+0x50>
		if ((attrs & MT_RW) || (attrs & MT_P_EXECUTE_NEVER))
    4000b42c:	52800507 	mov	w7, #0x28                  	// #40
    4000b430:	6a07007f 	tst	w3, w7
    4000b434:	54000080 	b.eq	4000b444 <__add_map.constprop.0+0x88>  // b.none
			desc |= PTE_BLOCK_DESC_PXN;
    4000b438:	d2808004 	mov	x4, #0x400                 	// #1024
    4000b43c:	f2e00404 	movk	x4, #0x20, lsl #48
    4000b440:	aa0400a4 	orr	x4, x5, x4
		if (((attrs & MT_RW) && (attrs & MT_RW_AP_ELx)) ||
    4000b444:	52801105 	mov	w5, #0x88                  	// #136
    4000b448:	0a050065 	and	w5, w3, w5
    4000b44c:	710220bf 	cmp	w5, #0x88
    4000b450:	54000040 	b.eq	4000b458 <__add_map.constprop.0+0x9c>  // b.none
    4000b454:	36300043 	tbz	w3, #6, 4000b45c <__add_map.constprop.0+0xa0>
			desc |= PTE_BLOCK_DESC_UXN;
    4000b458:	b24a0084 	orr	x4, x4, #0x40000000000000
			desc |= PTE_BLOCK_DESC_INNER_SHARE;
    4000b45c:	b2780485 	orr	x5, x4, #0x300
    4000b460:	7100105f 	cmp	w2, #0x4
    4000b464:	b2770084 	orr	x4, x4, #0x200
    4000b468:	9a851084 	csel	x4, x4, x5, ne  // ne = any
    4000b46c:	17ffffe8 	b	4000b40c <__add_map.constprop.0+0x50>

000000004000b470 <z_arm64_mm_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Management Unit (MMU).
 */
void z_arm64_mm_init(bool is_primary_core)
{
    4000b470:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	__ASSERT((read_sctlr_el1() & SCTLR_M_BIT) == 0, "MMU is already enabled\n");

	/*
	 * Only booting core setup up the page tables.
	 */
	if (is_primary_core) {
    4000b474:	72001c1f 	tst	w0, #0xff
{
    4000b478:	910003fd 	mov	x29, sp
    4000b47c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b480:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000b484:	d00000b5 	adrp	x21, 40021000 <k_sys_work_q+0x240>
    4000b488:	f9001bf7 	str	x23, [sp, #48]
	if (is_primary_core) {
    4000b48c:	54000360 	b.eq	4000b4f8 <z_arm64_mm_init+0x88>  // b.none
		kernel_ptables.base_xlat_table = new_table();
    4000b490:	97ffff00 	bl	4000b090 <new_table>
    4000b494:	f9035aa0 	str	x0, [x21, #1712]
	for (index = 0U; index < mmu_config.num_regions; index++) {
    4000b498:	90000040 	adrp	x0, 40013000 <shell_cmd_kernel>
    4000b49c:	b9409001 	ldr	w1, [x0, #144]
    4000b4a0:	90000053 	adrp	x19, 40013000 <shell_cmd_kernel>
    4000b4a4:	91318273 	add	x19, x19, #0xc60
    4000b4a8:	2a0103f7 	mov	w23, w1
    4000b4ac:	aa0003f4 	mov	x20, x0
    4000b4b0:	52800076 	mov	w22, #0x3                   	// #3
	size_t size = (uintptr_t)range->end - address;
    4000b4b4:	a9408a61 	ldp	x1, x2, [x19, #8]
	if (size) {
    4000b4b8:	eb010042 	subs	x2, x2, x1
    4000b4bc:	54000080 	b.eq	4000b4cc <z_arm64_mm_init+0x5c>  // b.none
		__add_map(ptables, range->name, address, address,
    4000b4c0:	b9401a63 	ldr	w3, [x19, #24]
    4000b4c4:	aa0103e0 	mov	x0, x1
    4000b4c8:	97ffffbd 	bl	4000b3bc <__add_map.constprop.0>
	for (index = 0U; index < ARRAY_SIZE(mmu_zephyr_ranges); index++) {
    4000b4cc:	91008273 	add	x19, x19, #0x20
    4000b4d0:	710006d6 	subs	w22, w22, #0x1
    4000b4d4:	54ffff01 	b.ne	4000b4b4 <z_arm64_mm_init+0x44>  // b.any
		region = &mmu_config.mmu_regions[index];
    4000b4d8:	91024294 	add	x20, x20, #0x90
    4000b4dc:	d2800013 	mov	x19, #0x0                   	// #0
    4000b4e0:	d2800516 	mov	x22, #0x28                  	// #40
	for (index = 0U; index < mmu_config.num_regions; index++) {
    4000b4e4:	6b1302ff 	cmp	w23, w19
    4000b4e8:	54000348 	b.hi	4000b550 <z_arm64_mm_init+0xe0>  // b.pmore
	__asm__ volatile (
    4000b4ec:	d508871f 	tlbi	vmalle1
    4000b4f0:	d5033f9f 	dsb	sy
    4000b4f4:	d5033fdf 	isb
MAKE_REG_HELPER_EL123(mair)
    4000b4f8:	d2808000 	mov	x0, #0x400                 	// #1024
    4000b4fc:	f2a88180 	movk	x0, #0x440c, lsl #16
    4000b500:	f2d77fe0 	movk	x0, #0xbbff, lsl #32
    4000b504:	d518a200 	msr	mair_el1, x0
MAKE_REG_HELPER_EL123(tcr)
    4000b508:	d286a400 	mov	x0, #0x3520                	// #13600
    4000b50c:	f2a01000 	movk	x0, #0x80, lsl #16
    4000b510:	d5182040 	msr	tcr_el1, x0
MAKE_REG_HELPER_EL123(ttbr0)
    4000b514:	f9435aa0 	ldr	x0, [x21, #1712]
    4000b518:	d5182000 	msr	ttbr0_el1, x0
	isb();
    4000b51c:	d5033fdf 	isb

__syscall int sys_cache_data_all(int op);
static inline int z_impl_sys_cache_data_all(int op)
{
#if defined(CONFIG_CACHE_MANAGEMENT)
	return cache_data_all(op);
    4000b520:	52800040 	mov	w0, #0x2                   	// #2
    4000b524:	9400005a 	bl	4000b68c <arch_dcache_all>
MAKE_REG_HELPER_EL123(sctlr)
    4000b528:	d5381000 	mrs	x0, sctlr_el1
	write_sctlr_el1(val | SCTLR_M_BIT | SCTLR_C_BIT);
    4000b52c:	d28000a1 	mov	x1, #0x5                   	// #5
    4000b530:	aa010000 	orr	x0, x0, x1
    4000b534:	d5181000 	msr	sctlr_el1, x0
	isb();
    4000b538:	d5033fdf 	isb
		setup_page_tables(&kernel_ptables);
	}

	/* currently only EL1 is supported */
	enable_mmu_el1(&kernel_ptables, flags);
}
    4000b53c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b540:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000b544:	f9401bf7 	ldr	x23, [sp, #48]
    4000b548:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000b54c:	d65f03c0 	ret
		region = &mmu_config.mmu_regions[index];
    4000b550:	f9400685 	ldr	x5, [x20, #8]
    4000b554:	9b167e64 	mul	x4, x19, x22
    4000b558:	8b0400a0 	add	x0, x5, x4
	if (region->size || region->attrs) {
    4000b55c:	f9400802 	ldr	x2, [x0, #16]
    4000b560:	b9402003 	ldr	w3, [x0, #32]
    4000b564:	b5000042 	cbnz	x2, 4000b56c <z_arm64_mm_init+0xfc>
    4000b568:	340000a3 	cbz	w3, 4000b57c <z_arm64_mm_init+0x10c>
		__add_map(ptables, region->name, region->base_pa, region->base_va,
    4000b56c:	f9400401 	ldr	x1, [x0, #8]
    4000b570:	32180063 	orr	w3, w3, #0x100
    4000b574:	f86468a0 	ldr	x0, [x5, x4]
    4000b578:	97ffff91 	bl	4000b3bc <__add_map.constprop.0>
	for (index = 0U; index < mmu_config.num_regions; index++) {
    4000b57c:	91000673 	add	x19, x19, #0x1
    4000b580:	17ffffd9 	b	4000b4e4 <z_arm64_mm_init+0x74>

000000004000b584 <arch_mem_map>:

	return add_map(ptables, "generic", phys, (uintptr_t)virt, size, entry_flags);
}

void arch_mem_map(void *virt, uintptr_t phys, size_t size, uint32_t flags)
{
    4000b584:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000b588:	2a0303e4 	mov	w4, w3
	switch (flags & K_MEM_CACHE_MASK) {
    4000b58c:	12000863 	and	w3, w3, #0x7
{
    4000b590:	910003fd 	mov	x29, sp
    4000b594:	f9000bf3 	str	x19, [sp, #16]
    4000b598:	7100087f 	cmp	w3, #0x2
    4000b59c:	540002c8 	b.hi	4000b5f4 <arch_mem_map+0x70>  // b.pmore
    4000b5a0:	aa0003e5 	mov	x5, x0
    4000b5a4:	aa0103e0 	mov	x0, x1
    4000b5a8:	d0000041 	adrp	x1, 40015000 <tabulator.1+0x262>
    4000b5ac:	912cec21 	add	x1, x1, #0xb3b
    4000b5b0:	38636823 	ldrb	w3, [x1, x3]
	if ((flags & K_MEM_PERM_RW) != 0U) {
    4000b5b4:	36180044 	tbz	w4, #3, 4000b5bc <arch_mem_map+0x38>
		entry_flags |= MT_RW;
    4000b5b8:	321d0063 	orr	w3, w3, #0x8
	if ((flags & K_MEM_PERM_EXEC) == 0U) {
    4000b5bc:	37200044 	tbnz	w4, #4, 4000b5c4 <arch_mem_map+0x40>
		entry_flags |= MT_P_EXECUTE_NEVER;
    4000b5c0:	321b0063 	orr	w3, w3, #0x20
	if ((flags & K_MEM_PERM_USER) != 0U) {
    4000b5c4:	37280184 	tbnz	w4, #5, 4000b5f4 <arch_mem_map+0x70>
MAKE_REG_HELPER(daif)
    4000b5c8:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000b5cc:	d50342df 	msr	daifset, #0x2
	ret = __add_map(ptables, name, phys, virt, size, attrs);
    4000b5d0:	aa0503e1 	mov	x1, x5
MAKE_REG_HELPER(daif)
    4000b5d4:	92407e73 	and	x19, x19, #0xffffffff
    4000b5d8:	97ffff79 	bl	4000b3bc <__add_map.constprop.0>
    4000b5dc:	d51b4233 	msr	daif, x19
	int ret = __arch_mem_map(virt, phys, size, flags);

	if (ret) {
    4000b5e0:	350000c0 	cbnz	w0, 4000b5f8 <arch_mem_map+0x74>
	__asm__ volatile (
    4000b5e4:	d508871f 	tlbi	vmalle1
    4000b5e8:	d5033f9f 	dsb	sy
    4000b5ec:	d5033fdf 	isb
		k_panic();
	} else {
		sync_domains((uintptr_t)virt, size);
		invalidate_tlb_all();
	}
}
    4000b5f0:	14000013 	b	4000b63c <arch_mem_map+0xb8>
		return -ENOTSUP;
    4000b5f4:	128010a0 	mov	w0, #0xffffff7a            	// #-134
		LOG_ERR("__arch_mem_map() returned %d", ret);
    4000b5f8:	90000321 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
    4000b5fc:	91293022 	add	x2, x1, #0xa4c
    4000b600:	b94a4c21 	ldr	w1, [x1, #2636]
    4000b604:	f240083f 	tst	x1, #0x7
    4000b608:	54000160 	b.eq	4000b634 <arch_mem_map+0xb0>  // b.none
    4000b60c:	90000321 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
    4000b610:	91290021 	add	x1, x1, #0xa40
    4000b614:	cb010042 	sub	x2, x2, x1
    4000b618:	93407c01 	sxtw	x1, w0
    4000b61c:	d0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000b620:	912be000 	add	x0, x0, #0xaf8
    4000b624:	d342fc42 	lsr	x2, x2, #2
    4000b628:	531a2442 	ubfiz	w2, w2, #6, #10
    4000b62c:	32000042 	orr	w2, w2, #0x1
    4000b630:	97ffe18b 	bl	40003c5c <log_1>
		k_panic();
    4000b634:	d2800088 	mov	x8, #0x4                   	// #4
    4000b638:	d4000041 	svc	#0x2
}
    4000b63c:	f9400bf3 	ldr	x19, [sp, #16]
    4000b640:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000b644:	d65f03c0 	ret

000000004000b648 <arch_virt_region_align>:
	int level;

	for (level = XLAT_LAST_LEVEL; level >= BASE_XLAT_LEVEL; level--) {
		level_size = 1 << LEVEL_TO_VA_SIZE_SHIFT(level);

		if (size < level_size) {
    4000b648:	b24053e2 	mov	x2, #0x1fffff              	// #2097151
    4000b64c:	eb02003f 	cmp	x1, x2
    4000b650:	54000169 	b.ls	4000b67c <arch_virt_region_align+0x34>  // b.plast
			break;
		}

		if ((phys & (level_size - 1))) {
    4000b654:	f240501f 	tst	x0, #0x1fffff
    4000b658:	54000121 	b.ne	4000b67c <arch_virt_region_align+0x34>  // b.any
		if (size < level_size) {
    4000b65c:	b24077e2 	mov	x2, #0x3fffffff            	// #1073741823
    4000b660:	eb02003f 	cmp	x1, x2
    4000b664:	54000109 	b.ls	4000b684 <arch_virt_region_align+0x3c>  // b.plast
		level_size = 1 << LEVEL_TO_VA_SIZE_SHIFT(level);
    4000b668:	f240741f 	tst	x0, #0x3fffffff
    4000b66c:	d2a80001 	mov	x1, #0x40000000            	// #1073741824
    4000b670:	d2a00400 	mov	x0, #0x200000              	// #2097152
    4000b674:	9a811000 	csel	x0, x0, x1, ne  // ne = any

		alignment = level_size;
	}

	return alignment;
}
    4000b678:	d65f03c0 	ret
	size_t alignment = CONFIG_MMU_PAGE_SIZE;
    4000b67c:	d2820000 	mov	x0, #0x1000                	// #4096
    4000b680:	17fffffe 	b	4000b678 <arch_virt_region_align+0x30>
		level_size = 1 << LEVEL_TO_VA_SIZE_SHIFT(level);
    4000b684:	d2a00400 	mov	x0, #0x200000              	// #2097152
    4000b688:	17fffffc 	b	4000b678 <arch_virt_region_align+0x30>

000000004000b68c <arch_dcache_all>:
{
	uint32_t clidr_el1, csselr_el1, ccsidr_el1;
	uint8_t loc, ctype, cache_level, line_size, way_pos;
	uint32_t max_ways, max_sets, dc_val, set, way;

	if (op != K_CACHE_INVD && op != K_CACHE_WB && op != K_CACHE_WB_INVD)
    4000b68c:	51000401 	sub	w1, w0, #0x1
    4000b690:	7100083f 	cmp	w1, #0x2
    4000b694:	540006a8 	b.hi	4000b768 <arch_dcache_all+0xdc>  // b.pmore
		return -ENOTSUP;

	/* Data barrier before start */
	dsb();
    4000b698:	d5033f9f 	dsb	sy
MAKE_REG_HELPER(clidr_el1);
    4000b69c:	d5390021 	mrs	x1, clidr_el1

	clidr_el1 = read_clidr_el1();
    4000b6a0:	2a0103ea 	mov	w10, w1

	loc = (clidr_el1 >> CLIDR_EL1_LOC_SHIFT) & CLIDR_EL1_LOC_MASK;
    4000b6a4:	53186829 	ubfx	w9, w1, #24, #3
	if (!loc)
    4000b6a8:	7208083f 	tst	w1, #0x7000000
    4000b6ac:	54000620 	b.eq	4000b770 <arch_dcache_all+0xe4>  // b.none
    4000b6b0:	d2800001 	mov	x1, #0x0                   	// #0
		return 0;

	for (cache_level = 0; cache_level < loc; cache_level++) {
		ctype = (clidr_el1 >> CLIDR_EL1_CTYPE_SHIFT(cache_level))
    4000b6b4:	0b010422 	add	w2, w1, w1, lsl #1
    4000b6b8:	531f782b 	lsl	w11, w1, #1
    4000b6bc:	1ac22542 	lsr	w2, w10, w2
				& CLIDR_EL1_CTYPE_MASK;
		/* No data cache, continue */
		if (ctype < 2)
    4000b6c0:	721f045f 	tst	w2, #0x6
    4000b6c4:	54000320 	b.eq	4000b728 <arch_dcache_all+0x9c>  // b.none
MAKE_REG_HELPER(csselr_el1);
    4000b6c8:	d37ff822 	lsl	x2, x1, #1
    4000b6cc:	d51a0002 	msr	csselr_el1, x2
			continue;

		/* select cache level */
		csselr_el1 = cache_level << 1;
		write_csselr_el1(csselr_el1);
		isb();
    4000b6d0:	d5033fdf 	isb
MAKE_REG_HELPER(ccsidr_el1);
    4000b6d4:	d5390002 	mrs	x2, ccsidr_el1

		ccsidr_el1 = read_ccsidr_el1();
		line_size = (ccsidr_el1 >> CCSIDR_EL1_LN_SZ_SHIFT
				& CCSIDR_EL1_LN_SZ_MASK) + 4;
    4000b6d8:	12000847 	and	w7, w2, #0x7
		max_ways = (ccsidr_el1 >> CCSIDR_EL1_WAYS_SHIFT)
    4000b6dc:	53033048 	ubfx	w8, w2, #3, #10
		line_size = (ccsidr_el1 >> CCSIDR_EL1_LN_SZ_SHIFT
    4000b6e0:	110010e7 	add	w7, w7, #0x4
				& CCSIDR_EL1_WAYS_MASK;
		max_sets = (ccsidr_el1 >> CCSIDR_EL1_SETS_SHIFT)
    4000b6e4:	530d6c42 	ubfx	w2, w2, #13, #15
				& CCSIDR_EL1_SETS_MASK;
		/* 32-log2(ways), bit position of way in DC operand */
		way_pos = __builtin_clz(max_ways);
    4000b6e8:	5ac0110c 	clz	w12, w8

		for (set = 0; set <= max_sets; set++) {
    4000b6ec:	52800005 	mov	w5, #0x0                   	// #0
				/* way number, aligned to pos in DC operand */
				dc_val = way << way_pos;
				/* cache level, aligned to pos in DC operand */
				dc_val |= csselr_el1;
				/* set number, aligned to pos in DC operand */
				dc_val |= set << line_size;
    4000b6f0:	1ac720a6 	lsl	w6, w5, w7
    4000b6f4:	2a0b00c6 	orr	w6, w6, w11
			for (way = 0; way <= max_ways; way++) {
    4000b6f8:	52800004 	mov	w4, #0x0                   	// #0
				dc_val = way << way_pos;
    4000b6fc:	1acc2083 	lsl	w3, w4, w12

				if (op == K_CACHE_INVD) {
    4000b700:	7100081f 	cmp	w0, #0x2
				dc_val |= set << line_size;
    4000b704:	2a060063 	orr	w3, w3, w6
				if (op == K_CACHE_INVD) {
    4000b708:	54000201 	b.ne	4000b748 <arch_dcache_all+0xbc>  // b.any
					dc_ops("isw", dc_val);
    4000b70c:	d5087643 	dc	isw, x3
			for (way = 0; way <= max_ways; way++) {
    4000b710:	11000484 	add	w4, w4, #0x1
    4000b714:	6b04011f 	cmp	w8, w4
    4000b718:	54ffff22 	b.cs	4000b6fc <arch_dcache_all+0x70>  // b.hs, b.nlast
		for (set = 0; set <= max_sets; set++) {
    4000b71c:	110004a5 	add	w5, w5, #0x1
    4000b720:	6b05005f 	cmp	w2, w5
    4000b724:	54fffe62 	b.cs	4000b6f0 <arch_dcache_all+0x64>  // b.hs, b.nlast
	for (cache_level = 0; cache_level < loc; cache_level++) {
    4000b728:	91000421 	add	x1, x1, #0x1
    4000b72c:	6b21013f 	cmp	w9, w1, uxtb
    4000b730:	54fffc28 	b.hi	4000b6b4 <arch_dcache_all+0x28>  // b.pmore
MAKE_REG_HELPER(csselr_el1);
    4000b734:	d2800000 	mov	x0, #0x0                   	// #0
    4000b738:	d51a0000 	msr	csselr_el1, x0
		}
	}

	/* Restore csselr_el1 to level 0 */
	write_csselr_el1(0);
	dsb();
    4000b73c:	d5033f9f 	dsb	sy
	isb();
    4000b740:	d5033fdf 	isb

	return 0;
}
    4000b744:	d65f03c0 	ret
				} else if (op == K_CACHE_WB_INVD) {
    4000b748:	71000c1f 	cmp	w0, #0x3
    4000b74c:	54000061 	b.ne	4000b758 <arch_dcache_all+0xcc>  // b.any
					dc_ops("cisw", dc_val);
    4000b750:	d5087e43 	dc	cisw, x3
    4000b754:	17ffffef 	b	4000b710 <arch_dcache_all+0x84>
				} else if (op == K_CACHE_WB) {
    4000b758:	7100041f 	cmp	w0, #0x1
    4000b75c:	54fffda1 	b.ne	4000b710 <arch_dcache_all+0x84>  // b.any
					dc_ops("csw", dc_val);
    4000b760:	d5087a43 	dc	csw, x3
    4000b764:	17ffffeb 	b	4000b710 <arch_dcache_all+0x84>
		return -ENOTSUP;
    4000b768:	128010a0 	mov	w0, #0xffffff7a            	// #-134
    4000b76c:	17fffff6 	b	4000b744 <arch_dcache_all+0xb8>
		return 0;
    4000b770:	52800000 	mov	w0, #0x0                   	// #0
    4000b774:	17fffff4 	b	4000b744 <arch_dcache_all+0xb8>

000000004000b778 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
    4000b778:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000b77c:	aa0003e6 	mov	x6, x0
    4000b780:	910003fd 	mov	x29, sp
    4000b784:	a90153f3 	stp	x19, x20, [sp, #16]
	register const char *s = nptr;
    4000b788:	aa0003f3 	mov	x19, x0
{
    4000b78c:	f90013f5 	str	x21, [sp, #32]
    4000b790:	aa0103f5 	mov	x21, x1
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
    4000b794:	aa1303e0 	mov	x0, x19
    4000b798:	38401663 	ldrb	w3, [x19], #1
    4000b79c:	51002461 	sub	w1, w3, #0x9
    4000b7a0:	7100807f 	cmp	w3, #0x20
	} while (isspace(c));
    4000b7a4:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    4000b7a8:	54ffff69 	b.ls	4000b794 <strtol+0x1c>  // b.plast
	if (c == '-') {
    4000b7ac:	7100b47f 	cmp	w3, #0x2d
    4000b7b0:	54000541 	b.ne	4000b858 <strtol+0xe0>  // b.any
		neg = 1;
		c = *s++;
    4000b7b4:	39400263 	ldrb	w3, [x19]
    4000b7b8:	91000813 	add	x19, x0, #0x2
		neg = 1;
    4000b7bc:	52800021 	mov	w1, #0x1                   	// #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
    4000b7c0:	721b785f 	tst	w2, #0xffffffef
    4000b7c4:	54000161 	b.ne	4000b7f0 <strtol+0x78>  // b.any
    4000b7c8:	7100c07f 	cmp	w3, #0x30
    4000b7cc:	540008c1 	b.ne	4000b8e4 <strtol+0x16c>  // b.any
	    c == '0' && (*s == 'x' || *s == 'X')) {
    4000b7d0:	39400260 	ldrb	w0, [x19]
    4000b7d4:	121a7800 	and	w0, w0, #0xffffffdf
    4000b7d8:	12001c00 	and	w0, w0, #0xff
    4000b7dc:	7101601f 	cmp	w0, #0x58
    4000b7e0:	540008a1 	b.ne	4000b8f4 <strtol+0x17c>  // b.any
		c = s[1];
    4000b7e4:	39400663 	ldrb	w3, [x19, #1]
		s += 2;
    4000b7e8:	91000a73 	add	x19, x19, #0x2
		base = 16;
    4000b7ec:	52800202 	mov	w2, #0x10                  	// #16
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    4000b7f0:	92f00014 	mov	x20, #0x7fffffffffffffff    	// #9223372036854775807
	cutlim = cutoff % (unsigned long)base;
    4000b7f4:	93407c47 	sxtw	x7, w2
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
    4000b7f8:	8b21c294 	add	x20, x20, w1, sxtw
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
    4000b7fc:	52800005 	mov	w5, #0x0                   	// #0
    4000b800:	d2800000 	mov	x0, #0x0                   	// #0
		if (isdigit(c)) {
			c -= '0';
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    4000b804:	528006ea 	mov	w10, #0x37                  	// #55
    4000b808:	52800aeb 	mov	w11, #0x57                  	// #87
	cutlim = cutoff % (unsigned long)base;
    4000b80c:	9ac70a88 	udiv	x8, x20, x7
    4000b810:	1b07d109 	msub	w9, w8, w7, w20
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    4000b814:	5100c064 	sub	w4, w3, #0x30
		if (isdigit(c)) {
    4000b818:	7100249f 	cmp	w4, #0x9
    4000b81c:	540002a8 	b.hi	4000b870 <strtol+0xf8>  // b.pmore
			c -= '0';
    4000b820:	2a0403e3 	mov	w3, w4
		} else {
			break;
		}
		if (c >= base) {
    4000b824:	6b03005f 	cmp	w2, w3
    4000b828:	540003ad 	b.le	4000b89c <strtol+0x124>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
    4000b82c:	710000bf 	cmp	w5, #0x0
    4000b830:	fa48a002 	ccmp	x0, x8, #0x2, ge  // ge = tcont
    4000b834:	54000308 	b.hi	4000b894 <strtol+0x11c>  // b.pmore
    4000b838:	eb08001f 	cmp	x0, x8
    4000b83c:	7a490064 	ccmp	w3, w9, #0x4, eq  // eq = none
    4000b840:	540002ac 	b.gt	4000b894 <strtol+0x11c>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
    4000b844:	93407c63 	sxtw	x3, w3
			any = 1;
    4000b848:	52800025 	mov	w5, #0x1                   	// #1
			acc += c;
    4000b84c:	9b000ce0 	madd	x0, x7, x0, x3
	for (acc = 0, any = 0;; c = *s++) {
    4000b850:	38401663 	ldrb	w3, [x19], #1
		if (isdigit(c)) {
    4000b854:	17fffff0 	b	4000b814 <strtol+0x9c>
	} else if (c == '+') {
    4000b858:	7100ac7f 	cmp	w3, #0x2b
    4000b85c:	54000061 	b.ne	4000b868 <strtol+0xf0>  // b.any
		c = *s++;
    4000b860:	39400263 	ldrb	w3, [x19]
    4000b864:	91000813 	add	x19, x0, #0x2
	register int neg = 0, any, cutlim;
    4000b868:	52800001 	mov	w1, #0x0                   	// #0
    4000b86c:	17ffffd5 	b	4000b7c0 <strtol+0x48>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    4000b870:	321b0064 	orr	w4, w3, #0x20
    4000b874:	51018484 	sub	w4, w4, #0x61
		} else if (isalpha(c)) {
    4000b878:	7100649f 	cmp	w4, #0x19
    4000b87c:	54000108 	b.hi	4000b89c <strtol+0x124>  // b.pmore
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    4000b880:	51010464 	sub	w4, w3, #0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    4000b884:	7100689f 	cmp	w4, #0x1a
    4000b888:	1a8b3144 	csel	w4, w10, w11, cc  // cc = lo, ul, last
    4000b88c:	4b040063 	sub	w3, w3, w4
    4000b890:	17ffffe5 	b	4000b824 <strtol+0xac>
			any = -1;
    4000b894:	12800005 	mov	w5, #0xffffffff            	// #-1
    4000b898:	17ffffee 	b	4000b850 <strtol+0xd8>
		}
	}

	if (any < 0) {
    4000b89c:	310004bf 	cmn	w5, #0x1
    4000b8a0:	54000141 	b.ne	4000b8c8 <strtol+0x150>  // b.any
		/* coverity[OVERRUN] */
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
    4000b8a4:	94000a8b 	bl	4000e2d0 <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
    4000b8a8:	52800441 	mov	w1, #0x22                  	// #34
    4000b8ac:	b9000001 	str	w1, [x0]
		acc = neg ? LONG_MIN : LONG_MAX;
    4000b8b0:	aa1403e0 	mov	x0, x20
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
    4000b8b4:	b5000135 	cbnz	x21, 4000b8d8 <strtol+0x160>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
    4000b8b8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000b8bc:	f94013f5 	ldr	x21, [sp, #32]
    4000b8c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000b8c4:	d65f03c0 	ret
	} else if (neg) {
    4000b8c8:	34000041 	cbz	w1, 4000b8d0 <strtol+0x158>
		acc = -acc;
    4000b8cc:	cb0003e0 	neg	x0, x0
	if (endptr != NULL) {
    4000b8d0:	b4ffff55 	cbz	x21, 4000b8b8 <strtol+0x140>
		*endptr = (char *)(any ? s - 1 : nptr);
    4000b8d4:	34000045 	cbz	w5, 4000b8dc <strtol+0x164>
    4000b8d8:	d1000666 	sub	x6, x19, #0x1
    4000b8dc:	f90002a6 	str	x6, [x21]
	return acc;
    4000b8e0:	17fffff6 	b	4000b8b8 <strtol+0x140>
		base = c == '0' ? 8 : 10;
    4000b8e4:	7100005f 	cmp	w2, #0x0
    4000b8e8:	52800140 	mov	w0, #0xa                   	// #10
    4000b8ec:	1a801042 	csel	w2, w2, w0, ne  // ne = any
    4000b8f0:	17ffffc0 	b	4000b7f0 <strtol+0x78>
    4000b8f4:	7100005f 	cmp	w2, #0x0
    4000b8f8:	52800100 	mov	w0, #0x8                   	// #8
    4000b8fc:	17fffffc 	b	4000b8ec <strtol+0x174>

000000004000b900 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
    4000b900:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000b904:	aa0003e6 	mov	x6, x0
    4000b908:	910003fd 	mov	x29, sp
    4000b90c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000b910:	aa0103f4 	mov	x20, x1
	register const char *s = nptr;
    4000b914:	aa0003f3 	mov	x19, x0

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
    4000b918:	aa1303e0 	mov	x0, x19
    4000b91c:	38401663 	ldrb	w3, [x19], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
    4000b920:	51002461 	sub	w1, w3, #0x9
    4000b924:	7100807f 	cmp	w3, #0x20
	} while (isspace(c));
    4000b928:	7a441820 	ccmp	w1, #0x4, #0x0, ne  // ne = any
    4000b92c:	54ffff69 	b.ls	4000b918 <strtoul+0x18>  // b.plast
	if (c == '-') {
    4000b930:	7100b47f 	cmp	w3, #0x2d
    4000b934:	54000541 	b.ne	4000b9dc <strtoul+0xdc>  // b.any
		neg = 1;
		c = *s++;
    4000b938:	39400263 	ldrb	w3, [x19]
    4000b93c:	91000813 	add	x19, x0, #0x2
		neg = 1;
    4000b940:	52800027 	mov	w7, #0x1                   	// #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
    4000b944:	721b785f 	tst	w2, #0xffffffef
    4000b948:	54000161 	b.ne	4000b974 <strtoul+0x74>  // b.any
    4000b94c:	7100c07f 	cmp	w3, #0x30
    4000b950:	54000921 	b.ne	4000ba74 <strtoul+0x174>  // b.any
	    c == '0' && (*s == 'x' || *s == 'X')) {
    4000b954:	39400260 	ldrb	w0, [x19]
    4000b958:	121a7800 	and	w0, w0, #0xffffffdf
    4000b95c:	12001c00 	and	w0, w0, #0xff
    4000b960:	7101601f 	cmp	w0, #0x58
    4000b964:	54000801 	b.ne	4000ba64 <strtoul+0x164>  // b.any
		c = s[1];
    4000b968:	39400663 	ldrb	w3, [x19, #1]
		s += 2;
    4000b96c:	91000a73 	add	x19, x19, #0x2
		base = 16;
    4000b970:	52800202 	mov	w2, #0x10                  	// #16

	if (base == 0) {
		base = c == '0' ? 8 : 10;
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    4000b974:	93407c48 	sxtw	x8, w2
    4000b978:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
    4000b97c:	52800005 	mov	w5, #0x0                   	// #0
    4000b980:	d2800000 	mov	x0, #0x0                   	// #0
		if (isdigit(c)) {
			c -= '0';
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    4000b984:	528006ea 	mov	w10, #0x37                  	// #55
    4000b988:	52800aeb 	mov	w11, #0x57                  	// #87
	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
    4000b98c:	9ac80821 	udiv	x1, x1, x8
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
    4000b990:	9b087c29 	mul	x9, x1, x8
    4000b994:	2a2903e9 	mvn	w9, w9
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    4000b998:	5100c064 	sub	w4, w3, #0x30
		if (isdigit(c)) {
    4000b99c:	7100249f 	cmp	w4, #0x9
    4000b9a0:	540002a8 	b.hi	4000b9f4 <strtoul+0xf4>  // b.pmore
			c -= '0';
    4000b9a4:	2a0403e3 	mov	w3, w4
		} else {
			break;
		}
		if (c >= base) {
    4000b9a8:	6b03005f 	cmp	w2, w3
    4000b9ac:	540003ad 	b.le	4000ba20 <strtoul+0x120>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
    4000b9b0:	710000bf 	cmp	w5, #0x0
    4000b9b4:	fa41a002 	ccmp	x0, x1, #0x2, ge  // ge = tcont
    4000b9b8:	54000308 	b.hi	4000ba18 <strtoul+0x118>  // b.pmore
    4000b9bc:	eb01001f 	cmp	x0, x1
    4000b9c0:	7a490064 	ccmp	w3, w9, #0x4, eq  // eq = none
    4000b9c4:	540002ac 	b.gt	4000ba18 <strtoul+0x118>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
    4000b9c8:	93407c63 	sxtw	x3, w3
			any = 1;
    4000b9cc:	52800025 	mov	w5, #0x1                   	// #1
			acc += c;
    4000b9d0:	9b000d00 	madd	x0, x8, x0, x3
	for (acc = 0, any = 0;; c = *s++) {
    4000b9d4:	38401663 	ldrb	w3, [x19], #1
		if (isdigit(c)) {
    4000b9d8:	17fffff0 	b	4000b998 <strtoul+0x98>
	} else if (c == '+') {
    4000b9dc:	7100ac7f 	cmp	w3, #0x2b
    4000b9e0:	54000061 	b.ne	4000b9ec <strtoul+0xec>  // b.any
		c = *s++;
    4000b9e4:	39400263 	ldrb	w3, [x19]
    4000b9e8:	91000813 	add	x19, x0, #0x2
	register int neg = 0, any, cutlim;
    4000b9ec:	52800007 	mov	w7, #0x0                   	// #0
    4000b9f0:	17ffffd5 	b	4000b944 <strtoul+0x44>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    4000b9f4:	321b0064 	orr	w4, w3, #0x20
    4000b9f8:	51018484 	sub	w4, w4, #0x61
		} else if (isalpha(c)) {
    4000b9fc:	7100649f 	cmp	w4, #0x19
    4000ba00:	54000108 	b.hi	4000ba20 <strtoul+0x120>  // b.pmore
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    4000ba04:	51010464 	sub	w4, w3, #0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
    4000ba08:	7100689f 	cmp	w4, #0x1a
    4000ba0c:	1a8b3144 	csel	w4, w10, w11, cc  // cc = lo, ul, last
    4000ba10:	4b040063 	sub	w3, w3, w4
    4000ba14:	17ffffe5 	b	4000b9a8 <strtoul+0xa8>
			any = -1;
    4000ba18:	12800005 	mov	w5, #0xffffffff            	// #-1
    4000ba1c:	17ffffee 	b	4000b9d4 <strtoul+0xd4>
		}
	}
	if (any < 0) {
    4000ba20:	310004bf 	cmn	w5, #0x1
    4000ba24:	54000121 	b.ne	4000ba48 <strtoul+0x148>  // b.any
    4000ba28:	94000a2a 	bl	4000e2d0 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
    4000ba2c:	52800441 	mov	w1, #0x22                  	// #34
    4000ba30:	b9000001 	str	w1, [x0]
		acc = ULONG_MAX;
    4000ba34:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
    4000ba38:	b5000114 	cbnz	x20, 4000ba58 <strtoul+0x158>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
    4000ba3c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ba40:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000ba44:	d65f03c0 	ret
	} else if (neg) {
    4000ba48:	34000047 	cbz	w7, 4000ba50 <strtoul+0x150>
		acc = -acc;
    4000ba4c:	cb0003e0 	neg	x0, x0
	if (endptr != NULL) {
    4000ba50:	b4ffff74 	cbz	x20, 4000ba3c <strtoul+0x13c>
		*endptr = (char *)(any ? s - 1 : nptr);
    4000ba54:	34000045 	cbz	w5, 4000ba5c <strtoul+0x15c>
    4000ba58:	d1000666 	sub	x6, x19, #0x1
    4000ba5c:	f9000286 	str	x6, [x20]
	return acc;
    4000ba60:	17fffff7 	b	4000ba3c <strtoul+0x13c>
		base = c == '0' ? 8 : 10;
    4000ba64:	7100005f 	cmp	w2, #0x0
    4000ba68:	52800100 	mov	w0, #0x8                   	// #8
    4000ba6c:	1a801042 	csel	w2, w2, w0, ne  // ne = any
    4000ba70:	17ffffc1 	b	4000b974 <strtoul+0x74>
    4000ba74:	7100005f 	cmp	w2, #0x0
    4000ba78:	52800140 	mov	w0, #0xa                   	// #10
    4000ba7c:	17fffffc 	b	4000ba6c <strtoul+0x16c>

000000004000ba80 <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
    4000ba80:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000ba84:	910003fd 	mov	x29, sp
    4000ba88:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ba8c:	aa0003f4 	mov	x20, x0
    4000ba90:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000ba94:	f9001bf7 	str	x23, [sp, #48]
	char c, sc;
	size_t len;

	c = *find++;
    4000ba98:	39400037 	ldrb	w23, [x1]
	if (c != 0) {
    4000ba9c:	340001f7 	cbz	w23, 4000bad8 <strstr+0x58>
	c = *find++;
    4000baa0:	91000433 	add	x19, x1, #0x1
		len = strlen(find);
    4000baa4:	aa1303e0 	mov	x0, x19
    4000baa8:	94000042 	bl	4000bbb0 <strlen>
    4000baac:	aa0003f6 	mov	x22, x0
		do {
			do {
				sc = *s++;
    4000bab0:	aa1403f5 	mov	x21, x20
    4000bab4:	384016a0 	ldrb	w0, [x21], #1
				if (sc == 0) {
    4000bab8:	34000200 	cbz	w0, 4000baf8 <strstr+0x78>
					return NULL;
				}
			} while (sc != c);
    4000babc:	6b0002ff 	cmp	w23, w0
    4000bac0:	54000181 	b.ne	4000baf0 <strstr+0x70>  // b.any
		} while (strncmp(s, find, len) != 0);
    4000bac4:	aa1603e2 	mov	x2, x22
    4000bac8:	aa1303e1 	mov	x1, x19
    4000bacc:	aa1503e0 	mov	x0, x21
    4000bad0:	94000051 	bl	4000bc14 <strncmp>
    4000bad4:	350000e0 	cbnz	w0, 4000baf0 <strstr+0x70>
	s--;
	}
	return (char *)s;
}
    4000bad8:	aa1403e0 	mov	x0, x20
    4000badc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000bae0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000bae4:	f9401bf7 	ldr	x23, [sp, #48]
    4000bae8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000baec:	d65f03c0 	ret
{
    4000baf0:	aa1503f4 	mov	x20, x21
    4000baf4:	17ffffef 	b	4000bab0 <strstr+0x30>
					return NULL;
    4000baf8:	d2800014 	mov	x20, #0x0                   	// #0
    4000bafc:	17fffff7 	b	4000bad8 <strstr+0x58>

000000004000bb00 <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
    4000bb00:	d2800002 	mov	x2, #0x0                   	// #0
    4000bb04:	38626823 	ldrb	w3, [x1, x2]
    4000bb08:	8b020004 	add	x4, x0, x2
    4000bb0c:	35000063 	cbnz	w3, 4000bb18 <strcpy+0x18>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
    4000bb10:	3900009f 	strb	wzr, [x4]

	return dest;
}
    4000bb14:	d65f03c0 	ret
		*d = *s;
    4000bb18:	38226803 	strb	w3, [x0, x2]
		s++;
    4000bb1c:	91000442 	add	x2, x2, #0x1
    4000bb20:	17fffff9 	b	4000bb04 <strcpy+0x4>

000000004000bb24 <strncpy>:

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    4000bb24:	d2800003 	mov	x3, #0x0                   	// #0
    4000bb28:	cb030045 	sub	x5, x2, x3
    4000bb2c:	8b030006 	add	x6, x0, x3
    4000bb30:	eb02007f 	cmp	x3, x2
    4000bb34:	54000100 	b.eq	4000bb54 <strncpy+0x30>  // b.none
    4000bb38:	38636824 	ldrb	w4, [x1, x3]
    4000bb3c:	350000e4 	cbnz	w4, 4000bb58 <strncpy+0x34>
    4000bb40:	d2800001 	mov	x1, #0x0                   	// #0
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
    4000bb44:	382168df 	strb	wzr, [x6, x1]
	while (n > 0) {
    4000bb48:	91000421 	add	x1, x1, #0x1
    4000bb4c:	eb05003f 	cmp	x1, x5
    4000bb50:	54ffffa1 	b.ne	4000bb44 <strncpy+0x20>  // b.any
		d++;
		n--;
	}

	return dest;
}
    4000bb54:	d65f03c0 	ret
		*d = *s;
    4000bb58:	38236804 	strb	w4, [x0, x3]
		n--;
    4000bb5c:	91000463 	add	x3, x3, #0x1
    4000bb60:	17fffff2 	b	4000bb28 <strncpy+0x4>

000000004000bb64 <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
    4000bb64:	12001c21 	and	w1, w1, #0xff

	while ((*s != tmp) && (*s != '\0')) {
    4000bb68:	39400002 	ldrb	w2, [x0]
    4000bb6c:	6b01005f 	cmp	w2, w1
    4000bb70:	54000080 	b.eq	4000bb80 <strchr+0x1c>  // b.none
    4000bb74:	35000082 	cbnz	w2, 4000bb84 <strchr+0x20>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
    4000bb78:	7100003f 	cmp	w1, #0x0
    4000bb7c:	9a9f0000 	csel	x0, x0, xzr, eq  // eq = none
}
    4000bb80:	d65f03c0 	ret
		s++;
    4000bb84:	91000400 	add	x0, x0, #0x1
    4000bb88:	17fffff8 	b	4000bb68 <strchr+0x4>

000000004000bb8c <strrchr>:
char *strrchr(const char *s, int c)
{
	char *match = NULL;

	do {
		if (*s == (char)c) {
    4000bb8c:	12001c21 	and	w1, w1, #0xff
{
    4000bb90:	aa0003e2 	mov	x2, x0
	char *match = NULL;
    4000bb94:	d2800000 	mov	x0, #0x0                   	// #0
		if (*s == (char)c) {
    4000bb98:	39400043 	ldrb	w3, [x2]
    4000bb9c:	6b01007f 	cmp	w3, w1
    4000bba0:	9a821000 	csel	x0, x0, x2, ne  // ne = any
			match = (char *)s;
		}
	} while (*s++);
    4000bba4:	91000442 	add	x2, x2, #0x1
    4000bba8:	35ffff83 	cbnz	w3, 4000bb98 <strrchr+0xc>

	return match;
}
    4000bbac:	d65f03c0 	ret

000000004000bbb0 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    4000bbb0:	aa0003e1 	mov	x1, x0
	size_t n = 0;
    4000bbb4:	d2800000 	mov	x0, #0x0                   	// #0

	while (*s != '\0') {
    4000bbb8:	38606822 	ldrb	w2, [x1, x0]
    4000bbbc:	35000042 	cbnz	w2, 4000bbc4 <strlen+0x14>
		s++;
		n++;
	}

	return n;
}
    4000bbc0:	d65f03c0 	ret
		n++;
    4000bbc4:	91000400 	add	x0, x0, #0x1
    4000bbc8:	17fffffc 	b	4000bbb8 <strlen+0x8>

000000004000bbcc <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    4000bbcc:	aa0003e2 	mov	x2, x0
	size_t n = 0;
    4000bbd0:	d2800000 	mov	x0, #0x0                   	// #0

	while (*s != '\0' && n < maxlen) {
    4000bbd4:	38606843 	ldrb	w3, [x2, x0]
    4000bbd8:	34000063 	cbz	w3, 4000bbe4 <strnlen+0x18>
    4000bbdc:	eb01001f 	cmp	x0, x1
    4000bbe0:	54000041 	b.ne	4000bbe8 <strnlen+0x1c>  // b.any
		s++;
		n++;
	}

	return n;
}
    4000bbe4:	d65f03c0 	ret
		n++;
    4000bbe8:	91000400 	add	x0, x0, #0x1
    4000bbec:	17fffffa 	b	4000bbd4 <strnlen+0x8>

000000004000bbf0 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    4000bbf0:	d2800002 	mov	x2, #0x0                   	// #0
    4000bbf4:	38626803 	ldrb	w3, [x0, x2]
    4000bbf8:	38626824 	ldrb	w4, [x1, x2]
    4000bbfc:	6b04007f 	cmp	w3, w4
    4000bc00:	54000061 	b.ne	4000bc0c <strcmp+0x1c>  // b.any
    4000bc04:	91000442 	add	x2, x2, #0x1
    4000bc08:	35ffff63 	cbnz	w3, 4000bbf4 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    4000bc0c:	4b040060 	sub	w0, w3, w4
    4000bc10:	d65f03c0 	ret

000000004000bc14 <strncmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
    4000bc14:	d2800004 	mov	x4, #0x0                   	// #0
    4000bc18:	eb04005f 	cmp	x2, x4
    4000bc1c:	54000120 	b.eq	4000bc40 <strncmp+0x2c>  // b.none
    4000bc20:	38646803 	ldrb	w3, [x0, x4]
    4000bc24:	38646825 	ldrb	w5, [x1, x4]
    4000bc28:	6b05007f 	cmp	w3, w5
    4000bc2c:	54000061 	b.ne	4000bc38 <strncmp+0x24>  // b.any
    4000bc30:	91000484 	add	x4, x4, #0x1
    4000bc34:	35ffff23 	cbnz	w3, 4000bc18 <strncmp+0x4>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
    4000bc38:	4b050060 	sub	w0, w3, w5
    4000bc3c:	14000002 	b	4000bc44 <strncmp+0x30>
    4000bc40:	52800000 	mov	w0, #0x0                   	// #0
}
    4000bc44:	d65f03c0 	ret

000000004000bc48 <memcmp>:
int memcmp(const void *m1, const void *m2, size_t n)
{
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
    4000bc48:	b4000182 	cbz	x2, 4000bc78 <memcmp+0x30>
    4000bc4c:	d1000442 	sub	x2, x2, #0x1
    4000bc50:	d2800004 	mov	x4, #0x0                   	// #0
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
    4000bc54:	38646803 	ldrb	w3, [x0, x4]
    4000bc58:	eb04005f 	cmp	x2, x4
    4000bc5c:	38646825 	ldrb	w5, [x1, x4]
    4000bc60:	54000080 	b.eq	4000bc70 <memcmp+0x28>  // b.none
    4000bc64:	91000484 	add	x4, x4, #0x1
    4000bc68:	6b05007f 	cmp	w3, w5
    4000bc6c:	54ffff40 	b.eq	4000bc54 <memcmp+0xc>  // b.none
		c1++;
		c2++;
	}

	return *c1 - *c2;
    4000bc70:	4b050060 	sub	w0, w3, w5
}
    4000bc74:	d65f03c0 	ret
		return 0;
    4000bc78:	52800000 	mov	w0, #0x0                   	// #0
    4000bc7c:	17fffffe 	b	4000bc74 <memcmp+0x2c>

000000004000bc80 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
    4000bc80:	cb010003 	sub	x3, x0, x1
    4000bc84:	eb02007f 	cmp	x3, x2
    4000bc88:	54000163 	b.cc	4000bcb4 <memmove+0x34>  // b.lo, b.ul, b.last
    4000bc8c:	d2800003 	mov	x3, #0x0                   	// #0
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
    4000bc90:	eb03005f 	cmp	x2, x3
    4000bc94:	54000120 	b.eq	4000bcb8 <memmove+0x38>  // b.none
			*dest = *src;
    4000bc98:	38636824 	ldrb	w4, [x1, x3]
    4000bc9c:	38236804 	strb	w4, [x0, x3]
			dest++;
			src++;
			n--;
    4000bca0:	91000463 	add	x3, x3, #0x1
    4000bca4:	17fffffb 	b	4000bc90 <memmove+0x10>
			n--;
    4000bca8:	d1000442 	sub	x2, x2, #0x1
			dest[n] = src[n];
    4000bcac:	38626823 	ldrb	w3, [x1, x2]
    4000bcb0:	38226803 	strb	w3, [x0, x2]
		while (n > 0) {
    4000bcb4:	b5ffffa2 	cbnz	x2, 4000bca8 <memmove+0x28>
		}
	}

	return d;
}
    4000bcb8:	d65f03c0 	ret

000000004000bcbc <memcpy>:
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
    4000bcbc:	d2800003 	mov	x3, #0x0                   	// #0
    4000bcc0:	eb03005f 	cmp	x2, x3
    4000bcc4:	54000041 	b.ne	4000bccc <memcpy+0x10>  // b.any
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    4000bcc8:	d65f03c0 	ret
		*(d_byte++) = *(s_byte++);
    4000bccc:	38636824 	ldrb	w4, [x1, x3]
    4000bcd0:	38236804 	strb	w4, [x0, x3]
		n--;
    4000bcd4:	91000463 	add	x3, x3, #0x1
    4000bcd8:	17fffffa 	b	4000bcc0 <memcpy+0x4>

000000004000bcdc <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    4000bcdc:	12001c21 	and	w1, w1, #0xff
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    4000bce0:	d2800003 	mov	x3, #0x0                   	// #0
    4000bce4:	eb03005f 	cmp	x2, x3
    4000bce8:	54000041 	b.ne	4000bcf0 <memset+0x14>  // b.any
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    4000bcec:	d65f03c0 	ret
		*(d_byte++) = c_byte;
    4000bcf0:	38236801 	strb	w1, [x0, x3]
		n--;
    4000bcf4:	91000463 	add	x3, x3, #0x1
    4000bcf8:	17fffffb 	b	4000bce4 <memset+0x8>

000000004000bcfc <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
    4000bcfc:	12800000 	mov	w0, #0xffffffff            	// #-1
    4000bd00:	d65f03c0 	ret

000000004000bd04 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    4000bd04:	90000321 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
    4000bd08:	f904a820 	str	x0, [x1, #2384]
}
    4000bd0c:	d65f03c0 	ret

000000004000bd10 <sprintf_out>:
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
	if (p->len > 1) { /* need to reserve a byte for EOS */
    4000bd10:	b9400822 	ldr	w2, [x1, #8]
    4000bd14:	7100045f 	cmp	w2, #0x1
    4000bd18:	5400012d 	b.le	4000bd3c <sprintf_out+0x2c>
		*(p->ptr) = c;
    4000bd1c:	f9400022 	ldr	x2, [x1]
    4000bd20:	39000040 	strb	w0, [x2]
		p->ptr += 1;
    4000bd24:	f9400020 	ldr	x0, [x1]
    4000bd28:	91000400 	add	x0, x0, #0x1
    4000bd2c:	f9000020 	str	x0, [x1]
		p->len -= 1;
    4000bd30:	b9400820 	ldr	w0, [x1, #8]
    4000bd34:	51000400 	sub	w0, w0, #0x1
    4000bd38:	b9000820 	str	w0, [x1, #8]
	}
	return 0; /* indicate keep going so we get the total count */
}
    4000bd3c:	52800000 	mov	w0, #0x0                   	// #0
    4000bd40:	d65f03c0 	ret

000000004000bd44 <snprintf>:

int snprintf(char *ZRESTRICT str, size_t len,
	     const char *ZRESTRICT format, ...)
{
    4000bd44:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
    4000bd48:	910003fd 	mov	x29, sp
    4000bd4c:	3d801fe0 	str	q0, [sp, #112]
    4000bd50:	3d8023e1 	str	q1, [sp, #128]
    4000bd54:	3d8027e2 	str	q2, [sp, #144]
    4000bd58:	3d802be3 	str	q3, [sp, #160]
    4000bd5c:	3d802fe4 	str	q4, [sp, #176]
    4000bd60:	3d8033e5 	str	q5, [sp, #192]
    4000bd64:	3d8037e6 	str	q6, [sp, #208]
    4000bd68:	3d803be7 	str	q7, [sp, #224]
    4000bd6c:	a90f93e3 	stp	x3, x4, [sp, #248]
    4000bd70:	a9109be5 	stp	x5, x6, [sp, #264]
    4000bd74:	f9008fe7 	str	x7, [sp, #280]

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
    4000bd78:	b5000041 	cbnz	x1, 4000bd80 <snprintf+0x3c>
		str = &dummy; /* write final NUL to dummy, can't change *s */
    4000bd7c:	9100ffe0 	add	x0, sp, #0x3f
	}

	p.ptr = str;
    4000bd80:	f90023e0 	str	x0, [sp, #64]
	p.len = (int) len;

	va_start(vargs, format);
    4000bd84:	910483e0 	add	x0, sp, #0x120
    4000bd88:	a90503e0 	stp	x0, x0, [sp, #80]
    4000bd8c:	9103c3e0 	add	x0, sp, #0xf0
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
    4000bd90:	910043e3 	add	x3, sp, #0x10
	va_start(vargs, format);
    4000bd94:	f90033e0 	str	x0, [sp, #96]
    4000bd98:	128004e0 	mov	w0, #0xffffffd8            	// #-40
    4000bd9c:	b9006be0 	str	w0, [sp, #104]
    4000bda0:	12800fe0 	mov	w0, #0xffffff80            	// #-128
    4000bda4:	b9006fe0 	str	w0, [sp, #108]
	p.len = (int) len;
    4000bda8:	b9004be1 	str	w1, [sp, #72]
	r = cbvprintf(sprintf_out, (void *) (&p), format, vargs);
    4000bdac:	a94507e0 	ldp	x0, x1, [sp, #80]
    4000bdb0:	a90107e0 	stp	x0, x1, [sp, #16]
    4000bdb4:	a94607e0 	ldp	x0, x1, [sp, #96]
    4000bdb8:	a90207e0 	stp	x0, x1, [sp, #32]
    4000bdbc:	910103e1 	add	x1, sp, #0x40
    4000bdc0:	90000000 	adrp	x0, 4000b000 <z_arm64_fpu_save+0x50>
    4000bdc4:	91344000 	add	x0, x0, #0xd10
    4000bdc8:	97ffd779 	bl	40001bac <cbvprintf>
	va_end(vargs);

	*(p.ptr) = 0;
    4000bdcc:	f94023e1 	ldr	x1, [sp, #64]
    4000bdd0:	3900003f 	strb	wzr, [x1]
	return r;
}
    4000bdd4:	a8d27bfd 	ldp	x29, x30, [sp], #288
    4000bdd8:	d65f03c0 	ret

000000004000bddc <fs_init>:
	LOG_DBG("fs unregister %d: %d", type, rc);
	return rc;
}

static int fs_init(const struct device *dev)
{
    4000bddc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000bde0:	910003fd 	mov	x29, sp
	return z_impl_k_mutex_init(mutex);
    4000bde4:	d00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000bde8:	911b2000 	add	x0, x0, #0x6c8
    4000bdec:	94000c5b 	bl	4000ef58 <z_impl_k_mutex_init>
	list->head = (sys_dnode_t *)list;
    4000bdf0:	d00000a1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000bdf4:	911ae020 	add	x0, x1, #0x6b8
    4000bdf8:	f9035c20 	str	x0, [x1, #1720]
	list->tail = (sys_dnode_t *)list;
    4000bdfc:	f9000400 	str	x0, [x0, #8]
	k_mutex_init(&mutex);
	sys_dlist_init(&fs_mnt_list);
	return 0;
}
    4000be00:	52800000 	mov	w0, #0x0                   	// #0
    4000be04:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000be08:	d65f03c0 	ret

000000004000be0c <k_mutex_lock.constprop.0.isra.0>:
static inline int k_mutex_lock(struct k_mutex * mutex, k_timeout_t timeout)
    4000be0c:	aa0003e1 	mov	x1, x0
	return z_impl_k_mutex_lock(mutex, timeout);
    4000be10:	d00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000be14:	911b2000 	add	x0, x0, #0x6c8
    4000be18:	14000c55 	b	4000ef6c <z_impl_k_mutex_lock>

000000004000be1c <k_mutex_unlock.constprop.0.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
    4000be1c:	d00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000be20:	911b2000 	add	x0, x0, #0x6c8
    4000be24:	14000ca7 	b	4000f0c0 <z_impl_k_mutex_unlock>

000000004000be28 <fs_get_mnt_point>:
{
    4000be28:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4000be2c:	910003fd 	mov	x29, sp
    4000be30:	a90153f3 	stp	x19, x20, [sp, #16]
    4000be34:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000be38:	aa0103f6 	mov	x22, x1
	return (node == list->tail) ? NULL : node->next;
    4000be3c:	d2800015 	mov	x21, #0x0                   	// #0
    4000be40:	a90363f7 	stp	x23, x24, [sp, #48]
    4000be44:	aa0203f7 	mov	x23, x2
    4000be48:	aa0003f8 	mov	x24, x0
	size_t len, name_len = strlen(name);
    4000be4c:	aa0103e0 	mov	x0, x1
{
    4000be50:	a9046bf9 	stp	x25, x26, [sp, #64]
    4000be54:	d2800019 	mov	x25, #0x0                   	// #0
    4000be58:	f9002bfb 	str	x27, [sp, #80]
	size_t len, name_len = strlen(name);
    4000be5c:	97ffff55 	bl	4000bbb0 <strlen>
    4000be60:	aa0003fa 	mov	x26, x0
	k_mutex_lock(&mutex, K_FOREVER);
    4000be64:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4000be68:	97ffffe9 	bl	4000be0c <k_mutex_lock.constprop.0.isra.0>
	return list->head == list;
    4000be6c:	d00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000be70:	911ae01b 	add	x27, x0, #0x6b8
    4000be74:	f9435c13 	ldr	x19, [x0, #1720]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000be78:	eb1b027f 	cmp	x19, x27
    4000be7c:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	SYS_DLIST_FOR_EACH_NODE(&fs_mnt_list, node) {
    4000be80:	b5000133 	cbnz	x19, 4000bea4 <fs_get_mnt_point+0x7c>
	k_mutex_unlock(&mutex);
    4000be84:	97ffffe6 	bl	4000be1c <k_mutex_unlock.constprop.0.isra.0>
	if (mnt_p == NULL) {
    4000be88:	b40003b5 	cbz	x21, 4000befc <fs_get_mnt_point+0xd4>
	*mnt_pntp = mnt_p;
    4000be8c:	f9000315 	str	x21, [x24]
	if (match_len)
    4000be90:	b4000077 	cbz	x23, 4000be9c <fs_get_mnt_point+0x74>
		*match_len = mnt_p->mountp_len;
    4000be94:	f9401aa0 	ldr	x0, [x21, #48]
    4000be98:	f90002e0 	str	x0, [x23]
	return 0;
    4000be9c:	52800000 	mov	w0, #0x0                   	// #0
    4000bea0:	14000018 	b	4000bf00 <fs_get_mnt_point+0xd8>
		len = itr->mountp_len;
    4000bea4:	f9401a74 	ldr	x20, [x19, #48]
		if ((len < longest_match) || (len > name_len)) {
    4000bea8:	eb14033f 	cmp	x25, x20
    4000beac:	fa549340 	ccmp	x26, x20, #0x0, ls  // ls = plast
    4000beb0:	540001c3 	b.cc	4000bee8 <fs_get_mnt_point+0xc0>  // b.lo, b.ul, b.last
		if ((len > 1) && (name[len] != '/') && (name[len] != '\0')) {
    4000beb4:	f100069f 	cmp	x20, #0x1
    4000beb8:	540000a9 	b.ls	4000becc <fs_get_mnt_point+0xa4>  // b.plast
    4000bebc:	38746ac0 	ldrb	w0, [x22, x20]
    4000bec0:	7100bc1f 	cmp	w0, #0x2f
    4000bec4:	54000040 	b.eq	4000becc <fs_get_mnt_point+0xa4>  // b.none
    4000bec8:	35000100 	cbnz	w0, 4000bee8 <fs_get_mnt_point+0xc0>
		if (strncmp(name, itr->mnt_point, len) == 0) {
    4000becc:	f9400e61 	ldr	x1, [x19, #24]
    4000bed0:	aa1403e2 	mov	x2, x20
    4000bed4:	aa1603e0 	mov	x0, x22
    4000bed8:	97ffff4f 	bl	4000bc14 <strncmp>
    4000bedc:	7100001f 	cmp	w0, #0x0
    4000bee0:	9a941339 	csel	x25, x25, x20, ne  // ne = any
    4000bee4:	9a9312b5 	csel	x21, x21, x19, ne  // ne = any
	return (node == list->tail) ? NULL : node->next;
    4000bee8:	f9400760 	ldr	x0, [x27, #8]
    4000beec:	eb00027f 	cmp	x19, x0
    4000bef0:	54fffca0 	b.eq	4000be84 <fs_get_mnt_point+0x5c>  // b.none
    4000bef4:	f9400273 	ldr	x19, [x19]
    4000bef8:	17ffffe2 	b	4000be80 <fs_get_mnt_point+0x58>
		return -ENOENT;
    4000befc:	12800020 	mov	w0, #0xfffffffe            	// #-2
}
    4000bf00:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000bf04:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000bf08:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000bf0c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000bf10:	f9402bfb 	ldr	x27, [sp, #80]
    4000bf14:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000bf18:	d65f03c0 	ret

000000004000bf1c <fs_open>:
{
    4000bf1c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000bf20:	910003fd 	mov	x29, sp
    4000bf24:	a90153f3 	stp	x19, x20, [sp, #16]
    4000bf28:	a9025bf5 	stp	x21, x22, [sp, #32]
	if ((file_name == NULL) ||
    4000bf2c:	b5000221 	cbnz	x1, 4000bf70 <fs_open+0x54>
		LOG_ERR("invalid file name!!");
    4000bf30:	90000320 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000bf34:	91291001 	add	x1, x0, #0xa44
    4000bf38:	b94a4400 	ldr	w0, [x0, #2628]
    4000bf3c:	f240081f 	tst	x0, #0x7
    4000bf40:	54000140 	b.eq	4000bf68 <fs_open+0x4c>  // b.none
    4000bf44:	90000320 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000bf48:	91290000 	add	x0, x0, #0xa40
    4000bf4c:	cb000021 	sub	x1, x1, x0
    4000bf50:	d0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000bf54:	912cf800 	add	x0, x0, #0xb3e
    4000bf58:	d342fc21 	lsr	x1, x1, #2
    4000bf5c:	531a2421 	ubfiz	w1, w1, #6, #10
    4000bf60:	32000021 	orr	w1, w1, #0x1
    4000bf64:	97ffdf2f 	bl	40003c20 <log_0>
		return -EINVAL;
    4000bf68:	128002b3 	mov	w19, #0xffffffea            	// #-22
    4000bf6c:	14000021 	b	4000bff0 <fs_open+0xd4>
    4000bf70:	aa0003f4 	mov	x20, x0
    4000bf74:	aa0103f5 	mov	x21, x1
    4000bf78:	12001c56 	and	w22, w2, #0xff
			(strlen(file_name) <= 1) || (file_name[0] != '/')) {
    4000bf7c:	aa0103e0 	mov	x0, x1
    4000bf80:	97ffff0c 	bl	4000bbb0 <strlen>
	if ((file_name == NULL) ||
    4000bf84:	f100041f 	cmp	x0, #0x1
    4000bf88:	54fffd49 	b.ls	4000bf30 <fs_open+0x14>  // b.plast
			(strlen(file_name) <= 1) || (file_name[0] != '/')) {
    4000bf8c:	394002a0 	ldrb	w0, [x21]
    4000bf90:	7100bc1f 	cmp	w0, #0x2f
    4000bf94:	54fffce1 	b.ne	4000bf30 <fs_open+0x14>  // b.any
	if (zfp->mp != NULL) {
    4000bf98:	f9400680 	ldr	x0, [x20, #8]
    4000bf9c:	b50007a0 	cbnz	x0, 4000c090 <fs_open+0x174>
	rc = fs_get_mnt_point(&mp, file_name, NULL);
    4000bfa0:	aa1503e1 	mov	x1, x21
    4000bfa4:	9100e3e0 	add	x0, sp, #0x38
    4000bfa8:	d2800002 	mov	x2, #0x0                   	// #0
    4000bfac:	97ffff9f 	bl	4000be28 <fs_get_mnt_point>
    4000bfb0:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000bfb4:	36f80280 	tbz	w0, #31, 4000c004 <fs_open+0xe8>
		LOG_ERR("mount point not found!!");
    4000bfb8:	90000320 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000bfbc:	91291001 	add	x1, x0, #0xa44
    4000bfc0:	b94a4400 	ldr	w0, [x0, #2628]
    4000bfc4:	f240081f 	tst	x0, #0x7
    4000bfc8:	54000140 	b.eq	4000bff0 <fs_open+0xd4>  // b.none
    4000bfcc:	90000320 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000bfd0:	91290000 	add	x0, x0, #0xa40
    4000bfd4:	cb000021 	sub	x1, x1, x0
    4000bfd8:	d0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000bfdc:	912d4800 	add	x0, x0, #0xb52
    4000bfe0:	d342fc21 	lsr	x1, x1, #2
    4000bfe4:	531a2421 	ubfiz	w1, w1, #6, #10
    4000bfe8:	32000021 	orr	w1, w1, #0x1
    4000bfec:	97ffdf0d 	bl	40003c20 <log_0>
}
    4000bff0:	2a1303e0 	mov	w0, w19
    4000bff4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000bff8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000bffc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000c000:	d65f03c0 	ret
	if (((mp->flags & FS_MOUNT_FLAG_READ_ONLY) != 0) &&
    4000c004:	f9401fe0 	ldr	x0, [sp, #56]
    4000c008:	39410001 	ldrb	w1, [x0, #64]
    4000c00c:	36080081 	tbz	w1, #1, 4000c01c <fs_open+0x100>
    4000c010:	52800241 	mov	w1, #0x12                  	// #18
    4000c014:	6a0102df 	tst	w22, w1
    4000c018:	54000401 	b.ne	4000c098 <fs_open+0x17c>  // b.any
	CHECKIF(mp->fs->open == NULL) {
    4000c01c:	f9401c01 	ldr	x1, [x0, #56]
    4000c020:	f9400023 	ldr	x3, [x1]
    4000c024:	b40003e3 	cbz	x3, 4000c0a0 <fs_open+0x184>
	zfp->mp = mp;
    4000c028:	f9000680 	str	x0, [x20, #8]
	rc = mp->fs->open(zfp, file_name, flags);
    4000c02c:	2a1603e2 	mov	w2, w22
    4000c030:	aa1503e1 	mov	x1, x21
    4000c034:	aa1403e0 	mov	x0, x20
    4000c038:	d63f0060 	blr	x3
    4000c03c:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c040:	36f80240 	tbz	w0, #31, 4000c088 <fs_open+0x16c>
		LOG_ERR("file open error (%d)", rc);
    4000c044:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c048:	91291002 	add	x2, x0, #0xa44
    4000c04c:	b94a4400 	ldr	w0, [x0, #2628]
    4000c050:	f240081f 	tst	x0, #0x7
    4000c054:	54000160 	b.eq	4000c080 <fs_open+0x164>  // b.none
    4000c058:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c05c:	91290000 	add	x0, x0, #0xa40
    4000c060:	cb000042 	sub	x2, x2, x0
    4000c064:	93407e61 	sxtw	x1, w19
    4000c068:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c06c:	912da800 	add	x0, x0, #0xb6a
    4000c070:	d342fc42 	lsr	x2, x2, #2
    4000c074:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c078:	32000042 	orr	w2, w2, #0x1
    4000c07c:	97ffdef8 	bl	40003c5c <log_1>
		zfp->mp = NULL;
    4000c080:	f900069f 	str	xzr, [x20, #8]
		return rc;
    4000c084:	17ffffdb 	b	4000bff0 <fs_open+0xd4>
	zfp->flags = flags;
    4000c088:	39004296 	strb	w22, [x20, #16]
	return rc;
    4000c08c:	17ffffd9 	b	4000bff0 <fs_open+0xd4>
		return -EBUSY;
    4000c090:	128001f3 	mov	w19, #0xfffffff0            	// #-16
    4000c094:	17ffffd7 	b	4000bff0 <fs_open+0xd4>
		return -EROFS;
    4000c098:	128003b3 	mov	w19, #0xffffffe2            	// #-30
    4000c09c:	17ffffd5 	b	4000bff0 <fs_open+0xd4>
		return -ENOTSUP;
    4000c0a0:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000c0a4:	17ffffd3 	b	4000bff0 <fs_open+0xd4>

000000004000c0a8 <fs_close>:
{
    4000c0a8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000c0ac:	910003fd 	mov	x29, sp
	if (zfp->mp == NULL) {
    4000c0b0:	f9400401 	ldr	x1, [x0, #8]
{
    4000c0b4:	a90153f3 	stp	x19, x20, [sp, #16]
	if (zfp->mp == NULL) {
    4000c0b8:	b40003a1 	cbz	x1, 4000c12c <fs_close+0x84>
	CHECKIF(zfp->mp->fs->close == NULL) {
    4000c0bc:	f9401c21 	ldr	x1, [x1, #56]
    4000c0c0:	f9401c21 	ldr	x1, [x1, #56]
    4000c0c4:	b4000381 	cbz	x1, 4000c134 <fs_close+0x8c>
    4000c0c8:	aa0003f4 	mov	x20, x0
	rc = zfp->mp->fs->close(zfp);
    4000c0cc:	d63f0020 	blr	x1
    4000c0d0:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c0d4:	36f80280 	tbz	w0, #31, 4000c124 <fs_close+0x7c>
		LOG_ERR("file close error (%d)", rc);
    4000c0d8:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c0dc:	91291002 	add	x2, x0, #0xa44
    4000c0e0:	b94a4400 	ldr	w0, [x0, #2628]
    4000c0e4:	f240081f 	tst	x0, #0x7
    4000c0e8:	54000160 	b.eq	4000c114 <fs_close+0x6c>  // b.none
    4000c0ec:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c0f0:	91290000 	add	x0, x0, #0xa40
    4000c0f4:	cb000042 	sub	x2, x2, x0
    4000c0f8:	93407e61 	sxtw	x1, w19
    4000c0fc:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c100:	912dfc00 	add	x0, x0, #0xb7f
    4000c104:	d342fc42 	lsr	x2, x2, #2
    4000c108:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c10c:	32000042 	orr	w2, w2, #0x1
    4000c110:	97ffded3 	bl	40003c5c <log_1>
}
    4000c114:	2a1303e0 	mov	w0, w19
    4000c118:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000c11c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000c120:	d65f03c0 	ret
	zfp->mp = NULL;
    4000c124:	f900069f 	str	xzr, [x20, #8]
	return rc;
    4000c128:	17fffffb 	b	4000c114 <fs_close+0x6c>
		return 0;
    4000c12c:	52800013 	mov	w19, #0x0                   	// #0
    4000c130:	17fffff9 	b	4000c114 <fs_close+0x6c>
		return -ENOTSUP;
    4000c134:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000c138:	17fffff7 	b	4000c114 <fs_close+0x6c>

000000004000c13c <fs_read>:
	if (zfp->mp == NULL) {
    4000c13c:	f9400403 	ldr	x3, [x0, #8]
    4000c140:	b40003a3 	cbz	x3, 4000c1b4 <fs_read+0x78>
	CHECKIF(zfp->mp->fs->read == NULL) {
    4000c144:	f9401c63 	ldr	x3, [x3, #56]
    4000c148:	f9400463 	ldr	x3, [x3, #8]
    4000c14c:	b4000383 	cbz	x3, 4000c1bc <fs_read+0x80>
{
    4000c150:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000c154:	910003fd 	mov	x29, sp
    4000c158:	f9000bf3 	str	x19, [sp, #16]
	rc = zfp->mp->fs->read(zfp, ptr, size);
    4000c15c:	d63f0060 	blr	x3
	if (rc < 0) {
    4000c160:	93407c13 	sxtw	x19, w0
    4000c164:	36f80200 	tbz	w0, #31, 4000c1a4 <fs_read+0x68>
		LOG_ERR("file read error (%d)", rc);
    4000c168:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c16c:	91291002 	add	x2, x0, #0xa44
    4000c170:	b94a4400 	ldr	w0, [x0, #2628]
    4000c174:	f240081f 	tst	x0, #0x7
    4000c178:	54000160 	b.eq	4000c1a4 <fs_read+0x68>  // b.none
    4000c17c:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c180:	91290000 	add	x0, x0, #0xa40
    4000c184:	cb000042 	sub	x2, x2, x0
    4000c188:	aa1303e1 	mov	x1, x19
    4000c18c:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c190:	912e5400 	add	x0, x0, #0xb95
    4000c194:	d342fc42 	lsr	x2, x2, #2
    4000c198:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c19c:	32000042 	orr	w2, w2, #0x1
    4000c1a0:	97ffdeaf 	bl	40003c5c <log_1>
	return rc;
    4000c1a4:	aa1303e0 	mov	x0, x19
}
    4000c1a8:	f9400bf3 	ldr	x19, [sp, #16]
    4000c1ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000c1b0:	d65f03c0 	ret
		return -EBADF;
    4000c1b4:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4000c1b8:	d65f03c0 	ret
		return -ENOTSUP;
    4000c1bc:	928010a0 	mov	x0, #0xffffffffffffff7a    	// #-134
}
    4000c1c0:	d65f03c0 	ret

000000004000c1c4 <fs_write>:
	if (zfp->mp == NULL) {
    4000c1c4:	f9400403 	ldr	x3, [x0, #8]
    4000c1c8:	b40003a3 	cbz	x3, 4000c23c <fs_write+0x78>
	CHECKIF(zfp->mp->fs->write == NULL) {
    4000c1cc:	f9401c63 	ldr	x3, [x3, #56]
    4000c1d0:	f9400863 	ldr	x3, [x3, #16]
    4000c1d4:	b4000383 	cbz	x3, 4000c244 <fs_write+0x80>
{
    4000c1d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000c1dc:	910003fd 	mov	x29, sp
    4000c1e0:	f9000bf3 	str	x19, [sp, #16]
	rc = zfp->mp->fs->write(zfp, ptr, size);
    4000c1e4:	d63f0060 	blr	x3
	if (rc < 0) {
    4000c1e8:	93407c13 	sxtw	x19, w0
    4000c1ec:	36f80200 	tbz	w0, #31, 4000c22c <fs_write+0x68>
		LOG_ERR("file write error (%d)", rc);
    4000c1f0:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c1f4:	91291002 	add	x2, x0, #0xa44
    4000c1f8:	b94a4400 	ldr	w0, [x0, #2628]
    4000c1fc:	f240081f 	tst	x0, #0x7
    4000c200:	54000160 	b.eq	4000c22c <fs_write+0x68>  // b.none
    4000c204:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c208:	91290000 	add	x0, x0, #0xa40
    4000c20c:	cb000042 	sub	x2, x2, x0
    4000c210:	aa1303e1 	mov	x1, x19
    4000c214:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c218:	912ea800 	add	x0, x0, #0xbaa
    4000c21c:	d342fc42 	lsr	x2, x2, #2
    4000c220:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c224:	32000042 	orr	w2, w2, #0x1
    4000c228:	97ffde8d 	bl	40003c5c <log_1>
	return rc;
    4000c22c:	aa1303e0 	mov	x0, x19
}
    4000c230:	f9400bf3 	ldr	x19, [sp, #16]
    4000c234:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000c238:	d65f03c0 	ret
		return -EBADF;
    4000c23c:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
    4000c240:	d65f03c0 	ret
		return -ENOTSUP;
    4000c244:	928010a0 	mov	x0, #0xffffffffffffff7a    	// #-134
}
    4000c248:	d65f03c0 	ret

000000004000c24c <fs_seek>:
{
    4000c24c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000c250:	910003fd 	mov	x29, sp
	if (zfp->mp == NULL) {
    4000c254:	f9400403 	ldr	x3, [x0, #8]
{
    4000c258:	f9000bf3 	str	x19, [sp, #16]
	if (zfp->mp == NULL) {
    4000c25c:	b4000343 	cbz	x3, 4000c2c4 <fs_seek+0x78>
	CHECKIF(zfp->mp->fs->lseek == NULL) {
    4000c260:	f9401c63 	ldr	x3, [x3, #56]
    4000c264:	f9400c63 	ldr	x3, [x3, #24]
    4000c268:	b4000323 	cbz	x3, 4000c2cc <fs_seek+0x80>
	rc = zfp->mp->fs->lseek(zfp, offset, whence);
    4000c26c:	d63f0060 	blr	x3
    4000c270:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c274:	36f80200 	tbz	w0, #31, 4000c2b4 <fs_seek+0x68>
		LOG_ERR("file seek error (%d)", rc);
    4000c278:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c27c:	91291002 	add	x2, x0, #0xa44
    4000c280:	b94a4400 	ldr	w0, [x0, #2628]
    4000c284:	f240081f 	tst	x0, #0x7
    4000c288:	54000160 	b.eq	4000c2b4 <fs_seek+0x68>  // b.none
    4000c28c:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c290:	91290000 	add	x0, x0, #0xa40
    4000c294:	cb000042 	sub	x2, x2, x0
    4000c298:	93407e61 	sxtw	x1, w19
    4000c29c:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c2a0:	912f0000 	add	x0, x0, #0xbc0
    4000c2a4:	d342fc42 	lsr	x2, x2, #2
    4000c2a8:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c2ac:	32000042 	orr	w2, w2, #0x1
    4000c2b0:	97ffde6b 	bl	40003c5c <log_1>
}
    4000c2b4:	2a1303e0 	mov	w0, w19
    4000c2b8:	f9400bf3 	ldr	x19, [sp, #16]
    4000c2bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000c2c0:	d65f03c0 	ret
		return -EBADF;
    4000c2c4:	12800113 	mov	w19, #0xfffffff7            	// #-9
    4000c2c8:	17fffffb 	b	4000c2b4 <fs_seek+0x68>
		return -ENOTSUP;
    4000c2cc:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000c2d0:	17fffff9 	b	4000c2b4 <fs_seek+0x68>

000000004000c2d4 <fs_truncate>:
{
    4000c2d4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000c2d8:	910003fd 	mov	x29, sp
	if (zfp->mp == NULL) {
    4000c2dc:	f9400402 	ldr	x2, [x0, #8]
{
    4000c2e0:	f9000bf3 	str	x19, [sp, #16]
	if (zfp->mp == NULL) {
    4000c2e4:	b4000342 	cbz	x2, 4000c34c <fs_truncate+0x78>
	CHECKIF(zfp->mp->fs->truncate == NULL) {
    4000c2e8:	f9401c42 	ldr	x2, [x2, #56]
    4000c2ec:	f9401442 	ldr	x2, [x2, #40]
    4000c2f0:	b4000322 	cbz	x2, 4000c354 <fs_truncate+0x80>
	rc = zfp->mp->fs->truncate(zfp, length);
    4000c2f4:	d63f0040 	blr	x2
    4000c2f8:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c2fc:	36f80200 	tbz	w0, #31, 4000c33c <fs_truncate+0x68>
		LOG_ERR("file truncate error (%d)", rc);
    4000c300:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c304:	91291002 	add	x2, x0, #0xa44
    4000c308:	b94a4400 	ldr	w0, [x0, #2628]
    4000c30c:	f240081f 	tst	x0, #0x7
    4000c310:	54000160 	b.eq	4000c33c <fs_truncate+0x68>  // b.none
    4000c314:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c318:	91290000 	add	x0, x0, #0xa40
    4000c31c:	cb000042 	sub	x2, x2, x0
    4000c320:	93407e61 	sxtw	x1, w19
    4000c324:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c328:	912f5400 	add	x0, x0, #0xbd5
    4000c32c:	d342fc42 	lsr	x2, x2, #2
    4000c330:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c334:	32000042 	orr	w2, w2, #0x1
    4000c338:	97ffde49 	bl	40003c5c <log_1>
}
    4000c33c:	2a1303e0 	mov	w0, w19
    4000c340:	f9400bf3 	ldr	x19, [sp, #16]
    4000c344:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000c348:	d65f03c0 	ret
		return -EBADF;
    4000c34c:	12800113 	mov	w19, #0xfffffff7            	// #-9
    4000c350:	17fffffb 	b	4000c33c <fs_truncate+0x68>
		return -ENOTSUP;
    4000c354:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000c358:	17fffff9 	b	4000c33c <fs_truncate+0x68>

000000004000c35c <fs_opendir>:
{
    4000c35c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000c360:	910003fd 	mov	x29, sp
    4000c364:	a90153f3 	stp	x19, x20, [sp, #16]
    4000c368:	f90013f5 	str	x21, [sp, #32]
	if ((abs_path == NULL) ||
    4000c36c:	b5000221 	cbnz	x1, 4000c3b0 <fs_opendir+0x54>
		LOG_ERR("invalid directory name!!");
    4000c370:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c374:	91291001 	add	x1, x0, #0xa44
    4000c378:	b94a4400 	ldr	w0, [x0, #2628]
    4000c37c:	f240081f 	tst	x0, #0x7
    4000c380:	54000140 	b.eq	4000c3a8 <fs_opendir+0x4c>  // b.none
    4000c384:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c388:	91290000 	add	x0, x0, #0xa40
    4000c38c:	cb000021 	sub	x1, x1, x0
    4000c390:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c394:	912fb800 	add	x0, x0, #0xbee
    4000c398:	d342fc21 	lsr	x1, x1, #2
    4000c39c:	531a2421 	ubfiz	w1, w1, #6, #10
    4000c3a0:	32000021 	orr	w1, w1, #0x1
    4000c3a4:	97ffde1f 	bl	40003c20 <log_0>
		return -EINVAL;
    4000c3a8:	128002b3 	mov	w19, #0xffffffea            	// #-22
    4000c3ac:	1400001c 	b	4000c41c <fs_opendir+0xc0>
    4000c3b0:	aa0003f4 	mov	x20, x0
    4000c3b4:	aa0103f5 	mov	x21, x1
			(strlen(abs_path) < 1) || (abs_path[0] != '/')) {
    4000c3b8:	aa0103e0 	mov	x0, x1
    4000c3bc:	97fffdfd 	bl	4000bbb0 <strlen>
	if ((abs_path == NULL) ||
    4000c3c0:	b4fffd80 	cbz	x0, 4000c370 <fs_opendir+0x14>
			(strlen(abs_path) < 1) || (abs_path[0] != '/')) {
    4000c3c4:	394002a0 	ldrb	w0, [x21]
    4000c3c8:	7100bc1f 	cmp	w0, #0x2f
    4000c3cc:	54fffd21 	b.ne	4000c370 <fs_opendir+0x14>  // b.any
	if (zdp->mp != NULL || zdp->dirp != NULL) {
    4000c3d0:	f9400680 	ldr	x0, [x20, #8]
    4000c3d4:	b50008e0 	cbnz	x0, 4000c4f0 <fs_opendir+0x194>
    4000c3d8:	f9400280 	ldr	x0, [x20]
    4000c3dc:	b50008a0 	cbnz	x0, 4000c4f0 <fs_opendir+0x194>
	if (strcmp(abs_path, "/") == 0) {
    4000c3e0:	aa1503e0 	mov	x0, x21
    4000c3e4:	b0000041 	adrp	x1, 40015000 <tabulator.1+0x262>
    4000c3e8:	91301c21 	add	x1, x1, #0xc07
    4000c3ec:	97fffe01 	bl	4000bbf0 <strcmp>
    4000c3f0:	2a0003f3 	mov	w19, w0
    4000c3f4:	350001e0 	cbnz	w0, 4000c430 <fs_opendir+0xd4>
		k_mutex_lock(&mutex, K_FOREVER);
    4000c3f8:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4000c3fc:	97fffe84 	bl	4000be0c <k_mutex_lock.constprop.0.isra.0>
	return list->head == list;
    4000c400:	b00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000c404:	911ae001 	add	x1, x0, #0x6b8
    4000c408:	f9435c00 	ldr	x0, [x0, #1720]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000c40c:	eb01001f 	cmp	x0, x1
    4000c410:	9a8003e0 	csel	x0, xzr, x0, eq  // eq = none
		zdp->mp = NULL;
    4000c414:	a9007e80 	stp	x0, xzr, [x20]
		k_mutex_unlock(&mutex);
    4000c418:	97fffe81 	bl	4000be1c <k_mutex_unlock.constprop.0.isra.0>
}
    4000c41c:	2a1303e0 	mov	w0, w19
    4000c420:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000c424:	f94013f5 	ldr	x21, [sp, #32]
    4000c428:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000c42c:	d65f03c0 	ret
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    4000c430:	aa1503e1 	mov	x1, x21
    4000c434:	9100e3e0 	add	x0, sp, #0x38
    4000c438:	d2800002 	mov	x2, #0x0                   	// #0
    4000c43c:	97fffe7b 	bl	4000be28 <fs_get_mnt_point>
    4000c440:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c444:	36f80200 	tbz	w0, #31, 4000c484 <fs_opendir+0x128>
		LOG_ERR("mount point not found!!");
    4000c448:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c44c:	91291001 	add	x1, x0, #0xa44
    4000c450:	b94a4400 	ldr	w0, [x0, #2628]
    4000c454:	f240081f 	tst	x0, #0x7
    4000c458:	54fffe20 	b.eq	4000c41c <fs_opendir+0xc0>  // b.none
    4000c45c:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c460:	91290000 	add	x0, x0, #0xa40
    4000c464:	cb000021 	sub	x1, x1, x0
    4000c468:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c46c:	912d4800 	add	x0, x0, #0xb52
    4000c470:	d342fc21 	lsr	x1, x1, #2
    4000c474:	531a2421 	ubfiz	w1, w1, #6, #10
    4000c478:	32000021 	orr	w1, w1, #0x1
    4000c47c:	97ffdde9 	bl	40003c20 <log_0>
    4000c480:	17ffffe7 	b	4000c41c <fs_opendir+0xc0>
	CHECKIF(mp->fs->opendir == NULL) {
    4000c484:	f9401fe0 	ldr	x0, [sp, #56]
    4000c488:	f9401c01 	ldr	x1, [x0, #56]
    4000c48c:	f9402022 	ldr	x2, [x1, #64]
    4000c490:	b4000342 	cbz	x2, 4000c4f8 <fs_opendir+0x19c>
	zdp->mp = mp;
    4000c494:	f9000680 	str	x0, [x20, #8]
	rc = zdp->mp->fs->opendir(zdp, abs_path);
    4000c498:	aa1503e1 	mov	x1, x21
    4000c49c:	aa1403e0 	mov	x0, x20
    4000c4a0:	d63f0040 	blr	x2
    4000c4a4:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c4a8:	36fffba0 	tbz	w0, #31, 4000c41c <fs_opendir+0xc0>
		LOG_ERR("directory open error (%d)", rc);
    4000c4ac:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c4b0:	b94a4401 	ldr	w1, [x0, #2628]
		zdp->mp = NULL;
    4000c4b4:	a9007e9f 	stp	xzr, xzr, [x20]
		LOG_ERR("directory open error (%d)", rc);
    4000c4b8:	f240083f 	tst	x1, #0x7
    4000c4bc:	54fffb00 	b.eq	4000c41c <fs_opendir+0xc0>  // b.none
    4000c4c0:	91291002 	add	x2, x0, #0xa44
    4000c4c4:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c4c8:	91290000 	add	x0, x0, #0xa40
    4000c4cc:	93407e61 	sxtw	x1, w19
    4000c4d0:	cb000042 	sub	x2, x2, x0
    4000c4d4:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c4d8:	91302400 	add	x0, x0, #0xc09
    4000c4dc:	d342fc42 	lsr	x2, x2, #2
    4000c4e0:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c4e4:	32000042 	orr	w2, w2, #0x1
    4000c4e8:	97ffdddd 	bl	40003c5c <log_1>
    4000c4ec:	17ffffcc 	b	4000c41c <fs_opendir+0xc0>
		return -EBUSY;
    4000c4f0:	128001f3 	mov	w19, #0xfffffff0            	// #-16
    4000c4f4:	17ffffca 	b	4000c41c <fs_opendir+0xc0>
		return -ENOTSUP;
    4000c4f8:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000c4fc:	17ffffc8 	b	4000c41c <fs_opendir+0xc0>

000000004000c500 <fs_readdir>:
{
    4000c500:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000c504:	910003fd 	mov	x29, sp
    4000c508:	a90363f7 	stp	x23, x24, [sp, #48]
	if (zdp->mp) {
    4000c50c:	f9400417 	ldr	x23, [x0, #8]
{
    4000c510:	a90153f3 	stp	x19, x20, [sp, #16]
    4000c514:	aa0103f4 	mov	x20, x1
    4000c518:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000c51c:	aa0003f5 	mov	x21, x0
	if (zdp->mp) {
    4000c520:	b4000477 	cbz	x23, 4000c5ac <fs_readdir+0xac>
		CHECKIF(zdp->mp->fs->readdir == NULL) {
    4000c524:	f9401ee0 	ldr	x0, [x23, #56]
    4000c528:	f9402400 	ldr	x0, [x0, #72]
    4000c52c:	b4000920 	cbz	x0, 4000c650 <fs_readdir+0x150>
			if ((strcmp(entry->name, ".") != 0)
    4000c530:	90000056 	adrp	x22, 40014000 <CSWTCH.135+0x90>
    4000c534:	9106eed6 	add	x22, x22, #0x1bb
    4000c538:	91001037 	add	x23, x1, #0x4
			rc = zdp->mp->fs->readdir(zdp, entry);
    4000c53c:	f94006a0 	ldr	x0, [x21, #8]
    4000c540:	aa1403e1 	mov	x1, x20
    4000c544:	f9401c00 	ldr	x0, [x0, #56]
    4000c548:	f9402402 	ldr	x2, [x0, #72]
    4000c54c:	aa1503e0 	mov	x0, x21
    4000c550:	d63f0040 	blr	x2
    4000c554:	2a0003f3 	mov	w19, w0
			if (rc < 0) {
    4000c558:	37f80840 	tbnz	w0, #31, 4000c660 <fs_readdir+0x160>
			if (entry->name[0] == 0) {
    4000c55c:	39401280 	ldrb	w0, [x20, #4]
    4000c560:	340001a0 	cbz	w0, 4000c594 <fs_readdir+0x94>
			if (entry->type != FS_DIR_ENTRY_DIR) {
    4000c564:	b9400280 	ldr	w0, [x20]
    4000c568:	7100041f 	cmp	w0, #0x1
    4000c56c:	54000141 	b.ne	4000c594 <fs_readdir+0x94>  // b.any
			if ((strcmp(entry->name, ".") != 0)
    4000c570:	aa1603e1 	mov	x1, x22
    4000c574:	aa1703e0 	mov	x0, x23
    4000c578:	97fffd9e 	bl	4000bbf0 <strcmp>
    4000c57c:	34fffe00 	cbz	w0, 4000c53c <fs_readdir+0x3c>
			    && (strcmp(entry->name, "..") != 0)) {
    4000c580:	b0000041 	adrp	x1, 40015000 <tabulator.1+0x262>
    4000c584:	91308c21 	add	x1, x1, #0xc23
    4000c588:	aa1703e0 	mov	x0, x23
    4000c58c:	97fffd99 	bl	4000bbf0 <strcmp>
    4000c590:	34fffd60 	cbz	w0, 4000c53c <fs_readdir+0x3c>
}
    4000c594:	2a1303e0 	mov	w0, w19
    4000c598:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000c59c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000c5a0:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000c5a4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000c5a8:	d65f03c0 	ret
	if (zdp->dirp == NULL) {
    4000c5ac:	f9400000 	ldr	x0, [x0]
    4000c5b0:	b5000080 	cbnz	x0, 4000c5c0 <fs_readdir+0xc0>
		entry->name[0] = 0;
    4000c5b4:	3900103f 	strb	wzr, [x1, #4]
	return 0;
    4000c5b8:	52800013 	mov	w19, #0x0                   	// #0
    4000c5bc:	17fffff6 	b	4000c594 <fs_readdir+0x94>
	k_mutex_lock(&mutex, K_FOREVER);
    4000c5c0:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    4000c5c4:	97fffe12 	bl	4000be0c <k_mutex_lock.constprop.0.isra.0>
	return list->head == list;
    4000c5c8:	b00000a0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000c5cc:	911ae018 	add	x24, x0, #0x6b8
    4000c5d0:	f9435c13 	ldr	x19, [x0, #1720]
	return (node == list->tail) ? NULL : node->next;
    4000c5d4:	f9400700 	ldr	x0, [x24, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000c5d8:	eb18027f 	cmp	x19, x24
    4000c5dc:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	SYS_DLIST_FOR_EACH_NODE(&fs_mnt_list, node) {
    4000c5e0:	b5000093 	cbnz	x19, 4000c5f0 <fs_readdir+0xf0>
	sys_dnode_t *node, *next = NULL;
    4000c5e4:	d2800017 	mov	x23, #0x0                   	// #0
	bool found = false;
    4000c5e8:	52800016 	mov	w22, #0x0                   	// #0
    4000c5ec:	14000011 	b	4000c630 <fs_readdir+0x130>
		if (node == zdp->dirp) {
    4000c5f0:	f94002a1 	ldr	x1, [x21]
    4000c5f4:	eb01027f 	cmp	x19, x1
    4000c5f8:	54000241 	b.ne	4000c640 <fs_readdir+0x140>  // b.any
			entry->type = FS_DIR_ENTRY_DIR;
    4000c5fc:	aa1403e0 	mov	x0, x20
    4000c600:	52800036 	mov	w22, #0x1                   	// #1
			strncpy(entry->name, mnt->mnt_point + 1,
    4000c604:	f9400e61 	ldr	x1, [x19, #24]
    4000c608:	d2800182 	mov	x2, #0xc                   	// #12
			entry->type = FS_DIR_ENTRY_DIR;
    4000c60c:	b8004416 	str	w22, [x0], #4
			strncpy(entry->name, mnt->mnt_point + 1,
    4000c610:	91000421 	add	x1, x1, #0x1
    4000c614:	97fffd44 	bl	4000bb24 <strncpy>
			entry->name[sizeof(entry->name) - 1] = 0;
    4000c618:	3900429f 	strb	wzr, [x20, #16]
	return (node == list->tail) ? NULL : node->next;
    4000c61c:	f9400700 	ldr	x0, [x24, #8]
			entry->size = 0;
    4000c620:	f9000e9f 	str	xzr, [x20, #24]
    4000c624:	eb00027f 	cmp	x19, x0
    4000c628:	54000040 	b.eq	4000c630 <fs_readdir+0x130>  // b.none
    4000c62c:	f9400277 	ldr	x23, [x19]
	k_mutex_unlock(&mutex);
    4000c630:	97fffdfb 	bl	4000be1c <k_mutex_unlock.constprop.0.isra.0>
	if (!found) {
    4000c634:	34000136 	cbz	w22, 4000c658 <fs_readdir+0x158>
	zdp->dirp = next;
    4000c638:	f90002b7 	str	x23, [x21]
    4000c63c:	17ffffdf 	b	4000c5b8 <fs_readdir+0xb8>
    4000c640:	eb00027f 	cmp	x19, x0
    4000c644:	54fffd20 	b.eq	4000c5e8 <fs_readdir+0xe8>  // b.none
    4000c648:	f9400273 	ldr	x19, [x19]
    4000c64c:	17ffffe5 	b	4000c5e0 <fs_readdir+0xe0>
			return  -ENOTSUP;
    4000c650:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000c654:	17ffffd0 	b	4000c594 <fs_readdir+0x94>
		return -ENOENT;
    4000c658:	12800033 	mov	w19, #0xfffffffe            	// #-2
    4000c65c:	17ffffce 	b	4000c594 <fs_readdir+0x94>
			LOG_ERR("directory read error (%d)", rc);
    4000c660:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c664:	91291002 	add	x2, x0, #0xa44
    4000c668:	b94a4400 	ldr	w0, [x0, #2628]
    4000c66c:	f240081f 	tst	x0, #0x7
    4000c670:	54fff920 	b.eq	4000c594 <fs_readdir+0x94>  // b.none
    4000c674:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c678:	91290000 	add	x0, x0, #0xa40
    4000c67c:	cb000042 	sub	x2, x2, x0
    4000c680:	93407e61 	sxtw	x1, w19
    4000c684:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c688:	91309800 	add	x0, x0, #0xc26
    4000c68c:	d342fc42 	lsr	x2, x2, #2
    4000c690:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c694:	32000042 	orr	w2, w2, #0x1
    4000c698:	97ffdd71 	bl	40003c5c <log_1>
    4000c69c:	17ffffbe 	b	4000c594 <fs_readdir+0x94>

000000004000c6a0 <fs_closedir>:
{
    4000c6a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000c6a4:	910003fd 	mov	x29, sp
	if (zdp->mp == NULL) {
    4000c6a8:	f9400401 	ldr	x1, [x0, #8]
{
    4000c6ac:	a90153f3 	stp	x19, x20, [sp, #16]
    4000c6b0:	aa0003f4 	mov	x20, x0
	if (zdp->mp == NULL) {
    4000c6b4:	b50000e1 	cbnz	x1, 4000c6d0 <fs_closedir+0x30>
		return 0;
    4000c6b8:	52800013 	mov	w19, #0x0                   	// #0
		zdp->dirp = NULL;
    4000c6bc:	f900001f 	str	xzr, [x0]
}
    4000c6c0:	2a1303e0 	mov	w0, w19
    4000c6c4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000c6c8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000c6cc:	d65f03c0 	ret
	CHECKIF(zdp->mp->fs->closedir == NULL) {
    4000c6d0:	f9401c21 	ldr	x1, [x1, #56]
    4000c6d4:	f9402821 	ldr	x1, [x1, #80]
    4000c6d8:	b40002c1 	cbz	x1, 4000c730 <fs_closedir+0x90>
	rc = zdp->mp->fs->closedir(zdp);
    4000c6dc:	d63f0020 	blr	x1
    4000c6e0:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c6e4:	36f80220 	tbz	w0, #31, 4000c728 <fs_closedir+0x88>
		LOG_ERR("directory close error (%d)", rc);
    4000c6e8:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c6ec:	91291002 	add	x2, x0, #0xa44
    4000c6f0:	b94a4400 	ldr	w0, [x0, #2628]
    4000c6f4:	f240081f 	tst	x0, #0x7
    4000c6f8:	54fffe40 	b.eq	4000c6c0 <fs_closedir+0x20>  // b.none
    4000c6fc:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c700:	91290000 	add	x0, x0, #0xa40
    4000c704:	cb000042 	sub	x2, x2, x0
    4000c708:	93407e61 	sxtw	x1, w19
    4000c70c:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c710:	91310000 	add	x0, x0, #0xc40
    4000c714:	d342fc42 	lsr	x2, x2, #2
    4000c718:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c71c:	32000042 	orr	w2, w2, #0x1
    4000c720:	97ffdd4f 	bl	40003c5c <log_1>
    4000c724:	17ffffe7 	b	4000c6c0 <fs_closedir+0x20>
	zdp->mp = NULL;
    4000c728:	a9007e9f 	stp	xzr, xzr, [x20]
	return rc;
    4000c72c:	17ffffe5 	b	4000c6c0 <fs_closedir+0x20>
		return -ENOTSUP;
    4000c730:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000c734:	17ffffe3 	b	4000c6c0 <fs_closedir+0x20>

000000004000c738 <fs_mkdir>:
{
    4000c738:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000c73c:	910003fd 	mov	x29, sp
    4000c740:	a90153f3 	stp	x19, x20, [sp, #16]
	if ((abs_path == NULL) ||
    4000c744:	b5000220 	cbnz	x0, 4000c788 <fs_mkdir+0x50>
		LOG_ERR("invalid directory name!!");
    4000c748:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c74c:	91291001 	add	x1, x0, #0xa44
    4000c750:	b94a4400 	ldr	w0, [x0, #2628]
    4000c754:	f240081f 	tst	x0, #0x7
    4000c758:	54000140 	b.eq	4000c780 <fs_mkdir+0x48>  // b.none
    4000c75c:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c760:	91290000 	add	x0, x0, #0xa40
    4000c764:	cb000021 	sub	x1, x1, x0
    4000c768:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c76c:	912fb800 	add	x0, x0, #0xbee
    4000c770:	d342fc21 	lsr	x1, x1, #2
    4000c774:	531a2421 	ubfiz	w1, w1, #6, #10
    4000c778:	32000021 	orr	w1, w1, #0x1
    4000c77c:	97ffdd29 	bl	40003c20 <log_0>
		return -EINVAL;
    4000c780:	128002b3 	mov	w19, #0xffffffea            	// #-22
    4000c784:	1400001c 	b	4000c7f4 <fs_mkdir+0xbc>
    4000c788:	aa0003f4 	mov	x20, x0
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    4000c78c:	97fffd09 	bl	4000bbb0 <strlen>
	if ((abs_path == NULL) ||
    4000c790:	f100041f 	cmp	x0, #0x1
    4000c794:	54fffda9 	b.ls	4000c748 <fs_mkdir+0x10>  // b.plast
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    4000c798:	39400280 	ldrb	w0, [x20]
    4000c79c:	7100bc1f 	cmp	w0, #0x2f
    4000c7a0:	54fffd41 	b.ne	4000c748 <fs_mkdir+0x10>  // b.any
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    4000c7a4:	aa1403e1 	mov	x1, x20
    4000c7a8:	9100a3e0 	add	x0, sp, #0x28
    4000c7ac:	d2800002 	mov	x2, #0x0                   	// #0
    4000c7b0:	97fffd9e 	bl	4000be28 <fs_get_mnt_point>
    4000c7b4:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c7b8:	36f80260 	tbz	w0, #31, 4000c804 <fs_mkdir+0xcc>
		LOG_ERR("mount point not found!!");
    4000c7bc:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c7c0:	91291001 	add	x1, x0, #0xa44
    4000c7c4:	b94a4400 	ldr	w0, [x0, #2628]
    4000c7c8:	f240081f 	tst	x0, #0x7
    4000c7cc:	54000140 	b.eq	4000c7f4 <fs_mkdir+0xbc>  // b.none
    4000c7d0:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c7d4:	91290000 	add	x0, x0, #0xa40
    4000c7d8:	cb000021 	sub	x1, x1, x0
    4000c7dc:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c7e0:	912d4800 	add	x0, x0, #0xb52
    4000c7e4:	d342fc21 	lsr	x1, x1, #2
    4000c7e8:	531a2421 	ubfiz	w1, w1, #6, #10
    4000c7ec:	32000021 	orr	w1, w1, #0x1
    4000c7f0:	97ffdd0c 	bl	40003c20 <log_0>
}
    4000c7f4:	2a1303e0 	mov	w0, w19
    4000c7f8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000c7fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000c800:	d65f03c0 	ret
	if (mp->flags & FS_MOUNT_FLAG_READ_ONLY) {
    4000c804:	f94017e0 	ldr	x0, [sp, #40]
    4000c808:	39410001 	ldrb	w1, [x0, #64]
    4000c80c:	37080301 	tbnz	w1, #1, 4000c86c <fs_mkdir+0x134>
	CHECKIF(mp->fs->mkdir == NULL) {
    4000c810:	f9401c01 	ldr	x1, [x0, #56]
    4000c814:	f9403c22 	ldr	x2, [x1, #120]
    4000c818:	b40002e2 	cbz	x2, 4000c874 <fs_mkdir+0x13c>
	rc = mp->fs->mkdir(mp, abs_path);
    4000c81c:	aa1403e1 	mov	x1, x20
    4000c820:	d63f0040 	blr	x2
    4000c824:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c828:	36fffe60 	tbz	w0, #31, 4000c7f4 <fs_mkdir+0xbc>
		LOG_ERR("failed to create directory (%d)", rc);
    4000c82c:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c830:	91291002 	add	x2, x0, #0xa44
    4000c834:	b94a4400 	ldr	w0, [x0, #2628]
    4000c838:	f240081f 	tst	x0, #0x7
    4000c83c:	54fffdc0 	b.eq	4000c7f4 <fs_mkdir+0xbc>  // b.none
    4000c840:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c844:	91290000 	add	x0, x0, #0xa40
    4000c848:	cb000042 	sub	x2, x2, x0
    4000c84c:	93407e61 	sxtw	x1, w19
    4000c850:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c854:	91316c00 	add	x0, x0, #0xc5b
    4000c858:	d342fc42 	lsr	x2, x2, #2
    4000c85c:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c860:	32000042 	orr	w2, w2, #0x1
    4000c864:	97ffdcfe 	bl	40003c5c <log_1>
    4000c868:	17ffffe3 	b	4000c7f4 <fs_mkdir+0xbc>
		return -EROFS;
    4000c86c:	128003b3 	mov	w19, #0xffffffe2            	// #-30
    4000c870:	17ffffe1 	b	4000c7f4 <fs_mkdir+0xbc>
		return -ENOTSUP;
    4000c874:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000c878:	17ffffdf 	b	4000c7f4 <fs_mkdir+0xbc>

000000004000c87c <fs_unlink>:
{
    4000c87c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000c880:	910003fd 	mov	x29, sp
    4000c884:	a90153f3 	stp	x19, x20, [sp, #16]
	if ((abs_path == NULL) ||
    4000c888:	b5000220 	cbnz	x0, 4000c8cc <fs_unlink+0x50>
		LOG_ERR("invalid file name!!");
    4000c88c:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c890:	91291001 	add	x1, x0, #0xa44
    4000c894:	b94a4400 	ldr	w0, [x0, #2628]
    4000c898:	f240081f 	tst	x0, #0x7
    4000c89c:	54000140 	b.eq	4000c8c4 <fs_unlink+0x48>  // b.none
    4000c8a0:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c8a4:	91290000 	add	x0, x0, #0xa40
    4000c8a8:	cb000021 	sub	x1, x1, x0
    4000c8ac:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c8b0:	912cf800 	add	x0, x0, #0xb3e
    4000c8b4:	d342fc21 	lsr	x1, x1, #2
    4000c8b8:	531a2421 	ubfiz	w1, w1, #6, #10
    4000c8bc:	32000021 	orr	w1, w1, #0x1
    4000c8c0:	97ffdcd8 	bl	40003c20 <log_0>
		return -EINVAL;
    4000c8c4:	128002b3 	mov	w19, #0xffffffea            	// #-22
    4000c8c8:	1400001c 	b	4000c938 <fs_unlink+0xbc>
    4000c8cc:	aa0003f4 	mov	x20, x0
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    4000c8d0:	97fffcb8 	bl	4000bbb0 <strlen>
	if ((abs_path == NULL) ||
    4000c8d4:	f100041f 	cmp	x0, #0x1
    4000c8d8:	54fffda9 	b.ls	4000c88c <fs_unlink+0x10>  // b.plast
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    4000c8dc:	39400280 	ldrb	w0, [x20]
    4000c8e0:	7100bc1f 	cmp	w0, #0x2f
    4000c8e4:	54fffd41 	b.ne	4000c88c <fs_unlink+0x10>  // b.any
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    4000c8e8:	aa1403e1 	mov	x1, x20
    4000c8ec:	9100a3e0 	add	x0, sp, #0x28
    4000c8f0:	d2800002 	mov	x2, #0x0                   	// #0
    4000c8f4:	97fffd4d 	bl	4000be28 <fs_get_mnt_point>
    4000c8f8:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c8fc:	36f80260 	tbz	w0, #31, 4000c948 <fs_unlink+0xcc>
		LOG_ERR("mount point not found!!");
    4000c900:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c904:	91291001 	add	x1, x0, #0xa44
    4000c908:	b94a4400 	ldr	w0, [x0, #2628]
    4000c90c:	f240081f 	tst	x0, #0x7
    4000c910:	54000140 	b.eq	4000c938 <fs_unlink+0xbc>  // b.none
    4000c914:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c918:	91290000 	add	x0, x0, #0xa40
    4000c91c:	cb000021 	sub	x1, x1, x0
    4000c920:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c924:	912d4800 	add	x0, x0, #0xb52
    4000c928:	d342fc21 	lsr	x1, x1, #2
    4000c92c:	531a2421 	ubfiz	w1, w1, #6, #10
    4000c930:	32000021 	orr	w1, w1, #0x1
    4000c934:	97ffdcbb 	bl	40003c20 <log_0>
}
    4000c938:	2a1303e0 	mov	w0, w19
    4000c93c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000c940:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000c944:	d65f03c0 	ret
	if (mp->flags & FS_MOUNT_FLAG_READ_ONLY) {
    4000c948:	f94017e0 	ldr	x0, [sp, #40]
    4000c94c:	39410001 	ldrb	w1, [x0, #64]
    4000c950:	37080301 	tbnz	w1, #1, 4000c9b0 <fs_unlink+0x134>
	CHECKIF(mp->fs->unlink == NULL) {
    4000c954:	f9401c01 	ldr	x1, [x0, #56]
    4000c958:	f9403422 	ldr	x2, [x1, #104]
    4000c95c:	b40002e2 	cbz	x2, 4000c9b8 <fs_unlink+0x13c>
	rc = mp->fs->unlink(mp, abs_path);
    4000c960:	aa1403e1 	mov	x1, x20
    4000c964:	d63f0040 	blr	x2
    4000c968:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000c96c:	36fffe60 	tbz	w0, #31, 4000c938 <fs_unlink+0xbc>
		LOG_ERR("failed to unlink path (%d)", rc);
    4000c970:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c974:	91291002 	add	x2, x0, #0xa44
    4000c978:	b94a4400 	ldr	w0, [x0, #2628]
    4000c97c:	f240081f 	tst	x0, #0x7
    4000c980:	54fffdc0 	b.eq	4000c938 <fs_unlink+0xbc>  // b.none
    4000c984:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c988:	91290000 	add	x0, x0, #0xa40
    4000c98c:	cb000042 	sub	x2, x2, x0
    4000c990:	93407e61 	sxtw	x1, w19
    4000c994:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c998:	9131ec00 	add	x0, x0, #0xc7b
    4000c99c:	d342fc42 	lsr	x2, x2, #2
    4000c9a0:	531a2442 	ubfiz	w2, w2, #6, #10
    4000c9a4:	32000042 	orr	w2, w2, #0x1
    4000c9a8:	97ffdcad 	bl	40003c5c <log_1>
    4000c9ac:	17ffffe3 	b	4000c938 <fs_unlink+0xbc>
		return -EROFS;
    4000c9b0:	128003b3 	mov	w19, #0xffffffe2            	// #-30
    4000c9b4:	17ffffe1 	b	4000c938 <fs_unlink+0xbc>
		return -ENOTSUP;
    4000c9b8:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000c9bc:	17ffffdf 	b	4000c938 <fs_unlink+0xbc>

000000004000c9c0 <fs_stat>:
{
    4000c9c0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000c9c4:	910003fd 	mov	x29, sp
    4000c9c8:	a90153f3 	stp	x19, x20, [sp, #16]
    4000c9cc:	f90013f5 	str	x21, [sp, #32]
	if ((abs_path == NULL) ||
    4000c9d0:	b5000220 	cbnz	x0, 4000ca14 <fs_stat+0x54>
		LOG_ERR("invalid file or dir name!!");
    4000c9d4:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c9d8:	91291001 	add	x1, x0, #0xa44
    4000c9dc:	b94a4400 	ldr	w0, [x0, #2628]
    4000c9e0:	f240081f 	tst	x0, #0x7
    4000c9e4:	54000140 	b.eq	4000ca0c <fs_stat+0x4c>  // b.none
    4000c9e8:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000c9ec:	91290000 	add	x0, x0, #0xa40
    4000c9f0:	cb000021 	sub	x1, x1, x0
    4000c9f4:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000c9f8:	91325800 	add	x0, x0, #0xc96
    4000c9fc:	d342fc21 	lsr	x1, x1, #2
    4000ca00:	531a2421 	ubfiz	w1, w1, #6, #10
    4000ca04:	32000021 	orr	w1, w1, #0x1
    4000ca08:	97ffdc86 	bl	40003c20 <log_0>
		return -EINVAL;
    4000ca0c:	128002b3 	mov	w19, #0xffffffea            	// #-22
    4000ca10:	1400001d 	b	4000ca84 <fs_stat+0xc4>
    4000ca14:	aa0003f4 	mov	x20, x0
    4000ca18:	aa0103f5 	mov	x21, x1
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    4000ca1c:	97fffc65 	bl	4000bbb0 <strlen>
	if ((abs_path == NULL) ||
    4000ca20:	f100041f 	cmp	x0, #0x1
    4000ca24:	54fffd89 	b.ls	4000c9d4 <fs_stat+0x14>  // b.plast
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    4000ca28:	39400280 	ldrb	w0, [x20]
    4000ca2c:	7100bc1f 	cmp	w0, #0x2f
    4000ca30:	54fffd21 	b.ne	4000c9d4 <fs_stat+0x14>  // b.any
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    4000ca34:	aa1403e1 	mov	x1, x20
    4000ca38:	9100e3e0 	add	x0, sp, #0x38
    4000ca3c:	d2800002 	mov	x2, #0x0                   	// #0
    4000ca40:	97fffcfa 	bl	4000be28 <fs_get_mnt_point>
    4000ca44:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000ca48:	36f80280 	tbz	w0, #31, 4000ca98 <fs_stat+0xd8>
		LOG_ERR("mount point not found!!");
    4000ca4c:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000ca50:	91291001 	add	x1, x0, #0xa44
    4000ca54:	b94a4400 	ldr	w0, [x0, #2628]
    4000ca58:	f240081f 	tst	x0, #0x7
    4000ca5c:	54000140 	b.eq	4000ca84 <fs_stat+0xc4>  // b.none
    4000ca60:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000ca64:	91290000 	add	x0, x0, #0xa40
    4000ca68:	cb000021 	sub	x1, x1, x0
    4000ca6c:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000ca70:	912d4800 	add	x0, x0, #0xb52
    4000ca74:	d342fc21 	lsr	x1, x1, #2
    4000ca78:	531a2421 	ubfiz	w1, w1, #6, #10
    4000ca7c:	32000021 	orr	w1, w1, #0x1
    4000ca80:	97ffdc68 	bl	40003c20 <log_0>
}
    4000ca84:	2a1303e0 	mov	w0, w19
    4000ca88:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ca8c:	f94013f5 	ldr	x21, [sp, #32]
    4000ca90:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000ca94:	d65f03c0 	ret
	CHECKIF(mp->fs->stat == NULL) {
    4000ca98:	f9401fe0 	ldr	x0, [sp, #56]
    4000ca9c:	f9401c01 	ldr	x1, [x0, #56]
    4000caa0:	f9404023 	ldr	x3, [x1, #128]
    4000caa4:	b4000303 	cbz	x3, 4000cb04 <fs_stat+0x144>
	rc = mp->fs->stat(mp, abs_path, entry);
    4000caa8:	aa1503e2 	mov	x2, x21
    4000caac:	aa1403e1 	mov	x1, x20
    4000cab0:	d63f0060 	blr	x3
    4000cab4:	2a0003f3 	mov	w19, w0
	if (rc == -ENOENT) {
    4000cab8:	3100081f 	cmn	w0, #0x2
    4000cabc:	54fffe40 	b.eq	4000ca84 <fs_stat+0xc4>  // b.none
	} else if (rc < 0) {
    4000cac0:	36fffe20 	tbz	w0, #31, 4000ca84 <fs_stat+0xc4>
		LOG_ERR("failed get file or dir stat (%d)", rc);
    4000cac4:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000cac8:	91291002 	add	x2, x0, #0xa44
    4000cacc:	b94a4400 	ldr	w0, [x0, #2628]
    4000cad0:	f240081f 	tst	x0, #0x7
    4000cad4:	54fffd80 	b.eq	4000ca84 <fs_stat+0xc4>  // b.none
    4000cad8:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000cadc:	91290000 	add	x0, x0, #0xa40
    4000cae0:	cb000042 	sub	x2, x2, x0
    4000cae4:	93407e61 	sxtw	x1, w19
    4000cae8:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000caec:	9132c400 	add	x0, x0, #0xcb1
    4000caf0:	d342fc42 	lsr	x2, x2, #2
    4000caf4:	531a2442 	ubfiz	w2, w2, #6, #10
    4000caf8:	32000042 	orr	w2, w2, #0x1
    4000cafc:	97ffdc58 	bl	40003c5c <log_1>
    4000cb00:	17ffffe1 	b	4000ca84 <fs_stat+0xc4>
		return -ENOTSUP;
    4000cb04:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000cb08:	17ffffdf 	b	4000ca84 <fs_stat+0xc4>

000000004000cb0c <fs_statvfs>:
{
    4000cb0c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000cb10:	910003fd 	mov	x29, sp
    4000cb14:	a90153f3 	stp	x19, x20, [sp, #16]
    4000cb18:	f90013f5 	str	x21, [sp, #32]
	if ((abs_path == NULL) ||
    4000cb1c:	b5000220 	cbnz	x0, 4000cb60 <fs_statvfs+0x54>
		LOG_ERR("invalid file or dir name!!");
    4000cb20:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000cb24:	91291001 	add	x1, x0, #0xa44
    4000cb28:	b94a4400 	ldr	w0, [x0, #2628]
    4000cb2c:	f240081f 	tst	x0, #0x7
    4000cb30:	54000140 	b.eq	4000cb58 <fs_statvfs+0x4c>  // b.none
    4000cb34:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000cb38:	91290000 	add	x0, x0, #0xa40
    4000cb3c:	cb000021 	sub	x1, x1, x0
    4000cb40:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000cb44:	91325800 	add	x0, x0, #0xc96
    4000cb48:	d342fc21 	lsr	x1, x1, #2
    4000cb4c:	531a2421 	ubfiz	w1, w1, #6, #10
    4000cb50:	32000021 	orr	w1, w1, #0x1
    4000cb54:	97ffdc33 	bl	40003c20 <log_0>
		return -EINVAL;
    4000cb58:	128002b3 	mov	w19, #0xffffffea            	// #-22
    4000cb5c:	1400001d 	b	4000cbd0 <fs_statvfs+0xc4>
    4000cb60:	aa0003f4 	mov	x20, x0
    4000cb64:	aa0103f5 	mov	x21, x1
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    4000cb68:	97fffc12 	bl	4000bbb0 <strlen>
	if ((abs_path == NULL) ||
    4000cb6c:	f100041f 	cmp	x0, #0x1
    4000cb70:	54fffd89 	b.ls	4000cb20 <fs_statvfs+0x14>  // b.plast
			(strlen(abs_path) <= 1) || (abs_path[0] != '/')) {
    4000cb74:	39400280 	ldrb	w0, [x20]
    4000cb78:	7100bc1f 	cmp	w0, #0x2f
    4000cb7c:	54fffd21 	b.ne	4000cb20 <fs_statvfs+0x14>  // b.any
	rc = fs_get_mnt_point(&mp, abs_path, NULL);
    4000cb80:	aa1403e1 	mov	x1, x20
    4000cb84:	9100e3e0 	add	x0, sp, #0x38
    4000cb88:	d2800002 	mov	x2, #0x0                   	// #0
    4000cb8c:	97fffca7 	bl	4000be28 <fs_get_mnt_point>
    4000cb90:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000cb94:	36f80280 	tbz	w0, #31, 4000cbe4 <fs_statvfs+0xd8>
		LOG_ERR("mount point not found!!");
    4000cb98:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000cb9c:	91291001 	add	x1, x0, #0xa44
    4000cba0:	b94a4400 	ldr	w0, [x0, #2628]
    4000cba4:	f240081f 	tst	x0, #0x7
    4000cba8:	54000140 	b.eq	4000cbd0 <fs_statvfs+0xc4>  // b.none
    4000cbac:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000cbb0:	91290000 	add	x0, x0, #0xa40
    4000cbb4:	cb000021 	sub	x1, x1, x0
    4000cbb8:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000cbbc:	912d4800 	add	x0, x0, #0xb52
    4000cbc0:	d342fc21 	lsr	x1, x1, #2
    4000cbc4:	531a2421 	ubfiz	w1, w1, #6, #10
    4000cbc8:	32000021 	orr	w1, w1, #0x1
    4000cbcc:	97ffdc15 	bl	40003c20 <log_0>
}
    4000cbd0:	2a1303e0 	mov	w0, w19
    4000cbd4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000cbd8:	f94013f5 	ldr	x21, [sp, #32]
    4000cbdc:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000cbe0:	d65f03c0 	ret
	CHECKIF(mp->fs->statvfs == NULL) {
    4000cbe4:	f9401fe0 	ldr	x0, [sp, #56]
    4000cbe8:	f9401c01 	ldr	x1, [x0, #56]
    4000cbec:	f9404423 	ldr	x3, [x1, #136]
    4000cbf0:	b40002c3 	cbz	x3, 4000cc48 <fs_statvfs+0x13c>
	rc = mp->fs->statvfs(mp, abs_path, stat);
    4000cbf4:	aa1503e2 	mov	x2, x21
    4000cbf8:	aa1403e1 	mov	x1, x20
    4000cbfc:	d63f0060 	blr	x3
    4000cc00:	2a0003f3 	mov	w19, w0
	if (rc < 0) {
    4000cc04:	36fffe60 	tbz	w0, #31, 4000cbd0 <fs_statvfs+0xc4>
		LOG_ERR("failed get file or dir stat (%d)", rc);
    4000cc08:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000cc0c:	91291002 	add	x2, x0, #0xa44
    4000cc10:	b94a4400 	ldr	w0, [x0, #2628]
    4000cc14:	f240081f 	tst	x0, #0x7
    4000cc18:	54fffdc0 	b.eq	4000cbd0 <fs_statvfs+0xc4>  // b.none
    4000cc1c:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000cc20:	91290000 	add	x0, x0, #0xa40
    4000cc24:	cb000042 	sub	x2, x2, x0
    4000cc28:	93407e61 	sxtw	x1, w19
    4000cc2c:	b0000040 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000cc30:	9132c400 	add	x0, x0, #0xcb1
    4000cc34:	d342fc42 	lsr	x2, x2, #2
    4000cc38:	531a2442 	ubfiz	w2, w2, #6, #10
    4000cc3c:	32000042 	orr	w2, w2, #0x1
    4000cc40:	97ffdc07 	bl	40003c5c <log_1>
    4000cc44:	17ffffe3 	b	4000cbd0 <fs_statvfs+0xc4>
		return -ENOTSUP;
    4000cc48:	128010b3 	mov	w19, #0xffffff7a            	// #-134
    4000cc4c:	17ffffe1 	b	4000cbd0 <fs_statvfs+0xc4>

000000004000cc50 <cmd_pwd>:

	return 0;
}

static int cmd_pwd(const struct shell *shell, size_t argc, char **argv)
{
    4000cc50:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	shell_print(shell, "%s", cwd);
    4000cc54:	52800101 	mov	w1, #0x8                   	// #8
    4000cc58:	f0000303 	adrp	x3, 4006f000 <sys_work_q_stack+0xf20>
    4000cc5c:	9126e063 	add	x3, x3, #0x9b8
{
    4000cc60:	910003fd 	mov	x29, sp
	shell_print(shell, "%s", cwd);
    4000cc64:	90000042 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    4000cc68:	91208c42 	add	x2, x2, #0x823
    4000cc6c:	97ffec3e 	bl	40007d64 <shell_fprintf>

	return 0;
}
    4000cc70:	52800000 	mov	w0, #0x0                   	// #0
    4000cc74:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000cc78:	d65f03c0 	ret

000000004000cc7c <create_abs_path.constprop.0>:
static void create_abs_path(const char *name, char *path, size_t len)
    4000cc7c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000cc80:	910003fd 	mov	x29, sp
    4000cc84:	a90153f3 	stp	x19, x20, [sp, #16]
    4000cc88:	aa0103f3 	mov	x19, x1
    4000cc8c:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000cc90:	aa0003f6 	mov	x22, x0
	if (name[0] == '/') {
    4000cc94:	39400000 	ldrb	w0, [x0]
    4000cc98:	7100bc1f 	cmp	w0, #0x2f
    4000cc9c:	54000141 	b.ne	4000ccc4 <create_abs_path.constprop.0+0x48>  // b.any
		strncpy(path, name, len);
    4000cca0:	aa1603e1 	mov	x1, x22
    4000cca4:	aa1303e0 	mov	x0, x19
    4000cca8:	d2801002 	mov	x2, #0x80                  	// #128
			strncpy(path, name, len);
    4000ccac:	97fffb9e 	bl	4000bb24 <strncpy>
			path[len - 1] = '\0';
    4000ccb0:	3901fe7f 	strb	wzr, [x19, #127]
}
    4000ccb4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ccb8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000ccbc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000ccc0:	d65f03c0 	ret
		if (cwd[1] == '\0') {
    4000ccc4:	f0000301 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
    4000ccc8:	9126e021 	add	x1, x1, #0x9b8
    4000cccc:	39400420 	ldrb	w0, [x1, #1]
    4000ccd0:	350000e0 	cbnz	w0, 4000ccec <create_abs_path.constprop.0+0x70>
			*path++ = '/';
    4000ccd4:	aa1303e0 	mov	x0, x19
    4000ccd8:	528005e1 	mov	w1, #0x2f                  	// #47
			strncpy(path, name, len);
    4000ccdc:	d2800fe2 	mov	x2, #0x7f                  	// #127
			*path++ = '/';
    4000cce0:	38001401 	strb	w1, [x0], #1
			strncpy(path, name, len);
    4000cce4:	aa1603e1 	mov	x1, x22
    4000cce8:	17fffff1 	b	4000ccac <create_abs_path.constprop.0+0x30>
			strncpy(path, cwd, len);
    4000ccec:	d2801002 	mov	x2, #0x80                  	// #128
    4000ccf0:	aa1303e0 	mov	x0, x19
    4000ccf4:	97fffb8c 	bl	4000bb24 <strncpy>
			path[len - 1] = '\0';
    4000ccf8:	3901fe7f 	strb	wzr, [x19, #127]
			size_t plen = strlen(path);
    4000ccfc:	aa1303e0 	mov	x0, x19
    4000cd00:	97fffbac 	bl	4000bbb0 <strlen>
    4000cd04:	aa0003f4 	mov	x20, x0
			if (plen < len) {
    4000cd08:	f101fc1f 	cmp	x0, #0x7f
    4000cd0c:	54fffd48 	b.hi	4000ccb4 <create_abs_path.constprop.0+0x38>  // b.pmore
				path += plen;
    4000cd10:	8b000275 	add	x21, x19, x0
				strncpy(path, name, len);
    4000cd14:	d2800fe2 	mov	x2, #0x7f                  	// #127
				*path++ = '/';
    4000cd18:	910006b5 	add	x21, x21, #0x1
				strncpy(path, name, len);
    4000cd1c:	cb140042 	sub	x2, x2, x20
				*path++ = '/';
    4000cd20:	528005e0 	mov	w0, #0x2f                  	// #47
    4000cd24:	38346a60 	strb	w0, [x19, x20]
				path[len - 1] = '\0';
    4000cd28:	cb1402b4 	sub	x20, x21, x20
				strncpy(path, name, len);
    4000cd2c:	aa1603e1 	mov	x1, x22
    4000cd30:	aa1503e0 	mov	x0, x21
    4000cd34:	97fffb7c 	bl	4000bb24 <strncpy>
				path[len - 1] = '\0';
    4000cd38:	3901fa9f 	strb	wzr, [x20, #126]
}
    4000cd3c:	17ffffde 	b	4000ccb4 <create_abs_path.constprop.0+0x38>

000000004000cd40 <cmd_cd>:
{
    4000cd40:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
	if (argc < 2) {
    4000cd44:	f100043f 	cmp	x1, #0x1
{
    4000cd48:	910003fd 	mov	x29, sp
    4000cd4c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000cd50:	f90013f5 	str	x21, [sp, #32]
	if (argc < 2) {
    4000cd54:	54000188 	b.hi	4000cd84 <cmd_cd+0x44>  // b.pmore
		return 0;
    4000cd58:	52800013 	mov	w19, #0x0                   	// #0
		strcpy(cwd, "/");
    4000cd5c:	b0000041 	adrp	x1, 40015000 <tabulator.1+0x262>
    4000cd60:	91301c21 	add	x1, x1, #0xc07
    4000cd64:	f0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000cd68:	9126e000 	add	x0, x0, #0x9b8
    4000cd6c:	97fffb65 	bl	4000bb00 <strcpy>
}
    4000cd70:	2a1303e0 	mov	w0, w19
    4000cd74:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000cd78:	f94013f5 	ldr	x21, [sp, #32]
    4000cd7c:	a8cd7bfd 	ldp	x29, x30, [sp], #208
    4000cd80:	d65f03c0 	ret
    4000cd84:	aa0003f4 	mov	x20, x0
    4000cd88:	aa0203f5 	mov	x21, x2
	if (strcmp(argv[1], "..") == 0) {
    4000cd8c:	f9400440 	ldr	x0, [x2, #8]
    4000cd90:	b0000041 	adrp	x1, 40015000 <tabulator.1+0x262>
    4000cd94:	91308c21 	add	x1, x1, #0xc23
    4000cd98:	97fffb96 	bl	4000bbf0 <strcmp>
    4000cd9c:	2a0003f3 	mov	w19, w0
    4000cda0:	35000160 	cbnz	w0, 4000cdcc <cmd_cd+0x8c>
		char *prev = strrchr(cwd, '/');
    4000cda4:	f0000314 	adrp	x20, 4006f000 <sys_work_q_stack+0xf20>
    4000cda8:	9126e294 	add	x20, x20, #0x9b8
    4000cdac:	aa1403e0 	mov	x0, x20
    4000cdb0:	528005e1 	mov	w1, #0x2f                  	// #47
    4000cdb4:	97fffb76 	bl	4000bb8c <strrchr>
		if (!prev || prev == cwd) {
    4000cdb8:	b4fffd00 	cbz	x0, 4000cd58 <cmd_cd+0x18>
    4000cdbc:	eb14001f 	cmp	x0, x20
    4000cdc0:	54fffcc0 	b.eq	4000cd58 <cmd_cd+0x18>  // b.none
			*prev = '\0';
    4000cdc4:	3900001f 	strb	wzr, [x0]
    4000cdc8:	17ffffea 	b	4000cd70 <cmd_cd+0x30>
	create_abs_path(argv[1], path, sizeof(path));
    4000cdcc:	f94006a0 	ldr	x0, [x21, #8]
    4000cdd0:	910143e1 	add	x1, sp, #0x50
    4000cdd4:	97ffffaa 	bl	4000cc7c <create_abs_path.constprop.0>
	err = fs_stat(path, &entry);
    4000cdd8:	9100c3e1 	add	x1, sp, #0x30
    4000cddc:	910143e0 	add	x0, sp, #0x50
    4000cde0:	97fffef8 	bl	4000c9c0 <fs_stat>
    4000cde4:	2a0003f3 	mov	w19, w0
	if (err) {
    4000cde8:	34000120 	cbz	w0, 4000ce0c <cmd_cd+0xcc>
		shell_error(shell, "%s doesn't exist", path);
    4000cdec:	b0000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000cdf0:	91334842 	add	x2, x2, #0xcd2
    4000cdf4:	910143e3 	add	x3, sp, #0x50
		shell_error(shell, "%s is not a directory", path);
    4000cdf8:	aa1403e0 	mov	x0, x20
    4000cdfc:	52800021 	mov	w1, #0x1                   	// #1
		return -ENOEXEC;
    4000ce00:	128000f3 	mov	w19, #0xfffffff8            	// #-8
		shell_error(shell, "%s is not a directory", path);
    4000ce04:	97ffebd8 	bl	40007d64 <shell_fprintf>
		return -ENOEXEC;
    4000ce08:	17ffffda 	b	4000cd70 <cmd_cd+0x30>
	if (entry.type != FS_DIR_ENTRY_DIR) {
    4000ce0c:	b94033e0 	ldr	w0, [sp, #48]
    4000ce10:	7100041f 	cmp	w0, #0x1
    4000ce14:	540000a0 	b.eq	4000ce28 <cmd_cd+0xe8>  // b.none
		shell_error(shell, "%s is not a directory", path);
    4000ce18:	b0000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000ce1c:	91339042 	add	x2, x2, #0xce4
    4000ce20:	910143e3 	add	x3, sp, #0x50
    4000ce24:	17fffff5 	b	4000cdf8 <cmd_cd+0xb8>
	strncpy(cwd, path, sizeof(cwd));
    4000ce28:	f0000314 	adrp	x20, 4006f000 <sys_work_q_stack+0xf20>
    4000ce2c:	9126e294 	add	x20, x20, #0x9b8
    4000ce30:	910143e1 	add	x1, sp, #0x50
    4000ce34:	aa1403e0 	mov	x0, x20
    4000ce38:	d2801002 	mov	x2, #0x80                  	// #128
    4000ce3c:	97fffb3a 	bl	4000bb24 <strncpy>
	cwd[sizeof(cwd) - 1] = '\0';
    4000ce40:	3901fe9f 	strb	wzr, [x20, #127]
	return 0;
    4000ce44:	17ffffcb 	b	4000cd70 <cmd_cd+0x30>

000000004000ce48 <cmd_ls>:
{
    4000ce48:	a9b27bfd 	stp	x29, x30, [sp, #-224]!
	if (argc < 2) {
    4000ce4c:	f100043f 	cmp	x1, #0x1
{
    4000ce50:	910003fd 	mov	x29, sp
    4000ce54:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ce58:	aa0003f4 	mov	x20, x0
    4000ce5c:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (argc < 2) {
    4000ce60:	540003a8 	b.hi	4000ced4 <cmd_ls+0x8c>  // b.pmore
		strncpy(path, cwd, sizeof(path));
    4000ce64:	910183e0 	add	x0, sp, #0x60
    4000ce68:	d2801002 	mov	x2, #0x80                  	// #128
    4000ce6c:	f0000301 	adrp	x1, 4006f000 <sys_work_q_stack+0xf20>
    4000ce70:	9126e021 	add	x1, x1, #0x9b8
    4000ce74:	97fffb2c 	bl	4000bb24 <strncpy>
		path[sizeof(path) - 1] = '\0';
    4000ce78:	39037fff 	strb	wzr, [sp, #223]
	err = fs_opendir(&dir, path);
    4000ce7c:	910183e1 	add	x1, sp, #0x60
    4000ce80:	9100c3e0 	add	x0, sp, #0x30
 * @param zdp Pointer to file object
 *
 */
static inline void fs_dir_t_init(struct fs_dir_t *zdp)
{
	*zdp = (struct fs_dir_t){ 0 };
    4000ce84:	a9037fff 	stp	xzr, xzr, [sp, #48]
    4000ce88:	97fffd35 	bl	4000c35c <fs_opendir>
    4000ce8c:	2a0003f3 	mov	w19, w0
	if (err) {
    4000ce90:	350002a0 	cbnz	w0, 4000cee4 <cmd_ls+0x9c>
		shell_print(shell, "%s%s", entry.name,
    4000ce94:	90000055 	adrp	x21, 40014000 <CSWTCH.135+0x90>
    4000ce98:	911be6b5 	add	x21, x21, #0x6f9
    4000ce9c:	b0000056 	adrp	x22, 40015000 <tabulator.1+0x262>
    4000cea0:	91301ed6 	add	x22, x22, #0xc07
		err = fs_readdir(&dir, &entry);
    4000cea4:	910103e1 	add	x1, sp, #0x40
    4000cea8:	9100c3e0 	add	x0, sp, #0x30
    4000ceac:	97fffd95 	bl	4000c500 <fs_readdir>
		if (err) {
    4000ceb0:	34000340 	cbz	w0, 4000cf18 <cmd_ls+0xd0>
			shell_error(shell, "Unable to read directory");
    4000ceb4:	b0000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000ceb8:	91345c42 	add	x2, x2, #0xd17
    4000cebc:	aa1403e0 	mov	x0, x20
    4000cec0:	52800021 	mov	w1, #0x1                   	// #1
    4000cec4:	97ffeba8 	bl	40007d64 <shell_fprintf>
	fs_closedir(&dir);
    4000cec8:	9100c3e0 	add	x0, sp, #0x30
    4000cecc:	97fffdf5 	bl	4000c6a0 <fs_closedir>
	return 0;
    4000ced0:	1400000d 	b	4000cf04 <cmd_ls+0xbc>
		create_abs_path(argv[1], path, sizeof(path));
    4000ced4:	f9400440 	ldr	x0, [x2, #8]
    4000ced8:	910183e1 	add	x1, sp, #0x60
    4000cedc:	97ffff68 	bl	4000cc7c <create_abs_path.constprop.0>
    4000cee0:	17ffffe7 	b	4000ce7c <cmd_ls+0x34>
		return -ENOEXEC;
    4000cee4:	128000f3 	mov	w19, #0xfffffff8            	// #-8
		shell_error(shell, "Unable to open %s (err %d)", path, err);
    4000cee8:	2a0003e4 	mov	w4, w0
    4000ceec:	910183e3 	add	x3, sp, #0x60
    4000cef0:	aa1403e0 	mov	x0, x20
    4000cef4:	b0000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000cef8:	9133ec42 	add	x2, x2, #0xcfb
    4000cefc:	52800021 	mov	w1, #0x1                   	// #1
    4000cf00:	97ffeb99 	bl	40007d64 <shell_fprintf>
}
    4000cf04:	2a1303e0 	mov	w0, w19
    4000cf08:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000cf0c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000cf10:	a8ce7bfd 	ldp	x29, x30, [sp], #224
    4000cf14:	d65f03c0 	ret
		if (entry.name[0] == '\0') {
    4000cf18:	394113e0 	ldrb	w0, [sp, #68]
    4000cf1c:	34fffd60 	cbz	w0, 4000cec8 <cmd_ls+0x80>
		shell_print(shell, "%s%s", entry.name,
    4000cf20:	b94043e0 	ldr	w0, [sp, #64]
    4000cf24:	910113e3 	add	x3, sp, #0x44
    4000cf28:	90000042 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    4000cf2c:	91375c42 	add	x2, x2, #0xdd7
    4000cf30:	7100041f 	cmp	w0, #0x1
    4000cf34:	52800101 	mov	w1, #0x8                   	// #8
    4000cf38:	9a9502c4 	csel	x4, x22, x21, eq  // eq = none
    4000cf3c:	aa1403e0 	mov	x0, x20
    4000cf40:	97ffeb89 	bl	40007d64 <shell_fprintf>
	while (1) {
    4000cf44:	17ffffd8 	b	4000cea4 <cmd_ls+0x5c>

000000004000cf48 <cmd_mkdir>:

	return err;
}

static int cmd_mkdir(const struct shell *shell, size_t argc, char **argv)
{
    4000cf48:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    4000cf4c:	910003fd 	mov	x29, sp
    4000cf50:	f9000bf3 	str	x19, [sp, #16]
    4000cf54:	aa0003f3 	mov	x19, x0
	int err;
	char path[MAX_PATH_LEN];

	create_abs_path(argv[1], path, sizeof(path));
    4000cf58:	f9400440 	ldr	x0, [x2, #8]
    4000cf5c:	910083e1 	add	x1, sp, #0x20
    4000cf60:	97ffff47 	bl	4000cc7c <create_abs_path.constprop.0>

	err = fs_mkdir(path);
    4000cf64:	910083e0 	add	x0, sp, #0x20
    4000cf68:	97fffdf4 	bl	4000c738 <fs_mkdir>
	if (err) {
    4000cf6c:	34000100 	cbz	w0, 4000cf8c <cmd_mkdir+0x44>
		shell_error(shell, "Error creating dir[%d]", err);
    4000cf70:	2a0003e3 	mov	w3, w0
    4000cf74:	b0000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000cf78:	9134c442 	add	x2, x2, #0xd31
    4000cf7c:	aa1303e0 	mov	x0, x19
    4000cf80:	52800021 	mov	w1, #0x1                   	// #1
    4000cf84:	97ffeb78 	bl	40007d64 <shell_fprintf>
		err = -ENOEXEC;
    4000cf88:	128000e0 	mov	w0, #0xfffffff8            	// #-8
	}

	return err;
}
    4000cf8c:	f9400bf3 	ldr	x19, [sp, #16]
    4000cf90:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    4000cf94:	d65f03c0 	ret

000000004000cf98 <cmd_read>:

	return err;
}

static int cmd_read(const struct shell *shell, size_t argc, char **argv)
{
    4000cf98:	a9ad7bfd 	stp	x29, x30, [sp, #-304]!
    4000cf9c:	910003fd 	mov	x29, sp
    4000cfa0:	a90153f3 	stp	x19, x20, [sp, #16]
    4000cfa4:	aa0003f3 	mov	x19, x0
	struct fs_file_t file;
	int count;
	off_t offset;
	int err;

	create_abs_path(argv[1], path, sizeof(path));
    4000cfa8:	f9400440 	ldr	x0, [x2, #8]
{
    4000cfac:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000cfb0:	aa0103f6 	mov	x22, x1
    4000cfb4:	aa0203f5 	mov	x21, x2
	create_abs_path(argv[1], path, sizeof(path));
    4000cfb8:	9102c3e1 	add	x1, sp, #0xb0
{
    4000cfbc:	a90363f7 	stp	x23, x24, [sp, #48]
    4000cfc0:	a9046bf9 	stp	x25, x26, [sp, #64]
    4000cfc4:	a90573fb 	stp	x27, x28, [sp, #80]
	create_abs_path(argv[1], path, sizeof(path));
    4000cfc8:	97ffff2d 	bl	4000cc7c <create_abs_path.constprop.0>

	if (argc > 2) {
    4000cfcc:	f1000adf 	cmp	x22, #0x2
    4000cfd0:	54000369 	b.ls	4000d03c <cmd_read+0xa4>  // b.plast
		count = strtol(argv[2], NULL, 0);
    4000cfd4:	f9400aa0 	ldr	x0, [x21, #16]
    4000cfd8:	52800002 	mov	w2, #0x0                   	// #0
    4000cfdc:	d2800001 	mov	x1, #0x0                   	// #0
		if (count <= 0) {
			count = INT_MAX;
    4000cfe0:	12b00014 	mov	w20, #0x7fffffff            	// #2147483647
		count = strtol(argv[2], NULL, 0);
    4000cfe4:	97fff9e5 	bl	4000b778 <strtol>
			count = INT_MAX;
    4000cfe8:	7100001f 	cmp	w0, #0x0
    4000cfec:	1a94c014 	csel	w20, w0, w20, gt
		}
	} else {
		count = INT_MAX;
	}

	if (argc > 3) {
    4000cff0:	f1000edf 	cmp	x22, #0x3
    4000cff4:	54000260 	b.eq	4000d040 <cmd_read+0xa8>  // b.none
		offset = strtol(argv[3], NULL, 0);
    4000cff8:	f9400ea0 	ldr	x0, [x21, #24]
    4000cffc:	52800002 	mov	w2, #0x0                   	// #0
    4000d000:	d2800001 	mov	x1, #0x0                   	// #0
    4000d004:	97fff9dd 	bl	4000b778 <strtol>
    4000d008:	2a0003f6 	mov	w22, w0
	} else {
		offset = 0;
	}

	err = fs_stat(path, &dirent);
    4000d00c:	910243e1 	add	x1, sp, #0x90
    4000d010:	9102c3e0 	add	x0, sp, #0xb0
    4000d014:	97fffe6b 	bl	4000c9c0 <fs_stat>
    4000d018:	2a0003e4 	mov	w4, w0
	if (err) {
    4000d01c:	34000160 	cbz	w0, 4000d048 <cmd_read+0xb0>
		shell_error(shell, "Failed to obtain file %s (err: %d)",
    4000d020:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d024:	91352442 	add	x2, x2, #0xd49
    4000d028:	9102c3e3 	add	x3, sp, #0xb0
	shell_print(shell, "File size: %zd", dirent.size);

	fs_file_t_init(&file);
	err = fs_open(&file, path, FS_O_READ);
	if (err) {
		shell_error(shell, "Failed to open %s (%d)", path, err);
    4000d02c:	aa1303e0 	mov	x0, x19
    4000d030:	52800021 	mov	w1, #0x1                   	// #1
    4000d034:	97ffeb4c 	bl	40007d64 <shell_fprintf>
		return -ENOEXEC;
    4000d038:	1400000c 	b	4000d068 <cmd_read+0xd0>
		count = INT_MAX;
    4000d03c:	12b00014 	mov	w20, #0x7fffffff            	// #2147483647
		offset = 0;
    4000d040:	52800016 	mov	w22, #0x0                   	// #0
    4000d044:	17fffff2 	b	4000d00c <cmd_read+0x74>
	if (dirent.type != FS_DIR_ENTRY_FILE) {
    4000d048:	b94093e0 	ldr	w0, [sp, #144]
    4000d04c:	34000200 	cbz	w0, 4000d08c <cmd_read+0xf4>
		shell_error(shell, "Note a file %s", path);
    4000d050:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d054:	9135b442 	add	x2, x2, #0xd6d
    4000d058:	9102c3e3 	add	x3, sp, #0xb0
    4000d05c:	aa1303e0 	mov	x0, x19
    4000d060:	52800021 	mov	w1, #0x1                   	// #1
    4000d064:	97ffeb40 	bl	40007d64 <shell_fprintf>
		err = fs_seek(&file, offset, FS_SEEK_SET);
		if (err) {
			shell_error(shell, "Failed to seek %s (%d)",
				    path, err);
			fs_close(&file);
			return -ENOEXEC;
    4000d068:	128000f5 	mov	w21, #0xfffffff8            	// #-8
	}

	fs_close(&file);

	return 0;
}
    4000d06c:	2a1503e0 	mov	w0, w21
    4000d070:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000d074:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000d078:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000d07c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000d080:	a94573fb 	ldp	x27, x28, [sp, #80]
    4000d084:	a8d37bfd 	ldp	x29, x30, [sp], #304
    4000d088:	d65f03c0 	ret
	shell_print(shell, "File size: %zd", dirent.size);
    4000d08c:	f94057e3 	ldr	x3, [sp, #168]
    4000d090:	aa1303e0 	mov	x0, x19
    4000d094:	52800101 	mov	w1, #0x8                   	// #8
    4000d098:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d09c:	9135f442 	add	x2, x2, #0xd7d
    4000d0a0:	97ffeb31 	bl	40007d64 <shell_fprintf>
	*zfp = (struct fs_file_t){ 0 };
    4000d0a4:	a907ffff 	stp	xzr, xzr, [sp, #120]
	err = fs_open(&file, path, FS_O_READ);
    4000d0a8:	9102c3e1 	add	x1, sp, #0xb0
    4000d0ac:	9101e3e0 	add	x0, sp, #0x78
    4000d0b0:	52800022 	mov	w2, #0x1                   	// #1
    4000d0b4:	f90047ff 	str	xzr, [sp, #136]
    4000d0b8:	97fffb99 	bl	4000bf1c <fs_open>
    4000d0bc:	2a0003f5 	mov	w21, w0
	if (err) {
    4000d0c0:	340000c0 	cbz	w0, 4000d0d8 <cmd_read+0x140>
		shell_error(shell, "Failed to open %s (%d)", path, err);
    4000d0c4:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d0c8:	91363442 	add	x2, x2, #0xd8d
    4000d0cc:	2a0003e4 	mov	w4, w0
    4000d0d0:	9102c3e3 	add	x3, sp, #0xb0
    4000d0d4:	17ffffd6 	b	4000d02c <cmd_read+0x94>
	if (offset > 0) {
    4000d0d8:	710002df 	cmp	w22, #0x0
    4000d0dc:	5400020d 	b.le	4000d11c <cmd_read+0x184>
		err = fs_seek(&file, offset, FS_SEEK_SET);
    4000d0e0:	2a1603e1 	mov	w1, w22
    4000d0e4:	9101e3e0 	add	x0, sp, #0x78
    4000d0e8:	52800002 	mov	w2, #0x0                   	// #0
    4000d0ec:	97fffc58 	bl	4000c24c <fs_seek>
    4000d0f0:	2a0003e4 	mov	w4, w0
		if (err) {
    4000d0f4:	34000140 	cbz	w0, 4000d11c <cmd_read+0x184>
			shell_error(shell, "Failed to seek %s (%d)",
    4000d0f8:	9102c3e3 	add	x3, sp, #0xb0
    4000d0fc:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d100:	91369442 	add	x2, x2, #0xda5
    4000d104:	52800021 	mov	w1, #0x1                   	// #1
    4000d108:	aa1303e0 	mov	x0, x19
    4000d10c:	97ffeb16 	bl	40007d64 <shell_fprintf>
			fs_close(&file);
    4000d110:	9101e3e0 	add	x0, sp, #0x78
    4000d114:	97fffbe5 	bl	4000c0a8 <fs_close>
    4000d118:	17ffffd4 	b	4000d068 <cmd_read+0xd0>
		shell_fprintf(shell, SHELL_NORMAL, "%08X  ", (uint32_t)offset);
    4000d11c:	90000059 	adrp	x25, 40015000 <tabulator.1+0x262>
    4000d120:	9136f739 	add	x25, x25, #0xdbd
			shell_fprintf(shell, SHELL_NORMAL, "   ");
    4000d124:	f000003a 	adrp	x26, 40014000 <CSWTCH.135+0x90>
    4000d128:	91071f5a 	add	x26, x26, #0x1c7
		read = fs_read(&file, buf, MIN(count, sizeof(buf)));
    4000d12c:	71003e9f 	cmp	w20, #0xf
    4000d130:	52800202 	mov	w2, #0x10                  	// #16
    4000d134:	1a82d282 	csel	w2, w20, w2, le
    4000d138:	9101a3fb 	add	x27, sp, #0x68
    4000d13c:	aa1b03e1 	mov	x1, x27
    4000d140:	9101e3e0 	add	x0, sp, #0x78
    4000d144:	93407c42 	sxtw	x2, w2
    4000d148:	97fffbfd 	bl	4000c13c <fs_read>
    4000d14c:	aa0003f8 	mov	x24, x0
		if (read <= 0) {
    4000d150:	f100001f 	cmp	x0, #0x0
    4000d154:	540006ad 	b.le	4000d228 <cmd_read+0x290>
			shell_fprintf(shell, SHELL_NORMAL, "%02X ", buf[i]);
    4000d158:	9000005c 	adrp	x28, 40015000 <tabulator.1+0x262>
    4000d15c:	9137139c 	add	x28, x28, #0xdc4
		shell_fprintf(shell, SHELL_NORMAL, "%08X  ", (uint32_t)offset);
    4000d160:	d2800017 	mov	x23, #0x0                   	// #0
    4000d164:	2a1603e3 	mov	w3, w22
    4000d168:	aa1903e2 	mov	x2, x25
    4000d16c:	aa1303e0 	mov	x0, x19
    4000d170:	52800101 	mov	w1, #0x8                   	// #8
    4000d174:	97ffeafc 	bl	40007d64 <shell_fprintf>
			shell_fprintf(shell, SHELL_NORMAL, "%02X ", buf[i]);
    4000d178:	38776b63 	ldrb	w3, [x27, x23]
    4000d17c:	aa1c03e2 	mov	x2, x28
    4000d180:	aa1303e0 	mov	x0, x19
		for (i = 0; i < read; i++) {
    4000d184:	910006f7 	add	x23, x23, #0x1
			shell_fprintf(shell, SHELL_NORMAL, "%02X ", buf[i]);
    4000d188:	52800101 	mov	w1, #0x8                   	// #8
    4000d18c:	97ffeaf6 	bl	40007d64 <shell_fprintf>
		for (i = 0; i < read; i++) {
    4000d190:	eb1802ff 	cmp	x23, x24
    4000d194:	54ffff21 	b.ne	4000d178 <cmd_read+0x1e0>  // b.any
    4000d198:	51000717 	sub	w23, w24, #0x1
		for (; i < sizeof(buf); i++) {
    4000d19c:	71003eff 	cmp	w23, #0xf
    4000d1a0:	540004a1 	b.ne	4000d234 <cmd_read+0x29c>  // b.any
		shell_fprintf(shell, SHELL_NORMAL, "%*c", i*3, ' ');
    4000d1a4:	52800404 	mov	w4, #0x20                  	// #32
    4000d1a8:	aa1303e0 	mov	x0, x19
    4000d1ac:	52800003 	mov	w3, #0x0                   	// #0
    4000d1b0:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d1b4:	91372842 	add	x2, x2, #0xdca
    4000d1b8:	52800101 	mov	w1, #0x8                   	// #8
			shell_fprintf(shell, SHELL_NORMAL, "%c", buf[i] < 32 ||
    4000d1bc:	f000003c 	adrp	x28, 40014000 <CSWTCH.135+0x90>
    4000d1c0:	9135c79c 	add	x28, x28, #0xd71
		shell_fprintf(shell, SHELL_NORMAL, "%*c", i*3, ' ');
    4000d1c4:	97ffeae8 	bl	40007d64 <shell_fprintf>
    4000d1c8:	d2800017 	mov	x23, #0x0                   	// #0
    4000d1cc:	528005c4 	mov	w4, #0x2e                  	// #46
			shell_fprintf(shell, SHELL_NORMAL, "%c", buf[i] < 32 ||
    4000d1d0:	38776b63 	ldrb	w3, [x27, x23]
    4000d1d4:	aa1c03e2 	mov	x2, x28
		for (i = 0; i < read; i++) {
    4000d1d8:	910006f7 	add	x23, x23, #0x1
			shell_fprintf(shell, SHELL_NORMAL, "%c", buf[i] < 32 ||
    4000d1dc:	52800101 	mov	w1, #0x8                   	// #8
    4000d1e0:	51008060 	sub	w0, w3, #0x20
    4000d1e4:	12001c00 	and	w0, w0, #0xff
    4000d1e8:	7101801f 	cmp	w0, #0x60
    4000d1ec:	aa1303e0 	mov	x0, x19
    4000d1f0:	1a843063 	csel	w3, w3, w4, cc  // cc = lo, ul, last
    4000d1f4:	97ffeadc 	bl	40007d64 <shell_fprintf>
		for (i = 0; i < read; i++) {
    4000d1f8:	eb1802ff 	cmp	x23, x24
    4000d1fc:	528005c4 	mov	w4, #0x2e                  	// #46
    4000d200:	54fffe81 	b.ne	4000d1d0 <cmd_read+0x238>  // b.any
		shell_print(shell, "");
    4000d204:	aa1303e0 	mov	x0, x19
		count -= read;
    4000d208:	4b170294 	sub	w20, w20, w23
		shell_print(shell, "");
    4000d20c:	f0000022 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    4000d210:	911be042 	add	x2, x2, #0x6f8
    4000d214:	52800101 	mov	w1, #0x8                   	// #8
    4000d218:	97ffead3 	bl	40007d64 <shell_fprintf>
		offset += read;
    4000d21c:	0b1702d6 	add	w22, w22, w23
	while (count > 0) {
    4000d220:	7100029f 	cmp	w20, #0x0
    4000d224:	54fff84c 	b.gt	4000d12c <cmd_read+0x194>
	fs_close(&file);
    4000d228:	9101e3e0 	add	x0, sp, #0x78
    4000d22c:	97fffb9f 	bl	4000c0a8 <fs_close>
	return 0;
    4000d230:	17ffff8f 	b	4000d06c <cmd_read+0xd4>
			shell_fprintf(shell, SHELL_NORMAL, "   ");
    4000d234:	aa1a03e2 	mov	x2, x26
    4000d238:	aa1303e0 	mov	x0, x19
    4000d23c:	52800101 	mov	w1, #0x8                   	// #8
    4000d240:	110006f7 	add	w23, w23, #0x1
    4000d244:	97ffeac8 	bl	40007d64 <shell_fprintf>
		for (; i < sizeof(buf); i++) {
    4000d248:	17ffffd5 	b	4000d19c <cmd_read+0x204>

000000004000d24c <cmd_cat>:

static int cmd_cat(const struct shell *shell, size_t argc, char **argv)
{
    4000d24c:	a9aa7bfd 	stp	x29, x30, [sp, #-352]!
    4000d250:	910003fd 	mov	x29, sp
    4000d254:	a90153f3 	stp	x19, x20, [sp, #16]
    4000d258:	aa0003f3 	mov	x19, x0
    4000d25c:	a90363f7 	stp	x23, x24, [sp, #48]
    4000d260:	aa0103f7 	mov	x23, x1
    4000d264:	aa0203f8 	mov	x24, x2
    4000d268:	a9046bf9 	stp	x25, x26, [sp, #64]
			if (read <= 0) {
				break;
			}

			for (int j = 0; j < read; j++) {
				shell_fprintf(shell, SHELL_NORMAL, "%c", buf[j]);
    4000d26c:	f0000039 	adrp	x25, 40014000 <CSWTCH.135+0x90>
    4000d270:	9135c739 	add	x25, x25, #0xd71
			}
		}

		if (read < 0) {
			shell_error(shell, "Failed to read from file %s (err: %zd)",
    4000d274:	9000005a 	adrp	x26, 40015000 <tabulator.1+0x262>
    4000d278:	91373b5a 	add	x26, x26, #0xdce
{
    4000d27c:	a9025bf5 	stp	x21, x22, [sp, #32]
	for (size_t i = 1; i < argc; ++i) {
    4000d280:	d2800035 	mov	x21, #0x1                   	// #1
{
    4000d284:	f9002bfb 	str	x27, [sp, #80]
    4000d288:	a906ffff 	stp	xzr, xzr, [sp, #104]
    4000d28c:	f9003fff 	str	xzr, [sp, #120]
	for (size_t i = 1; i < argc; ++i) {
    4000d290:	eb1702bf 	cmp	x21, x23
    4000d294:	54000123 	b.cc	4000d2b8 <cmd_cat+0x6c>  // b.lo, b.ul, b.last

		fs_close(&file);
	}

	return 0;
}
    4000d298:	52800000 	mov	w0, #0x0                   	// #0
    4000d29c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000d2a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000d2a4:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000d2a8:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000d2ac:	f9402bfb 	ldr	x27, [sp, #80]
    4000d2b0:	a8d67bfd 	ldp	x29, x30, [sp], #352
    4000d2b4:	d65f03c0 	ret
		create_abs_path(argv[i], path, sizeof(path));
    4000d2b8:	f8757b00 	ldr	x0, [x24, x21, lsl #3]
    4000d2bc:	910383e1 	add	x1, sp, #0xe0
    4000d2c0:	97fffe6f 	bl	4000cc7c <create_abs_path.constprop.0>
		err = fs_stat(path, &dirent);
    4000d2c4:	910203e1 	add	x1, sp, #0x80
    4000d2c8:	910383e0 	add	x0, sp, #0xe0
    4000d2cc:	97fffdbd 	bl	4000c9c0 <fs_stat>
    4000d2d0:	2a0003e4 	mov	w4, w0
		if (err < 0) {
    4000d2d4:	36f80100 	tbz	w0, #31, 4000d2f4 <cmd_cat+0xa8>
			shell_error(shell, "Failed to obtain file %s (err: %d)",
    4000d2d8:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d2dc:	91352442 	add	x2, x2, #0xd49
    4000d2e0:	910383e3 	add	x3, sp, #0xe0
			shell_error(shell, "Failed to open %s (%d)", path, err);
    4000d2e4:	aa1303e0 	mov	x0, x19
    4000d2e8:	52800021 	mov	w1, #0x1                   	// #1
    4000d2ec:	97ffea9e 	bl	40007d64 <shell_fprintf>
			continue;
    4000d2f0:	14000009 	b	4000d314 <cmd_cat+0xc8>
		if (dirent.type != FS_DIR_ENTRY_FILE) {
    4000d2f4:	b94083e0 	ldr	w0, [sp, #128]
    4000d2f8:	34000120 	cbz	w0, 4000d31c <cmd_cat+0xd0>
			shell_error(shell, "Note a file %s", path);
    4000d2fc:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d300:	9135b442 	add	x2, x2, #0xd6d
    4000d304:	910383e3 	add	x3, sp, #0xe0
    4000d308:	aa1303e0 	mov	x0, x19
    4000d30c:	52800021 	mov	w1, #0x1                   	// #1
    4000d310:	97ffea95 	bl	40007d64 <shell_fprintf>
	for (size_t i = 1; i < argc; ++i) {
    4000d314:	910006b5 	add	x21, x21, #0x1
    4000d318:	17ffffde 	b	4000d290 <cmd_cat+0x44>
		err = fs_open(&file, path, FS_O_READ);
    4000d31c:	910383e1 	add	x1, sp, #0xe0
    4000d320:	9101a3e0 	add	x0, sp, #0x68
    4000d324:	52800022 	mov	w2, #0x1                   	// #1
    4000d328:	97fffafd 	bl	4000bf1c <fs_open>
    4000d32c:	2a0003e4 	mov	w4, w0
		if (err < 0) {
    4000d330:	37f80260 	tbnz	w0, #31, 4000d37c <cmd_cat+0x130>
			read = fs_read(&file, buf, sizeof(buf));
    4000d334:	910283fb 	add	x27, sp, #0xa0
    4000d338:	aa1b03e1 	mov	x1, x27
    4000d33c:	9101a3e0 	add	x0, sp, #0x68
    4000d340:	d2800802 	mov	x2, #0x40                  	// #64
    4000d344:	97fffb7e 	bl	4000c13c <fs_read>
    4000d348:	aa0003f4 	mov	x20, x0
			if (read <= 0) {
    4000d34c:	f100001f 	cmp	x0, #0x0
    4000d350:	540001ed 	b.le	4000d38c <cmd_cat+0x140>
    4000d354:	d2800016 	mov	x22, #0x0                   	// #0
				shell_fprintf(shell, SHELL_NORMAL, "%c", buf[j]);
    4000d358:	38766b63 	ldrb	w3, [x27, x22]
    4000d35c:	aa1903e2 	mov	x2, x25
    4000d360:	aa1303e0 	mov	x0, x19
			for (int j = 0; j < read; j++) {
    4000d364:	910006d6 	add	x22, x22, #0x1
				shell_fprintf(shell, SHELL_NORMAL, "%c", buf[j]);
    4000d368:	52800101 	mov	w1, #0x8                   	// #8
    4000d36c:	97ffea7e 	bl	40007d64 <shell_fprintf>
			for (int j = 0; j < read; j++) {
    4000d370:	eb16029f 	cmp	x20, x22
    4000d374:	54ffff21 	b.ne	4000d358 <cmd_cat+0x10c>  // b.any
    4000d378:	17fffff0 	b	4000d338 <cmd_cat+0xec>
			shell_error(shell, "Failed to open %s (%d)", path, err);
    4000d37c:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d380:	91363442 	add	x2, x2, #0xd8d
    4000d384:	910383e3 	add	x3, sp, #0xe0
    4000d388:	17ffffd7 	b	4000d2e4 <cmd_cat+0x98>
		if (read < 0) {
    4000d38c:	540000e0 	b.eq	4000d3a8 <cmd_cat+0x15c>  // b.none
			shell_error(shell, "Failed to read from file %s (err: %zd)",
    4000d390:	aa0003e4 	mov	x4, x0
    4000d394:	910383e3 	add	x3, sp, #0xe0
    4000d398:	aa1a03e2 	mov	x2, x26
    4000d39c:	aa1303e0 	mov	x0, x19
    4000d3a0:	52800021 	mov	w1, #0x1                   	// #1
    4000d3a4:	97ffea70 	bl	40007d64 <shell_fprintf>
		fs_close(&file);
    4000d3a8:	9101a3e0 	add	x0, sp, #0x68
    4000d3ac:	97fffb3f 	bl	4000c0a8 <fs_close>
    4000d3b0:	17ffffd9 	b	4000d314 <cmd_cat+0xc8>

000000004000d3b4 <cmd_rm>:
{
    4000d3b4:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
    4000d3b8:	910003fd 	mov	x29, sp
    4000d3bc:	f9000bf3 	str	x19, [sp, #16]
    4000d3c0:	aa0003f3 	mov	x19, x0
	create_abs_path(argv[1], path, sizeof(path));
    4000d3c4:	f9400440 	ldr	x0, [x2, #8]
    4000d3c8:	910083e1 	add	x1, sp, #0x20
    4000d3cc:	97fffe2c 	bl	4000cc7c <create_abs_path.constprop.0>
	err = fs_unlink(path);
    4000d3d0:	910083e0 	add	x0, sp, #0x20
    4000d3d4:	97fffd2a 	bl	4000c87c <fs_unlink>
	if (err) {
    4000d3d8:	34000120 	cbz	w0, 4000d3fc <cmd_rm+0x48>
		shell_error(shell, "Failed to remove %s (%d)", path, err);
    4000d3dc:	2a0003e4 	mov	w4, w0
    4000d3e0:	910083e3 	add	x3, sp, #0x20
    4000d3e4:	aa1303e0 	mov	x0, x19
    4000d3e8:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d3ec:	9137d842 	add	x2, x2, #0xdf6
    4000d3f0:	52800021 	mov	w1, #0x1                   	// #1
    4000d3f4:	97ffea5c 	bl	40007d64 <shell_fprintf>
		err = -ENOEXEC;
    4000d3f8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
    4000d3fc:	f9400bf3 	ldr	x19, [sp, #16]
    4000d400:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    4000d404:	d65f03c0 	ret

000000004000d408 <cmd_statvfs>:

static int cmd_statvfs(const struct shell *shell, size_t argc, char **argv)
{
    4000d408:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
    4000d40c:	910003fd 	mov	x29, sp
    4000d410:	f9000bf3 	str	x19, [sp, #16]
    4000d414:	aa0003f3 	mov	x19, x0
	int err;
	char path[MAX_PATH_LEN];
	struct fs_statvfs stat;

	create_abs_path(argv[1], path, sizeof(path));
    4000d418:	f9400440 	ldr	x0, [x2, #8]
    4000d41c:	910103e1 	add	x1, sp, #0x40
    4000d420:	97fffe17 	bl	4000cc7c <create_abs_path.constprop.0>

	err = fs_statvfs(path, &stat);
    4000d424:	910083e1 	add	x1, sp, #0x20
    4000d428:	910103e0 	add	x0, sp, #0x40
    4000d42c:	97fffdb8 	bl	4000cb0c <fs_statvfs>
	if (err < 0) {
    4000d430:	36f80180 	tbz	w0, #31, 4000d460 <cmd_statvfs+0x58>
    4000d434:	2a0003e4 	mov	w4, w0
		shell_error(shell, "Failed to statvfs %s (%d)", path, err);
    4000d438:	910103e3 	add	x3, sp, #0x40
    4000d43c:	aa1303e0 	mov	x0, x19
    4000d440:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d444:	91384042 	add	x2, x2, #0xe10
    4000d448:	52800021 	mov	w1, #0x1                   	// #1
    4000d44c:	97ffea46 	bl	40007d64 <shell_fprintf>
		return -ENOEXEC;
    4000d450:	128000e0 	mov	w0, #0xfffffff8            	// #-8
	shell_fprintf(shell, SHELL_NORMAL,
		      "bsize %lu, frsize %lu, blocks %lu, bfree %lu\n",
		      stat.f_bsize, stat.f_frsize, stat.f_blocks, stat.f_bfree);

	return 0;
}
    4000d454:	f9400bf3 	ldr	x19, [sp, #16]
    4000d458:	a8cc7bfd 	ldp	x29, x30, [sp], #192
    4000d45c:	d65f03c0 	ret
	shell_fprintf(shell, SHELL_NORMAL,
    4000d460:	a94213e3 	ldp	x3, x4, [sp, #32]
    4000d464:	aa1303e0 	mov	x0, x19
    4000d468:	a9431be5 	ldp	x5, x6, [sp, #48]
    4000d46c:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d470:	9138ac42 	add	x2, x2, #0xe2b
    4000d474:	52800101 	mov	w1, #0x8                   	// #8
    4000d478:	97ffea3b 	bl	40007d64 <shell_fprintf>
	return 0;
    4000d47c:	52800000 	mov	w0, #0x0                   	// #0
    4000d480:	17fffff5 	b	4000d454 <cmd_statvfs+0x4c>

000000004000d484 <cmd_trunc>:
{
    4000d484:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
    4000d488:	910003fd 	mov	x29, sp
    4000d48c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000d490:	aa0003f4 	mov	x20, x0
    4000d494:	aa0203f3 	mov	x19, x2
	create_abs_path(argv[1], path, sizeof(path));
    4000d498:	f9400440 	ldr	x0, [x2, #8]
{
    4000d49c:	f90013f5 	str	x21, [sp, #32]
    4000d4a0:	aa0103f5 	mov	x21, x1
	create_abs_path(argv[1], path, sizeof(path));
    4000d4a4:	910143e1 	add	x1, sp, #0x50
    4000d4a8:	97fffdf5 	bl	4000cc7c <create_abs_path.constprop.0>
	if (argc > 2) {
    4000d4ac:	f1000abf 	cmp	x21, #0x2
    4000d4b0:	54000349 	b.ls	4000d518 <cmd_trunc+0x94>  // b.plast
		length = strtol(argv[2], NULL, 0);
    4000d4b4:	f9400a60 	ldr	x0, [x19, #16]
    4000d4b8:	52800002 	mov	w2, #0x0                   	// #0
    4000d4bc:	d2800001 	mov	x1, #0x0                   	// #0
    4000d4c0:	97fff8ae 	bl	4000b778 <strtol>
    4000d4c4:	2a0003f3 	mov	w19, w0
	err = fs_open(&file, path, FS_O_WRITE);
    4000d4c8:	910143e1 	add	x1, sp, #0x50
    4000d4cc:	9100e3e0 	add	x0, sp, #0x38
    4000d4d0:	52800042 	mov	w2, #0x2                   	// #2
    4000d4d4:	a903ffff 	stp	xzr, xzr, [sp, #56]
    4000d4d8:	f90027ff 	str	xzr, [sp, #72]
    4000d4dc:	97fffa90 	bl	4000bf1c <fs_open>
    4000d4e0:	2a0003e4 	mov	w4, w0
	if (err) {
    4000d4e4:	340001e0 	cbz	w0, 4000d520 <cmd_trunc+0x9c>
		return -ENOEXEC;;
    4000d4e8:	128000f3 	mov	w19, #0xfffffff8            	// #-8
		shell_error(shell, "Failed to open %s (%d)", path, err);
    4000d4ec:	910143e3 	add	x3, sp, #0x50
    4000d4f0:	aa1403e0 	mov	x0, x20
    4000d4f4:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d4f8:	91363442 	add	x2, x2, #0xd8d
    4000d4fc:	52800021 	mov	w1, #0x1                   	// #1
    4000d500:	97ffea19 	bl	40007d64 <shell_fprintf>
}
    4000d504:	2a1303e0 	mov	w0, w19
    4000d508:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000d50c:	f94013f5 	ldr	x21, [sp, #32]
    4000d510:	a8cd7bfd 	ldp	x29, x30, [sp], #208
    4000d514:	d65f03c0 	ret
		length = 0;
    4000d518:	52800013 	mov	w19, #0x0                   	// #0
    4000d51c:	17ffffeb 	b	4000d4c8 <cmd_trunc+0x44>
	err = fs_truncate(&file, length);
    4000d520:	2a1303e1 	mov	w1, w19
    4000d524:	9100e3e0 	add	x0, sp, #0x38
    4000d528:	97fffb6b 	bl	4000c2d4 <fs_truncate>
    4000d52c:	2a0003f3 	mov	w19, w0
	if (err) {
    4000d530:	34000120 	cbz	w0, 4000d554 <cmd_trunc+0xd0>
		err = -ENOEXEC;
    4000d534:	128000f3 	mov	w19, #0xfffffff8            	// #-8
		shell_error(shell, "Failed to truncate %s (%d)", path, err);
    4000d538:	2a0003e4 	mov	w4, w0
    4000d53c:	910143e3 	add	x3, sp, #0x50
    4000d540:	aa1403e0 	mov	x0, x20
    4000d544:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d548:	91396442 	add	x2, x2, #0xe59
    4000d54c:	52800021 	mov	w1, #0x1                   	// #1
    4000d550:	97ffea05 	bl	40007d64 <shell_fprintf>
	fs_close(&file);
    4000d554:	9100e3e0 	add	x0, sp, #0x38
    4000d558:	97fffad4 	bl	4000c0a8 <fs_close>
	return err;
    4000d55c:	17ffffea 	b	4000d504 <cmd_trunc+0x80>

000000004000d560 <cmd_write>:

static int cmd_write(const struct shell *shell, size_t argc, char **argv)
{
    4000d560:	a9ad7bfd 	stp	x29, x30, [sp, #-304]!
    4000d564:	910003fd 	mov	x29, sp
    4000d568:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000d56c:	aa0003f5 	mov	x21, x0
    4000d570:	aa0203f6 	mov	x22, x2
	int arg_offset;
	struct fs_file_t file;
	off_t offset = -1;
	int err;

	create_abs_path(argv[1], path, sizeof(path));
    4000d574:	f9400440 	ldr	x0, [x2, #8]
{
    4000d578:	a90153f3 	stp	x19, x20, [sp, #16]
    4000d57c:	a90363f7 	stp	x23, x24, [sp, #48]
    4000d580:	aa0103f7 	mov	x23, x1
	create_abs_path(argv[1], path, sizeof(path));
    4000d584:	9102c3e1 	add	x1, sp, #0xb0
{
    4000d588:	f90023f9 	str	x25, [sp, #64]
	create_abs_path(argv[1], path, sizeof(path));
    4000d58c:	97fffdbc 	bl	4000cc7c <create_abs_path.constprop.0>

	if (!strcmp(argv[2], "-o")) {
    4000d590:	f9400ac0 	ldr	x0, [x22, #16]
    4000d594:	90000041 	adrp	x1, 40015000 <tabulator.1+0x262>
    4000d598:	9139d421 	add	x1, x1, #0xe75
    4000d59c:	97fff995 	bl	4000bbf0 <strcmp>
    4000d5a0:	350004a0 	cbnz	w0, 4000d634 <cmd_write+0xd4>
		if (argc < 4) {
    4000d5a4:	f1000eff 	cmp	x23, #0x3
    4000d5a8:	540001c8 	b.hi	4000d5e0 <cmd_write+0x80>  // b.pmore
			shell_error(shell, "Missing argument");
    4000d5ac:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d5b0:	9139e042 	add	x2, x2, #0xe78
    4000d5b4:	aa1503e0 	mov	x0, x21
    4000d5b8:	52800021 	mov	w1, #0x1                   	// #1
    4000d5bc:	97ffe9ea 	bl	40007d64 <shell_fprintf>
			err = fs_write(&file, buf, buf_len);
			if (err < 0) {
				shell_error(shell, "Failed to write %s (%d)",
					      path, err);
				fs_close(&file);
				return -ENOEXEC;
    4000d5c0:	128000f3 	mov	w19, #0xfffffff8            	// #-8
	}

	fs_close(&file);

	return 0;
}
    4000d5c4:	2a1303e0 	mov	w0, w19
    4000d5c8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000d5cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000d5d0:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000d5d4:	f94023f9 	ldr	x25, [sp, #64]
    4000d5d8:	a8d37bfd 	ldp	x29, x30, [sp], #304
    4000d5dc:	d65f03c0 	ret
		offset = strtol(argv[3], NULL, 0);
    4000d5e0:	f9400ec0 	ldr	x0, [x22, #24]
    4000d5e4:	52800002 	mov	w2, #0x0                   	// #0
    4000d5e8:	d2800001 	mov	x1, #0x0                   	// #0
		arg_offset = 4;
    4000d5ec:	52800094 	mov	w20, #0x4                   	// #4
		offset = strtol(argv[3], NULL, 0);
    4000d5f0:	97fff862 	bl	4000b778 <strtol>
    4000d5f4:	2a0003f3 	mov	w19, w0
	err = fs_open(&file, path, FS_O_CREATE | FS_O_WRITE);
    4000d5f8:	9102c3e1 	add	x1, sp, #0xb0
    4000d5fc:	910163e0 	add	x0, sp, #0x58
    4000d600:	52800242 	mov	w2, #0x12                  	// #18
    4000d604:	a905ffff 	stp	xzr, xzr, [sp, #88]
    4000d608:	f90037ff 	str	xzr, [sp, #104]
    4000d60c:	97fffa44 	bl	4000bf1c <fs_open>
    4000d610:	2a0003e4 	mov	w4, w0
	if (err) {
    4000d614:	34000160 	cbz	w0, 4000d640 <cmd_write+0xe0>
		shell_error(shell, "Failed to open %s (%d)", path, err);
    4000d618:	9102c3e3 	add	x3, sp, #0xb0
    4000d61c:	aa1503e0 	mov	x0, x21
    4000d620:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d624:	91363442 	add	x2, x2, #0xd8d
    4000d628:	52800021 	mov	w1, #0x1                   	// #1
    4000d62c:	97ffe9ce 	bl	40007d64 <shell_fprintf>
		return -ENOEXEC;
    4000d630:	17ffffe4 	b	4000d5c0 <cmd_write+0x60>
	off_t offset = -1;
    4000d634:	12800013 	mov	w19, #0xffffffff            	// #-1
		arg_offset = 2;
    4000d638:	52800054 	mov	w20, #0x2                   	// #2
    4000d63c:	17ffffef 	b	4000d5f8 <cmd_write+0x98>
	if (offset < 0) {
    4000d640:	36f801f3 	tbz	w19, #31, 4000d67c <cmd_write+0x11c>
		err = fs_seek(&file, 0, FS_SEEK_END);
    4000d644:	52800042 	mov	w2, #0x2                   	// #2
    4000d648:	52800001 	mov	w1, #0x0                   	// #0
		err = fs_seek(&file, offset, FS_SEEK_SET);
    4000d64c:	910163e0 	add	x0, sp, #0x58
	buf_len = 0U;
    4000d650:	52800019 	mov	w25, #0x0                   	// #0
		err = fs_seek(&file, offset, FS_SEEK_SET);
    4000d654:	97fffafe 	bl	4000c24c <fs_seek>
    4000d658:	2a0003f3 	mov	w19, w0
	if (err) {
    4000d65c:	35000160 	cbnz	w0, 4000d688 <cmd_write+0x128>
		buf[buf_len++] = strtol(argv[arg_offset++], NULL, 16);
    4000d660:	9101c3f8 	add	x24, sp, #0x70
	while (arg_offset < argc) {
    4000d664:	93407e80 	sxtw	x0, w20
    4000d668:	eb34c2ff 	cmp	x23, w20, sxtw
    4000d66c:	54000228 	b.hi	4000d6b0 <cmd_write+0x150>  // b.pmore
	fs_close(&file);
    4000d670:	910163e0 	add	x0, sp, #0x58
    4000d674:	97fffa8d 	bl	4000c0a8 <fs_close>
	return 0;
    4000d678:	17ffffd3 	b	4000d5c4 <cmd_write+0x64>
		err = fs_seek(&file, offset, FS_SEEK_SET);
    4000d67c:	2a1303e1 	mov	w1, w19
    4000d680:	52800002 	mov	w2, #0x0                   	// #0
    4000d684:	17fffff2 	b	4000d64c <cmd_write+0xec>
		shell_error(shell, "Failed to seek %s (%d)", path, err);
    4000d688:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d68c:	91369442 	add	x2, x2, #0xda5
    4000d690:	2a0003e4 	mov	w4, w0
    4000d694:	9102c3e3 	add	x3, sp, #0xb0
				shell_error(shell, "Failed to write %s (%d)",
    4000d698:	52800021 	mov	w1, #0x1                   	// #1
    4000d69c:	aa1503e0 	mov	x0, x21
    4000d6a0:	97ffe9b1 	bl	40007d64 <shell_fprintf>
				fs_close(&file);
    4000d6a4:	910163e0 	add	x0, sp, #0x58
    4000d6a8:	97fffa80 	bl	4000c0a8 <fs_close>
    4000d6ac:	17ffffc5 	b	4000d5c0 <cmd_write+0x60>
		buf[buf_len++] = strtol(argv[arg_offset++], NULL, 16);
    4000d6b0:	f8607ac0 	ldr	x0, [x22, x0, lsl #3]
    4000d6b4:	52800202 	mov	w2, #0x10                  	// #16
    4000d6b8:	d2800001 	mov	x1, #0x0                   	// #0
    4000d6bc:	11000694 	add	w20, w20, #0x1
    4000d6c0:	97fff82e 	bl	4000b778 <strtol>
    4000d6c4:	3839cb00 	strb	w0, [x24, w25, sxtw]
    4000d6c8:	11000722 	add	w2, w25, #0x1
    4000d6cc:	12001c42 	and	w2, w2, #0xff
		if ((buf_len == BUF_CNT) || (arg_offset == argc)) {
    4000d6d0:	7101005f 	cmp	w2, #0x40
    4000d6d4:	54000060 	b.eq	4000d6e0 <cmd_write+0x180>  // b.none
    4000d6d8:	eb34c2ff 	cmp	x23, w20, sxtw
    4000d6dc:	54000181 	b.ne	4000d70c <cmd_write+0x1ac>  // b.any
			err = fs_write(&file, buf, buf_len);
    4000d6e0:	92401c42 	and	x2, x2, #0xff
    4000d6e4:	aa1803e1 	mov	x1, x24
    4000d6e8:	910163e0 	add	x0, sp, #0x58
    4000d6ec:	97fffab6 	bl	4000c1c4 <fs_write>
    4000d6f0:	aa0003e4 	mov	x4, x0
			if (err < 0) {
    4000d6f4:	36f800a0 	tbz	w0, #31, 4000d708 <cmd_write+0x1a8>
				shell_error(shell, "Failed to write %s (%d)",
    4000d6f8:	90000042 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000d6fc:	913a2842 	add	x2, x2, #0xe8a
    4000d700:	9102c3e3 	add	x3, sp, #0xb0
    4000d704:	17ffffe5 	b	4000d698 <cmd_write+0x138>
			buf_len = 0U;
    4000d708:	52800002 	mov	w2, #0x0                   	// #0
    4000d70c:	2a0203f9 	mov	w25, w2
    4000d710:	17ffffd5 	b	4000d664 <cmd_write+0x104>

000000004000d714 <gic_get_rdist>:
MAKE_REG_HELPER(tpidrro_el0);
    4000d714:	d53bd060 	mrs	x0, tpidrro_el0
	return (_cpu_t *)(read_tpidrro_el0() & TPIDRROEL0_CURR_CPU);
    4000d718:	927db000 	and	x0, x0, #0xfffffffffff8
atomic_t nlpi_intid = ATOMIC_INIT(8192);
#endif

static inline mem_addr_t gic_get_rdist(void)
{
	return gic_rdists[arch_curr_cpu()->id];
    4000d71c:	39409001 	ldrb	w1, [x0, #36]
}
    4000d720:	900000a0 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000d724:	911ba000 	add	x0, x0, #0x6e8
    4000d728:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    4000d72c:	d65f03c0 	ret

000000004000d730 <gic_wait_rwp.isra.0>:
static int gic_wait_rwp(uint32_t intid)
{
	uint32_t rwp_mask;
	mem_addr_t base;

	if (intid < GIC_SPI_INT_BASE) {
    4000d730:	71007c1f 	cmp	w0, #0x1f
    4000d734:	54000168 	b.hi	4000d760 <gic_wait_rwp.isra.0+0x30>  // b.pmore
static int gic_wait_rwp(uint32_t intid)
    4000d738:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000d73c:	910003fd 	mov	x29, sp
		base = (gic_get_rdist() + GICR_CTLR);
    4000d740:	97fffff5 	bl	4000d714 <gic_get_rdist>
		rwp_mask = BIT(GICR_CTLR_RWP);
    4000d744:	52800101 	mov	w1, #0x8                   	// #8
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000d748:	b9400002 	ldr	w2, [x0]
	__DMB();
    4000d74c:	d5033fbf 	dmb	sy
	} else {
		base = GICD_CTLR;
		rwp_mask = BIT(GICD_CTLR_RWP);
	}

	while (sys_read32(base) & rwp_mask)
    4000d750:	6a01005f 	tst	w2, w1
    4000d754:	54ffffa1 	b.ne	4000d748 <gic_wait_rwp.isra.0+0x18>  // b.any
		;

	return 0;
}
    4000d758:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000d75c:	d65f03c0 	ret
		base = GICD_CTLR;
    4000d760:	d2a10000 	mov	x0, #0x8000000             	// #134217728
		rwp_mask = BIT(GICD_CTLR_RWP);
    4000d764:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000d768:	b9400002 	ldr	w2, [x0]
	__DMB();
    4000d76c:	d5033fbf 	dmb	sy
	while (sys_read32(base) & rwp_mask)
    4000d770:	6a01005f 	tst	w2, w1
    4000d774:	54ffffa1 	b.ne	4000d768 <gic_wait_rwp.isra.0+0x38>  // b.any
    4000d778:	d65f03c0 	ret

000000004000d77c <arm_gic_init>:

	gicv3_cpuif_init();
}

int arm_gic_init(const struct device *unused)
{
    4000d77c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000d780:	d2800083 	mov	x3, #0x4                   	// #4
    4000d784:	f2a10003 	movk	x3, #0x800, lsl #16
    4000d788:	910003fd 	mov	x29, sp
    4000d78c:	b9400063 	ldr	w3, [x3]
	__DMB();
    4000d790:	d5033fbf 	dmb	sy
	num_ints = (num_ints + 1) << 5;
    4000d794:	531b1063 	ubfiz	w3, w3, #5, #5
    4000d798:	11008063 	add	w3, w3, #0x20
	__DMB();
    4000d79c:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d7a0:	52800000 	mov	w0, #0x0                   	// #0
    4000d7a4:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    4000d7a8:	b9000020 	str	w0, [x1]
	gic_wait_rwp(GIC_SPI_INT_BASE);
    4000d7ac:	52800400 	mov	w0, #0x20                  	// #32
    4000d7b0:	97ffffe0 	bl	4000d730 <gic_wait_rwp.isra.0>
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000d7b4:	52803005 	mov	w5, #0x180                 	// #384
    4000d7b8:	72a10005 	movk	w5, #0x800, lsl #16
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000d7bc:	52805006 	mov	w6, #0x280                 	// #640
    4000d7c0:	72a10006 	movk	w6, #0x800, lsl #16
		sys_write32(IGROUPR_VAL, IGROUPR(base, idx));
    4000d7c4:	52801008 	mov	w8, #0x80                  	// #128
    4000d7c8:	72a10008 	movk	w8, #0x800, lsl #16
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000d7cc:	5281a009 	mov	w9, #0xd00                 	// #3328
    4000d7d0:	72a10009 	movk	w9, #0x800, lsl #16
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    4000d7d4:	52800401 	mov	w1, #0x20                  	// #32
    4000d7d8:	12800002 	mov	w2, #0xffffffff            	// #-1
    4000d7dc:	52800007 	mov	w7, #0x0                   	// #0
    4000d7e0:	6b01007f 	cmp	w3, w1
    4000d7e4:	54000ba8 	b.hi	4000d958 <arm_gic_init+0x1dc>  // b.pmore
	gic_wait_rwp(GIC_SPI_INT_BASE);
    4000d7e8:	52800400 	mov	w0, #0x20                  	// #32
    4000d7ec:	97ffffd1 	bl	4000d730 <gic_wait_rwp.isra.0>
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    4000d7f0:	d2808400 	mov	x0, #0x420                 	// #1056
    4000d7f4:	f2a10000 	movk	x0, #0x800, lsl #16
    4000d7f8:	529f8002 	mov	w2, #0xfc00                	// #64512
    4000d7fc:	72beffe2 	movk	w2, #0xf7ff, lsl #16
    4000d800:	52941404 	mov	w4, #0xa0a0                	// #41120
    4000d804:	72b41404 	movk	w4, #0xa0a0, lsl #16
    4000d808:	0b020001 	add	w1, w0, w2
    4000d80c:	6b01007f 	cmp	w3, w1
    4000d810:	54000c48 	b.hi	4000d998 <arm_gic_init+0x21c>  // b.pmore
		sys_write32(0, ICFGR(base, idx));
    4000d814:	52818004 	mov	w4, #0xc00                 	// #3072
    4000d818:	72a10004 	movk	w4, #0x800, lsl #16
	for (intid = GIC_SPI_INT_BASE; intid < num_ints;
    4000d81c:	52800401 	mov	w1, #0x20                  	// #32
    4000d820:	52800002 	mov	w2, #0x0                   	// #0
    4000d824:	6b01007f 	cmp	w3, w1
    4000d828:	54000c08 	b.hi	4000d9a8 <arm_gic_init+0x22c>  // b.pmore
extern "C" {
#endif

static ALWAYS_INLINE void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
    4000d82c:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    4000d830:	b9400020 	ldr	w0, [x1]

	*(volatile uint32_t *)addr = temp | (1 << bit);
    4000d834:	321e0000 	orr	w0, w0, #0x4
    4000d838:	b9000020 	str	w0, [x1]
    4000d83c:	d53bd060 	mrs	x0, tpidrro_el0
    4000d840:	927db000 	and	x0, x0, #0xfffffffffff8
	cpu = arch_curr_cpu()->id;
    4000d844:	39409002 	ldrb	w2, [x0, #36]
	gic_rdists[cpu] = GIC_RDIST_BASE + MPIDR_TO_CORE(GET_MPIDR()) * 0x20000;
    4000d848:	d53800a0 	mrs	x0, mpidr_el1
    4000d84c:	92401c00 	and	x0, x0, #0xff
    4000d850:	900000a1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000d854:	911ba021 	add	x1, x1, #0x6e8
    4000d858:	91101400 	add	x0, x0, #0x405
    4000d85c:	d36fb800 	lsl	x0, x0, #17
    4000d860:	f822d820 	str	x0, [x1, w2, sxtw #3]
	gicv3_rdist_enable(gic_get_rdist());
    4000d864:	97ffffac 	bl	4000d714 <gic_get_rdist>
	if (!(sys_read32(rdist + GICR_WAKER) & BIT(GICR_WAKER_CA)))
    4000d868:	91005002 	add	x2, x0, #0x14
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000d86c:	b9400041 	ldr	w1, [x2]
	__DMB();
    4000d870:	d5033fbf 	dmb	sy
    4000d874:	361000e1 	tbz	w1, #2, 4000d890 <arm_gic_init+0x114>
}

static ALWAYS_INLINE void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;
    4000d878:	b9401401 	ldr	w1, [x0, #20]

	*(volatile uint32_t *)addr = temp & ~(1 << bit);
    4000d87c:	121e7821 	and	w1, w1, #0xfffffffd
    4000d880:	b9001401 	str	w1, [x0, #20]
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000d884:	b9400040 	ldr	w0, [x2]
	__DMB();
    4000d888:	d5033fbf 	dmb	sy
	while (sys_read32(rdist + GICR_WAKER) & BIT(GICR_WAKER_CA))
    4000d88c:	3717ffc0 	tbnz	w0, #2, 4000d884 <arm_gic_init+0x108>
	mem_addr_t base = gic_get_rdist() + GICR_SGI_BASE_OFF;
    4000d890:	97ffffa1 	bl	4000d714 <gic_get_rdist>
    4000d894:	aa0003e3 	mov	x3, x0
	__DMB();
    4000d898:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), ICENABLER(base, 0));
    4000d89c:	91404000 	add	x0, x0, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d8a0:	12800004 	mov	w4, #0xffffffff            	// #-1
    4000d8a4:	91060000 	add	x0, x0, #0x180
    4000d8a8:	b9000004 	str	w4, [x0]
	gic_wait_rwp(0);
    4000d8ac:	52800000 	mov	w0, #0x0                   	// #0
    4000d8b0:	97ffffa0 	bl	4000d730 <gic_wait_rwp.isra.0>
	__DMB();
    4000d8b4:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), ICPENDR(base, 0));
    4000d8b8:	91404060 	add	x0, x3, #0x10, lsl #12
    4000d8bc:	910a0000 	add	x0, x0, #0x280
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d8c0:	b9000004 	str	w4, [x0]
	__DMB();
    4000d8c4:	d5033fbf 	dmb	sy
	sys_write32(IGROUPR_VAL, IGROUPR(base, 0));
    4000d8c8:	91404061 	add	x1, x3, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d8cc:	52800000 	mov	w0, #0x0                   	// #0
    4000d8d0:	91020021 	add	x1, x1, #0x80
    4000d8d4:	b9000020 	str	w0, [x1]
	__DMB();
    4000d8d8:	d5033fbf 	dmb	sy
	sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG), IGROUPMODR(base, 0));
    4000d8dc:	91404060 	add	x0, x3, #0x10, lsl #12
    4000d8e0:	91340000 	add	x0, x0, #0xd00
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d8e4:	b9000004 	str	w4, [x0]
	for (intid = 0; intid < GIC_SPI_INT_BASE;
    4000d8e8:	91404060 	add	x0, x3, #0x10, lsl #12
    4000d8ec:	91404061 	add	x1, x3, #0x10, lsl #12
    4000d8f0:	91100000 	add	x0, x0, #0x400
    4000d8f4:	91108021 	add	x1, x1, #0x420
    4000d8f8:	52941402 	mov	w2, #0xa0a0                	// #41120
    4000d8fc:	72b41402 	movk	w2, #0xa0a0, lsl #16
	__DMB();
    4000d900:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d904:	b9000002 	str	w2, [x0]
    4000d908:	91001000 	add	x0, x0, #0x4
    4000d90c:	eb01001f 	cmp	x0, x1
    4000d910:	54ffff81 	b.ne	4000d900 <arm_gic_init+0x184>  // b.any
	__DMB();
    4000d914:	d5033fbf 	dmb	sy
	sys_write32(0, ICFGR(base, 1));
    4000d918:	91404063 	add	x3, x3, #0x10, lsl #12
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d91c:	52800000 	mov	w0, #0x0                   	// #0
    4000d920:	91301063 	add	x3, x3, #0xc04
    4000d924:	b9000060 	str	w0, [x3]
	icc_sre = read_sysreg(ICC_SRE_EL1);
    4000d928:	d538cca0 	mrs	x0, s3_0_c12_c12_5
	if (!(icc_sre & ICC_SRE_ELx_SRE_BIT)) {
    4000d92c:	37000080 	tbnz	w0, #0, 4000d93c <arm_gic_init+0x1c0>
		icc_sre = (icc_sre | ICC_SRE_ELx_SRE_BIT |
    4000d930:	32000800 	orr	w0, w0, #0x7
		write_sysreg(icc_sre, ICC_SRE_EL1);
    4000d934:	d518cca0 	msr	s3_0_c12_c12_5, x0
		icc_sre = read_sysreg(ICC_SRE_EL1);
    4000d938:	d538cca0 	mrs	x0, s3_0_c12_c12_5
	write_sysreg(GIC_IDLE_PRIO, ICC_PMR_EL1);
    4000d93c:	52801fe0 	mov	w0, #0xff                  	// #255
    4000d940:	d5184600 	msr	s3_0_c4_c6_0, x0
	write_sysreg(1, ICC_IGRPEN1_EL1);
    4000d944:	52800020 	mov	w0, #0x1                   	// #1
    4000d948:	d518cce0 	msr	s3_0_c12_c12_7, x0
	gicv3_dist_init();

	__arm_gic_init();

	return 0;
}
    4000d94c:	52800000 	mov	w0, #0x0                   	// #0
    4000d950:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000d954:	d65f03c0 	ret
		idx = intid / GIC_NUM_INTR_PER_REG;
    4000d958:	53057c20 	lsr	w0, w1, #5
			    ICENABLER(base, idx));
    4000d95c:	531e7400 	lsl	w0, w0, #2
	__DMB();
    4000d960:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000d964:	0b050004 	add	w4, w0, w5
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d968:	b9000082 	str	w2, [x4]
	__DMB();
    4000d96c:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000d970:	0b060004 	add	w4, w0, w6
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d974:	b9000082 	str	w2, [x4]
	__DMB();
    4000d978:	d5033fbf 	dmb	sy
		sys_write32(IGROUPR_VAL, IGROUPR(base, idx));
    4000d97c:	0b080004 	add	w4, w0, w8
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d980:	b9000087 	str	w7, [x4]
	__DMB();
    4000d984:	d5033fbf 	dmb	sy
		sys_write32(BIT_MASK(GIC_NUM_INTR_PER_REG),
    4000d988:	0b090000 	add	w0, w0, w9
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d98c:	b9000002 	str	w2, [x0]
	     intid += GIC_NUM_INTR_PER_REG) {
    4000d990:	11008021 	add	w1, w1, #0x20
    4000d994:	17ffff93 	b	4000d7e0 <arm_gic_init+0x64>
	__DMB();
    4000d998:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d99c:	b9000004 	str	w4, [x0]
	     intid += GIC_NUM_PRI_PER_REG) {
    4000d9a0:	91001000 	add	x0, x0, #0x4
    4000d9a4:	17ffff99 	b	4000d808 <arm_gic_init+0x8c>
	__DMB();
    4000d9a8:	d5033fbf 	dmb	sy
		idx = intid / GIC_NUM_CFG_PER_REG;
    4000d9ac:	53047c20 	lsr	w0, w1, #4
		sys_write32(0, ICFGR(base, idx));
    4000d9b0:	0b000880 	add	w0, w4, w0, lsl #2
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000d9b4:	b9000002 	str	w2, [x0]
	     intid += GIC_NUM_CFG_PER_REG) {
    4000d9b8:	11004021 	add	w1, w1, #0x10
    4000d9bc:	17ffff9a 	b	4000d824 <arm_gic_init+0xa8>

000000004000d9c0 <arm_gic_irq_set_priority>:
{
    4000d9c0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000d9c4:	2a0003e3 	mov	w3, w0
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000d9c8:	12001000 	and	w0, w0, #0x1f
{
    4000d9cc:	910003fd 	mov	x29, sp
    4000d9d0:	2a0203e6 	mov	w6, w2
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000d9d4:	d2800022 	mov	x2, #0x1                   	// #1
{
    4000d9d8:	2a0103e7 	mov	w7, w1
	uint32_t idx = intid / GIC_NUM_INTR_PER_REG;
    4000d9dc:	53057c64 	lsr	w4, w3, #5
	mem_addr_t base = GET_DIST_BASE(intid);
    4000d9e0:	71007c7f 	cmp	w3, #0x1f
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000d9e4:	9ac02042 	lsl	x2, x2, x0
	mem_addr_t base = GET_DIST_BASE(intid);
    4000d9e8:	54000468 	b.hi	4000da74 <arm_gic_irq_set_priority+0xb4>  // b.pmore
    4000d9ec:	97ffff4a 	bl	4000d714 <gic_get_rdist>
    4000d9f0:	91404005 	add	x5, x0, #0x10, lsl #12
	__DMB();
    4000d9f4:	d5033fbf 	dmb	sy
	sys_write32(mask, ICENABLER(base, idx));
    4000d9f8:	531e7484 	lsl	w4, w4, #2
    4000d9fc:	11060084 	add	w4, w4, #0x180
    4000da00:	8b2440a4 	add	x4, x5, w4, uxtw
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000da04:	b9000082 	str	w2, [x4]
	gic_wait_rwp(intid);
    4000da08:	2a0303e0 	mov	w0, w3
    4000da0c:	97ffff49 	bl	4000d730 <gic_wait_rwp.isra.0>
	__DMB();
    4000da10:	d5033fbf 	dmb	sy
	sys_write8(prio & GIC_PRI_MASK, IPRIORITYR(base, intid));
    4000da14:	2a0303e0 	mov	w0, w3
    4000da18:	91100000 	add	x0, x0, #0x400
    4000da1c:	8b050000 	add	x0, x0, x5
	__asm__ volatile("strb %w0, [%1]" : : "r" (data), "r" (addr));
    4000da20:	39000007 	strb	w7, [x0]
	if (!GIC_IS_SGI(intid)) {
    4000da24:	71003c7f 	cmp	w3, #0xf
    4000da28:	54000229 	b.ls	4000da6c <arm_gic_irq_set_priority+0xac>  // b.plast
		idx = intid / GIC_NUM_CFG_PER_REG;
    4000da2c:	53047c60 	lsr	w0, w3, #4
		shift = (intid & (GIC_NUM_CFG_PER_REG - 1)) * 2;
    4000da30:	531f0c64 	ubfiz	w4, w3, #1, #4
		val = sys_read32(ICFGR(base, idx));
    4000da34:	531e7400 	lsl	w0, w0, #2
    4000da38:	11300000 	add	w0, w0, #0xc00
    4000da3c:	8b2040a0 	add	x0, x5, w0, uxtw
	__asm__ volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    4000da40:	b9400002 	ldr	w2, [x0]
	__DMB();
    4000da44:	d5033fbf 	dmb	sy
		val &= ~(GICD_ICFGR_MASK << shift);
    4000da48:	d2800061 	mov	x1, #0x3                   	// #3
    4000da4c:	9ac42021 	lsl	x1, x1, x4
    4000da50:	0a210041 	bic	w1, w2, w1
		if (flags & IRQ_TYPE_EDGE) {
    4000da54:	36100086 	tbz	w6, #2, 4000da64 <arm_gic_irq_set_priority+0xa4>
			val |= (GICD_ICFGR_TYPE << shift);
    4000da58:	d2800042 	mov	x2, #0x2                   	// #2
    4000da5c:	9ac42042 	lsl	x2, x2, x4
    4000da60:	2a020021 	orr	w1, w1, w2
	__DMB();
    4000da64:	d5033fbf 	dmb	sy
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000da68:	b9000001 	str	w1, [x0]
}
    4000da6c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000da70:	d65f03c0 	ret
	mem_addr_t base = GET_DIST_BASE(intid);
    4000da74:	d2a10005 	mov	x5, #0x8000000             	// #134217728
    4000da78:	17ffffdf 	b	4000d9f4 <arm_gic_irq_set_priority+0x34>

000000004000da7c <arm_gic_irq_enable>:
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000da7c:	12001001 	and	w1, w0, #0x1f
    4000da80:	d2800023 	mov	x3, #0x1                   	// #1
	uint32_t idx = intid / GIC_NUM_INTR_PER_REG;
    4000da84:	53057c02 	lsr	w2, w0, #5
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    4000da88:	71007c1f 	cmp	w0, #0x1f
	uint32_t mask = BIT(intid & (GIC_NUM_INTR_PER_REG - 1));
    4000da8c:	9ac12063 	lsl	x3, x3, x1
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    4000da90:	54000188 	b.hi	4000dac0 <arm_gic_irq_enable+0x44>  // b.pmore
{
    4000da94:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000da98:	910003fd 	mov	x29, sp
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    4000da9c:	97ffff1e 	bl	4000d714 <gic_get_rdist>
    4000daa0:	91404000 	add	x0, x0, #0x10, lsl #12
    4000daa4:	91040000 	add	x0, x0, #0x100
	__DMB();
    4000daa8:	d5033fbf 	dmb	sy
    4000daac:	d37e6842 	ubfiz	x2, x2, #2, #27
    4000dab0:	8b000042 	add	x2, x2, x0
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000dab4:	b9000043 	str	w3, [x2]
}
    4000dab8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000dabc:	d65f03c0 	ret
	sys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));
    4000dac0:	d2802000 	mov	x0, #0x100                 	// #256
    4000dac4:	f2a10000 	movk	x0, #0x800, lsl #16
	__DMB();
    4000dac8:	d5033fbf 	dmb	sy
    4000dacc:	d37e6842 	ubfiz	x2, x2, #2, #27
    4000dad0:	8b000042 	add	x2, x2, x0
	__asm__ volatile("str %w0, [%1]" : : "r" (data), "r" (addr));
    4000dad4:	b9000043 	str	w3, [x2]
    4000dad8:	d65f03c0 	ret

000000004000dadc <arm_gic_get_active>:
	intid = read_sysreg(ICC_IAR1_EL1);
    4000dadc:	d538cc00 	mrs	x0, s3_0_c12_c12_0
}
    4000dae0:	d65f03c0 	ret

000000004000dae4 <arm_gic_eoi>:
	__DSB();
    4000dae4:	d5033f9f 	dsb	sy
	write_sysreg(intid, ICC_EOIR1_EL1);
    4000dae8:	d518cc20 	msr	s3_0_c12_c12_1, x0
}
    4000daec:	d65f03c0 	ret

000000004000daf0 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    4000daf0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    4000daf4:	900000a1 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000daf8:	b0000020 	adrp	x0, 40012000 <__rodata_region_start>
    4000dafc:	91028000 	add	x0, x0, #0xa0
{
    4000db00:	910003fd 	mov	x29, sp
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
    4000db04:	f9037820 	str	x0, [x1, #1776]
{
    4000db08:	f9000bf3 	str	x19, [sp, #16]
    4000db0c:	940001d8 	bl	4000e26c <z_device_ready>
    4000db10:	72001c1f 	tst	w0, #0xff
    4000db14:	54000160 	b.eq	4000db40 <uart_console_init+0x50>  // b.none
	__stdout_hook_install(console_out);
    4000db18:	90000013 	adrp	x19, 4000d000 <cmd_read+0x68>
    4000db1c:	912d2273 	add	x19, x19, #0xb48
    4000db20:	aa1303e0 	mov	x0, x19
    4000db24:	97fff878 	bl	4000bd04 <__stdout_hook_install>
	__printk_hook_install(console_out);
    4000db28:	aa1303e0 	mov	x0, x19
    4000db2c:	97ffcdcc 	bl	4000125c <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
    4000db30:	52800000 	mov	w0, #0x0                   	// #0
}
    4000db34:	f9400bf3 	ldr	x19, [sp, #16]
    4000db38:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000db3c:	d65f03c0 	ret
		return -ENODEV;
    4000db40:	12800240 	mov	w0, #0xffffffed            	// #-19
    4000db44:	17fffffc 	b	4000db34 <uart_console_init+0x44>

000000004000db48 <console_out>:
{
    4000db48:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if ('\n' == c) {
    4000db4c:	7100281f 	cmp	w0, #0xa
{
    4000db50:	910003fd 	mov	x29, sp
    4000db54:	a90153f3 	stp	x19, x20, [sp, #16]
    4000db58:	2a0003f3 	mov	w19, w0
    4000db5c:	900000b4 	adrp	x20, 40021000 <k_sys_work_q+0x240>
	if ('\n' == c) {
    4000db60:	540000c1 	b.ne	4000db78 <console_out+0x30>  // b.any
		uart_poll_out(uart_console_dev, '\r');
    4000db64:	f9437a80 	ldr	x0, [x20, #1776]
	api->poll_out(dev, out_char);
    4000db68:	f9400801 	ldr	x1, [x0, #16]
    4000db6c:	f9400422 	ldr	x2, [x1, #8]
    4000db70:	528001a1 	mov	w1, #0xd                   	// #13
    4000db74:	d63f0040 	blr	x2
	uart_poll_out(uart_console_dev, c);
    4000db78:	f9437a80 	ldr	x0, [x20, #1776]
    4000db7c:	f9400801 	ldr	x1, [x0, #16]
    4000db80:	f9400422 	ldr	x2, [x1, #8]
    4000db84:	2a1303e1 	mov	w1, w19
    4000db88:	d63f0040 	blr	x2
}
    4000db8c:	2a1303e0 	mov	w0, w19
    4000db90:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000db94:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000db98:	d65f03c0 	ret

000000004000db9c <pl011_poll_in>:
	return 0;
}

static bool pl011_is_readable(const struct device *dev)
{
	if (!DEV_DATA(dev)->sbsa &&
    4000db9c:	f9401003 	ldr	x3, [x0, #32]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    4000dba0:	f9400402 	ldr	x2, [x0, #8]
	if (!DEV_DATA(dev)->sbsa &&
    4000dba4:	39401063 	ldrb	w3, [x3, #4]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    4000dba8:	f9400042 	ldr	x2, [x2]
	if (!DEV_DATA(dev)->sbsa &&
    4000dbac:	350000a3 	cbnz	w3, 4000dbc0 <pl011_poll_in+0x24>
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    4000dbb0:	b9403043 	ldr	w3, [x2, #48]
	if (!DEV_DATA(dev)->sbsa &&
    4000dbb4:	36000183 	tbz	w3, #0, 4000dbe4 <pl011_poll_in+0x48>
	     !(PL011_REGS(dev)->cr & PL011_CR_RXE)))
    4000dbb8:	b9403043 	ldr	w3, [x2, #48]
	    (!(PL011_REGS(dev)->cr & PL011_CR_UARTEN) ||
    4000dbbc:	36480143 	tbz	w3, #9, 4000dbe4 <pl011_poll_in+0x48>
		return false;

	return (PL011_REGS(dev)->fr & PL011_FR_RXFE) == 0U;
    4000dbc0:	b9401843 	ldr	w3, [x2, #24]
}

static int pl011_poll_in(const struct device *dev, unsigned char *c)
{
	if (!pl011_is_readable(dev)) {
    4000dbc4:	37200103 	tbnz	w3, #4, 4000dbe4 <pl011_poll_in+0x48>
		return -1;
	}

	/* got a character */
	*c = (unsigned char)PL011_REGS(dev)->dr;
    4000dbc8:	b9400042 	ldr	w2, [x2]
    4000dbcc:	39000022 	strb	w2, [x1]

	return PL011_REGS(dev)->rsr & PL011_RSR_ERROR_MASK;
    4000dbd0:	f9400400 	ldr	x0, [x0, #8]
    4000dbd4:	f9400000 	ldr	x0, [x0]
    4000dbd8:	b9400400 	ldr	w0, [x0, #4]
    4000dbdc:	12000c00 	and	w0, w0, #0xf
}
    4000dbe0:	d65f03c0 	ret
		return -1;
    4000dbe4:	12800000 	mov	w0, #0xffffffff            	// #-1
    4000dbe8:	17fffffe 	b	4000dbe0 <pl011_poll_in+0x44>

000000004000dbec <pl011_poll_out>:

static void pl011_poll_out(const struct device *dev,
					     unsigned char c)
{
	/* Wait for space in FIFO */
	while (PL011_REGS(dev)->fr & PL011_FR_TXFF) {
    4000dbec:	f9400400 	ldr	x0, [x0, #8]
{
    4000dbf0:	12001c21 	and	w1, w1, #0xff
	while (PL011_REGS(dev)->fr & PL011_FR_TXFF) {
    4000dbf4:	f9400000 	ldr	x0, [x0]
    4000dbf8:	b9401802 	ldr	w2, [x0, #24]
    4000dbfc:	372fffe2 	tbnz	w2, #5, 4000dbf8 <pl011_poll_out+0xc>
		; /* Wait */
	}

	/* Send a character */
	PL011_REGS(dev)->dr = (uint32_t)c;
    4000dc00:	b9000001 	str	w1, [x0]
}
    4000dc04:	d65f03c0 	ret

000000004000dc08 <pl011_fifo_fill>:
static int pl011_fifo_fill(const struct device *dev,
				    const uint8_t *tx_data, int len)
{
	uint8_t num_tx = 0U;

	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    4000dc08:	f9400400 	ldr	x0, [x0, #8]
    4000dc0c:	f9400003 	ldr	x3, [x0]
	uint8_t num_tx = 0U;
    4000dc10:	52800000 	mov	w0, #0x0                   	// #0
	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    4000dc14:	b9401864 	ldr	w4, [x3, #24]
    4000dc18:	37280084 	tbnz	w4, #5, 4000dc28 <pl011_fifo_fill+0x20>
	       (len - num_tx > 0)) {
    4000dc1c:	4b000044 	sub	w4, w2, w0
	while (!(PL011_REGS(dev)->fr & PL011_FR_TXFF) &&
    4000dc20:	7100009f 	cmp	w4, #0x0
    4000dc24:	5400004c 	b.gt	4000dc2c <pl011_fifo_fill+0x24>
		PL011_REGS(dev)->dr = tx_data[num_tx++];
	}
	return num_tx;
}
    4000dc28:	d65f03c0 	ret
		PL011_REGS(dev)->dr = tx_data[num_tx++];
    4000dc2c:	11000404 	add	w4, w0, #0x1
    4000dc30:	92401c00 	and	x0, x0, #0xff
    4000dc34:	38606820 	ldrb	w0, [x1, x0]
    4000dc38:	b9000060 	str	w0, [x3]
    4000dc3c:	12001c80 	and	w0, w4, #0xff
    4000dc40:	17fffff5 	b	4000dc14 <pl011_fifo_fill+0xc>

000000004000dc44 <pl011_fifo_read>:

static int pl011_fifo_read(const struct device *dev,
				    uint8_t *rx_data, const int len)
{
    4000dc44:	aa0003e4 	mov	x4, x0
	uint8_t num_rx = 0U;
    4000dc48:	52800000 	mov	w0, #0x0                   	// #0

	while ((len - num_rx > 0) &&
    4000dc4c:	4b000043 	sub	w3, w2, w0
    4000dc50:	7100007f 	cmp	w3, #0x0
    4000dc54:	540000ad 	b.le	4000dc68 <pl011_fifo_read+0x24>
	       !(PL011_REGS(dev)->fr & PL011_FR_RXFE)) {
    4000dc58:	f9400483 	ldr	x3, [x4, #8]
    4000dc5c:	f9400063 	ldr	x3, [x3]
    4000dc60:	b9401865 	ldr	w5, [x3, #24]
	while ((len - num_rx > 0) &&
    4000dc64:	36200045 	tbz	w5, #4, 4000dc6c <pl011_fifo_read+0x28>
		rx_data[num_rx++] = PL011_REGS(dev)->dr;
	}

	return num_rx;
}
    4000dc68:	d65f03c0 	ret
		rx_data[num_rx++] = PL011_REGS(dev)->dr;
    4000dc6c:	b9400066 	ldr	w6, [x3]
    4000dc70:	92401c03 	and	x3, x0, #0xff
    4000dc74:	11000405 	add	w5, w0, #0x1
    4000dc78:	12001ca0 	and	w0, w5, #0xff
    4000dc7c:	38236826 	strb	w6, [x1, x3]
    4000dc80:	17fffff3 	b	4000dc4c <pl011_fifo_read+0x8>

000000004000dc84 <pl011_irq_tx_enable>:

static void pl011_irq_tx_enable(const struct device *dev)
{
	PL011_REGS(dev)->imsc |= PL011_IMSC_TXIM;
    4000dc84:	f9400400 	ldr	x0, [x0, #8]
    4000dc88:	f9400001 	ldr	x1, [x0]
    4000dc8c:	b9403820 	ldr	w0, [x1, #56]
    4000dc90:	321b0000 	orr	w0, w0, #0x20
    4000dc94:	b9003820 	str	w0, [x1, #56]
}
    4000dc98:	d65f03c0 	ret

000000004000dc9c <pl011_irq_tx_disable>:

static void pl011_irq_tx_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~PL011_IMSC_TXIM;
    4000dc9c:	f9400400 	ldr	x0, [x0, #8]
    4000dca0:	f9400001 	ldr	x1, [x0]
    4000dca4:	b9403820 	ldr	w0, [x1, #56]
    4000dca8:	121a7800 	and	w0, w0, #0xffffffdf
    4000dcac:	b9003820 	str	w0, [x1, #56]
}
    4000dcb0:	d65f03c0 	ret

000000004000dcb4 <pl011_irq_tx_complete>:

static int pl011_irq_tx_complete(const struct device *dev)
{
	/* check for TX FIFO empty */
	return PL011_REGS(dev)->fr & PL011_FR_TXFE;
    4000dcb4:	f9400400 	ldr	x0, [x0, #8]
    4000dcb8:	f9400000 	ldr	x0, [x0]
    4000dcbc:	b9401800 	ldr	w0, [x0, #24]
}
    4000dcc0:	12190000 	and	w0, w0, #0x80
    4000dcc4:	d65f03c0 	ret

000000004000dcc8 <pl011_irq_rx_enable>:
		pl011_irq_tx_complete(dev));
}

static void pl011_irq_rx_enable(const struct device *dev)
{
	PL011_REGS(dev)->imsc |= PL011_IMSC_RXIM |
    4000dcc8:	f9400400 	ldr	x0, [x0, #8]
    4000dccc:	52800a02 	mov	w2, #0x50                  	// #80
    4000dcd0:	f9400001 	ldr	x1, [x0]
    4000dcd4:	b9403820 	ldr	w0, [x1, #56]
    4000dcd8:	2a020000 	orr	w0, w0, w2
    4000dcdc:	b9003820 	str	w0, [x1, #56]
				 PL011_IMSC_RTIM;
}
    4000dce0:	d65f03c0 	ret

000000004000dce4 <pl011_irq_rx_disable>:

static void pl011_irq_rx_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~(PL011_IMSC_RXIM |
    4000dce4:	f9400400 	ldr	x0, [x0, #8]
    4000dce8:	12800a02 	mov	w2, #0xffffffaf            	// #-81
    4000dcec:	f9400001 	ldr	x1, [x0]
    4000dcf0:	b9403820 	ldr	w0, [x1, #56]
    4000dcf4:	0a020000 	and	w0, w0, w2
    4000dcf8:	b9003820 	str	w0, [x1, #56]
				   PL011_IMSC_RTIM);
}
    4000dcfc:	d65f03c0 	ret

000000004000dd00 <pl011_irq_rx_ready>:

static int pl011_irq_rx_ready(const struct device *dev)
{
	if (!DEV_DATA(dev)->sbsa && !(PL011_REGS(dev)->cr & PL011_CR_RXE))
    4000dd00:	f9400401 	ldr	x1, [x0, #8]
    4000dd04:	f9401000 	ldr	x0, [x0, #32]
    4000dd08:	f9400021 	ldr	x1, [x1]
    4000dd0c:	39401000 	ldrb	w0, [x0, #4]
    4000dd10:	35000060 	cbnz	w0, 4000dd1c <pl011_irq_rx_ready+0x1c>
    4000dd14:	b9403020 	ldr	w0, [x1, #48]
    4000dd18:	364800e0 	tbz	w0, #9, 4000dd34 <pl011_irq_rx_ready+0x34>
		return false;

	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    4000dd1c:	b9403820 	ldr	w0, [x1, #56]
    4000dd20:	362000a0 	tbz	w0, #4, 4000dd34 <pl011_irq_rx_ready+0x34>
		(!(PL011_REGS(dev)->fr & PL011_FR_RXFE)));
    4000dd24:	b9401820 	ldr	w0, [x1, #24]
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    4000dd28:	d27c0000 	eor	x0, x0, #0x10
    4000dd2c:	d3441000 	ubfx	x0, x0, #4, #1
}
    4000dd30:	d65f03c0 	ret
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_RXIM) &&
    4000dd34:	52800000 	mov	w0, #0x0                   	// #0
    4000dd38:	17fffffe 	b	4000dd30 <pl011_irq_rx_ready+0x30>

000000004000dd3c <pl011_irq_err_enable>:

static void pl011_irq_err_enable(const struct device *dev)
{
	/* enable framing, parity, break, and overrun */
	PL011_REGS(dev)->imsc |= PL011_IMSC_ERROR_MASK;
    4000dd3c:	f9400400 	ldr	x0, [x0, #8]
    4000dd40:	f9400001 	ldr	x1, [x0]
    4000dd44:	b9403820 	ldr	w0, [x1, #56]
    4000dd48:	32190c00 	orr	w0, w0, #0x780
    4000dd4c:	b9003820 	str	w0, [x1, #56]
}
    4000dd50:	d65f03c0 	ret

000000004000dd54 <pl011_irq_err_disable>:

static void pl011_irq_err_disable(const struct device *dev)
{
	PL011_REGS(dev)->imsc &= ~PL011_IMSC_ERROR_MASK;
    4000dd54:	f9400400 	ldr	x0, [x0, #8]
    4000dd58:	f9400001 	ldr	x1, [x0]
    4000dd5c:	b9403820 	ldr	w0, [x1, #56]
    4000dd60:	12156c00 	and	w0, w0, #0xfffff87f
    4000dd64:	b9003820 	str	w0, [x1, #56]
}
    4000dd68:	d65f03c0 	ret

000000004000dd6c <pl011_irq_update>:
}

static int pl011_irq_update(const struct device *dev)
{
	return 1;
}
    4000dd6c:	52800020 	mov	w0, #0x1                   	// #1
    4000dd70:	d65f03c0 	ret

000000004000dd74 <pl011_irq_callback_set>:

static void pl011_irq_callback_set(const struct device *dev,
					    uart_irq_callback_user_data_t cb,
					    void *cb_data)
{
	DEV_DATA(dev)->irq_cb = cb;
    4000dd74:	f9401000 	ldr	x0, [x0, #32]
	DEV_DATA(dev)->irq_cb_data = cb_data;
    4000dd78:	a9008801 	stp	x1, x2, [x0, #8]
}
    4000dd7c:	d65f03c0 	ret

000000004000dd80 <pl011_isr>:
}

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
void pl011_isr(const struct device *dev)
{
	struct pl011_data *data = DEV_DATA(dev);
    4000dd80:	f9401001 	ldr	x1, [x0, #32]

	/* Verify if the callback has been registered */
	if (data->irq_cb) {
    4000dd84:	f9400422 	ldr	x2, [x1, #8]
    4000dd88:	b4000082 	cbz	x2, 4000dd98 <pl011_isr+0x18>
		data->irq_cb(dev, data->irq_cb_data);
    4000dd8c:	f9400821 	ldr	x1, [x1, #16]
    4000dd90:	aa0203f0 	mov	x16, x2
    4000dd94:	d61f0200 	br	x16
	}
}
    4000dd98:	d65f03c0 	ret

000000004000dd9c <pl011_irq_config_func_0>:
		    CONFIG_SERIAL_INIT_PRIORITY,
		    &pl011_driver_api);

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
static void pl011_irq_config_func_0(const struct device *dev)
{
    4000dd9c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
#if DT_NUM_IRQS(DT_INST(0, arm_pl011)) == 1
	IRQ_CONNECT(DT_INST_IRQN(0),
    4000dda0:	52800002 	mov	w2, #0x0                   	// #0
    4000dda4:	52800001 	mov	w1, #0x0                   	// #0
{
    4000dda8:	910003fd 	mov	x29, sp
	IRQ_CONNECT(DT_INST_IRQN(0),
    4000ddac:	52800420 	mov	w0, #0x21                  	// #33
    4000ddb0:	97fff352 	bl	4000aaf8 <z_arm64_irq_priority_set>
		    pl011_isr,
		    DEVICE_DT_INST_GET(0),
		    0);
	irq_enable(DT_INST_IRQ_BY_NAME(0, rxtim, irq));
#endif
}
    4000ddb4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	irq_enable(DT_INST_IRQN(0));
    4000ddb8:	52800420 	mov	w0, #0x21                  	// #33
    4000ddbc:	17fff34e 	b	4000aaf4 <arch_irq_enable>

000000004000ddc0 <pl011_irq_tx_ready>:
	if (!DEV_DATA(dev)->sbsa && !(PL011_REGS(dev)->cr & PL011_CR_TXE))
    4000ddc0:	f9401002 	ldr	x2, [x0, #32]
    4000ddc4:	f9400401 	ldr	x1, [x0, #8]
    4000ddc8:	39401042 	ldrb	w2, [x2, #4]
    4000ddcc:	f9400021 	ldr	x1, [x1]
    4000ddd0:	35000062 	cbnz	w2, 4000dddc <pl011_irq_tx_ready+0x1c>
    4000ddd4:	b9403022 	ldr	w2, [x1, #48]
    4000ddd8:	36400142 	tbz	w2, #8, 4000de00 <pl011_irq_tx_ready+0x40>
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_TXIM) &&
    4000dddc:	b9403821 	ldr	w1, [x1, #56]
    4000dde0:	36280101 	tbz	w1, #5, 4000de00 <pl011_irq_tx_ready+0x40>
{
    4000dde4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000dde8:	910003fd 	mov	x29, sp
		pl011_irq_tx_complete(dev));
    4000ddec:	97ffffb2 	bl	4000dcb4 <pl011_irq_tx_complete>
	return ((PL011_REGS(dev)->imsc & PL011_IMSC_TXIM) &&
    4000ddf0:	7100001f 	cmp	w0, #0x0
    4000ddf4:	1a9f07e0 	cset	w0, ne  // ne = any
}
    4000ddf8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000ddfc:	d65f03c0 	ret
		return false;
    4000de00:	52800000 	mov	w0, #0x0                   	// #0
}
    4000de04:	d65f03c0 	ret

000000004000de08 <pl011_irq_is_pending>:
{
    4000de08:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000de0c:	aa0003e2 	mov	x2, x0
    4000de10:	910003fd 	mov	x29, sp
	return pl011_irq_rx_ready(dev) || pl011_irq_tx_ready(dev);
    4000de14:	97ffffbb 	bl	4000dd00 <pl011_irq_rx_ready>
    4000de18:	350000e0 	cbnz	w0, 4000de34 <pl011_irq_is_pending+0x2c>
    4000de1c:	aa0203e0 	mov	x0, x2
    4000de20:	97ffffe8 	bl	4000ddc0 <pl011_irq_tx_ready>
    4000de24:	7100001f 	cmp	w0, #0x0
    4000de28:	1a9f07e0 	cset	w0, ne  // ne = any
}
    4000de2c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000de30:	d65f03c0 	ret
	return pl011_irq_rx_ready(dev) || pl011_irq_tx_ready(dev);
    4000de34:	52800020 	mov	w0, #0x1                   	// #1
    4000de38:	17fffffd 	b	4000de2c <pl011_irq_is_pending+0x24>

000000004000de3c <pl011_init>:
{
    4000de3c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000de40:	910003fd 	mov	x29, sp
	if (!DEV_DATA(dev)->sbsa) {
    4000de44:	f9401002 	ldr	x2, [x0, #32]
{
    4000de48:	f9000bf3 	str	x19, [sp, #16]
    4000de4c:	aa0003f3 	mov	x19, x0
	if (!DEV_DATA(dev)->sbsa) {
    4000de50:	39401040 	ldrb	w0, [x2, #4]
    4000de54:	35000460 	cbnz	w0, 4000dee0 <pl011_init+0xa4>
    4000de58:	f9400663 	ldr	x3, [x19, #8]
				/ (baudrate * 16U);
    4000de5c:	b9400042 	ldr	w2, [x2]
	PL011_REGS(dev)->cr &= ~PL011_CR_UARTEN;
    4000de60:	f9400061 	ldr	x1, [x3]
				/ (baudrate * 16U);
    4000de64:	531c6c42 	lsl	w2, w2, #4
	PL011_REGS(dev)->cr &= ~PL011_CR_UARTEN;
    4000de68:	b9403020 	ldr	w0, [x1, #48]
    4000de6c:	121f7800 	and	w0, w0, #0xfffffffe
    4000de70:	b9003020 	str	w0, [x1, #48]
	PL011_REGS(dev)->lcr_h &= ~PL011_LCRH_FEN;
    4000de74:	b9402c20 	ldr	w0, [x1, #44]
    4000de78:	121b7800 	and	w0, w0, #0xffffffef
    4000de7c:	b9002c20 	str	w0, [x1, #44]
	uint64_t bauddiv = (((uint64_t)clk) << PL011_FBRD_WIDTH)
    4000de80:	b9400860 	ldr	w0, [x3, #8]
    4000de84:	d37ae400 	lsl	x0, x0, #6
    4000de88:	9ac20800 	udiv	x0, x0, x2
	if ((bauddiv < (1u << PL011_FBRD_WIDTH))
    4000de8c:	b2793be2 	mov	x2, #0x3fff80              	// #4194176
		|| (bauddiv > (65535u << PL011_FBRD_WIDTH))) {
    4000de90:	d1010003 	sub	x3, x0, #0x40
	if ((bauddiv < (1u << PL011_FBRD_WIDTH))
    4000de94:	eb02007f 	cmp	x3, x2
    4000de98:	54000688 	b.hi	4000df68 <pl011_init+0x12c>  // b.pmore
	PL011_REGS(dev)->ibrd = bauddiv >> PL011_FBRD_WIDTH;
    4000de9c:	d346fc02 	lsr	x2, x0, #6
    4000dea0:	b9002422 	str	w2, [x1, #36]
	PL011_REGS(dev)->fbrd = bauddiv & ((1u << PL011_FBRD_WIDTH) - 1u);
    4000dea4:	12001400 	and	w0, w0, #0x3f
    4000dea8:	b9002820 	str	w0, [x1, #40]
	__DMB();
    4000deac:	d5033fbf 	dmb	sy
	PL011_REGS(dev)->lcr_h = PL011_REGS(dev)->lcr_h;
    4000deb0:	f9400660 	ldr	x0, [x19, #8]
		lcrh &= ~(BIT(0) | BIT(7));
    4000deb4:	12801ce2 	mov	w2, #0xffffff18            	// #-232
	PL011_REGS(dev)->lcr_h = PL011_REGS(dev)->lcr_h;
    4000deb8:	f9400000 	ldr	x0, [x0]
    4000debc:	b9402c01 	ldr	w1, [x0, #44]
    4000dec0:	b9002c01 	str	w1, [x0, #44]
		lcrh = PL011_REGS(dev)->lcr_h & ~(PL011_LCRH_FORMAT_MASK);
    4000dec4:	b9402c01 	ldr	w1, [x0, #44]
		lcrh &= ~(BIT(0) | BIT(7));
    4000dec8:	0a020021 	and	w1, w1, w2
		lcrh |= PL011_LCRH_WLEN_SIZE(8) << PL011_LCRH_WLEN_SHIFT;
    4000decc:	321b0421 	orr	w1, w1, #0x60
		PL011_REGS(dev)->lcr_h = lcrh;
    4000ded0:	b9002c01 	str	w1, [x0, #44]
	PL011_REGS(dev)->lcr_h |= PL011_LCRH_FEN;
    4000ded4:	b9402c01 	ldr	w1, [x0, #44]
    4000ded8:	321c0021 	orr	w1, w1, #0x10
    4000dedc:	b9002c01 	str	w1, [x0, #44]
	PL011_REGS(dev)->imsc = 0U;
    4000dee0:	f9400660 	ldr	x0, [x19, #8]
	PL011_REGS(dev)->icr = PL011_IMSC_MASK_ALL;
    4000dee4:	5280ffe1 	mov	w1, #0x7ff                 	// #2047
	PL011_REGS(dev)->imsc = 0U;
    4000dee8:	f9400000 	ldr	x0, [x0]
    4000deec:	b900381f 	str	wzr, [x0, #56]
	PL011_REGS(dev)->icr = PL011_IMSC_MASK_ALL;
    4000def0:	b9004401 	str	w1, [x0, #68]
	if (!DEV_DATA(dev)->sbsa) {
    4000def4:	f9401261 	ldr	x1, [x19, #32]
    4000def8:	39401021 	ldrb	w1, [x1, #4]
    4000defc:	350001a1 	cbnz	w1, 4000df30 <pl011_init+0xf4>
		PL011_REGS(dev)->dmacr = 0U;
    4000df00:	b900481f 	str	wzr, [x0, #72]
		__ISB();
    4000df04:	d5033fdf 	isb
		PL011_REGS(dev)->cr &= ~(BIT(14) | BIT(15) | BIT(1));
    4000df08:	f9400660 	ldr	x0, [x19, #8]
    4000df0c:	12980042 	mov	w2, #0xffff3ffd            	// #-49155
    4000df10:	f9400000 	ldr	x0, [x0]
    4000df14:	b9403001 	ldr	w1, [x0, #48]
    4000df18:	0a020021 	and	w1, w1, w2
    4000df1c:	b9003001 	str	w1, [x0, #48]
		PL011_REGS(dev)->cr |= PL011_CR_RXE | PL011_CR_TXE;
    4000df20:	b9403001 	ldr	w1, [x0, #48]
    4000df24:	32180421 	orr	w1, w1, #0x300
    4000df28:	b9003001 	str	w1, [x0, #48]
		__ISB();
    4000df2c:	d5033fdf 	isb
	DEV_CFG(dev)->irq_config_func(dev);
    4000df30:	f9400660 	ldr	x0, [x19, #8]
    4000df34:	f9400801 	ldr	x1, [x0, #16]
    4000df38:	aa1303e0 	mov	x0, x19
    4000df3c:	d63f0020 	blr	x1
	if (!DEV_DATA(dev)->sbsa)
    4000df40:	f9401260 	ldr	x0, [x19, #32]
    4000df44:	39401000 	ldrb	w0, [x0, #4]
    4000df48:	350000c0 	cbnz	w0, 4000df60 <pl011_init+0x124>
	PL011_REGS(dev)->cr |=  PL011_CR_UARTEN;
    4000df4c:	f9400660 	ldr	x0, [x19, #8]
    4000df50:	f9400001 	ldr	x1, [x0]
    4000df54:	b9403020 	ldr	w0, [x1, #48]
    4000df58:	32000000 	orr	w0, w0, #0x1
    4000df5c:	b9003020 	str	w0, [x1, #48]
	return 0;
    4000df60:	52800000 	mov	w0, #0x0                   	// #0
    4000df64:	14000002 	b	4000df6c <pl011_init+0x130>
		return -EINVAL;
    4000df68:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
    4000df6c:	f9400bf3 	ldr	x19, [sp, #16]
    4000df70:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000df74:	d65f03c0 	ret

000000004000df78 <arm_arch_timer_compare_isr>:
MAKE_REG_HELPER(daif)
    4000df78:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000df7c:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    4000df80:	d53be040 	mrs	x0, cntvct_el0
		return;
	}
#endif /* CONFIG_ARM_ARCH_TIMER_ERRATUM_740657 */

	uint64_t curr_cycle = arm_arch_timer_count();
	uint32_t delta_ticks = (uint32_t)((curr_cycle - last_cycle) / CYC_PER_TICK);
    4000df84:	900000a3 	adrp	x3, 40021000 <k_sys_work_q+0x240>
    4000df88:	f9437c64 	ldr	x4, [x3, #1784]
    4000df8c:	d2912d05 	mov	x5, #0x8968                	// #35176
    4000df90:	f2a00125 	movk	x5, #0x9, lsl #16
    4000df94:	cb040000 	sub	x0, x0, x4
    4000df98:	9ac50800 	udiv	x0, x0, x5

	last_cycle += delta_ticks * CYC_PER_TICK;
    4000df9c:	92407c02 	and	x2, x0, #0xffffffff
    4000dfa0:	9b051042 	madd	x2, x2, x5, x4
    4000dfa4:	f9037c62 	str	x2, [x3, #1784]
MAKE_REG_HELPER(cntv_ctl_el0)
    4000dfa8:	d53be322 	mrs	x2, cntv_ctl_el0
	uint64_t cntv_ctl;

	cntv_ctl = read_cntv_ctl_el0();

	if (mask) {
		cntv_ctl |= CNTV_CTL_IMASK_BIT;
    4000dfac:	b27f0042 	orr	x2, x2, #0x2
    4000dfb0:	d51be322 	msr	cntv_ctl_el0, x2
MAKE_REG_HELPER(daif)
    4000dfb4:	92407c21 	and	x1, x1, #0xffffffff
    4000dfb8:	d51b4221 	msr	daif, x1
	}
#endif /* CONFIG_ARM_ARCH_TIMER_ERRATUM_740657 */

	k_spin_unlock(&lock, key);

	sys_clock_announce(delta_ticks);
    4000dfbc:	140008bc 	b	400102ac <sys_clock_announce>

000000004000dfc0 <sys_clock_driver_init>:
}

int sys_clock_driver_init(const struct device *dev)
{
    4000dfc0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ARG_UNUSED(dev);

	IRQ_CONNECT(ARM_ARCH_TIMER_IRQ, ARM_ARCH_TIMER_PRIO,
    4000dfc4:	52800042 	mov	w2, #0x2                   	// #2
    4000dfc8:	52801401 	mov	w1, #0xa0                  	// #160
{
    4000dfcc:	910003fd 	mov	x29, sp
	IRQ_CONNECT(ARM_ARCH_TIMER_IRQ, ARM_ARCH_TIMER_PRIO,
    4000dfd0:	52800360 	mov	w0, #0x1b                  	// #27
    4000dfd4:	97fff2c9 	bl	4000aaf8 <z_arm64_irq_priority_set>
MAKE_REG_HELPER(cntvct_el0);
    4000dfd8:	d53be040 	mrs	x0, cntvct_el0
		    arm_arch_timer_compare_isr, NULL, ARM_ARCH_TIMER_FLAGS);
	arm_arch_timer_init();
	arm_arch_timer_set_compare(arm_arch_timer_count() + CYC_PER_TICK);
    4000dfdc:	91426000 	add	x0, x0, #0x98, lsl #12
    4000dfe0:	9125a000 	add	x0, x0, #0x968
MAKE_REG_HELPER(cntv_cval_el0)
    4000dfe4:	d51be340 	msr	cntv_cval_el0, x0
MAKE_REG_HELPER(cntv_ctl_el0)
    4000dfe8:	d53be320 	mrs	x0, cntv_ctl_el0
		cntv_ctl |= CNTV_CTL_ENABLE_BIT;
    4000dfec:	b2400000 	orr	x0, x0, #0x1
    4000dff0:	d51be320 	msr	cntv_ctl_el0, x0
	arm_arch_timer_enable(true);
	irq_enable(ARM_ARCH_TIMER_IRQ);
    4000dff4:	52800360 	mov	w0, #0x1b                  	// #27
    4000dff8:	97fff2bf 	bl	4000aaf4 <arch_irq_enable>
    4000dffc:	d53be320 	mrs	x0, cntv_ctl_el0
	} else {
		cntv_ctl &= ~CNTV_CTL_IMASK_BIT;
    4000e000:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    4000e004:	d51be320 	msr	cntv_ctl_el0, x0
	arm_arch_timer_set_irq_mask(false);

	return 0;
}
    4000e008:	52800000 	mov	w0, #0x0                   	// #0
    4000e00c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000e010:	d65f03c0 	ret

000000004000e014 <sys_clock_set_timeout>:

void sys_clock_set_timeout(int32_t ticks, bool idle)
{
#if defined(CONFIG_TICKLESS_KERNEL)

	if (ticks == K_TICKS_FOREVER && idle) {
    4000e014:	72001c3f 	tst	w1, #0xff
    4000e018:	3a411800 	ccmn	w0, #0x1, #0x0, ne  // ne = any
    4000e01c:	54000420 	b.eq	4000e0a0 <sys_clock_set_timeout+0x8c>  // b.none
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : \
    4000e020:	3100041f 	cmn	w0, #0x1
    4000e024:	54000400 	b.eq	4000e0a4 <sys_clock_set_timeout+0x90>  // b.none
    4000e028:	71000400 	subs	w0, w0, #0x1
    4000e02c:	1a9f5000 	csel	w0, w0, wzr, pl  // pl = nfrst
MAKE_REG_HELPER(daif)
    4000e030:	d53b4224 	mrs	x4, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e034:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    4000e038:	d53be042 	mrs	x2, cntvct_el0
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t curr_cycle = arm_arch_timer_count();
	uint64_t req_cycle = ticks * CYC_PER_TICK;

	/* Round up to next tick boundary */
	req_cycle += (curr_cycle - last_cycle) + (CYC_PER_TICK - 1);
    4000e03c:	f0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000e040:	f9437c23 	ldr	x3, [x1, #1784]
    4000e044:	52912d05 	mov	w5, #0x8968                	// #35176
    4000e048:	72a00125 	movk	w5, #0x9, lsl #16
    4000e04c:	d2912ce1 	mov	x1, #0x8967                	// #35175
    4000e050:	f2a00121 	movk	x1, #0x9, lsl #16
    4000e054:	cb030021 	sub	x1, x1, x3
    4000e058:	9b250800 	smaddl	x0, w0, w5, x2

	req_cycle = (req_cycle / CYC_PER_TICK) * CYC_PER_TICK;

	if ((req_cycle + last_cycle - curr_cycle) < MIN_DELAY) {
    4000e05c:	cb020062 	sub	x2, x3, x2
	req_cycle += (curr_cycle - last_cycle) + (CYC_PER_TICK - 1);
    4000e060:	8b000020 	add	x0, x1, x0
	req_cycle = (req_cycle / CYC_PER_TICK) * CYC_PER_TICK;
    4000e064:	d2912d01 	mov	x1, #0x8968                	// #35176
    4000e068:	f2a00121 	movk	x1, #0x9, lsl #16
    4000e06c:	9ac10800 	udiv	x0, x0, x1
    4000e070:	9b017c00 	mul	x0, x0, x1
	if ((req_cycle + last_cycle - curr_cycle) < MIN_DELAY) {
    4000e074:	8b000042 	add	x2, x2, x0
    4000e078:	f10f9c5f 	cmp	x2, #0x3e7
    4000e07c:	54000048 	b.hi	4000e084 <sys_clock_set_timeout+0x70>  // b.pmore
		req_cycle += CYC_PER_TICK;
    4000e080:	8b010000 	add	x0, x0, x1
	}

	arm_arch_timer_set_compare(req_cycle + last_cycle);
    4000e084:	8b000060 	add	x0, x3, x0
MAKE_REG_HELPER(cntv_cval_el0)
    4000e088:	d51be340 	msr	cntv_cval_el0, x0
MAKE_REG_HELPER(cntv_ctl_el0)
    4000e08c:	d53be320 	mrs	x0, cntv_ctl_el0
    4000e090:	927ef800 	and	x0, x0, #0xfffffffffffffffd
    4000e094:	d51be320 	msr	cntv_ctl_el0, x0
MAKE_REG_HELPER(daif)
    4000e098:	92407c80 	and	x0, x4, #0xffffffff
    4000e09c:	d51b4220 	msr	daif, x0

#else  /* CONFIG_TICKLESS_KERNEL */
	ARG_UNUSED(ticks);
	ARG_UNUSED(idle);
#endif
}
    4000e0a0:	d65f03c0 	ret
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : \
    4000e0a4:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    4000e0a8:	17ffffe2 	b	4000e030 <sys_clock_set_timeout+0x1c>

000000004000e0ac <sys_clock_elapsed>:
    4000e0ac:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e0b0:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(cntvct_el0);
    4000e0b4:	d53be040 	mrs	x0, cntvct_el0
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = (uint32_t)((arm_arch_timer_count() - last_cycle)
    4000e0b8:	f0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    4000e0bc:	f9437c42 	ldr	x2, [x2, #1784]
MAKE_REG_HELPER(daif)
    4000e0c0:	92407c21 	and	x1, x1, #0xffffffff
    4000e0c4:	cb020000 	sub	x0, x0, x2
		    / CYC_PER_TICK);
    4000e0c8:	d2912d02 	mov	x2, #0x8968                	// #35176
    4000e0cc:	f2a00122 	movk	x2, #0x9, lsl #16
    4000e0d0:	9ac20800 	udiv	x0, x0, x2
    4000e0d4:	d51b4221 	msr	daif, x1

	k_spin_unlock(&lock, key);
	return ret;
}
    4000e0d8:	d65f03c0 	ret

000000004000e0dc <sys_clock_cycle_get_32>:
MAKE_REG_HELPER(cntvct_el0);
    4000e0dc:	d53be040 	mrs	x0, cntvct_el0

uint32_t sys_clock_cycle_get_32(void)
{
	return (uint32_t)arm_arch_timer_count();
}
    4000e0e0:	d65f03c0 	ret

000000004000e0e4 <arch_busy_wait>:
}

#ifdef CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT
void arch_busy_wait(uint32_t usec_to_wait)
{
	if (usec_to_wait == 0) {
    4000e0e4:	34000100 	cbz	w0, 4000e104 <arch_busy_wait+0x20>
    4000e0e8:	d53be042 	mrs	x2, cntvct_el0
		return;
	}

	uint64_t start_cycles = arm_arch_timer_count();

	uint64_t cycles_to_wait = sys_clock_hw_cycles_per_sec() / USEC_PER_SEC * usec_to_wait;
    4000e0ec:	528007c1 	mov	w1, #0x3e                  	// #62
    4000e0f0:	1b017c00 	mul	w0, w0, w1
    4000e0f4:	d53be041 	mrs	x1, cntvct_el0

	for (;;) {
		uint64_t current_cycles = arm_arch_timer_count();

		/* this handles the rollover on an unsigned 32-bit value */
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
    4000e0f8:	cb020021 	sub	x1, x1, x2
    4000e0fc:	eb00003f 	cmp	x1, x0
    4000e100:	54ffffa3 	b.cc	4000e0f4 <arch_busy_wait+0x10>  // b.lo, b.ul, b.last
			break;
		}
	}
}
    4000e104:	d65f03c0 	ret

000000004000e108 <device_visitor>:

static int device_visitor(const device_handle_t *handles,
			   size_t handle_count,
			   device_visitor_callback_t visitor_cb,
			   void *context)
{
    4000e108:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    4000e10c:	910003fd 	mov	x29, sp
    4000e110:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t numdev = __device_end - __device_start;
    4000e114:	90000033 	adrp	x19, 40012000 <__rodata_region_start>
    4000e118:	91040273 	add	x19, x19, #0x100
    4000e11c:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000e120:	90000035 	adrp	x21, 40012000 <__rodata_region_start>
    4000e124:	910282b5 	add	x21, x21, #0xa0
    4000e128:	cb150273 	sub	x19, x19, x21
    4000e12c:	a90363f7 	stp	x23, x24, [sp, #48]
    4000e130:	aa0003f7 	mov	x23, x0
    4000e134:	9344fe73 	asr	x19, x19, #4
    4000e138:	b201f3e0 	mov	x0, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
    4000e13c:	f2955560 	movk	x0, #0xaaab
    4000e140:	aa0103f6 	mov	x22, x1
    4000e144:	aa0203f8 	mov	x24, x2
    4000e148:	a9046bf9 	stp	x25, x26, [sp, #64]
    4000e14c:	9b007e73 	mul	x19, x19, x0
    4000e150:	aa0303f9 	mov	x25, x3
	/* Iterate over fixed devices */
	for (size_t i = 0; i < handle_count; ++i) {
    4000e154:	d2800014 	mov	x20, #0x0                   	// #0
		dev = &__device_start[dev_handle - 1];
    4000e158:	5280061a 	mov	w26, #0x30                  	// #48
    4000e15c:	eb16029f 	cmp	x20, x22
    4000e160:	54000101 	b.ne	4000e180 <device_visitor+0x78>  // b.any
		if (rc < 0) {
			return rc;
		}
	}

	return handle_count;
    4000e164:	2a1403e0 	mov	w0, w20
}
    4000e168:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e16c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000e170:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000e174:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000e178:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4000e17c:	d65f03c0 	ret
		device_handle_t dh = handles[i];
    4000e180:	78f47ae0 	ldrsh	w0, [x23, x20, lsl #1]
	if ((dev_handle > 0) && ((size_t)dev_handle <= numdev)) {
    4000e184:	7100001f 	cmp	w0, #0x0
    4000e188:	5400016d 	b.le	4000e1b4 <device_visitor+0xac>
		dev = &__device_start[dev_handle - 1];
    4000e18c:	51000404 	sub	w4, w0, #0x1
    4000e190:	eb20a27f 	cmp	x19, w0, sxth
    4000e194:	13003c84 	sxth	w4, w4
    4000e198:	9b3a5484 	smaddl	x4, w4, w26, x21
    4000e19c:	9a9f2080 	csel	x0, x4, xzr, cs  // cs = hs, nlast
		int rc = visitor_cb(rdev, context);
    4000e1a0:	aa1903e1 	mov	x1, x25
    4000e1a4:	d63f0300 	blr	x24
		if (rc < 0) {
    4000e1a8:	37fffe00 	tbnz	w0, #31, 4000e168 <device_visitor+0x60>
	for (size_t i = 0; i < handle_count; ++i) {
    4000e1ac:	91000694 	add	x20, x20, #0x1
    4000e1b0:	17ffffeb 	b	4000e15c <device_visitor+0x54>
	const struct device *dev = NULL;
    4000e1b4:	d2800000 	mov	x0, #0x0                   	// #0
    4000e1b8:	17fffffa 	b	4000e1a0 <device_visitor+0x98>

000000004000e1bc <z_device_state_init>:
}
    4000e1bc:	d65f03c0 	ret

000000004000e1c0 <z_sys_init_run_level>:
{
    4000e1c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    4000e1c4:	b0000021 	adrp	x1, 40013000 <shell_cmd_kernel>
    4000e1c8:	913d2021 	add	x1, x1, #0xf48
{
    4000e1cc:	910003fd 	mov	x29, sp
    4000e1d0:	a90153f3 	stp	x19, x20, [sp, #16]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    4000e1d4:	f860d833 	ldr	x19, [x1, w0, sxtw #3]
    4000e1d8:	11000400 	add	w0, w0, #0x1
{
    4000e1dc:	a9025bf5 	stp	x21, x22, [sp, #32]
				dev->state->init_res = rc;
    4000e1e0:	52801ff6 	mov	w22, #0xff                  	// #255
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    4000e1e4:	f860d835 	ldr	x21, [x1, w0, sxtw #3]
    4000e1e8:	eb1302bf 	cmp	x21, x19
    4000e1ec:	540000a8 	b.hi	4000e200 <z_sys_init_run_level+0x40>  // b.pmore
}
    4000e1f0:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e1f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000e1f8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000e1fc:	d65f03c0 	ret
		const struct device *dev = entry->dev;
    4000e200:	a9405261 	ldp	x1, x20, [x19]
		int rc = entry->init(dev);
    4000e204:	aa1403e0 	mov	x0, x20
    4000e208:	d63f0020 	blr	x1
		if (dev != NULL) {
    4000e20c:	b4000174 	cbz	x20, 4000e238 <z_sys_init_run_level+0x78>
			if (rc != 0) {
    4000e210:	7100001f 	cmp	w0, #0x0
				dev->state->init_res = rc;
    4000e214:	f9400e81 	ldr	x1, [x20, #24]
			if (rc != 0) {
    4000e218:	340000a0 	cbz	w0, 4000e22c <z_sys_init_run_level+0x6c>
				if (rc < 0) {
    4000e21c:	5a80a400 	cneg	w0, w0, lt  // lt = tstop
				dev->state->init_res = rc;
    4000e220:	7103fc1f 	cmp	w0, #0xff
    4000e224:	1a96d000 	csel	w0, w0, w22, le
    4000e228:	39000020 	strb	w0, [x1]
			dev->state->initialized = true;
    4000e22c:	79400020 	ldrh	w0, [x1]
    4000e230:	32180000 	orr	w0, w0, #0x100
    4000e234:	79000020 	strh	w0, [x1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    4000e238:	91004273 	add	x19, x19, #0x10
    4000e23c:	17ffffeb 	b	4000e1e8 <z_sys_init_run_level+0x28>

000000004000e240 <z_device_get_all_static>:
	*devices = __device_start;
    4000e240:	90000021 	adrp	x1, 40012000 <__rodata_region_start>
    4000e244:	91028021 	add	x1, x1, #0xa0
    4000e248:	f9000001 	str	x1, [x0]
	return __device_end - __device_start;
    4000e24c:	90000020 	adrp	x0, 40012000 <__rodata_region_start>
    4000e250:	91040000 	add	x0, x0, #0x100
    4000e254:	cb010000 	sub	x0, x0, x1
}
    4000e258:	b201f3e1 	mov	x1, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
    4000e25c:	f2955561 	movk	x1, #0xaaab
	return __device_end - __device_start;
    4000e260:	9344fc00 	asr	x0, x0, #4
}
    4000e264:	9b017c00 	mul	x0, x0, x1
    4000e268:	d65f03c0 	ret

000000004000e26c <z_device_ready>:
	if (dev == NULL) {
    4000e26c:	b40000e0 	cbz	x0, 4000e288 <z_device_ready+0x1c>
	return dev->state->initialized && (dev->state->init_res == 0U);
    4000e270:	f9400c00 	ldr	x0, [x0, #24]
    4000e274:	b9400000 	ldr	w0, [x0]
    4000e278:	12002000 	and	w0, w0, #0x1ff
    4000e27c:	7104001f 	cmp	w0, #0x100
    4000e280:	1a9f17e0 	cset	w0, eq  // eq = none
}
    4000e284:	d65f03c0 	ret
		return false;
    4000e288:	52800000 	mov	w0, #0x0                   	// #0
    4000e28c:	17fffffe 	b	4000e284 <z_device_ready+0x18>

000000004000e290 <device_required_foreach>:
int device_required_foreach(const struct device *dev,
			    device_visitor_callback_t visitor_cb,
			    void *context)
{
	size_t handle_count = 0;
	const device_handle_t *handles = device_required_handles_get(dev, &handle_count);
    4000e290:	f9401400 	ldr	x0, [x0, #40]
{
    4000e294:	aa0103e4 	mov	x4, x1
    4000e298:	aa0203e3 	mov	x3, x2
		size_t i = 0;
    4000e29c:	d2800001 	mov	x1, #0x0                   	// #0
	if (rv != NULL) {
    4000e2a0:	b5000120 	cbnz	x0, 4000e2c4 <device_required_foreach+0x34>

	return device_visitor(handles, handle_count, visitor_cb, context);
    4000e2a4:	aa0403e2 	mov	x2, x4
    4000e2a8:	17ffff98 	b	4000e108 <device_visitor>
			++i;
    4000e2ac:	91000421 	add	x1, x1, #0x1
		       && (rv[i] != DEVICE_HANDLE_SEP)) {
    4000e2b0:	78617802 	ldrh	w2, [x0, x1, lsl #1]
    4000e2b4:	0b060042 	add	w2, w2, w6
		while ((rv[i] != DEVICE_HANDLE_ENDS)
    4000e2b8:	6b2220bf 	cmp	w5, w2, uxth
    4000e2bc:	54ffff82 	b.cs	4000e2ac <device_required_foreach+0x1c>  // b.hs, b.nlast
    4000e2c0:	17fffff9 	b	4000e2a4 <device_required_foreach+0x14>
		       && (rv[i] != DEVICE_HANDLE_SEP)) {
    4000e2c4:	528fffe6 	mov	w6, #0x7fff                	// #32767
		while ((rv[i] != DEVICE_HANDLE_ENDS)
    4000e2c8:	529fffa5 	mov	w5, #0xfffd                	// #65533
    4000e2cc:	17fffff9 	b	4000e2b0 <device_required_foreach+0x20>

000000004000e2d0 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
    4000e2d0:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000e2d4:	f9438800 	ldr	x0, [x0, #1808]
}
    4000e2d8:	91046000 	add	x0, x0, #0x118
    4000e2dc:	d65f03c0 	ret

000000004000e2e0 <arch_system_halt>:
MAKE_REG_HELPER(daif)
    4000e2e0:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e2e4:	d50342df 	msr	daifset, #0x2
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
    4000e2e8:	14000000 	b	4000e2e8 <arch_system_halt+0x8>

000000004000e2ec <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    4000e2ec:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000e2f0:	910003fd 	mov	x29, sp
    4000e2f4:	f9000bf3 	str	x19, [sp, #16]
    4000e2f8:	2a0003f3 	mov	w19, w0
	z_impl_log_panic();
    4000e2fc:	97ffd6a5 	bl	40003d90 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
    4000e300:	b0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000e304:	91293001 	add	x1, x0, #0xa4c
    4000e308:	b94a4c00 	ldr	w0, [x0, #2636]
    4000e30c:	f240081f 	tst	x0, #0x7
    4000e310:	54000140 	b.eq	4000e338 <k_sys_fatal_error_handler+0x4c>  // b.none
    4000e314:	b0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000e318:	91290000 	add	x0, x0, #0xa40
    4000e31c:	cb000021 	sub	x1, x1, x0
    4000e320:	f0000020 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000e324:	913f7800 	add	x0, x0, #0xfde
    4000e328:	d342fc21 	lsr	x1, x1, #2
    4000e32c:	531a2421 	ubfiz	w1, w1, #6, #10
    4000e330:	32000021 	orr	w1, w1, #0x1
    4000e334:	97ffd63b 	bl	40003c20 <log_0>
	arch_system_halt(reason);
    4000e338:	2a1303e0 	mov	w0, w19
    4000e33c:	97ffffe9 	bl	4000e2e0 <arch_system_halt>

000000004000e340 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    4000e340:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000e344:	910003fd 	mov	x29, sp
    4000e348:	a90153f3 	stp	x19, x20, [sp, #16]
    4000e34c:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000e350:	2a0003f5 	mov	w21, w0
    4000e354:	a90363f7 	stp	x23, x24, [sp, #48]
    4000e358:	aa0103f7 	mov	x23, x1
MAKE_REG_HELPER(daif)
    4000e35c:	d53b4236 	mrs	x22, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e360:	d50342df 	msr	daifset, #0x2
	return z_impl_z_current_get();
    4000e364:	940006bf 	bl	4000fe60 <z_impl_z_current_get>
    4000e368:	aa0003f4 	mov	x20, x0
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    4000e36c:	b0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000e370:	b94a4c01 	ldr	w1, [x0, #2636]
    4000e374:	f240083f 	tst	x1, #0x7
    4000e378:	54000420 	b.eq	4000e3fc <z_fatal_error+0xbc>  // b.none
    4000e37c:	91293013 	add	x19, x0, #0xa4c
    4000e380:	aa0003f8 	mov	x24, x0
    4000e384:	b0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000e388:	91290000 	add	x0, x0, #0xa40
    4000e38c:	cb000273 	sub	x19, x19, x0
    4000e390:	2a1503e1 	mov	w1, w21
    4000e394:	710012bf 	cmp	w21, #0x4
    4000e398:	d342fe73 	lsr	x19, x19, #2
    4000e39c:	531a2673 	ubfiz	w19, w19, #6, #10
    4000e3a0:	32000264 	orr	w4, w19, #0x1
	switch (reason) {
    4000e3a4:	54000428 	b.hi	4000e428 <z_fatal_error+0xe8>  // b.pmore
    4000e3a8:	b0000020 	adrp	x0, 40013000 <shell_cmd_kernel>
    4000e3ac:	913dc000 	add	x0, x0, #0xf70
    4000e3b0:	f8617802 	ldr	x2, [x0, x1, lsl #3]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    4000e3b4:	d2800003 	mov	x3, #0x0                   	// #0
    4000e3b8:	90000040 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    4000e3bc:	91000c00 	add	x0, x0, #0x3
    4000e3c0:	97ffd657 	bl	40003d1c <log_3>
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    4000e3c4:	b94a4f00 	ldr	w0, [x24, #2636]
    4000e3c8:	f240081f 	tst	x0, #0x7
    4000e3cc:	54000180 	b.eq	4000e3fc <z_fatal_error+0xbc>  // b.none
    4000e3d0:	32000273 	orr	w19, w19, #0x1
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    4000e3d4:	b5000314 	cbnz	x20, 4000e434 <z_fatal_error+0xf4>
		thread_name = "unknown";
    4000e3d8:	f0000020 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000e3dc:	913fec00 	add	x0, x0, #0xffb
{
	if (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
    4000e3e0:	97ffd509 	bl	40003804 <z_log_strdup>
	LOG_ERR("Current thread: %p (%s)", thread,
    4000e3e4:	aa0003e2 	mov	x2, x0
    4000e3e8:	2a1303e3 	mov	w3, w19
    4000e3ec:	90000040 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    4000e3f0:	9100ac00 	add	x0, x0, #0x2b
    4000e3f4:	aa1403e1 	mov	x1, x20
    4000e3f8:	97ffd630 	bl	40003cb8 <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    4000e3fc:	aa1703e1 	mov	x1, x23
    4000e400:	2a1503e0 	mov	w0, w21
MAKE_REG_HELPER(daif)
    4000e404:	92407ed6 	and	x22, x22, #0xffffffff
    4000e408:	97ffffb9 	bl	4000e2ec <k_sys_fatal_error_handler>
    4000e40c:	d51b4236 	msr	daif, x22
	z_impl_k_thread_abort(thread);
    4000e410:	aa1403e0 	mov	x0, x20
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    4000e414:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e418:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000e41c:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000e420:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000e424:	140006db 	b	4000ff90 <z_impl_k_thread_abort>
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    4000e428:	f0000022 	adrp	x2, 40015000 <tabulator.1+0x262>
    4000e42c:	913fb442 	add	x2, x2, #0xfed
    4000e430:	17ffffe1 	b	4000e3b4 <z_fatal_error+0x74>
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    4000e434:	aa1403e0 	mov	x0, x20
    4000e438:	94000143 	bl	4000e944 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
    4000e43c:	b4fffce0 	cbz	x0, 4000e3d8 <z_fatal_error+0x98>
    4000e440:	39400001 	ldrb	w1, [x0]
    4000e444:	34fffca1 	cbz	w1, 4000e3d8 <z_fatal_error+0x98>
    4000e448:	17ffffe6 	b	4000e3e0 <z_fatal_error+0xa0>

000000004000e44c <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    4000e44c:	d10143ff 	sub	sp, sp, #0x50
	k_thread_stack_t *stack = z_idle_stacks[i];

#ifdef CONFIG_THREAD_NAME
	char tname[8];

	snprintk(tname, 8, "idle %02d", i);
    4000e450:	d2800101 	mov	x1, #0x8                   	// #8
    4000e454:	90000042 	adrp	x2, 40016000 <CSWTCH.205+0x4c5>
    4000e458:	91023442 	add	x2, x2, #0x8d
{
    4000e45c:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000e460:	910043fd 	add	x29, sp, #0x10
    4000e464:	a90253f3 	stp	x19, x20, [sp, #32]
    4000e468:	93407c14 	sxtw	x20, w0
	snprintk(tname, 8, "idle %02d", i);
    4000e46c:	2a1403e3 	mov	w3, w20
{
    4000e470:	a9035bf5 	stp	x21, x22, [sp, #48]
	snprintk(tname, 8, "idle %02d", i);
    4000e474:	910123f6 	add	x22, sp, #0x48
    4000e478:	aa1603e0 	mov	x0, x22
    4000e47c:	97ffcbbe 	bl	40001374 <snprintk>
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
    4000e480:	f90007f6 	str	x22, [sp, #8]
	struct k_thread *thread = &z_idle_threads[i];
    4000e484:	d0000080 	adrp	x0, 40020000 <logging_thread>
    4000e488:	911b8015 	add	x21, x0, #0x6e0
	z_setup_new_thread(thread, stack,
    4000e48c:	52800020 	mov	w0, #0x1                   	// #1
    4000e490:	b90003e0 	str	w0, [sp]
    4000e494:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000e498:	911c0000 	add	x0, x0, #0x700
    4000e49c:	52800604 	mov	w4, #0x30                  	// #48
	k_thread_stack_t *stack = z_idle_stacks[i];
    4000e4a0:	93747e81 	sbfiz	x1, x20, #12, #32
	z_setup_new_thread(thread, stack,
    4000e4a4:	528001e7 	mov	w7, #0xf                   	// #15
    4000e4a8:	d2800006 	mov	x6, #0x0                   	// #0
    4000e4ac:	9b240284 	smaddl	x4, w20, w4, x0
    4000e4b0:	d00002e0 	adrp	x0, 4006c000 <z_main_stack+0xf20>
    4000e4b4:	91038000 	add	x0, x0, #0xe0
    4000e4b8:	d2800005 	mov	x5, #0x0                   	// #0
    4000e4bc:	8b010001 	add	x1, x0, x1
    4000e4c0:	52806e00 	mov	w0, #0x370                 	// #880
    4000e4c4:	d2820002 	mov	x2, #0x1000                	// #4096
    4000e4c8:	90000003 	adrp	x3, 4000e000 <sys_clock_driver_init+0x40>
    4000e4cc:	91326063 	add	x3, x3, #0xc98
    4000e4d0:	9b205680 	smaddl	x0, w20, w0, x21
    4000e4d4:	94000149 	bl	4000e9f8 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    4000e4d8:	d2806e00 	mov	x0, #0x370                 	// #880
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    4000e4dc:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000e4e0:	9b005680 	madd	x0, x20, x0, x21
    4000e4e4:	a94253f3 	ldp	x19, x20, [sp, #32]
    4000e4e8:	a9435bf5 	ldp	x21, x22, [sp, #48]
    4000e4ec:	39406401 	ldrb	w1, [x0, #25]
    4000e4f0:	121d7821 	and	w1, w1, #0xfffffffb
    4000e4f4:	39006401 	strb	w1, [x0, #25]
    4000e4f8:	910143ff 	add	sp, sp, #0x50
    4000e4fc:	d65f03c0 	ret

000000004000e500 <bg_thread_main>:
{
    4000e500:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000e504:	910003fd 	mov	x29, sp
	z_mem_manage_init();
    4000e508:	940008ef 	bl	400108c4 <z_mem_manage_init>
	z_sys_post_kernel = true;
    4000e50c:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000e510:	52800021 	mov	w1, #0x1                   	// #1
    4000e514:	39236401 	strb	w1, [x0, #2265]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    4000e518:	52800040 	mov	w0, #0x2                   	// #2
    4000e51c:	97ffff29 	bl	4000e1c0 <z_sys_init_run_level>
	boot_banner();
    4000e520:	94000a87 	bl	40010f3c <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    4000e524:	52800060 	mov	w0, #0x3                   	// #3
    4000e528:	97ffff26 	bl	4000e1c0 <z_sys_init_run_level>
	z_init_static_threads();
    4000e52c:	94000195 	bl	4000eb80 <z_init_static_threads>
	z_mem_manage_boot_finish();
    4000e530:	94000919 	bl	40010994 <z_mem_manage_boot_finish>
	main();
    4000e534:	97ffcb2e 	bl	400011ec <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    4000e538:	d0000080 	adrp	x0, 40020000 <logging_thread>
    4000e53c:	91294000 	add	x0, x0, #0xa50
    4000e540:	39406001 	ldrb	w1, [x0, #24]
    4000e544:	121f7821 	and	w1, w1, #0xfffffffe
    4000e548:	39006001 	strb	w1, [x0, #24]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    4000e54c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000e550:	d65f03c0 	ret

000000004000e554 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    4000e554:	d10ec3ff 	sub	sp, sp, #0x3b0
    4000e558:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000e55c:	910043fd 	add	x29, sp, #0x10
    4000e560:	a90253f3 	stp	x19, x20, [sp, #32]
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    4000e564:	f0000093 	adrp	x19, 40021000 <k_sys_work_q+0x240>
    4000e568:	911c0273 	add	x19, x19, #0x700
    4000e56c:	a9035bf5 	stp	x21, x22, [sp, #48]
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
    4000e570:	97ffd418 	bl	400035d0 <log_core_init>
	dummy_thread->base.user_options = K_ESSENTIAL;
    4000e574:	52802020 	mov	w0, #0x101                 	// #257
    4000e578:	7900b3e0 	strh	w0, [sp, #88]
	_current_cpu->current = dummy_thread;
    4000e57c:	910103e0 	add	x0, sp, #0x40
    4000e580:	f9000a60 	str	x0, [x19, #16]
	_kernel.ready_q.cache = &z_main_thread;
    4000e584:	d0000094 	adrp	x20, 40020000 <logging_thread>
    4000e588:	91294294 	add	x20, x20, #0xa50
	dummy_thread->stack_info.size = 0U;
    4000e58c:	a9167fff 	stp	xzr, xzr, [sp, #352]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    4000e590:	97ffff0b 	bl	4000e1bc <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    4000e594:	52800000 	mov	w0, #0x0                   	// #0
    4000e598:	97ffff0a 	bl	4000e1c0 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    4000e59c:	52800020 	mov	w0, #0x1                   	// #1
    4000e5a0:	97ffff08 	bl	4000e1c0 <z_sys_init_run_level>
	z_sched_init();
    4000e5a4:	940005b6 	bl	4000fc7c <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
    4000e5a8:	f9001a74 	str	x20, [x19, #48]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    4000e5ac:	90000040 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    4000e5b0:	91025c00 	add	x0, x0, #0x97
    4000e5b4:	f90007e0 	str	x0, [sp, #8]
    4000e5b8:	52800020 	mov	w0, #0x1                   	// #1
    4000e5bc:	b90003e0 	str	w0, [sp]
    4000e5c0:	52800007 	mov	w7, #0x0                   	// #0
    4000e5c4:	d2800006 	mov	x6, #0x0                   	// #0
    4000e5c8:	d2800005 	mov	x5, #0x0                   	// #0
    4000e5cc:	d2800004 	mov	x4, #0x0                   	// #0
    4000e5d0:	d2820002 	mov	x2, #0x1000                	// #4096
    4000e5d4:	aa1403e0 	mov	x0, x20
    4000e5d8:	90000003 	adrp	x3, 4000e000 <sys_clock_driver_init+0x40>
    4000e5dc:	91140063 	add	x3, x3, #0x500
    4000e5e0:	b00002e1 	adrp	x1, 4006b000 <shell_uart_stack+0x720>
    4000e5e4:	91038021 	add	x1, x1, #0xe0
    4000e5e8:	94000104 	bl	4000e9f8 <z_setup_new_thread>
    4000e5ec:	39406680 	ldrb	w0, [x20, #25]
    4000e5f0:	121d7800 	and	w0, w0, #0xfffffffb
    4000e5f4:	39006680 	strb	w0, [x20, #25]
	z_ready_thread(&z_main_thread);
    4000e5f8:	aa1403e0 	mov	x0, x20
    4000e5fc:	94000475 	bl	4000f7d0 <z_ready_thread>
		init_idle_thread(i);
    4000e600:	52800000 	mov	w0, #0x0                   	// #0
    4000e604:	97ffff92 	bl	4000e44c <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    4000e608:	d0000080 	adrp	x0, 40020000 <logging_thread>
    4000e60c:	911b8000 	add	x0, x0, #0x6e0
    4000e610:	f9000e60 	str	x0, [x19, #24]
		_kernel.cpus[i].irq_stack =
    4000e614:	90000300 	adrp	x0, 4006e000 <z_interrupt_stacks+0xf20>
    4000e618:	91038000 	add	x0, x0, #0xe0
    4000e61c:	f9000660 	str	x0, [x19, #8]
		_kernel.cpus[i].id = i;
    4000e620:	3900927f 	strb	wzr, [x19, #36]
    4000e624:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e628:	d50342df 	msr	daifset, #0x2
	old_thread = _current;
    4000e62c:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    4000e630:	12800140 	mov	w0, #0xfffffff5            	// #-11
    4000e634:	b9013ac0 	str	w0, [x22, #312]
MAKE_REG_HELPER(daif)
    4000e638:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e63c:	d50342df 	msr	daifset, #0x2
	new_thread = z_swap_next_thread();
    4000e640:	940003ba 	bl	4000f528 <z_swap_next_thread>
	if (new_thread != old_thread) {
    4000e644:	eb0002df 	cmp	x22, x0
    4000e648:	540000e0 	b.eq	4000e664 <z_cstart+0x110>  // b.none
    4000e64c:	aa0003f4 	mov	x20, x0
		z_reset_time_slice();
    4000e650:	9400030e 	bl	4000f288 <z_reset_time_slice>
{
}

static inline void arch_switch(void *switch_to, void **switched_from)
{
	z_arm64_call_svc(switch_to, switched_from);
    4000e654:	910502c1 	add	x1, x22, #0x140
		_current_cpu->current = new_thread;
    4000e658:	f9000a74 	str	x20, [x19, #16]
    4000e65c:	f940a280 	ldr	x0, [x20, #320]
    4000e660:	97fff1d7 	bl	4000adbc <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    4000e664:	92407eb5 	and	x21, x21, #0xffffffff
    4000e668:	d51b4235 	msr	daif, x21

000000004000e66c <init_mem_slab_module>:
static int init_mem_slab_module(const struct device *dev)
{
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    4000e66c:	b0000300 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4000e670:	91296000 	add	x0, x0, #0xa58
    4000e674:	b0000302 	adrp	x2, 4006f000 <sys_work_q_stack+0xf20>
    4000e678:	91296042 	add	x2, x2, #0xa58
    4000e67c:	eb02001f 	cmp	x0, x2
    4000e680:	54000063 	b.cc	4000e68c <init_mem_slab_module+0x20>  // b.lo, b.ul, b.last
			goto out;
		}
		z_object_init(slab);
	}

out:
    4000e684:	52800000 	mov	w0, #0x0                   	// #0
	return rc;
}
    4000e688:	d65f03c0 	ret
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    4000e68c:	a9418404 	ldp	x4, x1, [x0, #24]
    4000e690:	aa040023 	orr	x3, x1, x4
    4000e694:	f240087f 	tst	x3, #0x7
    4000e698:	540001c1 	b.ne	4000e6d0 <init_mem_slab_module+0x64>  // b.any
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e69c:	b9401005 	ldr	w5, [x0, #16]
    4000e6a0:	52800003 	mov	w3, #0x0                   	// #0
	slab->free_list = NULL;
    4000e6a4:	f900141f 	str	xzr, [x0, #40]
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e6a8:	6b05007f 	cmp	w3, w5
    4000e6ac:	54000061 	b.ne	4000e6b8 <init_mem_slab_module+0x4c>  // b.any
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    4000e6b0:	9100e000 	add	x0, x0, #0x38
    4000e6b4:	17fffff2 	b	4000e67c <init_mem_slab_module+0x10>
		*(char **)p = slab->free_list;
    4000e6b8:	f9401406 	ldr	x6, [x0, #40]
    4000e6bc:	f9000026 	str	x6, [x1]
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e6c0:	11000463 	add	w3, w3, #0x1
		slab->free_list = p;
    4000e6c4:	f9001401 	str	x1, [x0, #40]
		p += slab->block_size;
    4000e6c8:	8b040021 	add	x1, x1, x4
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e6cc:	17fffff7 	b	4000e6a8 <init_mem_slab_module+0x3c>
    4000e6d0:	128002a0 	mov	w0, #0xffffffea            	// #-22
	return rc;
    4000e6d4:	17ffffed 	b	4000e688 <init_mem_slab_module+0x1c>

000000004000e6d8 <k_mem_slab_init>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    4000e6d8:	aa020024 	orr	x4, x1, x2
int k_mem_slab_init(struct k_mem_slab *slab, void *buffer,
		    size_t block_size, uint32_t num_blocks)
{
	int rc = 0;

	slab->num_blocks = num_blocks;
    4000e6dc:	b9001003 	str	w3, [x0, #16]
	slab->block_size = block_size;
	slab->buffer = buffer;
    4000e6e0:	a9018402 	stp	x2, x1, [x0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    4000e6e4:	f240089f 	tst	x4, #0x7
	slab->num_used = 0U;
    4000e6e8:	b900301f 	str	wzr, [x0, #48]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    4000e6ec:	540001c1 	b.ne	4000e724 <k_mem_slab_init+0x4c>  // b.any
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e6f0:	52800004 	mov	w4, #0x0                   	// #0
	slab->free_list = NULL;
    4000e6f4:	f900141f 	str	xzr, [x0, #40]
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e6f8:	6b04007f 	cmp	w3, w4
    4000e6fc:	54000081 	b.ne	4000e70c <k_mem_slab_init+0x34>  // b.any
	list->tail = (sys_dnode_t *)list;
    4000e700:	a9000000 	stp	x0, x0, [x0]
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
}
    4000e704:	52800000 	mov	w0, #0x0                   	// #0
	z_object_init(slab);
out:
	SYS_PORT_TRACING_OBJ_INIT(k_mem_slab, slab, rc);

	return rc;
}
    4000e708:	d65f03c0 	ret
		*(char **)p = slab->free_list;
    4000e70c:	f9401405 	ldr	x5, [x0, #40]
    4000e710:	f9000025 	str	x5, [x1]
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e714:	11000484 	add	w4, w4, #0x1
		slab->free_list = p;
    4000e718:	f9001401 	str	x1, [x0, #40]
		p += slab->block_size;
    4000e71c:	8b020021 	add	x1, x1, x2
	for (j = 0U; j < slab->num_blocks; j++) {
    4000e720:	17fffff6 	b	4000e6f8 <k_mem_slab_init+0x20>
		return -EINVAL;
    4000e724:	128002a0 	mov	w0, #0xffffffea            	// #-22
	return rc;
    4000e728:	17fffff8 	b	4000e708 <k_mem_slab_init+0x30>

000000004000e72c <k_mem_slab_alloc>:

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
    4000e72c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000e730:	aa0203e3 	mov	x3, x2
    4000e734:	910003fd 	mov	x29, sp
    4000e738:	f9000bf3 	str	x19, [sp, #16]
    4000e73c:	aa0103f3 	mov	x19, x1
    4000e740:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e744:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
    4000e748:	f9401402 	ldr	x2, [x0, #40]
    4000e74c:	b4000162 	cbz	x2, 4000e778 <k_mem_slab_alloc+0x4c>
		/* take a free block */
		*mem = slab->free_list;
    4000e750:	f9000262 	str	x2, [x19]
		slab->free_list = *(char **)(slab->free_list);
    4000e754:	f9400042 	ldr	x2, [x2]
    4000e758:	f9001402 	str	x2, [x0, #40]
		slab->num_used++;
    4000e75c:	b9403002 	ldr	w2, [x0, #48]
    4000e760:	11000442 	add	w2, w2, #0x1
    4000e764:	b9003002 	str	w2, [x0, #48]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
    4000e768:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    4000e76c:	92407c21 	and	x1, x1, #0xffffffff
    4000e770:	d51b4221 	msr	daif, x1

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
    4000e774:	1400000d 	b	4000e7a8 <k_mem_slab_alloc+0x7c>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
    4000e778:	b5000083 	cbnz	x3, 4000e788 <k_mem_slab_alloc+0x5c>
		result = -ENOMEM;
    4000e77c:	12800160 	mov	w0, #0xfffffff4            	// #-12
		*mem = NULL;
    4000e780:	f900027f 	str	xzr, [x19]
		result = -ENOMEM;
    4000e784:	17fffffa 	b	4000e76c <k_mem_slab_alloc+0x40>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
    4000e788:	aa0003e2 	mov	x2, x0
    4000e78c:	91004000 	add	x0, x0, #0x10
    4000e790:	9400049d 	bl	4000fa04 <z_pend_curr>
		if (result == 0) {
    4000e794:	350000a0 	cbnz	w0, 4000e7a8 <k_mem_slab_alloc+0x7c>
			*mem = _current->base.swap_data;
    4000e798:	f0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000e79c:	f9438821 	ldr	x1, [x1, #1808]
    4000e7a0:	f9401021 	ldr	x1, [x1, #32]
    4000e7a4:	f9000261 	str	x1, [x19]
}
    4000e7a8:	f9400bf3 	ldr	x19, [sp, #16]
    4000e7ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000e7b0:	d65f03c0 	ret

000000004000e7b4 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    4000e7b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000e7b8:	910003fd 	mov	x29, sp
    4000e7bc:	a90153f3 	stp	x19, x20, [sp, #16]
    4000e7c0:	aa0003f3 	mov	x19, x0
    4000e7c4:	aa0103f4 	mov	x20, x1
    4000e7c8:	f90013f5 	str	x21, [sp, #32]
    4000e7cc:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e7d0:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
    4000e7d4:	f9401401 	ldr	x1, [x0, #40]
    4000e7d8:	b50001a1 	cbnz	x1, 4000e80c <k_mem_slab_free+0x58>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    4000e7dc:	94000517 	bl	4000fc38 <z_unpend_first_thread>

		if (pending_thread != NULL) {
    4000e7e0:	b4000160 	cbz	x0, 4000e80c <k_mem_slab_free+0x58>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    4000e7e4:	f9400281 	ldr	x1, [x20]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    4000e7e8:	f9001001 	str	x1, [x0, #32]
	thread->swap_retval = value;
    4000e7ec:	b901381f 	str	wzr, [x0, #312]
			z_ready_thread(pending_thread);
    4000e7f0:	940003f8 	bl	4000f7d0 <z_ready_thread>
			z_reschedule(&slab->lock, key);
    4000e7f4:	2a1503e1 	mov	w1, w21
    4000e7f8:	91004260 	add	x0, x19, #0x10
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
    4000e7fc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e800:	f94013f5 	ldr	x21, [sp, #32]
    4000e804:	a8c37bfd 	ldp	x29, x30, [sp], #48
			z_reschedule(&slab->lock, key);
    4000e808:	14000323 	b	4000f494 <z_reschedule>
	**(char ***) mem = slab->free_list;
    4000e80c:	f9400280 	ldr	x0, [x20]
MAKE_REG_HELPER(daif)
    4000e810:	92407eb5 	and	x21, x21, #0xffffffff
    4000e814:	f9401661 	ldr	x1, [x19, #40]
    4000e818:	f9000001 	str	x1, [x0]
	slab->free_list = *(char **) mem;
    4000e81c:	f9400280 	ldr	x0, [x20]
    4000e820:	f9001660 	str	x0, [x19, #40]
	slab->num_used--;
    4000e824:	b9403260 	ldr	w0, [x19, #48]
    4000e828:	51000400 	sub	w0, w0, #0x1
    4000e82c:	b9003260 	str	w0, [x19, #48]
    4000e830:	d51b4235 	msr	daif, x21
}
    4000e834:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e838:	f94013f5 	ldr	x21, [sp, #32]
    4000e83c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000e840:	d65f03c0 	ret

000000004000e844 <k_thread_foreach>:

#define _FOREACH_STATIC_THREAD(thread_data)              \
	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data)

void k_thread_foreach(k_thread_user_cb_t user_cb, void *user_data)
{
    4000e844:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000e848:	910003fd 	mov	x29, sp
    4000e84c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000e850:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000e854:	aa0003f5 	mov	x21, x0
    4000e858:	aa0103f6 	mov	x22, x1
    4000e85c:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e860:	d50342df 	msr	daifset, #0x2
	 */
	key = k_spin_lock(&z_thread_monitor_lock);

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, foreach);

	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
    4000e864:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000e868:	f943a813 	ldr	x19, [x0, #1872]
    4000e86c:	b50000f3 	cbnz	x19, 4000e888 <k_thread_foreach+0x44>
MAKE_REG_HELPER(daif)
    4000e870:	92407e94 	and	x20, x20, #0xffffffff
    4000e874:	d51b4234 	msr	daif, x20

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, foreach);

	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
}
    4000e878:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000e87c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000e880:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000e884:	d65f03c0 	ret
		user_cb(thread, user_data);
    4000e888:	aa1303e0 	mov	x0, x19
    4000e88c:	aa1603e1 	mov	x1, x22
    4000e890:	d63f02a0 	blr	x21
	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
    4000e894:	f9407a73 	ldr	x19, [x19, #240]
    4000e898:	17fffff5 	b	4000e86c <k_thread_foreach+0x28>

000000004000e89c <k_is_in_isr>:
MAKE_REG_HELPER(tpidrro_el0);
    4000e89c:	d53bd060 	mrs	x0, tpidrro_el0
    4000e8a0:	927db000 	and	x0, x0, #0xfffffffffff8
extern void z_arm64_offload(void);
#endif

static ALWAYS_INLINE bool arch_is_in_isr(void)
{
	return arch_curr_cpu()->nested != 0U;
    4000e8a4:	b9400000 	ldr	w0, [x0]
    4000e8a8:	7100001f 	cmp	w0, #0x0
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
    4000e8ac:	1a9f07e0 	cset	w0, ne  // ne = any
    4000e8b0:	d65f03c0 	ret

000000004000e8b4 <z_thread_monitor_exit>:
MAKE_REG_HELPER(daif)
    4000e8b4:	d53b4223 	mrs	x3, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000e8b8:	d50342df 	msr	daifset, #0x2
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
    4000e8bc:	f0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    4000e8c0:	911c0042 	add	x2, x2, #0x700
    4000e8c4:	f9402841 	ldr	x1, [x2, #80]
    4000e8c8:	eb00003f 	cmp	x1, x0
    4000e8cc:	540000e1 	b.ne	4000e8e8 <z_thread_monitor_exit+0x34>  // b.any
		_kernel.threads = _kernel.threads->next_thread;
    4000e8d0:	f9407820 	ldr	x0, [x1, #240]
    4000e8d4:	f9002840 	str	x0, [x2, #80]
MAKE_REG_HELPER(daif)
    4000e8d8:	92407c63 	and	x3, x3, #0xffffffff
    4000e8dc:	d51b4223 	msr	daif, x3
			prev_thread->next_thread = thread->next_thread;
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
    4000e8e0:	d65f03c0 	ret
    4000e8e4:	aa0203e1 	mov	x1, x2
		while ((prev_thread != NULL) &&
    4000e8e8:	b4ffff81 	cbz	x1, 4000e8d8 <z_thread_monitor_exit+0x24>
			(thread != prev_thread->next_thread)) {
    4000e8ec:	f9407822 	ldr	x2, [x1, #240]
		while ((prev_thread != NULL) &&
    4000e8f0:	eb00005f 	cmp	x2, x0
    4000e8f4:	54ffff81 	b.ne	4000e8e4 <z_thread_monitor_exit+0x30>  // b.any
			prev_thread->next_thread = thread->next_thread;
    4000e8f8:	f9407800 	ldr	x0, [x0, #240]
    4000e8fc:	f9007820 	str	x0, [x1, #240]
    4000e900:	17fffff6 	b	4000e8d8 <z_thread_monitor_exit+0x24>

000000004000e904 <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
    4000e904:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000e908:	910003fd 	mov	x29, sp
    4000e90c:	f9000bf3 	str	x19, [sp, #16]
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
    4000e910:	b5000160 	cbnz	x0, 4000e93c <z_impl_k_thread_name_set+0x38>
		thread = _current;
    4000e914:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000e918:	f9438813 	ldr	x19, [x0, #1808]
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
    4000e91c:	9103e260 	add	x0, x19, #0xf8
    4000e920:	d2800402 	mov	x2, #0x20                  	// #32
    4000e924:	97fff480 	bl	4000bb24 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    4000e928:	39045e7f 	strb	wzr, [x19, #279]

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
    4000e92c:	52800000 	mov	w0, #0x0                   	// #0
    4000e930:	f9400bf3 	ldr	x19, [sp, #16]
    4000e934:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000e938:	d65f03c0 	ret
    4000e93c:	aa0003f3 	mov	x19, x0
    4000e940:	17fffff7 	b	4000e91c <z_impl_k_thread_name_set+0x18>

000000004000e944 <k_thread_name_get>:
	return (const char *)thread->name;
#else
	ARG_UNUSED(thread);
	return NULL;
#endif /* CONFIG_THREAD_NAME */
}
    4000e944:	9103e000 	add	x0, x0, #0xf8
    4000e948:	d65f03c0 	ret

000000004000e94c <k_thread_state_str>:
#endif /* CONFIG_THREAD_NAME */
}

const char *k_thread_state_str(k_tid_t thread_id)
{
	switch (thread_id->base.thread_state) {
    4000e94c:	39406401 	ldrb	w1, [x0, #25]
    4000e950:	7100403f 	cmp	w1, #0x10
    4000e954:	54000148 	b.hi	4000e97c <k_thread_state_str+0x30>  // b.pmore
    4000e958:	d0000020 	adrp	x0, 40014000 <CSWTCH.135+0x90>
    4000e95c:	9104b000 	add	x0, x0, #0x12c
    4000e960:	38614800 	ldrb	w0, [x0, w1, uxtw]
    4000e964:	10000061 	adr	x1, 4000e970 <k_thread_state_str+0x24>
    4000e968:	8b208820 	add	x0, x1, w0, sxtb #2
    4000e96c:	d61f0000 	br	x0
    4000e970:	90000040 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    4000e974:	9102fc00 	add	x0, x0, #0xbf
	 * this bit of defensive programming will be useful
	 */
		break;
	}
	return "unknown";
}
    4000e978:	d65f03c0 	ret
	switch (thread_id->base.thread_state) {
    4000e97c:	7100803f 	cmp	w1, #0x20
    4000e980:	54000340 	b.eq	4000e9e8 <k_thread_state_str+0x9c>  // b.none
		return "queued";
    4000e984:	7102003f 	cmp	w1, #0x80
    4000e988:	90000042 	adrp	x2, 40016000 <CSWTCH.205+0x4c5>
    4000e98c:	f0000020 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000e990:	91033841 	add	x1, x2, #0xce
    4000e994:	913fec00 	add	x0, x0, #0xffb
    4000e998:	9a811000 	csel	x0, x0, x1, ne  // ne = any
    4000e99c:	17fffff7 	b	4000e978 <k_thread_state_str+0x2c>
		return "pending";
    4000e9a0:	90000040 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    4000e9a4:	91027c00 	add	x0, x0, #0x9f
    4000e9a8:	17fffff4 	b	4000e978 <k_thread_state_str+0x2c>
		return "prestart";
    4000e9ac:	90000040 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    4000e9b0:	91029c00 	add	x0, x0, #0xa7
    4000e9b4:	17fffff1 	b	4000e978 <k_thread_state_str+0x2c>
		return "dead";
    4000e9b8:	90000040 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    4000e9bc:	9102c000 	add	x0, x0, #0xb0
    4000e9c0:	17ffffee 	b	4000e978 <k_thread_state_str+0x2c>
		return "suspended";
    4000e9c4:	90000040 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    4000e9c8:	9102d400 	add	x0, x0, #0xb5
    4000e9cc:	17ffffeb 	b	4000e978 <k_thread_state_str+0x2c>
	return "unknown";
    4000e9d0:	f0000020 	adrp	x0, 40015000 <tabulator.1+0x262>
    4000e9d4:	913fec00 	add	x0, x0, #0xffb
    4000e9d8:	17ffffe8 	b	4000e978 <k_thread_state_str+0x2c>
		return "";
    4000e9dc:	d0000020 	adrp	x0, 40014000 <CSWTCH.135+0x90>
    4000e9e0:	911be400 	add	x0, x0, #0x6f9
    4000e9e4:	17ffffe5 	b	4000e978 <k_thread_state_str+0x2c>
		return "aborting";
    4000e9e8:	90000040 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    4000e9ec:	91031400 	add	x0, x0, #0xc5
    4000e9f0:	17ffffe2 	b	4000e978 <k_thread_state_str+0x2c>

000000004000e9f4 <z_impl_k_thread_start>:

void z_impl_k_thread_start(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_thread, start, thread);

	z_sched_start(thread);
    4000e9f4:	14000382 	b	4000f7fc <z_sched_start>

000000004000e9f8 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    4000e9f8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    4000e9fc:	91003c42 	add	x2, x2, #0xf
{
    4000ea00:	910003fd 	mov	x29, sp
    4000ea04:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ea08:	aa0003f3 	mov	x19, x0
	sys_dlist_init(&w->waitq);
    4000ea0c:	9102e000 	add	x0, x0, #0xb8
    4000ea10:	a9025bf5 	stp	x21, x22, [sp, #32]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    4000ea14:	927cec54 	and	x20, x2, #0xfffffffffffffff0
{
    4000ea18:	aa0103f5 	mov	x21, x1
    4000ea1c:	a90363f7 	stp	x23, x24, [sp, #48]
    4000ea20:	aa0603f6 	mov	x22, x6
    4000ea24:	aa0503f7 	mov	x23, x5
    4000ea28:	a9046bf9 	stp	x25, x26, [sp, #64]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    4000ea2c:	aa1403e2 	mov	x2, x20
{
    4000ea30:	aa0403f9 	mov	x25, x4
    4000ea34:	a90b8260 	stp	x0, x0, [x19, #184]
	stack_ptr = (char *)stack + stack_obj_size;
    4000ea38:	8b14003a 	add	x26, x1, x20
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
    4000ea3c:	b94063e0 	ldr	w0, [sp, #96]
	thread_base->pended_on = NULL;
    4000ea40:	f9000a7f 	str	xzr, [x19, #16]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    4000ea44:	52801541 	mov	w1, #0xaa                  	// #170
	thread_base->user_options = (uint8_t)options;
    4000ea48:	39006260 	strb	w0, [x19, #24]
	thread_base->thread_state = (uint8_t)initial_state;
    4000ea4c:	52800080 	mov	w0, #0x4                   	// #4
    4000ea50:	39006660 	strb	w0, [x19, #25]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    4000ea54:	aa1503e0 	mov	x0, x21

	thread_base->prio = priority;
    4000ea58:	39006a67 	strb	w7, [x19, #26]

	thread_base->sched_locked = 0U;
    4000ea5c:	39006e7f 	strb	wzr, [x19, #27]
	node->prev = NULL;
    4000ea60:	a902fe7f 	stp	xzr, xzr, [x19, #40]
{
    4000ea64:	f9002bfb 	str	x27, [sp, #80]
    4000ea68:	aa0303fb 	mov	x27, x3
    4000ea6c:	f94037f8 	ldr	x24, [sp, #104]
	memset(stack_buf_start, 0xaa, stack_buf_size);
    4000ea70:	97fff49b 	bl	4000bcdc <memset>
	new_thread->stack_info.size = stack_buf_size;
    4000ea74:	a9125275 	stp	x21, x20, [x19, #288]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    4000ea78:	aa1603e6 	mov	x6, x22
    4000ea7c:	aa1703e5 	mov	x5, x23
	new_thread->stack_info.delta = delta;
    4000ea80:	f9009a7f 	str	xzr, [x19, #304]
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    4000ea84:	aa1903e4 	mov	x4, x25
    4000ea88:	aa1b03e3 	mov	x3, x27
    4000ea8c:	aa1a03e2 	mov	x2, x26
    4000ea90:	aa1503e1 	mov	x1, x21
    4000ea94:	aa1303e0 	mov	x0, x19
    4000ea98:	97fff0cb 	bl	4000adc4 <arch_new_thread>
	new_thread->init_data = NULL;
    4000ea9c:	f9005a7f 	str	xzr, [x19, #176]
	new_thread->entry.parameter1 = p1;
    4000eaa0:	a90d667b 	stp	x27, x25, [x19, #208]
	new_thread->entry.parameter3 = p3;
    4000eaa4:	a90e5a77 	stp	x23, x22, [x19, #224]
    4000eaa8:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000eaac:	d50342df 	msr	daifset, #0x2
	new_thread->next_thread = _kernel.threads;
    4000eab0:	f0000094 	adrp	x20, 40021000 <k_sys_work_q+0x240>
    4000eab4:	911c0294 	add	x20, x20, #0x700
MAKE_REG_HELPER(daif)
    4000eab8:	92407c00 	and	x0, x0, #0xffffffff
    4000eabc:	f9402a81 	ldr	x1, [x20, #80]
	_kernel.threads = new_thread;
    4000eac0:	f9002a93 	str	x19, [x20, #80]
	new_thread->next_thread = _kernel.threads;
    4000eac4:	f9007a61 	str	x1, [x19, #240]
    4000eac8:	d51b4220 	msr	daif, x0
	if (name != NULL) {
    4000eacc:	b4000238 	cbz	x24, 4000eb10 <z_setup_new_thread+0x118>
		strncpy(new_thread->name, name,
    4000ead0:	aa1803e1 	mov	x1, x24
    4000ead4:	9103e260 	add	x0, x19, #0xf8
    4000ead8:	d28003e2 	mov	x2, #0x1f                  	// #31
    4000eadc:	97fff412 	bl	4000bb24 <strncpy>
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    4000eae0:	39045e7f 	strb	wzr, [x19, #279]
	new_thread->resource_pool = _current->resource_pool;
    4000eae4:	f9400a80 	ldr	x0, [x20, #16]
}
    4000eae8:	a9425bf5 	ldp	x21, x22, [sp, #32]
	new_thread->resource_pool = _current->resource_pool;
    4000eaec:	f940a400 	ldr	x0, [x0, #328]
}
    4000eaf0:	a94363f7 	ldp	x23, x24, [sp, #48]
    4000eaf4:	f9402bfb 	ldr	x27, [sp, #80]
	new_thread->resource_pool = _current->resource_pool;
    4000eaf8:	f900a660 	str	x0, [x19, #328]
}
    4000eafc:	aa1a03e0 	mov	x0, x26
    4000eb00:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000eb04:	a9446bf9 	ldp	x25, x26, [sp, #64]
    4000eb08:	a8c67bfd 	ldp	x29, x30, [sp], #96
    4000eb0c:	d65f03c0 	ret
		new_thread->name[0] = '\0';
    4000eb10:	3903e27f 	strb	wzr, [x19, #248]
    4000eb14:	17fffff4 	b	4000eae4 <z_setup_new_thread+0xec>

000000004000eb18 <z_impl_k_thread_create>:
{
    4000eb18:	d100c3ff 	sub	sp, sp, #0x30
    4000eb1c:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000eb20:	910043fd 	add	x29, sp, #0x10
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    4000eb24:	b94033e8 	ldr	w8, [sp, #48]
    4000eb28:	b90003e8 	str	w8, [sp]
    4000eb2c:	f90007ff 	str	xzr, [sp, #8]
{
    4000eb30:	a90253f3 	stp	x19, x20, [sp, #32]
    4000eb34:	aa0003f3 	mov	x19, x0
    4000eb38:	f9401ff4 	ldr	x20, [sp, #56]
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    4000eb3c:	97ffffaf 	bl	4000e9f8 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    4000eb40:	b100069f 	cmn	x20, #0x1
    4000eb44:	54000080 	b.eq	4000eb54 <z_impl_k_thread_create+0x3c>  // b.none
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    4000eb48:	b5000114 	cbnz	x20, 4000eb68 <z_impl_k_thread_create+0x50>
	z_sched_start(thread);
    4000eb4c:	aa1303e0 	mov	x0, x19
    4000eb50:	9400032b 	bl	4000f7fc <z_sched_start>
}
    4000eb54:	aa1303e0 	mov	x0, x19
    4000eb58:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000eb5c:	a94253f3 	ldp	x19, x20, [sp, #32]
    4000eb60:	9100c3ff 	add	sp, sp, #0x30
    4000eb64:	d65f03c0 	ret

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    4000eb68:	aa1403e2 	mov	x2, x20
    4000eb6c:	9100a260 	add	x0, x19, #0x28
    4000eb70:	b0000001 	adrp	x1, 4000f000 <z_impl_k_mutex_lock+0x94>
    4000eb74:	91214021 	add	x1, x1, #0x850
    4000eb78:	9400055f 	bl	400100f4 <z_add_timeout>
    4000eb7c:	17fffff6 	b	4000eb54 <z_impl_k_thread_create+0x3c>

000000004000eb80 <z_init_static_threads>:
{
    4000eb80:	d10103ff 	sub	sp, sp, #0x40
    4000eb84:	a9017bfd 	stp	x29, x30, [sp, #16]
    4000eb88:	910043fd 	add	x29, sp, #0x10
    4000eb8c:	a90253f3 	stp	x19, x20, [sp, #32]
	_FOREACH_STATIC_THREAD(thread_data) {
    4000eb90:	b0000313 	adrp	x19, 4006f000 <sys_work_q_stack+0xf20>
    4000eb94:	91296273 	add	x19, x19, #0xa58
    4000eb98:	aa1303f4 	mov	x20, x19
{
    4000eb9c:	a9035bf5 	stp	x21, x22, [sp, #48]
	_FOREACH_STATIC_THREAD(thread_data) {
    4000eba0:	b0000315 	adrp	x21, 4006f000 <sys_work_q_stack+0xf20>
    4000eba4:	912962b5 	add	x21, x21, #0xa58
    4000eba8:	eb15027f 	cmp	x19, x21
    4000ebac:	540001a3 	b.cc	4000ebe0 <z_init_static_threads+0x60>  // b.lo, b.ul, b.last
	_FOREACH_STATIC_THREAD(thread_data) {
    4000ebb0:	aa1403f3 	mov	x19, x20
    4000ebb4:	b0000014 	adrp	x20, 4000f000 <z_impl_k_mutex_lock+0x94>
    4000ebb8:	91214294 	add	x20, x20, #0x850
    4000ebbc:	d2800156 	mov	x22, #0xa                   	// #10
	k_sched_lock();
    4000ebc0:	94000250 	bl	4000f500 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    4000ebc4:	eb15027f 	cmp	x19, x21
    4000ebc8:	54000283 	b.cc	4000ec18 <z_init_static_threads+0x98>  // b.lo, b.ul, b.last
}
    4000ebcc:	a9417bfd 	ldp	x29, x30, [sp, #16]
    4000ebd0:	a94253f3 	ldp	x19, x20, [sp, #32]
    4000ebd4:	a9435bf5 	ldp	x21, x22, [sp, #48]
    4000ebd8:	910103ff 	add	sp, sp, #0x40
	k_sched_unlock();
    4000ebdc:	140003f9 	b	4000fbc0 <k_sched_unlock>
		z_setup_new_thread(
    4000ebe0:	f9402a60 	ldr	x0, [x19, #80]
    4000ebe4:	f90007e0 	str	x0, [sp, #8]
    4000ebe8:	b9403e60 	ldr	w0, [x19, #60]
    4000ebec:	b90003e0 	str	w0, [sp]
    4000ebf0:	a9400660 	ldp	x0, x1, [x19]
    4000ebf4:	a9419263 	ldp	x3, x4, [x19, #24]
    4000ebf8:	a9429a65 	ldp	x5, x6, [x19, #40]
    4000ebfc:	b9401262 	ldr	w2, [x19, #16]
    4000ec00:	b9403a67 	ldr	w7, [x19, #56]
    4000ec04:	97ffff7d 	bl	4000e9f8 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    4000ec08:	f9400260 	ldr	x0, [x19]
    4000ec0c:	f9005813 	str	x19, [x0, #176]
	_FOREACH_STATIC_THREAD(thread_data) {
    4000ec10:	91016273 	add	x19, x19, #0x58
    4000ec14:	17ffffe5 	b	4000eba8 <z_init_static_threads+0x28>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    4000ec18:	b9404262 	ldr	w2, [x19, #64]
    4000ec1c:	3100045f 	cmn	w2, #0x1
    4000ec20:	54000100 	b.eq	4000ec40 <z_init_static_threads+0xc0>  // b.none
					    K_MSEC(thread_data->init_delay));
    4000ec24:	7100005f 	cmp	w2, #0x0
    4000ec28:	1a9fa042 	csel	w2, w2, wzr, ge  // ge = tcont
			schedule_new_thread(thread_data->init_thread,
    4000ec2c:	f9400260 	ldr	x0, [x19]
					    K_MSEC(thread_data->init_delay));
    4000ec30:	93407c43 	sxtw	x3, w2
		t += off;
    4000ec34:	91002462 	add	x2, x3, #0x9
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    4000ec38:	b5000083 	cbnz	x3, 4000ec48 <z_init_static_threads+0xc8>
	z_sched_start(thread);
    4000ec3c:	940002f0 	bl	4000f7fc <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    4000ec40:	91016273 	add	x19, x19, #0x58
    4000ec44:	17ffffe0 	b	4000ebc4 <z_init_static_threads+0x44>
    4000ec48:	9ad60842 	udiv	x2, x2, x22
    4000ec4c:	aa1403e1 	mov	x1, x20
    4000ec50:	9100a000 	add	x0, x0, #0x28
    4000ec54:	94000528 	bl	400100f4 <z_add_timeout>
    4000ec58:	17fffffa 	b	4000ec40 <z_init_static_threads+0xc0>

000000004000ec5c <z_impl_k_thread_stack_space_get>:

int z_impl_k_thread_stack_space_get(const struct k_thread *thread,
				    size_t *unused_ptr)
{
	const uint8_t *start = (uint8_t *)thread->stack_info.start;
	size_t size = thread->stack_info.size;
    4000ec5c:	a9520803 	ldp	x3, x2, [x0, #288]
	size_t unused = 0;
    4000ec60:	d2800000 	mov	x0, #0x0                   	// #0
		 */
		checked_stack += 4;
		size -= 4;
	}

	for (size_t i = 0; i < size; i++) {
    4000ec64:	eb02001f 	cmp	x0, x2
    4000ec68:	54000081 	b.ne	4000ec78 <z_impl_k_thread_stack_space_get+0x1c>  // b.any
		} else {
			break;
		}
	}

	*unused_ptr = unused;
    4000ec6c:	f9000020 	str	x0, [x1]

	return 0;
}
    4000ec70:	52800000 	mov	w0, #0x0                   	// #0
    4000ec74:	d65f03c0 	ret
		if ((checked_stack[i]) == 0xaaU) {
    4000ec78:	38606864 	ldrb	w4, [x3, x0]
    4000ec7c:	7102a89f 	cmp	w4, #0xaa
    4000ec80:	54ffff61 	b.ne	4000ec6c <z_impl_k_thread_stack_space_get+0x10>  // b.any
			unused++;
    4000ec84:	91000400 	add	x0, x0, #0x1
	for (size_t i = 0; i < size; i++) {
    4000ec88:	17fffff7 	b	4000ec64 <z_impl_k_thread_stack_space_get+0x8>

000000004000ec8c <sys_kernel_version_get>:
 * @return kernel version
 */
uint32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
    4000ec8c:	528c6000 	mov	w0, #0x6300                	// #25344
    4000ec90:	72a040e0 	movk	w0, #0x207, lsl #16
    4000ec94:	d65f03c0 	ret

000000004000ec98 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    4000ec98:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000ec9c:	910003fd 	mov	x29, sp
    4000eca0:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000eca4:	d50342df 	msr	daifset, #0x2
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    4000eca8:	97ffee3a 	bl	4000a590 <arch_cpu_idle>
    4000ecac:	17fffffd 	b	4000eca0 <idle+0x8>

000000004000ecb0 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, const void *data, k_timeout_t timeout)
{
    4000ecb0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000ecb4:	aa0203e3 	mov	x3, x2
    4000ecb8:	910003fd 	mov	x29, sp
    4000ecbc:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ecc0:	aa0003f3 	mov	x19, x0
    4000ecc4:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000ecc8:	aa0103f6 	mov	x22, x1
    4000eccc:	f9001bf7 	str	x23, [sp, #48]

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
    4000ecd0:	91004017 	add	x23, x0, #0x10
MAKE_REG_HELPER(daif)
    4000ecd4:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ecd8:	d50342df 	msr	daifset, #0x2

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, put, msgq, timeout);

	if (msgq->used_msgs < msgq->max_msgs) {
    4000ecdc:	b9401801 	ldr	w1, [x0, #24]
    4000ece0:	b9404002 	ldr	w2, [x0, #64]
    4000ece4:	6b01005f 	cmp	w2, w1
    4000ece8:	54000522 	b.cs	4000ed8c <z_impl_k_msgq_put+0xdc>  // b.hs, b.nlast
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    4000ecec:	940003d3 	bl	4000fc38 <z_unpend_first_thread>
    4000ecf0:	aa0003f4 	mov	x20, x0
		if (pending_thread != NULL) {
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, 0);

			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
    4000ecf4:	aa1603e1 	mov	x1, x22
    4000ecf8:	f9400a62 	ldr	x2, [x19, #16]
		if (pending_thread != NULL) {
    4000ecfc:	b40001e0 	cbz	x0, 4000ed38 <z_impl_k_msgq_put+0x88>
			(void)memcpy(pending_thread->base.swap_data, data,
    4000ed00:	f9401000 	ldr	x0, [x0, #32]
    4000ed04:	97fff3ee 	bl	4000bcbc <memcpy>
    4000ed08:	b9013a9f 	str	wzr, [x20, #312]
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
    4000ed0c:	aa1403e0 	mov	x0, x20
    4000ed10:	940002b0 	bl	4000f7d0 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    4000ed14:	aa1703e0 	mov	x0, x23
    4000ed18:	2a1503e1 	mov	w1, w21
    4000ed1c:	940001de 	bl	4000f494 <z_reschedule>
			return 0;
    4000ed20:	52800000 	mov	w0, #0x0                   	// #0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, put, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    4000ed24:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ed28:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000ed2c:	f9401bf7 	ldr	x23, [sp, #48]
    4000ed30:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000ed34:	d65f03c0 	ret
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
    4000ed38:	f9401e60 	ldr	x0, [x19, #56]
    4000ed3c:	97fff3e0 	bl	4000bcbc <memcpy>
			msgq->write_ptr += msgq->msg_size;
    4000ed40:	f9400a61 	ldr	x1, [x19, #16]
    4000ed44:	f9401e60 	ldr	x0, [x19, #56]
    4000ed48:	8b010000 	add	x0, x0, x1
    4000ed4c:	f9001e60 	str	x0, [x19, #56]
			if (msgq->write_ptr == msgq->buffer_end) {
    4000ed50:	f9401661 	ldr	x1, [x19, #40]
    4000ed54:	eb01001f 	cmp	x0, x1
    4000ed58:	54000061 	b.ne	4000ed64 <z_impl_k_msgq_put+0xb4>  // b.any
				msgq->write_ptr = msgq->buffer_start;
    4000ed5c:	f9401260 	ldr	x0, [x19, #32]
    4000ed60:	f9001e60 	str	x0, [x19, #56]
			msgq->used_msgs++;
    4000ed64:	b9404260 	ldr	w0, [x19, #64]
	z_handle_obj_poll_events(&msgq->poll_events, state);
    4000ed68:	52800201 	mov	w1, #0x10                  	// #16
			msgq->used_msgs++;
    4000ed6c:	11000400 	add	w0, w0, #0x1
    4000ed70:	b9004260 	str	w0, [x19, #64]
	z_handle_obj_poll_events(&msgq->poll_events, state);
    4000ed74:	91012260 	add	x0, x19, #0x48
    4000ed78:	9400083f 	bl	40010e74 <z_handle_obj_poll_events>
		result = 0;
    4000ed7c:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    4000ed80:	92407eb5 	and	x21, x21, #0xffffffff
    4000ed84:	d51b4235 	msr	daif, x21
	return result;
    4000ed88:	17ffffe7 	b	4000ed24 <z_impl_k_msgq_put+0x74>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    4000ed8c:	b4000183 	cbz	x3, 4000edbc <z_impl_k_msgq_put+0x10c>
		_current->base.swap_data = (void *) data;
    4000ed90:	f0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000ed94:	f9438800 	ldr	x0, [x0, #1808]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000ed98:	aa1303e2 	mov	x2, x19
}
    4000ed9c:	a94153f3 	ldp	x19, x20, [sp, #16]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000eda0:	2a1503e1 	mov	w1, w21
		_current->base.swap_data = (void *) data;
    4000eda4:	f9001016 	str	x22, [x0, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000eda8:	aa1703e0 	mov	x0, x23
}
    4000edac:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000edb0:	f9401bf7 	ldr	x23, [sp, #48]
    4000edb4:	a8c47bfd 	ldp	x29, x30, [sp], #64
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000edb8:	14000313 	b	4000fa04 <z_pend_curr>
		result = -ENOMSG;
    4000edbc:	12800440 	mov	w0, #0xffffffdd            	// #-35
    4000edc0:	17fffff0 	b	4000ed80 <z_impl_k_msgq_put+0xd0>

000000004000edc4 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
    4000edc4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000edc8:	910003fd 	mov	x29, sp
    4000edcc:	a90153f3 	stp	x19, x20, [sp, #16]
    4000edd0:	aa0003f3 	mov	x19, x0
    4000edd4:	aa0103e0 	mov	x0, x1
    4000edd8:	a9025bf5 	stp	x21, x22, [sp, #32]

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
    4000eddc:	91004276 	add	x22, x19, #0x10
    4000ede0:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ede4:	d50342df 	msr	daifset, #0x2

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_msgq, get, msgq, timeout);

	if (msgq->used_msgs > 0U) {
    4000ede8:	b9404261 	ldr	w1, [x19, #64]
    4000edec:	340005e1 	cbz	w1, 4000eea8 <z_impl_k_msgq_get+0xe4>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
    4000edf0:	f9400a62 	ldr	x2, [x19, #16]
    4000edf4:	f9401a61 	ldr	x1, [x19, #48]
    4000edf8:	97fff3b1 	bl	4000bcbc <memcpy>
		msgq->read_ptr += msgq->msg_size;
    4000edfc:	f9400a61 	ldr	x1, [x19, #16]
    4000ee00:	f9401a60 	ldr	x0, [x19, #48]
    4000ee04:	8b010000 	add	x0, x0, x1
    4000ee08:	f9001a60 	str	x0, [x19, #48]
		if (msgq->read_ptr == msgq->buffer_end) {
    4000ee0c:	f9401661 	ldr	x1, [x19, #40]
    4000ee10:	eb01001f 	cmp	x0, x1
    4000ee14:	54000061 	b.ne	4000ee20 <z_impl_k_msgq_get+0x5c>  // b.any
			msgq->read_ptr = msgq->buffer_start;
    4000ee18:	f9401260 	ldr	x0, [x19, #32]
    4000ee1c:	f9001a60 	str	x0, [x19, #48]
		}
		msgq->used_msgs--;
    4000ee20:	b9404260 	ldr	w0, [x19, #64]
    4000ee24:	51000400 	sub	w0, w0, #0x1
    4000ee28:	b9004260 	str	w0, [x19, #64]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
    4000ee2c:	aa1303e0 	mov	x0, x19
    4000ee30:	94000382 	bl	4000fc38 <z_unpend_first_thread>
    4000ee34:	aa0003f4 	mov	x20, x0
		if (pending_thread != NULL) {
    4000ee38:	b4000500 	cbz	x0, 4000eed8 <z_impl_k_msgq_get+0x114>
			SYS_PORT_TRACING_OBJ_FUNC_BLOCKING(k_msgq, get, msgq, timeout);

			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
    4000ee3c:	f9400a62 	ldr	x2, [x19, #16]
    4000ee40:	f9401281 	ldr	x1, [x20, #32]
    4000ee44:	f9401e60 	ldr	x0, [x19, #56]
    4000ee48:	97fff39d 	bl	4000bcbc <memcpy>
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
    4000ee4c:	f9400a61 	ldr	x1, [x19, #16]
    4000ee50:	f9401e60 	ldr	x0, [x19, #56]
    4000ee54:	8b010000 	add	x0, x0, x1
    4000ee58:	f9001e60 	str	x0, [x19, #56]
			if (msgq->write_ptr == msgq->buffer_end) {
    4000ee5c:	f9401661 	ldr	x1, [x19, #40]
    4000ee60:	eb01001f 	cmp	x0, x1
    4000ee64:	54000061 	b.ne	4000ee70 <z_impl_k_msgq_get+0xac>  // b.any
				msgq->write_ptr = msgq->buffer_start;
    4000ee68:	f9401260 	ldr	x0, [x19, #32]
    4000ee6c:	f9001e60 	str	x0, [x19, #56]
			}
			msgq->used_msgs++;
    4000ee70:	b9404260 	ldr	w0, [x19, #64]
    4000ee74:	11000400 	add	w0, w0, #0x1
    4000ee78:	b9004260 	str	w0, [x19, #64]
    4000ee7c:	b9013a9f 	str	wzr, [x20, #312]

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
    4000ee80:	aa1403e0 	mov	x0, x20
    4000ee84:	94000253 	bl	4000f7d0 <z_ready_thread>
			z_reschedule(&msgq->lock, key);
    4000ee88:	aa1603e0 	mov	x0, x22
    4000ee8c:	2a1503e1 	mov	w1, w21
    4000ee90:	94000181 	bl	4000f494 <z_reschedule>

			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, 0);

			return 0;
    4000ee94:	52800000 	mov	w0, #0x0                   	// #0
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_msgq, get, msgq, timeout, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    4000ee98:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ee9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000eea0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000eea4:	d65f03c0 	ret
    4000eea8:	aa0203e3 	mov	x3, x2
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    4000eeac:	b40001e2 	cbz	x2, 4000eee8 <z_impl_k_msgq_get+0x124>
		_current->base.swap_data = data;
    4000eeb0:	f0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000eeb4:	f9438821 	ldr	x1, [x1, #1808]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000eeb8:	aa1303e2 	mov	x2, x19
}
    4000eebc:	a94153f3 	ldp	x19, x20, [sp, #16]
		_current->base.swap_data = data;
    4000eec0:	f9001020 	str	x0, [x1, #32]
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000eec4:	2a1503e1 	mov	w1, w21
    4000eec8:	aa1603e0 	mov	x0, x22
}
    4000eecc:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000eed0:	a8c37bfd 	ldp	x29, x30, [sp], #48
		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
    4000eed4:	140002cc 	b	4000fa04 <z_pend_curr>
		result = 0;
    4000eed8:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    4000eedc:	92407eb5 	and	x21, x21, #0xffffffff
    4000eee0:	d51b4235 	msr	daif, x21
	return result;
    4000eee4:	17ffffed 	b	4000ee98 <z_impl_k_msgq_get+0xd4>
		result = -ENOMSG;
    4000eee8:	12800440 	mov	w0, #0xffffffdd            	// #-35
    4000eeec:	17fffffc 	b	4000eedc <z_impl_k_msgq_get+0x118>

000000004000eef0 <z_impl_k_msgq_peek>:
}
#include <syscalls/k_msgq_get_mrsh.c>
#endif

int z_impl_k_msgq_peek(struct k_msgq *msgq, void *data)
{
    4000eef0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000eef4:	aa0003e3 	mov	x3, x0
    4000eef8:	aa0103e0 	mov	x0, x1
    4000eefc:	910003fd 	mov	x29, sp
    4000ef00:	f9000bf3 	str	x19, [sp, #16]
    4000ef04:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ef08:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);

	if (msgq->used_msgs > 0U) {
    4000ef0c:	b9404061 	ldr	w1, [x3, #64]
    4000ef10:	34000141 	cbz	w1, 4000ef38 <z_impl_k_msgq_peek+0x48>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
    4000ef14:	f9400862 	ldr	x2, [x3, #16]
    4000ef18:	f9401861 	ldr	x1, [x3, #48]
    4000ef1c:	97fff368 	bl	4000bcbc <memcpy>
		result = 0;
    4000ef20:	52800000 	mov	w0, #0x0                   	// #0
MAKE_REG_HELPER(daif)
    4000ef24:	92407e73 	and	x19, x19, #0xffffffff
    4000ef28:	d51b4233 	msr	daif, x19
	SYS_PORT_TRACING_OBJ_FUNC(k_msgq, peek, msgq, result);

	k_spin_unlock(&msgq->lock, key);

	return result;
}
    4000ef2c:	f9400bf3 	ldr	x19, [sp, #16]
    4000ef30:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000ef34:	d65f03c0 	ret
		result = -ENOMSG;
    4000ef38:	12800440 	mov	w0, #0xffffffdd            	// #-35
    4000ef3c:	17fffffa 	b	4000ef24 <z_impl_k_msgq_peek+0x34>

000000004000ef40 <adjust_owner_prio.isra.0>:
	return new_prio;
}

static bool adjust_owner_prio(struct k_mutex *mutex, int32_t new_prio)
{
	if (mutex->owner->base.prio != new_prio) {
    4000ef40:	39c06802 	ldrsb	w2, [x0, #26]
    4000ef44:	6b01005f 	cmp	w2, w1
    4000ef48:	54000040 	b.eq	4000ef50 <adjust_owner_prio.isra.0+0x10>  // b.none
		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
			mutex->owner, z_is_thread_ready(mutex->owner) ?
			'y' : 'n',
			new_prio, mutex->owner->base.prio);

		return z_set_prio(mutex->owner, new_prio);
    4000ef4c:	140002bd 	b	4000fa40 <z_set_prio>
	}
	return false;
}
    4000ef50:	52800000 	mov	w0, #0x0                   	// #0
    4000ef54:	d65f03c0 	ret

000000004000ef58 <z_impl_k_mutex_init>:
	list->tail = (sys_dnode_t *)list;
    4000ef58:	a9000000 	stp	x0, x0, [x0]
	mutex->owner = NULL;
    4000ef5c:	f900081f 	str	xzr, [x0, #16]
	mutex->lock_count = 0U;
    4000ef60:	b900181f 	str	wzr, [x0, #24]
}
    4000ef64:	52800000 	mov	w0, #0x0                   	// #0
    4000ef68:	d65f03c0 	ret

000000004000ef6c <z_impl_k_mutex_lock>:

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    4000ef6c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    4000ef70:	910003fd 	mov	x29, sp
    4000ef74:	a90153f3 	stp	x19, x20, [sp, #16]
    4000ef78:	aa0003f3 	mov	x19, x0
    4000ef7c:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000ef80:	f9001bf7 	str	x23, [sp, #48]
    4000ef84:	aa0103f7 	mov	x23, x1
    4000ef88:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ef8c:	d50342df 	msr	daifset, #0x2

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    4000ef90:	b9401801 	ldr	w1, [x0, #24]
    4000ef94:	f0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    4000ef98:	911c0042 	add	x2, x2, #0x700
    4000ef9c:	34000141 	cbz	w1, 4000efc4 <z_impl_k_mutex_lock+0x58>
    4000efa0:	f9400844 	ldr	x4, [x2, #16]
    4000efa4:	f9400800 	ldr	x0, [x0, #16]
    4000efa8:	eb04001f 	cmp	x0, x4
    4000efac:	54000280 	b.eq	4000effc <z_impl_k_mutex_lock+0x90>  // b.none
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    4000efb0:	b50002b7 	cbnz	x23, 4000f004 <z_impl_k_mutex_lock+0x98>
MAKE_REG_HELPER(daif)
    4000efb4:	92407e94 	and	x20, x20, #0xffffffff
    4000efb8:	d51b4234 	msr	daif, x20
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
    4000efbc:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    4000efc0:	1400000a 	b	4000efe8 <z_impl_k_mutex_lock+0x7c>
					_current->base.prio :
    4000efc4:	f9400840 	ldr	x0, [x2, #16]
    4000efc8:	39c06800 	ldrsb	w0, [x0, #26]
		mutex->lock_count++;
    4000efcc:	11000421 	add	w1, w1, #0x1
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    4000efd0:	29030261 	stp	w1, w0, [x19, #24]
		mutex->owner = _current;
    4000efd4:	f9400840 	ldr	x0, [x2, #16]
    4000efd8:	92407e94 	and	x20, x20, #0xffffffff
    4000efdc:	f9000a60 	str	x0, [x19, #16]
    4000efe0:	d51b4234 	msr	daif, x20
		return 0;
    4000efe4:	52800000 	mov	w0, #0x0                   	// #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
    4000efe8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000efec:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000eff0:	f9401bf7 	ldr	x23, [sp, #48]
    4000eff4:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4000eff8:	d65f03c0 	ret
					_current->base.prio :
    4000effc:	b9401e60 	ldr	w0, [x19, #28]
    4000f000:	17fffff3 	b	4000efcc <z_impl_k_mutex_lock+0x60>
	new_prio = new_prio_for_inheritance(_current->base.prio,
    4000f004:	39c06803 	ldrsb	w3, [x0, #26]
    4000f008:	39c06882 	ldrsb	w2, [x4, #26]
    4000f00c:	6b03005f 	cmp	w2, w3
    4000f010:	1a83d041 	csel	w1, w2, w3, le
    4000f014:	12800fc2 	mov	w2, #0xffffff81            	// #-127
    4000f018:	3101fc3f 	cmn	w1, #0x7f
    4000f01c:	1a82a021 	csel	w1, w1, w2, ge  // ge = tcont
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    4000f020:	6b01007f 	cmp	w3, w1
    4000f024:	5400044d 	b.le	4000f0ac <z_impl_k_mutex_lock+0x140>
		resched = adjust_owner_prio(mutex, new_prio);
    4000f028:	97ffffc6 	bl	4000ef40 <adjust_owner_prio.isra.0>
    4000f02c:	12001c16 	and	w22, w0, #0xff
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    4000f030:	d0000095 	adrp	x21, 40021000 <k_sys_work_q+0x240>
    4000f034:	91236ab5 	add	x21, x21, #0x8da
    4000f038:	aa1703e3 	mov	x3, x23
    4000f03c:	aa1303e2 	mov	x2, x19
    4000f040:	2a1403e1 	mov	w1, w20
    4000f044:	aa1503e0 	mov	x0, x21
    4000f048:	9400026f 	bl	4000fa04 <z_pend_curr>
	if (got_mutex == 0) {
    4000f04c:	34fffce0 	cbz	w0, 4000efe8 <z_impl_k_mutex_lock+0x7c>
    4000f050:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f054:	d50342df 	msr	daifset, #0x2
	return list->head == list;
    4000f058:	f9400260 	ldr	x0, [x19]
    4000f05c:	b9401e61 	ldr	w1, [x19, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000f060:	eb00027f 	cmp	x19, x0
    4000f064:	54000100 	b.eq	4000f084 <z_impl_k_mutex_lock+0x118>  // b.none
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    4000f068:	b40000e0 	cbz	x0, 4000f084 <z_impl_k_mutex_lock+0x118>
    4000f06c:	39c06800 	ldrsb	w0, [x0, #26]
    4000f070:	6b01001f 	cmp	w0, w1
    4000f074:	1a81d001 	csel	w1, w0, w1, le
    4000f078:	12800fc0 	mov	w0, #0xffffff81            	// #-127
    4000f07c:	3101fc3f 	cmn	w1, #0x7f
    4000f080:	1a80a021 	csel	w1, w1, w0, ge  // ge = tcont
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    4000f084:	f9400a60 	ldr	x0, [x19, #16]
    4000f088:	97ffffae 	bl	4000ef40 <adjust_owner_prio.isra.0>
    4000f08c:	72001c1f 	tst	w0, #0xff
    4000f090:	54000041 	b.ne	4000f098 <z_impl_k_mutex_lock+0x12c>  // b.any
	if (resched) {
    4000f094:	34000116 	cbz	w22, 4000f0b4 <z_impl_k_mutex_lock+0x148>
		z_reschedule(&lock, key);
    4000f098:	2a1403e1 	mov	w1, w20
    4000f09c:	aa1503e0 	mov	x0, x21
    4000f0a0:	940000fd 	bl	4000f494 <z_reschedule>
	return -EAGAIN;
    4000f0a4:	12800140 	mov	w0, #0xfffffff5            	// #-11
    4000f0a8:	17ffffd0 	b	4000efe8 <z_impl_k_mutex_lock+0x7c>
	bool resched = false;
    4000f0ac:	52800016 	mov	w22, #0x0                   	// #0
    4000f0b0:	17ffffe0 	b	4000f030 <z_impl_k_mutex_lock+0xc4>
MAKE_REG_HELPER(daif)
    4000f0b4:	92407e94 	and	x20, x20, #0xffffffff
    4000f0b8:	d51b4234 	msr	daif, x20
    4000f0bc:	17fffffa 	b	4000f0a4 <z_impl_k_mutex_lock+0x138>

000000004000f0c0 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    4000f0c0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f0c4:	910003fd 	mov	x29, sp
    4000f0c8:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f0cc:	aa0003f3 	mov	x19, x0

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
    4000f0d0:	f9400800 	ldr	x0, [x0, #16]
    4000f0d4:	b4000500 	cbz	x0, 4000f174 <z_impl_k_mutex_unlock+0xb4>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    4000f0d8:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000f0dc:	f9438821 	ldr	x1, [x1, #1808]
    4000f0e0:	eb01001f 	cmp	x0, x1
    4000f0e4:	540004c1 	b.ne	4000f17c <z_impl_k_mutex_unlock+0xbc>  // b.any
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    4000f0e8:	39406c01 	ldrb	w1, [x0, #27]
    4000f0ec:	51000421 	sub	w1, w1, #0x1
    4000f0f0:	39006c01 	strb	w1, [x0, #27]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
    4000f0f4:	b9401a60 	ldr	w0, [x19, #24]
    4000f0f8:	7100041f 	cmp	w0, #0x1
    4000f0fc:	54000109 	b.ls	4000f11c <z_impl_k_mutex_unlock+0x5c>  // b.plast
		mutex->lock_count--;
    4000f100:	51000400 	sub	w0, w0, #0x1
    4000f104:	b9001a60 	str	w0, [x19, #24]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
    4000f108:	940002ae 	bl	4000fbc0 <k_sched_unlock>

	return 0;
    4000f10c:	52800000 	mov	w0, #0x0                   	// #0
}
    4000f110:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f114:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f118:	d65f03c0 	ret
    4000f11c:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f120:	d50342df 	msr	daifset, #0x2
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    4000f124:	b9401e61 	ldr	w1, [x19, #28]
    4000f128:	f9400a60 	ldr	x0, [x19, #16]
    4000f12c:	97ffff85 	bl	4000ef40 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    4000f130:	aa1303e0 	mov	x0, x19
    4000f134:	940002c1 	bl	4000fc38 <z_unpend_first_thread>
	mutex->owner = new_owner;
    4000f138:	f9000a60 	str	x0, [x19, #16]
	if (new_owner != NULL) {
    4000f13c:	b4000140 	cbz	x0, 4000f164 <z_impl_k_mutex_unlock+0xa4>
		mutex->owner_orig_prio = new_owner->base.prio;
    4000f140:	39c06801 	ldrsb	w1, [x0, #26]
    4000f144:	b9001e61 	str	w1, [x19, #28]
    4000f148:	b901381f 	str	wzr, [x0, #312]
		z_ready_thread(new_owner);
    4000f14c:	940001a1 	bl	4000f7d0 <z_ready_thread>
		z_reschedule(&lock, key);
    4000f150:	2a1403e1 	mov	w1, w20
    4000f154:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000f158:	91236800 	add	x0, x0, #0x8da
    4000f15c:	940000ce 	bl	4000f494 <z_reschedule>
    4000f160:	17ffffea 	b	4000f108 <z_impl_k_mutex_unlock+0x48>
MAKE_REG_HELPER(daif)
    4000f164:	92407e94 	and	x20, x20, #0xffffffff
		mutex->lock_count = 0U;
    4000f168:	b9001a7f 	str	wzr, [x19, #24]
    4000f16c:	d51b4234 	msr	daif, x20
    4000f170:	17ffffe6 	b	4000f108 <z_impl_k_mutex_unlock+0x48>
		return -EINVAL;
    4000f174:	128002a0 	mov	w0, #0xffffffea            	// #-22
    4000f178:	17ffffe6 	b	4000f110 <z_impl_k_mutex_unlock+0x50>
		return -EPERM;
    4000f17c:	12800000 	mov	w0, #0xffffffff            	// #-1
    4000f180:	17ffffe4 	b	4000f110 <z_impl_k_mutex_unlock+0x50>

000000004000f184 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    4000f184:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f188:	910003fd 	mov	x29, sp
    4000f18c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f190:	aa0003f3 	mov	x19, x0
    4000f194:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f198:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    4000f19c:	940002a7 	bl	4000fc38 <z_unpend_first_thread>

	if (thread != NULL) {
    4000f1a0:	b4000120 	cbz	x0, 4000f1c4 <z_impl_k_sem_give+0x40>
    4000f1a4:	b901381f 	str	wzr, [x0, #312]
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    4000f1a8:	9400018a 	bl	4000f7d0 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    4000f1ac:	2a1403e1 	mov	w1, w20
    4000f1b0:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000f1b4:	91236800 	add	x0, x0, #0x8da

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    4000f1b8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f1bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule(&lock, key);
    4000f1c0:	140000b5 	b	4000f494 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    4000f1c4:	29420660 	ldp	w0, w1, [x19, #16]
    4000f1c8:	6b00003f 	cmp	w1, w0
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    4000f1cc:	52800041 	mov	w1, #0x2                   	// #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    4000f1d0:	1a800400 	cinc	w0, w0, ne  // ne = any
    4000f1d4:	b9001260 	str	w0, [x19, #16]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
    4000f1d8:	91006260 	add	x0, x19, #0x18
    4000f1dc:	94000726 	bl	40010e74 <z_handle_obj_poll_events>
}
    4000f1e0:	17fffff3 	b	4000f1ac <z_impl_k_sem_give+0x28>

000000004000f1e4 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    4000f1e4:	aa0003e2 	mov	x2, x0
    4000f1e8:	aa0103e3 	mov	x3, x1
MAKE_REG_HELPER(daif)
    4000f1ec:	d53b4221 	mrs	x1, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f1f0:	d50342df 	msr	daifset, #0x2

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    4000f1f4:	b9401000 	ldr	w0, [x0, #16]
    4000f1f8:	340000e0 	cbz	w0, 4000f214 <z_impl_k_sem_take+0x30>
		sem->count--;
    4000f1fc:	51000400 	sub	w0, w0, #0x1
MAKE_REG_HELPER(daif)
    4000f200:	92407c21 	and	x1, x1, #0xffffffff
    4000f204:	b9001040 	str	w0, [x2, #16]
    4000f208:	d51b4221 	msr	daif, x1
		k_spin_unlock(&lock, key);
		ret = 0;
    4000f20c:	52800000 	mov	w0, #0x0                   	// #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    4000f210:	d65f03c0 	ret
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    4000f214:	b50000a3 	cbnz	x3, 4000f228 <z_impl_k_sem_take+0x44>
    4000f218:	92407c21 	and	x1, x1, #0xffffffff
    4000f21c:	d51b4221 	msr	daif, x1
		ret = -EBUSY;
    4000f220:	128001e0 	mov	w0, #0xfffffff0            	// #-16
    4000f224:	17fffffb 	b	4000f210 <z_impl_k_sem_take+0x2c>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    4000f228:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000f22c:	91236800 	add	x0, x0, #0x8da
    4000f230:	140001f5 	b	4000fa04 <z_pend_curr>

000000004000f234 <sys_dlist_remove>:
	sys_dnode_t *const prev = node->prev;
    4000f234:	a9400801 	ldp	x1, x2, [x0]
	prev->next = next;
    4000f238:	f9000041 	str	x1, [x2]
	next->prev = prev;
    4000f23c:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
    4000f240:	a9007c1f 	stp	xzr, xzr, [x0]
	sys_dnode_init(node);
}
    4000f244:	d65f03c0 	ret

000000004000f248 <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
    4000f248:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000f24c:	aa0003e3 	mov	x3, x0
    4000f250:	910003fd 	mov	x29, sp

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
    4000f254:	97fffff8 	bl	4000f234 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    4000f258:	39406400 	ldrb	w0, [x0, #25]
    4000f25c:	121e7800 	and	w0, w0, #0xfffffffd
    4000f260:	39006460 	strb	w0, [x3, #25]
}
    4000f264:	a8c17bfd 	ldp	x29, x30, [sp], #16
	thread->base.pended_on = NULL;
    4000f268:	f900087f 	str	xzr, [x3, #16]
}
    4000f26c:	d65f03c0 	ret

000000004000f270 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
    4000f270:	39c06802 	ldrsb	w2, [x0, #26]
	int32_t b2 = thread_2->base.prio;
    4000f274:	39c06821 	ldrsb	w1, [x1, #26]
		return b2 - b1;
    4000f278:	4b020020 	sub	w0, w1, w2
    4000f27c:	6b01005f 	cmp	w2, w1
}
    4000f280:	1a9f1000 	csel	w0, w0, wzr, ne  // ne = any
    4000f284:	d65f03c0 	ret

000000004000f288 <z_reset_time_slice>:
{
    4000f288:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f28c:	910003fd 	mov	x29, sp
    4000f290:	f9000bf3 	str	x19, [sp, #16]
	if (slice_time != 0) {
    4000f294:	d0000093 	adrp	x19, 40021000 <k_sys_work_q+0x240>
    4000f298:	b9479e60 	ldr	w0, [x19, #1948]
    4000f29c:	34000160 	cbz	w0, 4000f2c8 <z_reset_time_slice+0x40>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    4000f2a0:	97fffb83 	bl	4000e0ac <sys_clock_elapsed>
    4000f2a4:	2a0003e1 	mov	w1, w0
    4000f2a8:	b9479e60 	ldr	w0, [x19, #1948]
    4000f2ac:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
}
    4000f2b0:	f9400bf3 	ldr	x19, [sp, #16]
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    4000f2b4:	0b010001 	add	w1, w0, w1
}
    4000f2b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    4000f2bc:	b9072041 	str	w1, [x2, #1824]
		z_set_timeout_expiry(slice_time, false);
    4000f2c0:	52800001 	mov	w1, #0x0                   	// #0
    4000f2c4:	140003e3 	b	40010250 <z_set_timeout_expiry>
}
    4000f2c8:	f9400bf3 	ldr	x19, [sp, #16]
    4000f2cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f2d0:	d65f03c0 	ret

000000004000f2d4 <z_swap_irqlock>:
{
    4000f2d4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000f2d8:	910003fd 	mov	x29, sp
    4000f2dc:	a90153f3 	stp	x19, x20, [sp, #16]
	old_thread = _current;
    4000f2e0:	d0000093 	adrp	x19, 40021000 <k_sys_work_q+0x240>
    4000f2e4:	911c0273 	add	x19, x19, #0x700
{
    4000f2e8:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000f2ec:	2a0003f4 	mov	w20, w0
	old_thread->swap_retval = -EAGAIN;
    4000f2f0:	12800140 	mov	w0, #0xfffffff5            	// #-11
	old_thread = _current;
    4000f2f4:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    4000f2f8:	b9013ac0 	str	w0, [x22, #312]
    4000f2fc:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f300:	d50342df 	msr	daifset, #0x2
	return _kernel.ready_q.cache;
    4000f304:	f9401a75 	ldr	x21, [x19, #48]
	if (new_thread != old_thread) {
    4000f308:	eb1502df 	cmp	x22, x21
    4000f30c:	540000c0 	b.eq	4000f324 <z_swap_irqlock+0x50>  // b.none
		z_reset_time_slice();
    4000f310:	97ffffde 	bl	4000f288 <z_reset_time_slice>
		_current_cpu->current = new_thread;
    4000f314:	f9000a75 	str	x21, [x19, #16]
    4000f318:	f940a2a0 	ldr	x0, [x21, #320]
    4000f31c:	910502c1 	add	x1, x22, #0x140
    4000f320:	97ffeea7 	bl	4000adbc <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    4000f324:	d51b4234 	msr	daif, x20
	return _current->swap_retval;
    4000f328:	f9400a60 	ldr	x0, [x19, #16]
}
    4000f32c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f330:	b9413800 	ldr	w0, [x0, #312]
    4000f334:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000f338:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000f33c:	d65f03c0 	ret

000000004000f340 <z_swap>:
{
    4000f340:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000f344:	910003fd 	mov	x29, sp
    4000f348:	a90153f3 	stp	x19, x20, [sp, #16]
	old_thread = _current;
    4000f34c:	d0000093 	adrp	x19, 40021000 <k_sys_work_q+0x240>
    4000f350:	911c0273 	add	x19, x19, #0x700
{
    4000f354:	a9025bf5 	stp	x21, x22, [sp, #32]
    4000f358:	2a0103f4 	mov	w20, w1
	old_thread->swap_retval = -EAGAIN;
    4000f35c:	12800141 	mov	w1, #0xfffffff5            	// #-11
	old_thread = _current;
    4000f360:	f9400a76 	ldr	x22, [x19, #16]
	old_thread->swap_retval = -EAGAIN;
    4000f364:	b9013ac1 	str	w1, [x22, #312]
	if (!is_spinlock || lock != &sched_spinlock) {
    4000f368:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000f36c:	91236821 	add	x1, x1, #0x8da
    4000f370:	eb00003f 	cmp	x1, x0
    4000f374:	54000060 	b.eq	4000f380 <z_swap+0x40>  // b.none
    4000f378:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f37c:	d50342df 	msr	daifset, #0x2
    4000f380:	f9401a75 	ldr	x21, [x19, #48]
	if (new_thread != old_thread) {
    4000f384:	eb1502df 	cmp	x22, x21
    4000f388:	540000c0 	b.eq	4000f3a0 <z_swap+0x60>  // b.none
		z_reset_time_slice();
    4000f38c:	97ffffbf 	bl	4000f288 <z_reset_time_slice>
		_current_cpu->current = new_thread;
    4000f390:	f9000a75 	str	x21, [x19, #16]
    4000f394:	f940a2a0 	ldr	x0, [x21, #320]
    4000f398:	910502c1 	add	x1, x22, #0x140
    4000f39c:	97ffee88 	bl	4000adbc <z_arm64_call_svc>
MAKE_REG_HELPER(daif)
    4000f3a0:	d51b4234 	msr	daif, x20
	return _current->swap_retval;
    4000f3a4:	f9400a60 	ldr	x0, [x19, #16]
}
    4000f3a8:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f3ac:	b9413800 	ldr	w0, [x0, #312]
    4000f3b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000f3b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000f3b8:	d65f03c0 	ret

000000004000f3bc <k_sched_time_slice_set>:
{
    4000f3bc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f3c0:	910003fd 	mov	x29, sp
    4000f3c4:	f9000bf3 	str	x19, [sp, #16]
    4000f3c8:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f3cc:	d50342df 	msr	daifset, #0x2
		_current_cpu->slice_ticks = 0;
    4000f3d0:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
		if (result32 && (t < BIT64(32))) {
    4000f3d4:	b2407fe3 	mov	x3, #0xffffffff            	// #4294967295
    4000f3d8:	b907205f 	str	wzr, [x2, #1824]
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
    4000f3dc:	2a0003e2 	mov	w2, w0
		t += off;
    4000f3e0:	91002442 	add	x2, x2, #0x9
		if (result32 && (t < BIT64(32))) {
    4000f3e4:	eb03005f 	cmp	x2, x3
    4000f3e8:	54000208 	b.hi	4000f428 <k_sched_time_slice_set+0x6c>  // b.pmore
			return ((uint32_t)t) / (from_hz / to_hz);
    4000f3ec:	11002402 	add	w2, w0, #0x9
    4000f3f0:	52800143 	mov	w3, #0xa                   	// #10
    4000f3f4:	1ac30842 	udiv	w2, w2, w3
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    4000f3f8:	7100001f 	cmp	w0, #0x0
    4000f3fc:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000f400:	540001ac 	b.gt	4000f434 <k_sched_time_slice_set+0x78>
			slice_time = MAX(2, slice_time);
    4000f404:	b9079c02 	str	w2, [x0, #1948]
		slice_max_prio = prio;
    4000f408:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
MAKE_REG_HELPER(daif)
    4000f40c:	92407e73 	and	x19, x19, #0xffffffff
    4000f410:	b9079801 	str	w1, [x0, #1944]
		z_reset_time_slice();
    4000f414:	97ffff9d 	bl	4000f288 <z_reset_time_slice>
    4000f418:	d51b4233 	msr	daif, x19
}
    4000f41c:	f9400bf3 	ldr	x19, [sp, #16]
    4000f420:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f424:	d65f03c0 	ret
			return t / ((uint64_t)from_hz / to_hz);
    4000f428:	d2800143 	mov	x3, #0xa                   	// #10
    4000f42c:	9ac30842 	udiv	x2, x2, x3
    4000f430:	17fffff2 	b	4000f3f8 <k_sched_time_slice_set+0x3c>
			slice_time = MAX(2, slice_time);
    4000f434:	7100085f 	cmp	w2, #0x2
    4000f438:	52800043 	mov	w3, #0x2                   	// #2
    4000f43c:	1a83a042 	csel	w2, w2, w3, ge  // ge = tcont
    4000f440:	17fffff1 	b	4000f404 <k_sched_time_slice_set+0x48>

000000004000f444 <z_unpend_thread_no_timeout>:
{
    4000f444:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000f448:	910003fd 	mov	x29, sp
    4000f44c:	d53b4224 	mrs	x4, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f450:	d50342df 	msr	daifset, #0x2
		unpend_thread_no_timeout(thread);
    4000f454:	97ffff7d 	bl	4000f248 <unpend_thread_no_timeout>
MAKE_REG_HELPER(daif)
    4000f458:	92407c84 	and	x4, x4, #0xffffffff
    4000f45c:	d51b4224 	msr	daif, x4
}
    4000f460:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000f464:	d65f03c0 	ret

000000004000f468 <z_unpend_thread>:
{
    4000f468:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000f46c:	aa0003e4 	mov	x4, x0
    4000f470:	910003fd 	mov	x29, sp
    4000f474:	d53b4225 	mrs	x5, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f478:	d50342df 	msr	daifset, #0x2
		unpend_thread_no_timeout(thread);
    4000f47c:	97ffff73 	bl	4000f248 <unpend_thread_no_timeout>
MAKE_REG_HELPER(daif)
    4000f480:	92407ca5 	and	x5, x5, #0xffffffff
    4000f484:	d51b4225 	msr	daif, x5
}
    4000f488:	a8c17bfd 	ldp	x29, x30, [sp], #16
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    4000f48c:	9100a080 	add	x0, x4, #0x28
    4000f490:	14000360 	b	40010210 <z_abort_timeout>

000000004000f494 <z_reschedule>:
{
    4000f494:	2a0103e2 	mov	w2, w1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    4000f498:	36380062 	tbz	w2, #7, 4000f4a4 <z_reschedule+0x10>
    4000f49c:	d51b4222 	msr	daif, x2
}
    4000f4a0:	d65f03c0 	ret
MAKE_REG_HELPER(tpidrro_el0);
    4000f4a4:	d53bd063 	mrs	x3, tpidrro_el0
    4000f4a8:	927db063 	and	x3, x3, #0xfffffffffff8
	if (resched(key.key) && need_swap()) {
    4000f4ac:	b9400063 	ldr	w3, [x3]
    4000f4b0:	35ffff63 	cbnz	w3, 4000f49c <z_reschedule+0x8>
	new_thread = _kernel.ready_q.cache;
    4000f4b4:	d0000083 	adrp	x3, 40021000 <k_sys_work_q+0x240>
    4000f4b8:	911c0063 	add	x3, x3, #0x700
	if (resched(key.key) && need_swap()) {
    4000f4bc:	f9401864 	ldr	x4, [x3, #48]
    4000f4c0:	f9400863 	ldr	x3, [x3, #16]
    4000f4c4:	eb03009f 	cmp	x4, x3
    4000f4c8:	54fffea0 	b.eq	4000f49c <z_reschedule+0x8>  // b.none
		z_swap(lock, key);
    4000f4cc:	17ffff9d 	b	4000f340 <z_swap>

000000004000f4d0 <z_reschedule_irqlock>:
{
    4000f4d0:	2a0003e1 	mov	w1, w0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    4000f4d4:	36380061 	tbz	w1, #7, 4000f4e0 <z_reschedule_irqlock+0x10>
MAKE_REG_HELPER(daif)
    4000f4d8:	d51b4221 	msr	daif, x1
}
    4000f4dc:	d65f03c0 	ret
MAKE_REG_HELPER(tpidrro_el0);
    4000f4e0:	d53bd062 	mrs	x2, tpidrro_el0
    4000f4e4:	927db042 	and	x2, x2, #0xfffffffffff8
	if (resched(key)) {
    4000f4e8:	b9400042 	ldr	w2, [x2]
    4000f4ec:	35ffff62 	cbnz	w2, 4000f4d8 <z_reschedule_irqlock+0x8>
		z_swap_irqlock(key);
    4000f4f0:	17ffff79 	b	4000f2d4 <z_swap_irqlock>

000000004000f4f4 <z_reschedule_unlocked>:
MAKE_REG_HELPER(daif)
    4000f4f4:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f4f8:	d50342df 	msr	daifset, #0x2
	(void) z_reschedule_irqlock(arch_irq_lock());
    4000f4fc:	17fffff5 	b	4000f4d0 <z_reschedule_irqlock>

000000004000f500 <k_sched_lock>:
MAKE_REG_HELPER(daif)
    4000f500:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f504:	d50342df 	msr	daifset, #0x2
	--_current->base.sched_locked;
    4000f508:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000f50c:	f9438822 	ldr	x2, [x1, #1808]
    4000f510:	39406c41 	ldrb	w1, [x2, #27]
    4000f514:	51000421 	sub	w1, w1, #0x1
    4000f518:	39006c41 	strb	w1, [x2, #27]
MAKE_REG_HELPER(daif)
    4000f51c:	92407c00 	and	x0, x0, #0xffffffff
    4000f520:	d51b4220 	msr	daif, x0
}
    4000f524:	d65f03c0 	ret

000000004000f528 <z_swap_next_thread>:
}
    4000f528:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000f52c:	f9439800 	ldr	x0, [x0, #1840]
    4000f530:	d65f03c0 	ret

000000004000f534 <z_get_next_switch_handle>:
	z_sched_usage_switch(_kernel.ready_q.cache);
    4000f534:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000f538:	911c0021 	add	x1, x1, #0x700
	_current->switch_handle = interrupted;
    4000f53c:	f9400823 	ldr	x3, [x1, #16]
	z_sched_usage_switch(_kernel.ready_q.cache);
    4000f540:	f9401822 	ldr	x2, [x1, #48]
	_current_cpu->current = new_thread;
    4000f544:	f9000822 	str	x2, [x1, #16]
	_current->switch_handle = interrupted;
    4000f548:	f900a060 	str	x0, [x3, #320]
}
    4000f54c:	f940a040 	ldr	x0, [x2, #320]
    4000f550:	d65f03c0 	ret

000000004000f554 <z_priq_dumb_best>:
	return list->head == list;
    4000f554:	f9400001 	ldr	x1, [x0]
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
	struct k_thread *thread = NULL;
    4000f558:	eb01001f 	cmp	x0, x1

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
    4000f55c:	9a9f1020 	csel	x0, x1, xzr, ne  // ne = any
    4000f560:	d65f03c0 	ret

000000004000f564 <update_cache>:
{
    4000f564:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f568:	2a0003e2 	mov	w2, w0
	return _priq_run_best(curr_cpu_runq());
    4000f56c:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000f570:	911ce000 	add	x0, x0, #0x738
{
    4000f574:	910003fd 	mov	x29, sp
    4000f578:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f57c:	d0000093 	adrp	x19, 40021000 <k_sys_work_q+0x240>
    4000f580:	911c0273 	add	x19, x19, #0x700
	return _priq_run_best(curr_cpu_runq());
    4000f584:	97fffff4 	bl	4000f554 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    4000f588:	b50001c0 	cbnz	x0, 4000f5c0 <update_cache+0x5c>
    4000f58c:	f9400e74 	ldr	x20, [x19, #24]
	if (z_is_thread_prevented_from_running(_current)) {
    4000f590:	f9400a61 	ldr	x1, [x19, #16]
	if (preempt_ok != 0) {
    4000f594:	350001a2 	cbnz	w2, 4000f5c8 <update_cache+0x64>
	if (z_is_thread_prevented_from_running(_current)) {
    4000f598:	39406420 	ldrb	w0, [x1, #25]
    4000f59c:	f240101f 	tst	x0, #0x1f
    4000f5a0:	54000141 	b.ne	4000f5c8 <update_cache+0x64>  // b.any
	if (is_preempt(_current) || is_metairq(thread)) {
    4000f5a4:	79403420 	ldrh	w0, [x1, #26]
    4000f5a8:	7101fc1f 	cmp	w0, #0x7f
    4000f5ac:	540000e9 	b.ls	4000f5c8 <update_cache+0x64>  // b.plast
		_kernel.ready_q.cache = _current;
    4000f5b0:	f9001a61 	str	x1, [x19, #48]
}
    4000f5b4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f5b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f5bc:	d65f03c0 	ret
    4000f5c0:	aa0003f4 	mov	x20, x0
    4000f5c4:	17fffff3 	b	4000f590 <update_cache+0x2c>
		if (thread != _current) {
    4000f5c8:	eb01029f 	cmp	x20, x1
    4000f5cc:	54000040 	b.eq	4000f5d4 <update_cache+0x70>  // b.none
			z_reset_time_slice();
    4000f5d0:	97ffff2e 	bl	4000f288 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    4000f5d4:	f9001a74 	str	x20, [x19, #48]
}
    4000f5d8:	17fffff7 	b	4000f5b4 <update_cache+0x50>

000000004000f5dc <move_thread_to_end_of_prio_q>:
{
    4000f5dc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000f5e0:	aa0003e3 	mov	x3, x0
    4000f5e4:	910003fd 	mov	x29, sp
	if (z_is_thread_queued(thread)) {
    4000f5e8:	39c06402 	ldrsb	w2, [x0, #25]
	return (thread->base.thread_state & state) != 0U;
    4000f5ec:	39406401 	ldrb	w1, [x0, #25]
    4000f5f0:	36f80082 	tbz	w2, #31, 4000f600 <move_thread_to_end_of_prio_q+0x24>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000f5f4:	12001821 	and	w1, w1, #0x7f
    4000f5f8:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000f5fc:	97ffff0e 	bl	4000f234 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
    4000f600:	39406460 	ldrb	w0, [x3, #25]
    4000f604:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000f608:	911c0021 	add	x1, x1, #0x700
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000f60c:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    4000f610:	911ce042 	add	x2, x2, #0x738
    4000f614:	32196000 	orr	w0, w0, #0xffffff80
    4000f618:	39006460 	strb	w0, [x3, #25]
	return (node == list->tail) ? NULL : node->next;
    4000f61c:	a9439420 	ldp	x0, x5, [x1, #56]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000f620:	eb02001f 	cmp	x0, x2
    4000f624:	540002c0 	b.eq	4000f67c <move_thread_to_end_of_prio_q+0xa0>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000f628:	b40002a0 	cbz	x0, 4000f67c <move_thread_to_end_of_prio_q+0xa0>
	int32_t b1 = thread_1->base.prio;
    4000f62c:	39c06866 	ldrsb	w6, [x3, #26]
	int32_t b2 = thread_2->base.prio;
    4000f630:	39c06804 	ldrsb	w4, [x0, #26]
	if (b1 != b2) {
    4000f634:	6b0400df 	cmp	w6, w4
    4000f638:	540001a0 	b.eq	4000f66c <move_thread_to_end_of_prio_q+0x90>  // b.none
		return b2 - b1;
    4000f63c:	4b060084 	sub	w4, w4, w6
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000f640:	7100009f 	cmp	w4, #0x0
    4000f644:	5400014d 	b.le	4000f66c <move_thread_to_end_of_prio_q+0x90>
	sys_dnode_t *const prev = successor->prev;
    4000f648:	f9400402 	ldr	x2, [x0, #8]
	node->prev = prev;
    4000f64c:	a9000860 	stp	x0, x2, [x3]
	prev->next = node;
    4000f650:	f9000043 	str	x3, [x2]
	successor->prev = node;
    4000f654:	f9000403 	str	x3, [x0, #8]
}
    4000f658:	a8c17bfd 	ldp	x29, x30, [sp], #16
	update_cache(thread == _current);
    4000f65c:	f9400820 	ldr	x0, [x1, #16]
    4000f660:	eb03001f 	cmp	x0, x3
    4000f664:	1a9f17e0 	cset	w0, eq  // eq = none
    4000f668:	17ffffbf 	b	4000f564 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    4000f66c:	eb05001f 	cmp	x0, x5
    4000f670:	54000060 	b.eq	4000f67c <move_thread_to_end_of_prio_q+0xa0>  // b.none
    4000f674:	f9400000 	ldr	x0, [x0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000f678:	b5fffdc0 	cbnz	x0, 4000f630 <move_thread_to_end_of_prio_q+0x54>
	node->prev = tail;
    4000f67c:	a9001462 	stp	x2, x5, [x3]
	tail->next = node;
    4000f680:	f90000a3 	str	x3, [x5]
	list->tail = node;
    4000f684:	f9002023 	str	x3, [x1, #64]
}
    4000f688:	17fffff4 	b	4000f658 <move_thread_to_end_of_prio_q+0x7c>

000000004000f68c <z_time_slice>:
{
    4000f68c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f690:	2a0003e3 	mov	w3, w0
    4000f694:	910003fd 	mov	x29, sp
    4000f698:	f9000bf3 	str	x19, [sp, #16]
    4000f69c:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f6a0:	d50342df 	msr	daifset, #0x2
	if (slice_time && sliceable(_current)) {
    4000f6a4:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000f6a8:	b9479c00 	ldr	w0, [x0, #1948]
    4000f6ac:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000f6b0:	911c0021 	add	x1, x1, #0x700
    4000f6b4:	340003c0 	cbz	w0, 4000f72c <z_time_slice+0xa0>
    4000f6b8:	f9400820 	ldr	x0, [x1, #16]
		&& !z_is_idle_thread_object(thread);
    4000f6bc:	79403402 	ldrh	w2, [x0, #26]
    4000f6c0:	7101fc5f 	cmp	w2, #0x7f
    4000f6c4:	54000348 	b.hi	4000f72c <z_time_slice+0xa0>  // b.pmore
		&& !z_is_thread_prevented_from_running(thread)
    4000f6c8:	39406402 	ldrb	w2, [x0, #25]
    4000f6cc:	f240105f 	tst	x2, #0x1f
    4000f6d0:	540002e1 	b.ne	4000f72c <z_time_slice+0xa0>  // b.any
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    4000f6d4:	39c06804 	ldrsb	w4, [x0, #26]
    4000f6d8:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    4000f6dc:	b9479842 	ldr	w2, [x2, #1944]
    4000f6e0:	6b02009f 	cmp	w4, w2
    4000f6e4:	5400024b 	b.lt	4000f72c <z_time_slice+0xa0>  // b.tstop
		&& !z_is_idle_thread_object(thread);
    4000f6e8:	b0000082 	adrp	x2, 40020000 <logging_thread>
    4000f6ec:	911b8042 	add	x2, x2, #0x6e0
    4000f6f0:	eb02001f 	cmp	x0, x2
    4000f6f4:	540001c0 	b.eq	4000f72c <z_time_slice+0xa0>  // b.none
		if (ticks >= _current_cpu->slice_ticks) {
    4000f6f8:	b9402022 	ldr	w2, [x1, #32]
    4000f6fc:	6b03005f 	cmp	w2, w3
    4000f700:	5400010c 	b.gt	4000f720 <z_time_slice+0x94>
			move_thread_to_end_of_prio_q(_current);
    4000f704:	97ffffb6 	bl	4000f5dc <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    4000f708:	97fffee0 	bl	4000f288 <z_reset_time_slice>
MAKE_REG_HELPER(daif)
    4000f70c:	92407e73 	and	x19, x19, #0xffffffff
    4000f710:	d51b4233 	msr	daif, x19
}
    4000f714:	f9400bf3 	ldr	x19, [sp, #16]
    4000f718:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f71c:	d65f03c0 	ret
			_current_cpu->slice_ticks -= ticks;
    4000f720:	4b030042 	sub	w2, w2, w3
    4000f724:	b9002022 	str	w2, [x1, #32]
    4000f728:	17fffff9 	b	4000f70c <z_time_slice+0x80>
		_current_cpu->slice_ticks = 0;
    4000f72c:	b900203f 	str	wzr, [x1, #32]
    4000f730:	17fffff7 	b	4000f70c <z_time_slice+0x80>

000000004000f734 <ready_thread>:
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    4000f734:	39c06402 	ldrsb	w2, [x0, #25]
    4000f738:	39406401 	ldrb	w1, [x0, #25]
    4000f73c:	37f80482 	tbnz	w2, #31, 4000f7cc <ready_thread+0x98>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    4000f740:	f240103f 	tst	x1, #0x1f
    4000f744:	54000441 	b.ne	4000f7cc <ready_thread+0x98>  // b.any
    4000f748:	f9401402 	ldr	x2, [x0, #40]
    4000f74c:	b5000402 	cbnz	x2, 4000f7cc <ready_thread+0x98>
	return list->head == list;
    4000f750:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    4000f754:	911c0042 	add	x2, x2, #0x700
	thread->base.thread_state |= _THREAD_QUEUED;
    4000f758:	32196021 	orr	w1, w1, #0xffffff80
    4000f75c:	39006401 	strb	w1, [x0, #25]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000f760:	d0000083 	adrp	x3, 40021000 <k_sys_work_q+0x240>
    4000f764:	911ce063 	add	x3, x3, #0x738
	return (node == list->tail) ? NULL : node->next;
    4000f768:	a9439441 	ldp	x1, x5, [x2, #56]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000f76c:	eb03003f 	cmp	x1, x3
    4000f770:	54000260 	b.eq	4000f7bc <ready_thread+0x88>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000f774:	b4000241 	cbz	x1, 4000f7bc <ready_thread+0x88>
	int32_t b1 = thread_1->base.prio;
    4000f778:	39c06806 	ldrsb	w6, [x0, #26]
	int32_t b2 = thread_2->base.prio;
    4000f77c:	39c06824 	ldrsb	w4, [x1, #26]
	if (b1 != b2) {
    4000f780:	6b0400df 	cmp	w6, w4
    4000f784:	54000140 	b.eq	4000f7ac <ready_thread+0x78>  // b.none
		return b2 - b1;
    4000f788:	4b060084 	sub	w4, w4, w6
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000f78c:	7100009f 	cmp	w4, #0x0
    4000f790:	540000ed 	b.le	4000f7ac <ready_thread+0x78>
	sys_dnode_t *const prev = successor->prev;
    4000f794:	f9400422 	ldr	x2, [x1, #8]
	node->prev = prev;
    4000f798:	a9000801 	stp	x1, x2, [x0]
	prev->next = node;
    4000f79c:	f9000040 	str	x0, [x2]
	successor->prev = node;
    4000f7a0:	f9000420 	str	x0, [x1, #8]
		update_cache(0);
    4000f7a4:	52800000 	mov	w0, #0x0                   	// #0
    4000f7a8:	17ffff6f 	b	4000f564 <update_cache>
	return (node == list->tail) ? NULL : node->next;
    4000f7ac:	eb05003f 	cmp	x1, x5
    4000f7b0:	54000060 	b.eq	4000f7bc <ready_thread+0x88>  // b.none
    4000f7b4:	f9400021 	ldr	x1, [x1]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000f7b8:	b5fffe21 	cbnz	x1, 4000f77c <ready_thread+0x48>
	node->prev = tail;
    4000f7bc:	a9001403 	stp	x3, x5, [x0]
	tail->next = node;
    4000f7c0:	f90000a0 	str	x0, [x5]
	list->tail = node;
    4000f7c4:	f9002040 	str	x0, [x2, #64]
}
    4000f7c8:	17fffff7 	b	4000f7a4 <ready_thread+0x70>
}
    4000f7cc:	d65f03c0 	ret

000000004000f7d0 <z_ready_thread>:
{
    4000f7d0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f7d4:	910003fd 	mov	x29, sp
    4000f7d8:	f9000bf3 	str	x19, [sp, #16]
    4000f7dc:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f7e0:	d50342df 	msr	daifset, #0x2
			ready_thread(thread);
    4000f7e4:	97ffffd4 	bl	4000f734 <ready_thread>
MAKE_REG_HELPER(daif)
    4000f7e8:	92407e73 	and	x19, x19, #0xffffffff
    4000f7ec:	d51b4233 	msr	daif, x19
}
    4000f7f0:	f9400bf3 	ldr	x19, [sp, #16]
    4000f7f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f7f8:	d65f03c0 	ret

000000004000f7fc <z_sched_start>:
{
    4000f7fc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f800:	910003fd 	mov	x29, sp
    4000f804:	f9000bf3 	str	x19, [sp, #16]
    4000f808:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f80c:	d50342df 	msr	daifset, #0x2
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    4000f810:	39406402 	ldrb	w2, [x0, #25]
	if (z_has_thread_started(thread)) {
    4000f814:	371000c2 	tbnz	w2, #2, 4000f82c <z_sched_start+0x30>
MAKE_REG_HELPER(daif)
    4000f818:	92407e73 	and	x19, x19, #0xffffffff
    4000f81c:	d51b4233 	msr	daif, x19
}
    4000f820:	f9400bf3 	ldr	x19, [sp, #16]
    4000f824:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f828:	d65f03c0 	ret
	thread->base.thread_state &= ~_THREAD_PRESTART;
    4000f82c:	121d7842 	and	w2, w2, #0xfffffffb
    4000f830:	39006402 	strb	w2, [x0, #25]
	ready_thread(thread);
    4000f834:	97ffffc0 	bl	4000f734 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    4000f838:	2a1303e1 	mov	w1, w19
    4000f83c:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000f840:	91236800 	add	x0, x0, #0x8da
}
    4000f844:	f9400bf3 	ldr	x19, [sp, #16]
    4000f848:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule(&sched_spinlock, key);
    4000f84c:	17ffff12 	b	4000f494 <z_reschedule>

000000004000f850 <z_thread_timeout>:
{
    4000f850:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f854:	910003fd 	mov	x29, sp
    4000f858:	f9000bf3 	str	x19, [sp, #16]
    4000f85c:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f860:	d50342df 	msr	daifset, #0x2
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
    4000f864:	d100a004 	sub	x4, x0, #0x28
		if (!killed) {
    4000f868:	52800501 	mov	w1, #0x28                  	// #40
    4000f86c:	39406480 	ldrb	w0, [x4, #25]
    4000f870:	6a00003f 	tst	w1, w0
    4000f874:	54000161 	b.ne	4000f8a0 <z_thread_timeout+0x50>  // b.any
			if (thread->base.pended_on != NULL) {
    4000f878:	f9400880 	ldr	x0, [x4, #16]
    4000f87c:	b4000060 	cbz	x0, 4000f888 <z_thread_timeout+0x38>
				unpend_thread_no_timeout(thread);
    4000f880:	aa0403e0 	mov	x0, x4
    4000f884:	97fffe71 	bl	4000f248 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    4000f888:	39406480 	ldrb	w0, [x4, #25]
    4000f88c:	12800281 	mov	w1, #0xffffffeb            	// #-21
    4000f890:	0a010000 	and	w0, w0, w1
    4000f894:	39006480 	strb	w0, [x4, #25]
			ready_thread(thread);
    4000f898:	aa0403e0 	mov	x0, x4
    4000f89c:	97ffffa6 	bl	4000f734 <ready_thread>
MAKE_REG_HELPER(daif)
    4000f8a0:	92407e73 	and	x19, x19, #0xffffffff
    4000f8a4:	d51b4233 	msr	daif, x19
}
    4000f8a8:	f9400bf3 	ldr	x19, [sp, #16]
    4000f8ac:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f8b0:	d65f03c0 	ret

000000004000f8b4 <unready_thread>:
	if (z_is_thread_queued(thread)) {
    4000f8b4:	39c06402 	ldrsb	w2, [x0, #25]
{
    4000f8b8:	aa0003e3 	mov	x3, x0
	return (thread->base.thread_state & state) != 0U;
    4000f8bc:	39406401 	ldrb	w1, [x0, #25]
	if (z_is_thread_queued(thread)) {
    4000f8c0:	36f80182 	tbz	w2, #31, 4000f8f0 <unready_thread+0x3c>
{
    4000f8c4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000f8c8:	12001821 	and	w1, w1, #0x7f
{
    4000f8cc:	910003fd 	mov	x29, sp
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000f8d0:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000f8d4:	97fffe58 	bl	4000f234 <sys_dlist_remove>
	update_cache(thread == _current);
    4000f8d8:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000f8dc:	f9438800 	ldr	x0, [x0, #1808]
}
    4000f8e0:	a8c17bfd 	ldp	x29, x30, [sp], #16
	update_cache(thread == _current);
    4000f8e4:	eb03001f 	cmp	x0, x3
    4000f8e8:	1a9f17e0 	cset	w0, eq  // eq = none
    4000f8ec:	17ffff1e 	b	4000f564 <update_cache>
    4000f8f0:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000f8f4:	f9438800 	ldr	x0, [x0, #1808]
    4000f8f8:	eb03001f 	cmp	x0, x3
    4000f8fc:	1a9f17e0 	cset	w0, eq  // eq = none
    4000f900:	17fffffb 	b	4000f8ec <unready_thread+0x38>

000000004000f904 <add_to_waitq_locked>:
{
    4000f904:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000f908:	910003fd 	mov	x29, sp
    4000f90c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f910:	aa0003f3 	mov	x19, x0
    4000f914:	aa0103f4 	mov	x20, x1
	unready_thread(thread);
    4000f918:	97ffffe7 	bl	4000f8b4 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    4000f91c:	39406660 	ldrb	w0, [x19, #25]
    4000f920:	321f0000 	orr	w0, w0, #0x2
    4000f924:	39006660 	strb	w0, [x19, #25]
	if (wait_q != NULL) {
    4000f928:	b4000234 	cbz	x20, 4000f96c <add_to_waitq_locked+0x68>
	return list->head == list;
    4000f92c:	f9400280 	ldr	x0, [x20]
		thread->base.pended_on = wait_q;
    4000f930:	f9000a74 	str	x20, [x19, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000f934:	eb00029f 	cmp	x20, x0
    4000f938:	540002a0 	b.eq	4000f98c <add_to_waitq_locked+0x88>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000f93c:	b4000280 	cbz	x0, 4000f98c <add_to_waitq_locked+0x88>
	int32_t b1 = thread_1->base.prio;
    4000f940:	39c06a62 	ldrsb	w2, [x19, #26]
	int32_t b2 = thread_2->base.prio;
    4000f944:	39c06801 	ldrsb	w1, [x0, #26]
	if (b1 != b2) {
    4000f948:	6b01005f 	cmp	w2, w1
    4000f94c:	54000160 	b.eq	4000f978 <add_to_waitq_locked+0x74>  // b.none
		return b2 - b1;
    4000f950:	4b020021 	sub	w1, w1, w2
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000f954:	7100003f 	cmp	w1, #0x0
    4000f958:	5400010d 	b.le	4000f978 <add_to_waitq_locked+0x74>
	sys_dnode_t *const prev = successor->prev;
    4000f95c:	f9400401 	ldr	x1, [x0, #8]
	node->prev = prev;
    4000f960:	a9000660 	stp	x0, x1, [x19]
	prev->next = node;
    4000f964:	f9000033 	str	x19, [x1]
	successor->prev = node;
    4000f968:	f9000413 	str	x19, [x0, #8]
}
    4000f96c:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f970:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000f974:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
    4000f978:	f9400681 	ldr	x1, [x20, #8]
    4000f97c:	eb01001f 	cmp	x0, x1
    4000f980:	54000060 	b.eq	4000f98c <add_to_waitq_locked+0x88>  // b.none
    4000f984:	f9400000 	ldr	x0, [x0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000f988:	b5fffde0 	cbnz	x0, 4000f944 <add_to_waitq_locked+0x40>
	sys_dnode_t *const tail = list->tail;
    4000f98c:	f9400680 	ldr	x0, [x20, #8]
	node->prev = tail;
    4000f990:	a9000274 	stp	x20, x0, [x19]
	tail->next = node;
    4000f994:	f9000013 	str	x19, [x0]
	list->tail = node;
    4000f998:	f9000693 	str	x19, [x20, #8]
}
    4000f99c:	17fffff4 	b	4000f96c <add_to_waitq_locked+0x68>

000000004000f9a0 <pend>:
{
    4000f9a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000f9a4:	910003fd 	mov	x29, sp
    4000f9a8:	a90153f3 	stp	x19, x20, [sp, #16]
    4000f9ac:	aa0003f4 	mov	x20, x0
    4000f9b0:	aa0203f3 	mov	x19, x2
    4000f9b4:	f90013f5 	str	x21, [sp, #32]
    4000f9b8:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000f9bc:	d50342df 	msr	daifset, #0x2
MAKE_REG_HELPER(daif)
    4000f9c0:	92407eb5 	and	x21, x21, #0xffffffff
		add_to_waitq_locked(thread, wait_q);
    4000f9c4:	97ffffd0 	bl	4000f904 <add_to_waitq_locked>
    4000f9c8:	d51b4235 	msr	daif, x21
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    4000f9cc:	b100067f 	cmn	x19, #0x1
    4000f9d0:	54000120 	b.eq	4000f9f4 <pend+0x54>  // b.none
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    4000f9d4:	aa1303e2 	mov	x2, x19
    4000f9d8:	9100a280 	add	x0, x20, #0x28
}
    4000f9dc:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f9e0:	90000001 	adrp	x1, 4000f000 <z_impl_k_mutex_lock+0x94>
    4000f9e4:	91214021 	add	x1, x1, #0x850
    4000f9e8:	f94013f5 	ldr	x21, [sp, #32]
    4000f9ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000f9f0:	140001c1 	b	400100f4 <z_add_timeout>
    4000f9f4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000f9f8:	f94013f5 	ldr	x21, [sp, #32]
    4000f9fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000fa00:	d65f03c0 	ret

000000004000fa04 <z_pend_curr>:
{
    4000fa04:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fa08:	910003fd 	mov	x29, sp
    4000fa0c:	a90153f3 	stp	x19, x20, [sp, #16]
    4000fa10:	aa0003f3 	mov	x19, x0
	pend(_current, wait_q, timeout);
    4000fa14:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000fa18:	f9438800 	ldr	x0, [x0, #1808]
{
    4000fa1c:	2a0103f4 	mov	w20, w1
    4000fa20:	aa0203e1 	mov	x1, x2
    4000fa24:	aa0303e2 	mov	x2, x3
	pend(_current, wait_q, timeout);
    4000fa28:	97ffffde 	bl	4000f9a0 <pend>
	return z_swap(lock, key);
    4000fa2c:	2a1403e1 	mov	w1, w20
    4000fa30:	aa1303e0 	mov	x0, x19
}
    4000fa34:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000fa38:	a8c27bfd 	ldp	x29, x30, [sp], #32
	return z_swap(lock, key);
    4000fa3c:	17fffe41 	b	4000f340 <z_swap>

000000004000fa40 <z_set_prio>:
{
    4000fa40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fa44:	aa0003e3 	mov	x3, x0
    4000fa48:	910003fd 	mov	x29, sp
    4000fa4c:	f9000bf3 	str	x19, [sp, #16]
    4000fa50:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fa54:	d50342df 	msr	daifset, #0x2
	uint8_t state = thread->base.thread_state;
    4000fa58:	39406402 	ldrb	w2, [x0, #25]
				thread->base.prio = prio;
    4000fa5c:	13001c24 	sxtb	w4, w1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    4000fa60:	f240105f 	tst	x2, #0x1f
    4000fa64:	540005c1 	b.ne	4000fb1c <z_set_prio+0xdc>  // b.any
		if (need_sched) {
    4000fa68:	f9401401 	ldr	x1, [x0, #40]
    4000fa6c:	b5000581 	cbnz	x1, 4000fb1c <z_set_prio+0xdc>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000fa70:	12001842 	and	w2, w2, #0x7f
    4000fa74:	39006402 	strb	w2, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000fa78:	97fffdef 	bl	4000f234 <sys_dlist_remove>
				thread->base.prio = prio;
    4000fa7c:	39006804 	strb	w4, [x0, #26]
	thread->base.thread_state |= _THREAD_QUEUED;
    4000fa80:	39406400 	ldrb	w0, [x0, #25]
	return list->head == list;
    4000fa84:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000fa88:	911c0021 	add	x1, x1, #0x700
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000fa8c:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    4000fa90:	911ce042 	add	x2, x2, #0x738
    4000fa94:	32196000 	orr	w0, w0, #0xffffff80
    4000fa98:	39006460 	strb	w0, [x3, #25]
	return list->head == list;
    4000fa9c:	f9401c20 	ldr	x0, [x1, #56]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000faa0:	eb02001f 	cmp	x0, x2
    4000faa4:	54000320 	b.eq	4000fb08 <z_set_prio+0xc8>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000faa8:	b4000300 	cbz	x0, 4000fb08 <z_set_prio+0xc8>
	return (node == list->tail) ? NULL : node->next;
    4000faac:	f9402026 	ldr	x6, [x1, #64]
	int32_t b2 = thread_2->base.prio;
    4000fab0:	39c06805 	ldrsb	w5, [x0, #26]
	if (b1 != b2) {
    4000fab4:	6b05009f 	cmp	w4, w5
    4000fab8:	54000200 	b.eq	4000faf8 <z_set_prio+0xb8>  // b.none
		return b2 - b1;
    4000fabc:	4b0400a5 	sub	w5, w5, w4
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000fac0:	710000bf 	cmp	w5, #0x0
    4000fac4:	540001ad 	b.le	4000faf8 <z_set_prio+0xb8>
	sys_dnode_t *const prev = successor->prev;
    4000fac8:	f9400401 	ldr	x1, [x0, #8]
	node->prev = prev;
    4000facc:	a9000460 	stp	x0, x1, [x3]
	prev->next = node;
    4000fad0:	f9000023 	str	x3, [x1]
	successor->prev = node;
    4000fad4:	f9000403 	str	x3, [x0, #8]
			update_cache(1);
    4000fad8:	52800020 	mov	w0, #0x1                   	// #1
    4000fadc:	97fffea2 	bl	4000f564 <update_cache>
    4000fae0:	52800020 	mov	w0, #0x1                   	// #1
MAKE_REG_HELPER(daif)
    4000fae4:	92407e73 	and	x19, x19, #0xffffffff
    4000fae8:	d51b4233 	msr	daif, x19
}
    4000faec:	f9400bf3 	ldr	x19, [sp, #16]
    4000faf0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000faf4:	d65f03c0 	ret
	return (node == list->tail) ? NULL : node->next;
    4000faf8:	eb06001f 	cmp	x0, x6
    4000fafc:	54000060 	b.eq	4000fb08 <z_set_prio+0xc8>  // b.none
    4000fb00:	f9400000 	ldr	x0, [x0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fb04:	b5fffd60 	cbnz	x0, 4000fab0 <z_set_prio+0x70>
	sys_dnode_t *const tail = list->tail;
    4000fb08:	f9402020 	ldr	x0, [x1, #64]
	node->prev = tail;
    4000fb0c:	a9000062 	stp	x2, x0, [x3]
	tail->next = node;
    4000fb10:	f9000003 	str	x3, [x0]
	list->tail = node;
    4000fb14:	f9002023 	str	x3, [x1, #64]
}
    4000fb18:	17fffff0 	b	4000fad8 <z_set_prio+0x98>
			thread->base.prio = prio;
    4000fb1c:	52800000 	mov	w0, #0x0                   	// #0
    4000fb20:	39006864 	strb	w4, [x3, #26]
    4000fb24:	17fffff0 	b	4000fae4 <z_set_prio+0xa4>

000000004000fb28 <z_impl_k_thread_suspend>:
{
    4000fb28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000fb2c:	910003fd 	mov	x29, sp
    4000fb30:	a90153f3 	stp	x19, x20, [sp, #16]
    4000fb34:	aa0003f3 	mov	x19, x0
	return z_abort_timeout(&thread->base.timeout);
    4000fb38:	9100a000 	add	x0, x0, #0x28
    4000fb3c:	f90013f5 	str	x21, [sp, #32]
    4000fb40:	940001b4 	bl	40010210 <z_abort_timeout>
    4000fb44:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fb48:	d50342df 	msr	daifset, #0x2
		if (z_is_thread_queued(thread)) {
    4000fb4c:	39c06661 	ldrsb	w1, [x19, #25]
	return (thread->base.thread_state & state) != 0U;
    4000fb50:	39406660 	ldrb	w0, [x19, #25]
    4000fb54:	36f800a1 	tbz	w1, #31, 4000fb68 <z_impl_k_thread_suspend+0x40>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000fb58:	12001800 	and	w0, w0, #0x7f
    4000fb5c:	39006660 	strb	w0, [x19, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000fb60:	aa1303e0 	mov	x0, x19
    4000fb64:	97fffdb4 	bl	4000f234 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    4000fb68:	39406660 	ldrb	w0, [x19, #25]
		update_cache(thread == _current);
    4000fb6c:	d0000094 	adrp	x20, 40021000 <k_sys_work_q+0x240>
    4000fb70:	911c0294 	add	x20, x20, #0x700
MAKE_REG_HELPER(daif)
    4000fb74:	92407eb5 	and	x21, x21, #0xffffffff
    4000fb78:	321c0000 	orr	w0, w0, #0x10
    4000fb7c:	39006660 	strb	w0, [x19, #25]
    4000fb80:	f9400a80 	ldr	x0, [x20, #16]
    4000fb84:	eb13001f 	cmp	x0, x19
    4000fb88:	1a9f17e0 	cset	w0, eq  // eq = none
    4000fb8c:	97fffe76 	bl	4000f564 <update_cache>
    4000fb90:	d51b4235 	msr	daif, x21
	if (thread == _current) {
    4000fb94:	f9400a80 	ldr	x0, [x20, #16]
    4000fb98:	eb13001f 	cmp	x0, x19
    4000fb9c:	540000a1 	b.ne	4000fbb0 <z_impl_k_thread_suspend+0x88>  // b.any
}
    4000fba0:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000fba4:	f94013f5 	ldr	x21, [sp, #32]
    4000fba8:	a8c37bfd 	ldp	x29, x30, [sp], #48
		z_reschedule_unlocked();
    4000fbac:	17fffe52 	b	4000f4f4 <z_reschedule_unlocked>
}
    4000fbb0:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000fbb4:	f94013f5 	ldr	x21, [sp, #32]
    4000fbb8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000fbbc:	d65f03c0 	ret

000000004000fbc0 <k_sched_unlock>:
{
    4000fbc0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fbc4:	910003fd 	mov	x29, sp
    4000fbc8:	f9000bf3 	str	x19, [sp, #16]
    4000fbcc:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fbd0:	d50342df 	msr	daifset, #0x2
		++_current->base.sched_locked;
    4000fbd4:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000fbd8:	f9438801 	ldr	x1, [x0, #1808]
MAKE_REG_HELPER(daif)
    4000fbdc:	92407e73 	and	x19, x19, #0xffffffff
    4000fbe0:	39406c20 	ldrb	w0, [x1, #27]
    4000fbe4:	11000400 	add	w0, w0, #0x1
    4000fbe8:	39006c20 	strb	w0, [x1, #27]
		update_cache(0);
    4000fbec:	52800000 	mov	w0, #0x0                   	// #0
    4000fbf0:	97fffe5d 	bl	4000f564 <update_cache>
    4000fbf4:	d51b4233 	msr	daif, x19
}
    4000fbf8:	f9400bf3 	ldr	x19, [sp, #16]
    4000fbfc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_reschedule_unlocked();
    4000fc00:	17fffe3d 	b	4000f4f4 <z_reschedule_unlocked>

000000004000fc04 <z_unpend1_no_timeout>:
{
    4000fc04:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4000fc08:	910003fd 	mov	x29, sp
    4000fc0c:	d53b4225 	mrs	x5, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fc10:	d50342df 	msr	daifset, #0x2
		thread = _priq_wait_best(&wait_q->waitq);
    4000fc14:	97fffe50 	bl	4000f554 <z_priq_dumb_best>
    4000fc18:	aa0003e4 	mov	x4, x0
		if (thread != NULL) {
    4000fc1c:	b4000040 	cbz	x0, 4000fc24 <z_unpend1_no_timeout+0x20>
			unpend_thread_no_timeout(thread);
    4000fc20:	97fffd8a 	bl	4000f248 <unpend_thread_no_timeout>
MAKE_REG_HELPER(daif)
    4000fc24:	92407ca5 	and	x5, x5, #0xffffffff
    4000fc28:	d51b4225 	msr	daif, x5
}
    4000fc2c:	aa0403e0 	mov	x0, x4
    4000fc30:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4000fc34:	d65f03c0 	ret

000000004000fc38 <z_unpend_first_thread>:
{
    4000fc38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fc3c:	910003fd 	mov	x29, sp
    4000fc40:	a90153f3 	stp	x19, x20, [sp, #16]
    4000fc44:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fc48:	d50342df 	msr	daifset, #0x2
		thread = _priq_wait_best(&wait_q->waitq);
    4000fc4c:	97fffe42 	bl	4000f554 <z_priq_dumb_best>
    4000fc50:	aa0003f3 	mov	x19, x0
		if (thread != NULL) {
    4000fc54:	b4000080 	cbz	x0, 4000fc64 <z_unpend_first_thread+0x2c>
			unpend_thread_no_timeout(thread);
    4000fc58:	97fffd7c 	bl	4000f248 <unpend_thread_no_timeout>
    4000fc5c:	9100a260 	add	x0, x19, #0x28
    4000fc60:	9400016c 	bl	40010210 <z_abort_timeout>
MAKE_REG_HELPER(daif)
    4000fc64:	92407e94 	and	x20, x20, #0xffffffff
    4000fc68:	d51b4234 	msr	daif, x20
}
    4000fc6c:	aa1303e0 	mov	x0, x19
    4000fc70:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000fc74:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000fc78:	d65f03c0 	ret

000000004000fc7c <z_sched_init>:
	list->head = (sys_dnode_t *)list;
    4000fc7c:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000fc80:	911c0000 	add	x0, x0, #0x700
    4000fc84:	d0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    4000fc88:	911ce021 	add	x1, x1, #0x738
	list->tail = (sys_dnode_t *)list;
    4000fc8c:	a9038401 	stp	x1, x1, [x0, #56]
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    4000fc90:	52800001 	mov	w1, #0x0                   	// #0
    4000fc94:	52800000 	mov	w0, #0x0                   	// #0
    4000fc98:	17fffdc9 	b	4000f3bc <k_sched_time_slice_set>

000000004000fc9c <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
    4000fc9c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fca0:	910003fd 	mov	x29, sp
    4000fca4:	f9000bf3 	str	x19, [sp, #16]
    4000fca8:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fcac:	d50342df 	msr	daifset, #0x2

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
    4000fcb0:	d0000083 	adrp	x3, 40021000 <k_sys_work_q+0x240>
    4000fcb4:	911c0063 	add	x3, x3, #0x700
    4000fcb8:	f9400860 	ldr	x0, [x3, #16]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000fcbc:	39406401 	ldrb	w1, [x0, #25]
    4000fcc0:	12001821 	and	w1, w1, #0x7f
    4000fcc4:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000fcc8:	97fffd5b 	bl	4000f234 <sys_dlist_remove>
	}
	queue_thread(_current);
    4000fccc:	f9400860 	ldr	x0, [x3, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000fcd0:	d0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    4000fcd4:	911ce042 	add	x2, x2, #0x738
	thread->base.thread_state |= _THREAD_QUEUED;
    4000fcd8:	39406401 	ldrb	w1, [x0, #25]
    4000fcdc:	32196021 	orr	w1, w1, #0xffffff80
    4000fce0:	39006401 	strb	w1, [x0, #25]
	return list->head == list;
    4000fce4:	f9401c61 	ldr	x1, [x3, #56]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000fce8:	eb02003f 	cmp	x1, x2
    4000fcec:	54000340 	b.eq	4000fd54 <z_impl_k_yield+0xb8>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fcf0:	b4000321 	cbz	x1, 4000fd54 <z_impl_k_yield+0xb8>
	int32_t b1 = thread_1->base.prio;
    4000fcf4:	39c06805 	ldrsb	w5, [x0, #26]
	return (node == list->tail) ? NULL : node->next;
    4000fcf8:	f9402066 	ldr	x6, [x3, #64]
	int32_t b2 = thread_2->base.prio;
    4000fcfc:	39c06824 	ldrsb	w4, [x1, #26]
	if (b1 != b2) {
    4000fd00:	6b0400bf 	cmp	w5, w4
    4000fd04:	54000200 	b.eq	4000fd44 <z_impl_k_yield+0xa8>  // b.none
		return b2 - b1;
    4000fd08:	4b050084 	sub	w4, w4, w5
		if (z_sched_prio_cmp(thread, t) > 0) {
    4000fd0c:	7100009f 	cmp	w4, #0x0
    4000fd10:	540001ad 	b.le	4000fd44 <z_impl_k_yield+0xa8>
	sys_dnode_t *const prev = successor->prev;
    4000fd14:	f9400422 	ldr	x2, [x1, #8]
	node->prev = prev;
    4000fd18:	a9000801 	stp	x1, x2, [x0]
	prev->next = node;
    4000fd1c:	f9000040 	str	x0, [x2]
	successor->prev = node;
    4000fd20:	f9000420 	str	x0, [x1, #8]
	update_cache(1);
    4000fd24:	52800020 	mov	w0, #0x1                   	// #1
    4000fd28:	97fffe0f 	bl	4000f564 <update_cache>
	z_swap(&sched_spinlock, key);
    4000fd2c:	2a1303e1 	mov	w1, w19
    4000fd30:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000fd34:	91236800 	add	x0, x0, #0x8da
}
    4000fd38:	f9400bf3 	ldr	x19, [sp, #16]
    4000fd3c:	a8c27bfd 	ldp	x29, x30, [sp], #32
	z_swap(&sched_spinlock, key);
    4000fd40:	17fffd80 	b	4000f340 <z_swap>
	return (node == list->tail) ? NULL : node->next;
    4000fd44:	eb06003f 	cmp	x1, x6
    4000fd48:	54000060 	b.eq	4000fd54 <z_impl_k_yield+0xb8>  // b.none
    4000fd4c:	f9400021 	ldr	x1, [x1]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    4000fd50:	b5fffd61 	cbnz	x1, 4000fcfc <z_impl_k_yield+0x60>
	sys_dnode_t *const tail = list->tail;
    4000fd54:	f9402061 	ldr	x1, [x3, #64]
	node->prev = tail;
    4000fd58:	a9000402 	stp	x2, x1, [x0]
	tail->next = node;
    4000fd5c:	f9000020 	str	x0, [x1]
	list->tail = node;
    4000fd60:	f9002060 	str	x0, [x3, #64]
}
    4000fd64:	17fffff0 	b	4000fd24 <z_impl_k_yield+0x88>

000000004000fd68 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
    4000fd68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000fd6c:	910003fd 	mov	x29, sp
    4000fd70:	a90153f3 	stp	x19, x20, [sp, #16]
    4000fd74:	a9025bf5 	stp	x21, x22, [sp, #32]
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
    4000fd78:	b50000e0 	cbnz	x0, 4000fd94 <z_tick_sleep+0x2c>
	z_impl_k_yield();
    4000fd7c:	97ffffc8 	bl	4000fc9c <z_impl_k_yield>
		k_yield();
		return 0;
    4000fd80:	52800000 	mov	w0, #0x0                   	// #0
		return ticks;
	}
#endif

	return 0;
}
    4000fd84:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000fd88:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000fd8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000fd90:	d65f03c0 	ret
    4000fd94:	aa0003f4 	mov	x20, x0
	if (Z_TICK_ABS(ticks) <= 0) {
    4000fd98:	92800033 	mov	x19, #0xfffffffffffffffe    	// #-2
    4000fd9c:	cb000260 	sub	x0, x19, x0
    4000fda0:	f100001f 	cmp	x0, #0x0
    4000fda4:	5400038c 	b.gt	4000fe14 <z_tick_sleep+0xac>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    4000fda8:	94000184 	bl	400103b8 <sys_clock_tick_get_32>
    4000fdac:	0b140013 	add	w19, w0, w20
MAKE_REG_HELPER(daif)
    4000fdb0:	d53b4236 	mrs	x22, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000fdb4:	d50342df 	msr	daifset, #0x2
	unready_thread(_current);
    4000fdb8:	d0000095 	adrp	x21, 40021000 <k_sys_work_q+0x240>
    4000fdbc:	911c02b5 	add	x21, x21, #0x700
    4000fdc0:	f9400aa0 	ldr	x0, [x21, #16]
    4000fdc4:	97fffebc 	bl	4000f8b4 <unready_thread>
	z_add_thread_timeout(_current, timeout);
    4000fdc8:	f9400aa0 	ldr	x0, [x21, #16]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    4000fdcc:	aa1403e2 	mov	x2, x20
    4000fdd0:	90000001 	adrp	x1, 4000f000 <z_impl_k_mutex_lock+0x94>
    4000fdd4:	91214021 	add	x1, x1, #0x850
    4000fdd8:	9100a000 	add	x0, x0, #0x28
    4000fddc:	940000c6 	bl	400100f4 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    4000fde0:	f9400aa1 	ldr	x1, [x21, #16]
    4000fde4:	39406420 	ldrb	w0, [x1, #25]
    4000fde8:	321c0000 	orr	w0, w0, #0x10
    4000fdec:	39006420 	strb	w0, [x1, #25]
	(void)z_swap(&sched_spinlock, key);
    4000fdf0:	2a1603e1 	mov	w1, w22
    4000fdf4:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000fdf8:	91236800 	add	x0, x0, #0x8da
    4000fdfc:	97fffd51 	bl	4000f340 <z_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    4000fe00:	9400016e 	bl	400103b8 <sys_clock_tick_get_32>
    4000fe04:	cb204260 	sub	x0, x19, w0, uxtw
		return ticks;
    4000fe08:	f100001f 	cmp	x0, #0x0
    4000fe0c:	1a9fc000 	csel	w0, w0, wzr, gt
    4000fe10:	17ffffdd 	b	4000fd84 <z_tick_sleep+0x1c>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
    4000fe14:	4b140273 	sub	w19, w19, w20
    4000fe18:	17ffffe6 	b	4000fdb0 <z_tick_sleep+0x48>

000000004000fe1c <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
    4000fe1c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    4000fe20:	b100041f 	cmn	x0, #0x1
{
    4000fe24:	910003fd 	mov	x29, sp
    4000fe28:	f9000bf3 	str	x19, [sp, #16]
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    4000fe2c:	54000121 	b.ne	4000fe50 <z_impl_k_sleep+0x34>  // b.any
    4000fe30:	aa0003f3 	mov	x19, x0
		k_thread_suspend(_current);
    4000fe34:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000fe38:	f9438800 	ldr	x0, [x0, #1808]
	z_impl_k_thread_suspend(thread);
    4000fe3c:	97ffff3b 	bl	4000fb28 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
    4000fe40:	2a1303e0 	mov	w0, w19
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
    4000fe44:	f9400bf3 	ldr	x19, [sp, #16]
    4000fe48:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000fe4c:	d65f03c0 	ret
	int32_t ret = k_ticks_to_ms_floor64(ticks);
    4000fe50:	52800153 	mov	w19, #0xa                   	// #10
	ticks = z_tick_sleep(ticks);
    4000fe54:	97ffffc5 	bl	4000fd68 <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
    4000fe58:	1b137c00 	mul	w0, w0, w19
	return ret;
    4000fe5c:	17fffffa 	b	4000fe44 <z_impl_k_sleep+0x28>

000000004000fe60 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    4000fe60:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000fe64:	f9438800 	ldr	x0, [x0, #1808]
    4000fe68:	d65f03c0 	ret

000000004000fe6c <z_impl_k_is_preempt_thread>:
MAKE_REG_HELPER(tpidrro_el0);
    4000fe6c:	d53bd060 	mrs	x0, tpidrro_el0
    4000fe70:	927db000 	and	x0, x0, #0xfffffffffff8
#include <syscalls/z_current_get_mrsh.c>
#endif

int z_impl_k_is_preempt_thread(void)
{
	return !arch_is_in_isr() && is_preempt(_current);
    4000fe74:	b9400000 	ldr	w0, [x0]
    4000fe78:	350000e0 	cbnz	w0, 4000fe94 <z_impl_k_is_preempt_thread+0x28>
    4000fe7c:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    4000fe80:	f9438800 	ldr	x0, [x0, #1808]
	return !arch_is_in_isr() && is_preempt(_current);
    4000fe84:	79403400 	ldrh	w0, [x0, #26]
    4000fe88:	7101fc1f 	cmp	w0, #0x7f
    4000fe8c:	1a9f87e0 	cset	w0, ls  // ls = plast
}
    4000fe90:	d65f03c0 	ret
	return !arch_is_in_isr() && is_preempt(_current);
    4000fe94:	52800000 	mov	w0, #0x0                   	// #0
    4000fe98:	17fffffe 	b	4000fe90 <z_impl_k_is_preempt_thread+0x24>

000000004000fe9c <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
    4000fe9c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4000fea0:	910003fd 	mov	x29, sp
    4000fea4:	a90153f3 	stp	x19, x20, [sp, #16]
    4000fea8:	a9025bf5 	stp	x21, x22, [sp, #32]
MAKE_REG_HELPER(daif)
    4000feac:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000feb0:	d50342df 	msr	daifset, #0x2
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    4000feb4:	39406401 	ldrb	w1, [x0, #25]
    4000feb8:	361800e1 	tbz	w1, #3, 4000fed4 <z_thread_abort+0x38>
MAKE_REG_HELPER(daif)
    4000febc:	92407e94 	and	x20, x20, #0xffffffff
    4000fec0:	d51b4234 	msr	daif, x20
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    4000fec4:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000fec8:	a9425bf5 	ldp	x21, x22, [sp, #32]
    4000fecc:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4000fed0:	d65f03c0 	ret
		thread->base.thread_state &= ~_THREAD_ABORTING;
    4000fed4:	121a7822 	and	w2, w1, #0xffffffdf
    4000fed8:	aa0003f3 	mov	x19, x0
    4000fedc:	321d0043 	orr	w3, w2, #0x8
		if (z_is_thread_queued(thread)) {
    4000fee0:	373803c2 	tbnz	w2, #7, 4000ff58 <z_thread_abort+0xbc>
		thread->base.thread_state &= ~_THREAD_ABORTING;
    4000fee4:	39006403 	strb	w3, [x0, #25]
		if (thread->base.pended_on != NULL) {
    4000fee8:	f9400a60 	ldr	x0, [x19, #16]
    4000feec:	b4000060 	cbz	x0, 4000fef8 <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
    4000fef0:	aa1303e0 	mov	x0, x19
    4000fef4:	97fffcd5 	bl	4000f248 <unpend_thread_no_timeout>

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    4000fef8:	9102e276 	add	x22, x19, #0xb8
	return z_abort_timeout(&thread->base.timeout);
    4000fefc:	9100a260 	add	x0, x19, #0x28
    4000ff00:	940000c4 	bl	40010210 <z_abort_timeout>
	return list->head == list;
    4000ff04:	f9405e75 	ldr	x21, [x19, #184]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4000ff08:	eb1602bf 	cmp	x21, x22
    4000ff0c:	54000040 	b.eq	4000ff14 <z_thread_abort+0x78>  // b.none
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    4000ff10:	b5000315 	cbnz	x21, 4000ff70 <z_thread_abort+0xd4>
		update_cache(1);
    4000ff14:	52800020 	mov	w0, #0x1                   	// #1
    4000ff18:	97fffd93 	bl	4000f564 <update_cache>
		z_thread_monitor_exit(thread);
    4000ff1c:	aa1303e0 	mov	x0, x19
    4000ff20:	97fffa65 	bl	4000e8b4 <z_thread_monitor_exit>
	if (thread == _current && !arch_is_in_isr()) {
    4000ff24:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000ff28:	f9438800 	ldr	x0, [x0, #1808]
    4000ff2c:	eb13001f 	cmp	x0, x19
    4000ff30:	54fffc61 	b.ne	4000febc <z_thread_abort+0x20>  // b.any
MAKE_REG_HELPER(tpidrro_el0);
    4000ff34:	d53bd060 	mrs	x0, tpidrro_el0
    4000ff38:	927db000 	and	x0, x0, #0xfffffffffff8
    4000ff3c:	b9400000 	ldr	w0, [x0]
    4000ff40:	35fffbe0 	cbnz	w0, 4000febc <z_thread_abort+0x20>
		z_swap(&sched_spinlock, key);
    4000ff44:	2a1403e1 	mov	w1, w20
    4000ff48:	d0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4000ff4c:	91236800 	add	x0, x0, #0x8da
    4000ff50:	97fffcfc 	bl	4000f340 <z_swap>
    4000ff54:	17ffffda 	b	4000febc <z_thread_abort+0x20>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    4000ff58:	52800be2 	mov	w2, #0x5f                  	// #95
    4000ff5c:	0a020021 	and	w1, w1, w2
    4000ff60:	321d0021 	orr	w1, w1, #0x8
    4000ff64:	39006401 	strb	w1, [x0, #25]
	sys_dlist_remove(&thread->base.qnode_dlist);
    4000ff68:	97fffcb3 	bl	4000f234 <sys_dlist_remove>
}
    4000ff6c:	17ffffdf 	b	4000fee8 <z_thread_abort+0x4c>
		unpend_thread_no_timeout(thread);
    4000ff70:	aa1503e0 	mov	x0, x21
    4000ff74:	97fffcb5 	bl	4000f248 <unpend_thread_no_timeout>
    4000ff78:	9100a2a0 	add	x0, x21, #0x28
    4000ff7c:	940000a5 	bl	40010210 <z_abort_timeout>
    4000ff80:	b9013abf 	str	wzr, [x21, #312]
		ready_thread(thread);
    4000ff84:	aa1503e0 	mov	x0, x21
    4000ff88:	97fffdeb 	bl	4000f734 <ready_thread>
    4000ff8c:	17ffffde 	b	4000ff04 <z_thread_abort+0x68>

000000004000ff90 <z_impl_k_thread_abort>:
#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(struct k_thread *thread)
{
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_thread, abort, thread);

	z_thread_abort(thread);
    4000ff90:	17ffffc3 	b	4000fe9c <z_thread_abort>

000000004000ff94 <z_sched_wake>:

/*
 * future scheduler.h API implementations
 */
bool z_sched_wake(_wait_q_t *wait_q, int swap_retval, void *swap_data)
{
    4000ff94:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000ff98:	2a0103e3 	mov	w3, w1
    4000ff9c:	910003fd 	mov	x29, sp
    4000ffa0:	a90153f3 	stp	x19, x20, [sp, #16]
MAKE_REG_HELPER(daif)
    4000ffa4:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4000ffa8:	d50342df 	msr	daifset, #0x2
	struct k_thread *thread;
	bool ret = false;

	LOCKED(&sched_spinlock) {
		thread = _priq_wait_best(&wait_q->waitq);
    4000ffac:	97fffd6a 	bl	4000f554 <z_priq_dumb_best>

		if (thread != NULL) {
    4000ffb0:	b40001e0 	cbz	x0, 4000ffec <z_sched_wake+0x58>
	thread->base.swap_data = data;
    4000ffb4:	f9001002 	str	x2, [x0, #32]
    4000ffb8:	aa0003f3 	mov	x19, x0
	thread->swap_retval = value;
    4000ffbc:	b9013803 	str	w3, [x0, #312]
			z_thread_return_value_set_with_data(thread,
							    swap_retval,
							    swap_data);
			unpend_thread_no_timeout(thread);
    4000ffc0:	97fffca2 	bl	4000f248 <unpend_thread_no_timeout>
    4000ffc4:	9100a260 	add	x0, x19, #0x28
    4000ffc8:	94000092 	bl	40010210 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
			ready_thread(thread);
    4000ffcc:	aa1303e0 	mov	x0, x19
    4000ffd0:	97fffdd9 	bl	4000f734 <ready_thread>
			ret = true;
    4000ffd4:	52800020 	mov	w0, #0x1                   	// #1
MAKE_REG_HELPER(daif)
    4000ffd8:	92407e94 	and	x20, x20, #0xffffffff
    4000ffdc:	d51b4234 	msr	daif, x20
		}
	}

	return ret;
}
    4000ffe0:	a94153f3 	ldp	x19, x20, [sp, #16]
    4000ffe4:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4000ffe8:	d65f03c0 	ret
	bool ret = false;
    4000ffec:	52800000 	mov	w0, #0x0                   	// #0
    4000fff0:	17fffffa 	b	4000ffd8 <z_sched_wake+0x44>

000000004000fff4 <z_sched_wait>:

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
    4000fff4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4000fff8:	910003fd 	mov	x29, sp
    4000fffc:	f9000bf3 	str	x19, [sp, #16]
    40010000:	aa0403f3 	mov	x19, x4
	int ret = z_pend_curr(lock, key, wait_q, timeout);
    40010004:	97fffe80 	bl	4000fa04 <z_pend_curr>

	if (data != NULL) {
    40010008:	b40000b3 	cbz	x19, 4001001c <z_sched_wait+0x28>
		*data = _current->base.swap_data;
    4001000c:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40010010:	f9438821 	ldr	x1, [x1, #1808]
    40010014:	f9401021 	ldr	x1, [x1, #32]
    40010018:	f9000261 	str	x1, [x19]
	}
	return ret;
}
    4001001c:	f9400bf3 	ldr	x19, [sp, #16]
    40010020:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40010024:	d65f03c0 	ret

0000000040010028 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    40010028:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    4001002c:	b947a000 	ldr	w0, [x0, #1952]
    40010030:	35000040 	cbnz	w0, 40010038 <elapsed+0x10>
    40010034:	17fff81e 	b	4000e0ac <sys_clock_elapsed>
}
    40010038:	52800000 	mov	w0, #0x0                   	// #0
    4001003c:	d65f03c0 	ret

0000000040010040 <next_timeout>:

static int32_t next_timeout(void)
{
    40010040:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	return list->head == list;
    40010044:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    40010048:	91262001 	add	x1, x0, #0x988
    4001004c:	910003fd 	mov	x29, sp
    40010050:	f9000bf3 	str	x19, [sp, #16]
    40010054:	f944c413 	ldr	x19, [x0, #2440]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40010058:	eb01027f 	cmp	x19, x1
    4001005c:	9a9f1273 	csel	x19, x19, xzr, ne  // ne = any
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    40010060:	97fffff2 	bl	40010028 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
    40010064:	b4000213 	cbz	x19, 400100a4 <next_timeout+0x64>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    40010068:	f9400e61 	ldr	x1, [x19, #24]
    4001006c:	cb20c020 	sub	x0, x1, w0, sxtw
	int32_t ret = to == NULL ? MAX_WAIT
    40010070:	f100001f 	cmp	x0, #0x0
    40010074:	540001cd 	b.le	400100ac <next_timeout+0x6c>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    40010078:	b2407be1 	mov	x1, #0x7fffffff            	// #2147483647
    4001007c:	eb01001f 	cmp	x0, x1
	int32_t ret = to == NULL ? MAX_WAIT
    40010080:	9a81d000 	csel	x0, x0, x1, le

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    40010084:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40010088:	b9472021 	ldr	w1, [x1, #1824]
    4001008c:	34000061 	cbz	w1, 40010098 <next_timeout+0x58>
    40010090:	6b01001f 	cmp	w0, w1
    40010094:	1a81d000 	csel	w0, w0, w1, le
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    40010098:	f9400bf3 	ldr	x19, [sp, #16]
    4001009c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400100a0:	d65f03c0 	ret
	int32_t ret = to == NULL ? MAX_WAIT
    400100a4:	12b00000 	mov	w0, #0x7fffffff            	// #2147483647
    400100a8:	17fffff7 	b	40010084 <next_timeout+0x44>
    400100ac:	52800000 	mov	w0, #0x0                   	// #0
    400100b0:	17fffff5 	b	40010084 <next_timeout+0x44>

00000000400100b4 <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
    400100b4:	f9400001 	ldr	x1, [x0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    400100b8:	b4000140 	cbz	x0, 400100e0 <remove_timeout+0x2c>
	return (node == list->tail) ? NULL : node->next;
    400100bc:	f00002e2 	adrp	x2, 4006f000 <sys_work_q_stack+0xf20>
    400100c0:	f944c842 	ldr	x2, [x2, #2448]
    400100c4:	eb02001f 	cmp	x0, x2
    400100c8:	540000c0 	b.eq	400100e0 <remove_timeout+0x2c>  // b.none
	if (next(t) != NULL) {
    400100cc:	b40000a1 	cbz	x1, 400100e0 <remove_timeout+0x2c>
		next(t)->dticks += t->dticks;
    400100d0:	f9400c03 	ldr	x3, [x0, #24]
    400100d4:	f9400c22 	ldr	x2, [x1, #24]
    400100d8:	8b030042 	add	x2, x2, x3
    400100dc:	f9000c22 	str	x2, [x1, #24]
	sys_dnode_t *const prev = node->prev;
    400100e0:	f9400402 	ldr	x2, [x0, #8]
	prev->next = next;
    400100e4:	f9000041 	str	x1, [x2]
	next->prev = prev;
    400100e8:	f9000422 	str	x2, [x1, #8]
	node->prev = NULL;
    400100ec:	a9007c1f 	stp	xzr, xzr, [x0]
}
    400100f0:	d65f03c0 	ret

00000000400100f4 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    400100f4:	b100045f 	cmn	x2, #0x1
    400100f8:	540008a0 	b.eq	4001020c <z_add_timeout+0x118>  // b.none
{
    400100fc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40010100:	910003fd 	mov	x29, sp
    40010104:	a90153f3 	stp	x19, x20, [sp, #16]
    40010108:	aa0003f3 	mov	x19, x0
    4001010c:	aa0203f4 	mov	x20, x2
    40010110:	f90013f5 	str	x21, [sp, #32]
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    40010114:	f9000801 	str	x1, [x0, #16]
    40010118:	d53b4235 	mrs	x21, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4001011c:	d50342df 	msr	daifset, #0x2

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    40010120:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    40010124:	eb02001f 	cmp	x0, x2
    40010128:	54000244 	b.mi	40010170 <z_add_timeout+0x7c>  // b.first
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    4001012c:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40010130:	f943ac22 	ldr	x2, [x1, #1880]
    40010134:	cb020000 	sub	x0, x0, x2
    40010138:	cb140002 	sub	x2, x0, x20

			to->dticks = MAX(1, ticks);
    4001013c:	f100005f 	cmp	x2, #0x0
    40010140:	9a9fc442 	csinc	x2, x2, xzr, gt
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    40010144:	f9000e62 	str	x2, [x19, #24]
	return list->head == list;
    40010148:	f00002e2 	adrp	x2, 4006f000 <sys_work_q_stack+0xf20>
    4001014c:	91262041 	add	x1, x2, #0x988
    40010150:	f944c440 	ldr	x0, [x2, #2440]
	sys_dnode_t *const tail = list->tail;
    40010154:	f9400425 	ldr	x5, [x1, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40010158:	eb01001f 	cmp	x0, x1
    4001015c:	540001c1 	b.ne	40010194 <z_add_timeout+0xa0>  // b.any
	node->prev = tail;
    40010160:	a9001661 	stp	x1, x5, [x19]
	tail->next = node;
    40010164:	f90000b3 	str	x19, [x5]
	list->tail = node;
    40010168:	f9000433 	str	x19, [x1, #8]
}
    4001016c:	14000015 	b	400101c0 <z_add_timeout+0xcc>
    40010170:	97ffffae 	bl	40010028 <elapsed>
    40010174:	91000682 	add	x2, x20, #0x1
    40010178:	8b20c042 	add	x2, x2, w0, sxtw
    4001017c:	17fffff2 	b	40010144 <z_add_timeout+0x50>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
    40010180:	cb040063 	sub	x3, x3, x4
    40010184:	f9000e63 	str	x3, [x19, #24]
	return (node == list->tail) ? NULL : node->next;
    40010188:	eb0000bf 	cmp	x5, x0
    4001018c:	54fffea0 	b.eq	40010160 <z_add_timeout+0x6c>  // b.none
    40010190:	f9400000 	ldr	x0, [x0]
		for (t = first(); t != NULL; t = next(t)) {
    40010194:	b4fffe60 	cbz	x0, 40010160 <z_add_timeout+0x6c>
			if (t->dticks > to->dticks) {
    40010198:	f9400c04 	ldr	x4, [x0, #24]
    4001019c:	f9400e63 	ldr	x3, [x19, #24]
    400101a0:	eb03009f 	cmp	x4, x3
    400101a4:	54fffeed 	b.le	40010180 <z_add_timeout+0x8c>
				t->dticks -= to->dticks;
    400101a8:	cb030083 	sub	x3, x4, x3
    400101ac:	f9000c03 	str	x3, [x0, #24]
	sys_dnode_t *const prev = successor->prev;
    400101b0:	f9400403 	ldr	x3, [x0, #8]
	node->prev = prev;
    400101b4:	a9000e60 	stp	x0, x3, [x19]
	prev->next = node;
    400101b8:	f9000073 	str	x19, [x3]
	successor->prev = node;
    400101bc:	f9000413 	str	x19, [x0, #8]
	return list->head == list;
    400101c0:	f944c440 	ldr	x0, [x2, #2440]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    400101c4:	eb01001f 	cmp	x0, x1
    400101c8:	54000160 	b.eq	400101f4 <z_add_timeout+0x100>  // b.none

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    400101cc:	eb00027f 	cmp	x19, x0
    400101d0:	54000121 	b.ne	400101f4 <z_add_timeout+0x100>  // b.any
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    400101d4:	97ffff9b 	bl	40010040 <next_timeout>

			if (next_time == 0 ||
    400101d8:	340000a0 	cbz	w0, 400101ec <z_add_timeout+0xf8>
			    _current_cpu->slice_ticks != next_time) {
    400101dc:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
			if (next_time == 0 ||
    400101e0:	b9472021 	ldr	w1, [x1, #1824]
    400101e4:	6b00003f 	cmp	w1, w0
    400101e8:	54000060 	b.eq	400101f4 <z_add_timeout+0x100>  // b.none
				sys_clock_set_timeout(next_time, false);
    400101ec:	52800001 	mov	w1, #0x0                   	// #0
    400101f0:	97fff789 	bl	4000e014 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    400101f4:	92407eb5 	and	x21, x21, #0xffffffff
    400101f8:	d51b4235 	msr	daif, x21
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    400101fc:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010200:	f94013f5 	ldr	x21, [sp, #32]
    40010204:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40010208:	d65f03c0 	ret
    4001020c:	d65f03c0 	ret

0000000040010210 <z_abort_timeout>:
    40010210:	d53b4224 	mrs	x4, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010214:	d50342df 	msr	daifset, #0x2
int z_abort_timeout(struct _timeout *to)
{
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
    40010218:	f9400001 	ldr	x1, [x0]
    4001021c:	b4000121 	cbz	x1, 40010240 <z_abort_timeout+0x30>
{
    40010220:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
MAKE_REG_HELPER(daif)
    40010224:	92407c84 	and	x4, x4, #0xffffffff
    40010228:	910003fd 	mov	x29, sp
			remove_timeout(to);
    4001022c:	97ffffa2 	bl	400100b4 <remove_timeout>
			ret = 0;
    40010230:	52800000 	mov	w0, #0x0                   	// #0
    40010234:	d51b4224 	msr	daif, x4
		}
	}

	return ret;
}
    40010238:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4001023c:	d65f03c0 	ret
	int ret = -EINVAL;
    40010240:	128002a0 	mov	w0, #0xffffffea            	// #-22
    40010244:	92407c84 	and	x4, x4, #0xffffffff
    40010248:	d51b4224 	msr	daif, x4
}
    4001024c:	d65f03c0 	ret

0000000040010250 <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
    40010250:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40010254:	910003fd 	mov	x29, sp
    40010258:	a90153f3 	stp	x19, x20, [sp, #16]
    4001025c:	2a0003f3 	mov	w19, w0
    40010260:	f90013f5 	str	x21, [sp, #32]
    40010264:	12001c35 	and	w21, w1, #0xff
    40010268:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4001026c:	d50342df 	msr	daifset, #0x2
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
    40010270:	97ffff74 	bl	40010040 <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    40010274:	6b13001f 	cmp	w0, w19
    40010278:	3a41b804 	ccmn	w0, #0x1, #0x4, lt  // lt = tstop
    4001027c:	7a410804 	ccmp	w0, #0x1, #0x4, eq  // eq = none
    40010280:	540000ad 	b.le	40010294 <z_set_timeout_expiry+0x44>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    40010284:	6b13001f 	cmp	w0, w19
    40010288:	2a1503e1 	mov	w1, w21
    4001028c:	1a93d000 	csel	w0, w0, w19, le
    40010290:	97fff761 	bl	4000e014 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    40010294:	92407e94 	and	x20, x20, #0xffffffff
    40010298:	d51b4234 	msr	daif, x20
		}
	}
}
    4001029c:	a94153f3 	ldp	x19, x20, [sp, #16]
    400102a0:	f94013f5 	ldr	x21, [sp, #32]
    400102a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400102a8:	d65f03c0 	ret

00000000400102ac <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
    400102ac:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    400102b0:	910003fd 	mov	x29, sp
    400102b4:	a90153f3 	stp	x19, x20, [sp, #16]
    400102b8:	a9025bf5 	stp	x21, x22, [sp, #32]
    400102bc:	2a0003f5 	mov	w21, w0
    400102c0:	a90363f7 	stp	x23, x24, [sp, #48]
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    400102c4:	97fffcf2 	bl	4000f68c <z_time_slice>
    400102c8:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400102cc:	d50342df 	msr	daifset, #0x2
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    400102d0:	b0000094 	adrp	x20, 40021000 <k_sys_work_q+0x240>

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    400102d4:	b0000096 	adrp	x22, 40021000 <k_sys_work_q+0x240>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    400102d8:	911e8297 	add	x23, x20, #0x7a0
    400102dc:	aa1603f8 	mov	x24, x22
	announce_remaining = ticks;
    400102e0:	b907a295 	str	w21, [x20, #1952]
	return list->head == list;
    400102e4:	f00002f5 	adrp	x21, 4006f000 <sys_work_q_stack+0xf20>
    400102e8:	912622b5 	add	x21, x21, #0x988
	while (first() != NULL && first()->dticks <= announce_remaining) {
    400102ec:	b94002e4 	ldr	w4, [x23]
	return key;
}

static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	write_daif(key);
    400102f0:	2a1303f3 	mov	w19, w19
    400102f4:	f94002a0 	ldr	x0, [x21]
		curr_tick += dt;
    400102f8:	f943aec3 	ldr	x3, [x22, #1880]
    400102fc:	93407c82 	sxtw	x2, w4
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40010300:	eb15001f 	cmp	x0, x21
    40010304:	540000e0 	b.eq	40010320 <sys_clock_announce+0x74>  // b.none
	while (first() != NULL && first()->dticks <= announce_remaining) {
    40010308:	b40000c0 	cbz	x0, 40010320 <sys_clock_announce+0x74>
    4001030c:	f9400c01 	ldr	x1, [x0, #24]
    40010310:	eb02003f 	cmp	x1, x2
    40010314:	540001ed 	b.le	40010350 <sys_clock_announce+0xa4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    40010318:	cb020021 	sub	x1, x1, x2
    4001031c:	f9000c01 	str	x1, [x0, #24]
	}

	curr_tick += announce_remaining;
    40010320:	8b030042 	add	x2, x2, x3
	announce_remaining = 0;
    40010324:	b907a29f 	str	wzr, [x20, #1952]
	curr_tick += announce_remaining;
    40010328:	f903af02 	str	x2, [x24, #1880]

	sys_clock_set_timeout(next_timeout(), false);
    4001032c:	97ffff45 	bl	40010040 <next_timeout>
    40010330:	52800001 	mov	w1, #0x0                   	// #0
    40010334:	97fff738 	bl	4000e014 <sys_clock_set_timeout>
MAKE_REG_HELPER(daif)
    40010338:	d51b4233 	msr	daif, x19

	k_spin_unlock(&timeout_lock, key);
}
    4001033c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010340:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010344:	a94363f7 	ldp	x23, x24, [sp, #48]
    40010348:	a8c47bfd 	ldp	x29, x30, [sp], #64
    4001034c:	d65f03c0 	ret
		curr_tick += dt;
    40010350:	8b21c062 	add	x2, x3, w1, sxtw
		announce_remaining -= dt;
    40010354:	4b010081 	sub	w1, w4, w1
		t->dticks = 0;
    40010358:	f9000c1f 	str	xzr, [x0, #24]
		curr_tick += dt;
    4001035c:	f903aec2 	str	x2, [x22, #1880]
		announce_remaining -= dt;
    40010360:	b90002e1 	str	w1, [x23]
		remove_timeout(t);
    40010364:	97ffff54 	bl	400100b4 <remove_timeout>
    40010368:	d51b4233 	msr	daif, x19
		t->fn(t);
    4001036c:	f9400801 	ldr	x1, [x0, #16]
    40010370:	d63f0020 	blr	x1
    40010374:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010378:	d50342df 	msr	daifset, #0x2
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    4001037c:	17ffffdc 	b	400102ec <sys_clock_announce+0x40>

0000000040010380 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    40010380:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40010384:	910003fd 	mov	x29, sp
    40010388:	f9000bf3 	str	x19, [sp, #16]
MAKE_REG_HELPER(daif)
    4001038c:	d53b4233 	mrs	x19, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010390:	d50342df 	msr	daifset, #0x2
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
    40010394:	97fff746 	bl	4000e0ac <sys_clock_elapsed>
MAKE_REG_HELPER(daif)
    40010398:	92407e73 	and	x19, x19, #0xffffffff
    4001039c:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    400103a0:	f943ac21 	ldr	x1, [x1, #1880]
    400103a4:	8b204020 	add	x0, x1, w0, uxtw
    400103a8:	d51b4233 	msr	daif, x19
	}
	return t;
}
    400103ac:	f9400bf3 	ldr	x19, [sp, #16]
    400103b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400103b4:	d65f03c0 	ret

00000000400103b8 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    400103b8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400103bc:	910003fd 	mov	x29, sp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    400103c0:	97fffff0 	bl	40010380 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    400103c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400103c8:	d65f03c0 	ret

00000000400103cc <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
    400103cc:	17ffffed 	b	40010380 <sys_clock_tick_get>

00000000400103d0 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    400103d0:	34000040 	cbz	w0, 400103d8 <z_impl_k_busy_wait+0x8>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    400103d4:	17fff744 	b	4000e0e4 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    400103d8:	d65f03c0 	ret

00000000400103dc <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
    400103dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400103e0:	910003fd 	mov	x29, sp
    400103e4:	a90153f3 	stp	x19, x20, [sp, #16]
    400103e8:	aa0003f3 	mov	x19, x0
    400103ec:	f90013f5 	str	x21, [sp, #32]
    400103f0:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400103f4:	d50342df 	msr	daifset, #0x2

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
    400103f8:	f9402002 	ldr	x2, [x0, #64]
    400103fc:	91000441 	add	x1, x2, #0x1
    40010400:	f100043f 	cmp	x1, #0x1
    40010404:	54000089 	b.ls	40010414 <z_timer_expiration_handler+0x38>  // b.plast
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    40010408:	90000001 	adrp	x1, 40010000 <z_sched_wait+0xc>
    4001040c:	910f7021 	add	x1, x1, #0x3dc
    40010410:	97ffff39 	bl	400100f4 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
    40010414:	b9404a60 	ldr	w0, [x19, #72]
    40010418:	11000400 	add	w0, w0, #0x1
    4001041c:	b9004a60 	str	w0, [x19, #72]

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
    40010420:	f9401a60 	ldr	x0, [x19, #48]
    40010424:	b4000100 	cbz	x0, 40010444 <z_timer_expiration_handler+0x68>
MAKE_REG_HELPER(daif)
    40010428:	92407e94 	and	x20, x20, #0xffffffff
    4001042c:	d51b4234 	msr	daif, x20
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
    40010430:	f9401a61 	ldr	x1, [x19, #48]
    40010434:	aa1303e0 	mov	x0, x19
    40010438:	d63f0020 	blr	x1
    4001043c:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010440:	d50342df 	msr	daifset, #0x2
	return list->head == list;
    40010444:	f8420e75 	ldr	x21, [x19, #32]!
    40010448:	2a1403f4 	mov	w20, w20
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4001044c:	eb1302bf 	cmp	x21, x19
    40010450:	54000040 	b.eq	40010458 <z_timer_expiration_handler+0x7c>  // b.none
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
    40010454:	b50000d5 	cbnz	x21, 4001046c <z_timer_expiration_handler+0x90>
MAKE_REG_HELPER(daif)
    40010458:	d51b4234 	msr	daif, x20
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
    4001045c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010460:	f94013f5 	ldr	x21, [sp, #32]
    40010464:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40010468:	d65f03c0 	ret
	z_unpend_thread_no_timeout(thread);
    4001046c:	aa1503e0 	mov	x0, x21
    40010470:	97fffbf5 	bl	4000f444 <z_unpend_thread_no_timeout>
    40010474:	b9013abf 	str	wzr, [x21, #312]
    40010478:	d51b4234 	msr	daif, x20
	z_ready_thread(thread);
    4001047c:	aa1503e0 	mov	x0, x21
}
    40010480:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010484:	f94013f5 	ldr	x21, [sp, #32]
    40010488:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_ready_thread(thread);
    4001048c:	17fffcd1 	b	4000f7d0 <z_ready_thread>

0000000040010490 <k_timer_init>:
	node->prev = NULL;
    40010490:	a9007c1f 	stp	xzr, xzr, [x0]
void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
	timer->stop_fn = stop_fn;
    40010494:	a9030801 	stp	x1, x2, [x0, #48]
	sys_dlist_init(&w->waitq);
    40010498:	91008001 	add	x1, x0, #0x20
	list->tail = (sys_dnode_t *)list;
    4001049c:	a9020401 	stp	x1, x1, [x0, #32]
	timer->status = 0U;
    400104a0:	b900481f 	str	wzr, [x0, #72]

	z_init_timeout(&timer->timeout);

	SYS_PORT_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
    400104a4:	f900281f 	str	xzr, [x0, #80]

	z_object_init(timer);
}
    400104a8:	d65f03c0 	ret

00000000400104ac <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
    400104ac:	b100043f 	cmn	x1, #0x1
    400104b0:	54000440 	b.eq	40010538 <z_impl_k_timer_start+0x8c>  // b.none
{
    400104b4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    400104b8:	b100045f 	cmn	x2, #0x1
{
    400104bc:	910003fd 	mov	x29, sp
    400104c0:	a90153f3 	stp	x19, x20, [sp, #16]
    400104c4:	aa0003f4 	mov	x20, x0
    400104c8:	aa0203f3 	mov	x19, x2
    400104cc:	f90013f5 	str	x21, [sp, #32]
    400104d0:	aa0103f5 	mov	x21, x1
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    400104d4:	54000100 	b.eq	400104f4 <z_impl_k_timer_start+0x48>  // b.none
    400104d8:	b40000e2 	cbz	x2, 400104f4 <z_impl_k_timer_start+0x48>
    400104dc:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    400104e0:	eb02001f 	cmp	x0, x2
    400104e4:	54000085 	b.pl	400104f4 <z_impl_k_timer_start+0x48>  // b.nfrst
	    Z_TICK_ABS(period.ticks) < 0) {
		period.ticks = MAX(period.ticks - 1, 1);
    400104e8:	d1000453 	sub	x19, x2, #0x1
    400104ec:	f100027f 	cmp	x19, #0x0
    400104f0:	9a9fc673 	csinc	x19, x19, xzr, gt
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
    400104f4:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
    400104f8:	eb01001f 	cmp	x0, x1
    400104fc:	54000065 	b.pl	40010508 <z_impl_k_timer_start+0x5c>  // b.nfrst
		duration.ticks = MAX(duration.ticks - 1, 0);
    40010500:	f1000435 	subs	x21, x1, #0x1
    40010504:	9a9f52b5 	csel	x21, x21, xzr, pl  // pl = nfrst
	}

	(void)z_abort_timeout(&timer->timeout);
    40010508:	aa1403e0 	mov	x0, x20
    4001050c:	97ffff41 	bl	40010210 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    40010510:	aa1503e2 	mov	x2, x21
    40010514:	aa1403e0 	mov	x0, x20
		     duration);
}
    40010518:	f94013f5 	ldr	x21, [sp, #32]
	timer->period = period;
    4001051c:	f9002293 	str	x19, [x20, #64]
	timer->status = 0U;
    40010520:	b9004a9f 	str	wzr, [x20, #72]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    40010524:	90000001 	adrp	x1, 40010000 <z_sched_wait+0xc>
    40010528:	910f7021 	add	x1, x1, #0x3dc
}
    4001052c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010530:	a8c37bfd 	ldp	x29, x30, [sp], #48
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    40010534:	17fffef0 	b	400100f4 <z_add_timeout>
    40010538:	d65f03c0 	ret

000000004001053c <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
    4001053c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40010540:	910003fd 	mov	x29, sp
    40010544:	f9000bf3 	str	x19, [sp, #16]
    40010548:	aa0003f3 	mov	x19, x0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
    4001054c:	97ffff31 	bl	40010210 <z_abort_timeout>

	if (inactive) {
    40010550:	350001c0 	cbnz	w0, 40010588 <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
    40010554:	f9401e61 	ldr	x1, [x19, #56]
    40010558:	b4000061 	cbz	x1, 40010564 <z_impl_k_timer_stop+0x28>
		timer->stop_fn(timer);
    4001055c:	aa1303e0 	mov	x0, x19
    40010560:	d63f0020 	blr	x1
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
    40010564:	91008260 	add	x0, x19, #0x20
    40010568:	97fffda7 	bl	4000fc04 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
    4001056c:	b40000e0 	cbz	x0, 40010588 <z_impl_k_timer_stop+0x4c>
			z_ready_thread(pending_thread);
    40010570:	97fffc98 	bl	4000f7d0 <z_ready_thread>
    40010574:	d53b4220 	mrs	x0, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010578:	d50342df 	msr	daifset, #0x2
			z_reschedule_unlocked();
		}
	}
}
    4001057c:	f9400bf3 	ldr	x19, [sp, #16]
    40010580:	a8c27bfd 	ldp	x29, x30, [sp], #32
	(void) z_reschedule_irqlock(arch_irq_lock());
    40010584:	17fffbd3 	b	4000f4d0 <z_reschedule_irqlock>
    40010588:	f9400bf3 	ldr	x19, [sp, #16]
    4001058c:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40010590:	d65f03c0 	ret

0000000040010594 <virt_region_free>:

	virt_region_inited = true;
}

static void virt_region_free(void *vaddr, size_t size)
{
    40010594:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40010598:	910003fd 	mov	x29, sp
    4001059c:	a90153f3 	stp	x19, x20, [sp, #16]
    400105a0:	aa0003f4 	mov	x20, x0
    400105a4:	aa0103f3 	mov	x19, x1
    400105a8:	a9025bf5 	stp	x21, x22, [sp, #32]
	size_t offset, num_bits;
	uint8_t *vaddr_u8 = (uint8_t *)vaddr;

	if (unlikely(!virt_region_inited)) {
    400105ac:	b0000096 	adrp	x22, 40021000 <k_sys_work_q+0x240>
    400105b0:	39636ac0 	ldrb	w0, [x22, #2266]
    400105b4:	90000315 	adrp	x21, 40070000 <_end>
    400105b8:	910002b5 	add	x21, x21, #0x0
    400105bc:	35000180 	cbnz	w0, 400105ec <virt_region_free+0x58>
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    400105c0:	b26287e1 	mov	x1, #0xffffffffc0000000    	// #-1073741824
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    400105c4:	d2a81002 	mov	x2, #0x40800000            	// #1082130432
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    400105c8:	8b0102a1 	add	x1, x21, x1
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    400105cc:	cb150042 	sub	x2, x2, x21
	(void)sys_bitarray_set_region(&virt_region_bitmap,
    400105d0:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    400105d4:	91266000 	add	x0, x0, #0x998
    400105d8:	d34cfc42 	lsr	x2, x2, #12
    400105dc:	d34cfc21 	lsr	x1, x1, #12
    400105e0:	97ffc514 	bl	40001a30 <sys_bitarray_set_region>
	virt_region_inited = true;
    400105e4:	52800020 	mov	w0, #0x1                   	// #1
    400105e8:	39236ac0 	strb	w0, [x22, #2266]
	}

	__ASSERT((vaddr_u8 >= Z_VIRT_REGION_START_ADDR)
		 && ((vaddr_u8 + size) < Z_VIRT_REGION_END_ADDR),
		 "invalid virtual address region %p (%zu)", vaddr_u8, size);
	if (!((vaddr_u8 >= Z_VIRT_REGION_START_ADDR)
    400105ec:	eb15029f 	cmp	x20, x21
    400105f0:	54000203 	b.cc	40010630 <virt_region_free+0x9c>  // b.lo, b.ul, b.last
	      && ((vaddr_u8 + size) < Z_VIRT_REGION_END_ADDR))) {
    400105f4:	8b130281 	add	x1, x20, x19
	if (!((vaddr_u8 >= Z_VIRT_REGION_START_ADDR)
    400105f8:	12b7f000 	mov	w0, #0x407fffff            	// #1082130431
    400105fc:	eb00003f 	cmp	x1, x0
    40010600:	54000188 	b.hi	40010630 <virt_region_free+0x9c>  // b.pmore
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    40010604:	d2a81002 	mov	x2, #0x40800000            	// #1082130432
    40010608:	cb130042 	sub	x2, x2, x19
    4001060c:	cb140042 	sub	x2, x2, x20
		return;
	}

	offset = virt_to_bitmap_offset(vaddr, size);
	num_bits = size / CONFIG_MMU_PAGE_SIZE;
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    40010610:	d34cfe61 	lsr	x1, x19, #12
}
    40010614:	a94153f3 	ldp	x19, x20, [sp, #16]
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    40010618:	d34cfc42 	lsr	x2, x2, #12
}
    4001061c:	a9425bf5 	ldp	x21, x22, [sp, #32]
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    40010620:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    40010624:	91266000 	add	x0, x0, #0x998
}
    40010628:	a8c37bfd 	ldp	x29, x30, [sp], #48
	(void)sys_bitarray_free(&virt_region_bitmap, num_bits, offset);
    4001062c:	17ffc4d7 	b	40001988 <sys_bitarray_free>
}
    40010630:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010634:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010638:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4001063c:	d65f03c0 	ret

0000000040010640 <free_page_frame_list_put>:
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
    40010640:	b0000083 	adrp	x3, 40021000 <k_sys_work_q+0x240>
    40010644:	911d8061 	add	x1, x3, #0x760
    40010648:	f9400422 	ldr	x2, [x1, #8]
	parent->next = child;
    4001064c:	f900001f 	str	xzr, [x0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    40010650:	b5000102 	cbnz	x2, 40010670 <free_page_frame_list_put+0x30>
	list->head = node;
    40010654:	f903b060 	str	x0, [x3, #1888]
	list->tail = node;
    40010658:	f9000420 	str	x0, [x1, #8]
static void free_page_frame_list_put(struct z_page_frame *pf)
{
	PF_ASSERT(pf, z_page_frame_is_available(pf),
		 "unavailable page put on free list");
	sys_slist_append(&free_page_frame_list, &pf->node);
	z_free_page_count++;
    4001065c:	b0000081 	adrp	x1, 40021000 <k_sys_work_q+0x240>
    40010660:	f943b820 	ldr	x0, [x1, #1904]
    40010664:	91000400 	add	x0, x0, #0x1
    40010668:	f903b820 	str	x0, [x1, #1904]
}
    4001066c:	d65f03c0 	ret
	parent->next = child;
    40010670:	f9000040 	str	x0, [x2]
	list->tail = node;
    40010674:	f9000420 	str	x0, [x1, #8]
}
    40010678:	17fffff9 	b	4001065c <free_page_frame_list_put+0x1c>

000000004001067c <virt_region_alloc>:
{
    4001067c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40010680:	910003fd 	mov	x29, sp
    40010684:	a90153f3 	stp	x19, x20, [sp, #16]
    40010688:	a9025bf5 	stp	x21, x22, [sp, #32]
    4001068c:	aa0003f5 	mov	x21, x0
	if (unlikely(!virt_region_inited)) {
    40010690:	b0000093 	adrp	x19, 40021000 <k_sys_work_q+0x240>
    40010694:	39636a60 	ldrb	w0, [x19, #2266]
{
    40010698:	aa0103f6 	mov	x22, x1
    4001069c:	a90363f7 	stp	x23, x24, [sp, #48]
    400106a0:	f00002f7 	adrp	x23, 4006f000 <sys_work_q_stack+0xf20>
    400106a4:	912662f7 	add	x23, x23, #0x998
	if (unlikely(!virt_region_inited)) {
    400106a8:	350001a0 	cbnz	w0, 400106dc <virt_region_alloc+0x60>
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    400106ac:	90000302 	adrp	x2, 40070000 <_end>
    400106b0:	91000042 	add	x2, x2, #0x0
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    400106b4:	d2a81000 	mov	x0, #0x40800000            	// #1082130432
	num_bits = POINTER_TO_UINT(Z_FREE_VM_START)
    400106b8:	b26287e1 	mov	x1, #0xffffffffc0000000    	// #-1073741824
    400106bc:	8b010041 	add	x1, x2, x1
		- POINTER_TO_UINT(vaddr) - size) / CONFIG_MMU_PAGE_SIZE;
    400106c0:	cb020002 	sub	x2, x0, x2
	(void)sys_bitarray_set_region(&virt_region_bitmap,
    400106c4:	aa1703e0 	mov	x0, x23
    400106c8:	d34cfc42 	lsr	x2, x2, #12
    400106cc:	d34cfc21 	lsr	x1, x1, #12
    400106d0:	97ffc4d8 	bl	40001a30 <sys_bitarray_set_region>
	virt_region_inited = true;
    400106d4:	52800020 	mov	w0, #0x1                   	// #1
    400106d8:	39236a60 	strb	w0, [x19, #2266]
	num_bits = (size + align - CONFIG_MMU_PAGE_SIZE) / CONFIG_MMU_PAGE_SIZE;
    400106dc:	d14006c1 	sub	x1, x22, #0x1, lsl #12
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
    400106e0:	910123e2 	add	x2, sp, #0x48
	num_bits = (size + align - CONFIG_MMU_PAGE_SIZE) / CONFIG_MMU_PAGE_SIZE;
    400106e4:	8b150021 	add	x1, x1, x21
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
    400106e8:	aa1703e0 	mov	x0, x23
	alloc_size = num_bits * CONFIG_MMU_PAGE_SIZE;
    400106ec:	9274cc38 	and	x24, x1, #0xfffffffffffff000
	ret = sys_bitarray_alloc(&virt_region_bitmap, num_bits, &offset);
    400106f0:	d34cfc21 	lsr	x1, x1, #12
    400106f4:	97ffc460 	bl	40001874 <sys_bitarray_alloc>
	if (ret != 0) {
    400106f8:	340002c0 	cbz	w0, 40010750 <virt_region_alloc+0xd4>
		LOG_ERR("insufficient virtual address space (requested %zu)",
    400106fc:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    40010700:	91293002 	add	x2, x0, #0xa4c
    40010704:	b94a4c00 	ldr	w0, [x0, #2636]
    40010708:	f240081f 	tst	x0, #0x7
    4001070c:	54000160 	b.eq	40010738 <virt_region_alloc+0xbc>  // b.none
    40010710:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    40010714:	91290000 	add	x0, x0, #0xa40
    40010718:	cb000042 	sub	x2, x2, x0
    4001071c:	aa1503e1 	mov	x1, x21
    40010720:	d0000020 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    40010724:	91035400 	add	x0, x0, #0xd5
    40010728:	d342fc42 	lsr	x2, x2, #2
    4001072c:	531a2442 	ubfiz	w2, w2, #6, #10
    40010730:	32000042 	orr	w2, w2, #0x1
    40010734:	97ffcd4a 	bl	40003c5c <log_1>
		return NULL;
    40010738:	d2800000 	mov	x0, #0x0                   	// #0
}
    4001073c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010740:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010744:	a94363f7 	ldp	x23, x24, [sp, #48]
    40010748:	a8c57bfd 	ldp	x29, x30, [sp], #80
    4001074c:	d65f03c0 	ret
	       - (offset * CONFIG_MMU_PAGE_SIZE) - size;
    40010750:	f94027e0 	ldr	x0, [sp, #72]
    40010754:	d2810014 	mov	x20, #0x800                 	// #2048
    40010758:	f2a00094 	movk	x20, #0x4, lsl #16
	if (alloc_size > size) {
    4001075c:	eb15031f 	cmp	x24, x21
	       - (offset * CONFIG_MMU_PAGE_SIZE) - size;
    40010760:	cb000294 	sub	x20, x20, x0
    40010764:	d374ce94 	lsl	x20, x20, #12
    40010768:	cb180280 	sub	x0, x20, x24
	if (alloc_size > size) {
    4001076c:	540002e9 	b.ls	400107c8 <virt_region_alloc+0x14c>  // b.plast
		uintptr_t aligned_dest_addr = ROUND_UP(dest_addr, align);
    40010770:	d10006d3 	sub	x19, x22, #0x1
    40010774:	cb1603f6 	neg	x22, x22
    40010778:	8b000273 	add	x19, x19, x0
		virt_region_free(UINT_TO_POINTER(dest_addr),
    4001077c:	cb140301 	sub	x1, x24, x20
		uintptr_t aligned_dest_addr = ROUND_UP(dest_addr, align);
    40010780:	8a160273 	and	x19, x19, x22
		virt_region_free(UINT_TO_POINTER(dest_addr),
    40010784:	8b130021 	add	x1, x1, x19
    40010788:	97ffff83 	bl	40010594 <virt_region_free>
		if (((dest_addr + alloc_size) - (aligned_dest_addr + size)) > 0) {
    4001078c:	8b150260 	add	x0, x19, x21
    40010790:	eb00029f 	cmp	x20, x0
    40010794:	54000060 	b.eq	400107a0 <virt_region_alloc+0x124>  // b.none
			virt_region_free(UINT_TO_POINTER(aligned_dest_addr + size),
    40010798:	cb000281 	sub	x1, x20, x0
    4001079c:	97ffff7e 	bl	40010594 <virt_region_free>
	if (dest_addr < POINTER_TO_UINT(Z_VIRT_REGION_START_ADDR)) {
    400107a0:	90000301 	adrp	x1, 40070000 <_end>
    400107a4:	91000021 	add	x1, x1, #0x0
	return UINT_TO_POINTER(dest_addr);
    400107a8:	aa1303e0 	mov	x0, x19
	if (dest_addr < POINTER_TO_UINT(Z_VIRT_REGION_START_ADDR)) {
    400107ac:	eb01027f 	cmp	x19, x1
    400107b0:	54fffc62 	b.cs	4001073c <virt_region_alloc+0xc0>  // b.hs, b.nlast
		(void)sys_bitarray_free(&virt_region_bitmap, size, offset);
    400107b4:	f94027e2 	ldr	x2, [sp, #72]
    400107b8:	aa1503e1 	mov	x1, x21
    400107bc:	aa1703e0 	mov	x0, x23
    400107c0:	97ffc472 	bl	40001988 <sys_bitarray_free>
		return NULL;
    400107c4:	17ffffdd 	b	40010738 <virt_region_alloc+0xbc>
	dest_addr = virt_from_bitmap_offset(offset, alloc_size);
    400107c8:	aa0003f3 	mov	x19, x0
    400107cc:	17fffff5 	b	400107a0 <virt_region_alloc+0x124>

00000000400107d0 <z_phys_map>:
/* This may be called from arch early boot code before z_cstart() is invoked.
 * Data will be copied and BSS zeroed, but this must not rely on any
 * initialization functions being called prior to work correctly.
 */
void z_phys_map(uint8_t **virt_ptr, uintptr_t phys, size_t size, uint32_t flags)
{
    400107d0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    400107d4:	910003fd 	mov	x29, sp
    400107d8:	a9046bf9 	stp	x25, x26, [sp, #64]

	/* The actual mapped region must be page-aligned. Round down the
	 * physical address and pad the region size appropriately
	 */
	*aligned_addr = ROUND_DOWN(addr, align);
	addr_offset = addr - *aligned_addr;
    400107dc:	92402c39 	and	x25, x1, #0xfff
{
    400107e0:	a90153f3 	stp	x19, x20, [sp, #16]
	*aligned_size = ROUND_UP(size + addr_offset, align);
    400107e4:	8b020333 	add	x19, x25, x2
    400107e8:	913ffe73 	add	x19, x19, #0xfff
    400107ec:	9274ce73 	and	x19, x19, #0xfffffffffffff000
{
    400107f0:	a9025bf5 	stp	x21, x22, [sp, #32]
    400107f4:	aa0103f5 	mov	x21, x1
    400107f8:	f9002bfb 	str	x27, [sp, #80]
	*aligned_addr = ROUND_DOWN(addr, align);
    400107fc:	9274cc3b 	and	x27, x1, #0xfffffffffffff000
	align_boundary = arch_virt_region_align(aligned_phys, aligned_size);
    40010800:	aa1303e1 	mov	x1, x19
{
    40010804:	aa0203f6 	mov	x22, x2
    40010808:	a90363f7 	stp	x23, x24, [sp, #48]
    4001080c:	aa0003f7 	mov	x23, x0
    40010810:	2a0303f8 	mov	w24, w3
	align_boundary = arch_virt_region_align(aligned_phys, aligned_size);
    40010814:	aa1b03e0 	mov	x0, x27
    40010818:	97ffeb8c 	bl	4000b648 <arch_virt_region_align>
    4001081c:	aa0003e1 	mov	x1, x0
MAKE_REG_HELPER(daif)
    40010820:	d53b423a 	mrs	x26, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010824:	d50342df 	msr	daifset, #0x2
	dest_addr = virt_region_alloc(aligned_size, align_boundary);
    40010828:	aa1303e0 	mov	x0, x19
    4001082c:	97ffff94 	bl	4001067c <virt_region_alloc>
	if (!dest_addr) {
    40010830:	b50002a0 	cbnz	x0, 40010884 <z_phys_map+0xb4>
	LOG_ERR("memory mapping 0x%lx (size %zu, flags 0x%x) failed",
    40010834:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    40010838:	91293004 	add	x4, x0, #0xa4c
    4001083c:	b94a4c00 	ldr	w0, [x0, #2636]
    40010840:	f240081f 	tst	x0, #0x7
    40010844:	540001a0 	b.eq	40010878 <z_phys_map+0xa8>  // b.none
    40010848:	f00002e0 	adrp	x0, 4006f000 <sys_work_q_stack+0xf20>
    4001084c:	91290000 	add	x0, x0, #0xa40
    40010850:	cb000084 	sub	x4, x4, x0
    40010854:	2a1803e3 	mov	w3, w24
    40010858:	d0000020 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    4001085c:	91042000 	add	x0, x0, #0x108
    40010860:	d342fc84 	lsr	x4, x4, #2
    40010864:	aa1603e2 	mov	x2, x22
    40010868:	aa1503e1 	mov	x1, x21
    4001086c:	531a2484 	ubfiz	w4, w4, #6, #10
    40010870:	32000084 	orr	w4, w4, #0x1
    40010874:	97ffcd2a 	bl	40003d1c <log_3>
	k_panic();
    40010878:	d2800088 	mov	x8, #0x4                   	// #4
    4001087c:	d4000041 	svc	#0x2
    40010880:	1400000a 	b	400108a8 <z_phys_map+0xd8>
    40010884:	aa0003f4 	mov	x20, x0
	arch_mem_map(dest_addr, aligned_phys, aligned_size, flags);
    40010888:	2a1803e3 	mov	w3, w24
    4001088c:	aa1303e2 	mov	x2, x19
    40010890:	aa1b03e1 	mov	x1, x27
MAKE_REG_HELPER(daif)
    40010894:	92407f5a 	and	x26, x26, #0xffffffff
    40010898:	97ffeb3b 	bl	4000b584 <arch_mem_map>
    4001089c:	d51b423a 	msr	daif, x26
	*virt_ptr = dest_addr + addr_offset;
    400108a0:	8b190294 	add	x20, x20, x25
    400108a4:	f90002f4 	str	x20, [x23]
}
    400108a8:	a94153f3 	ldp	x19, x20, [sp, #16]
    400108ac:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400108b0:	a94363f7 	ldp	x23, x24, [sp, #48]
    400108b4:	a9446bf9 	ldp	x25, x26, [sp, #64]
    400108b8:	f9402bfb 	ldr	x27, [sp, #80]
    400108bc:	a8c67bfd 	ldp	x29, x30, [sp], #96
    400108c0:	d65f03c0 	ret

00000000400108c4 <z_mem_manage_init>:
    400108c4:	d53b4225 	mrs	x5, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400108c8:	d50342df 	msr	daifset, #0x2
	list->head = NULL;
    400108cc:	b0000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    400108d0:	911d8001 	add	x1, x0, #0x760

#ifdef CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT
	/* All pages composing the Zephyr image are mapped at boot in a
	 * predictable way. This can change at runtime.
	 */
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    400108d4:	90000302 	adrp	x2, 40070000 <_end>
    400108d8:	91000042 	add	x2, x2, #0x0
    400108dc:	f903b01f 	str	xzr, [x0, #1888]
	list->tail = NULL;
    400108e0:	b0000084 	adrp	x4, 40021000 <k_sys_work_q+0x240>
    400108e4:	91236c84 	add	x4, x4, #0x8db
    400108e8:	90ffff80 	adrp	x0, 40000000 <__text_region_start>
    400108ec:	91000000 	add	x0, x0, #0x0
static inline struct z_page_frame *z_phys_to_page_frame(uintptr_t phys)
{
	__ASSERT(z_is_page_frame(phys),
		 "0x%lx not an SRAM physical address", phys);

	return &z_page_frames[(phys - Z_PHYS_RAM_START) /
    400108f0:	b26287e7 	mov	x7, #0xffffffffc0000000    	// #-1073741824
		 * code/data pages which are pinned in memory and
		 * may not be evicted. This will contain critical CPU data
		 * structures, and any code used to perform page fault
		 * handling, page-ins, etc.
		 */
		pf->flags |= Z_PAGE_FRAME_PINNED;
    400108f4:	528000a8 	mov	w8, #0x5                   	// #5
    400108f8:	f900043f 	str	xzr, [x1, #8]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    400108fc:	eb02001f 	cmp	x0, x2
    40010900:	54000183 	b.cc	40010930 <z_mem_manage_init+0x6c>  // b.lo, b.ul, b.last
#endif

	/* Any remaining pages that aren't mapped, reserved, or pinned get
	 * added to the free pages list
	 */
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    40010904:	d2a80006 	mov	x6, #0x40000000            	// #1073741824
    40010908:	d2a90007 	mov	x7, #0x48000000            	// #1207959552
		if (z_page_frame_is_available(pf)) {
    4001090c:	39402080 	ldrb	w0, [x4, #8]
    40010910:	340003c0 	cbz	w0, 40010988 <z_mem_manage_init+0xc4>
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    40010914:	914004c6 	add	x6, x6, #0x1, lsl #12
    40010918:	91002484 	add	x4, x4, #0x9
    4001091c:	eb0700df 	cmp	x6, x7
    40010920:	54ffff61 	b.ne	4001090c <z_mem_manage_init+0x48>  // b.any
MAKE_REG_HELPER(daif)
    40010924:	92407ca5 	and	x5, x5, #0xffffffff
    40010928:	d51b4225 	msr	daif, x5
    4001092c:	d65f03c0 	ret
    40010930:	8b070001 	add	x1, x0, x7
    40010934:	d34cfc21 	lsr	x1, x1, #12
	pf->flags |= Z_PAGE_FRAME_MAPPED;
    40010938:	8b010c21 	add	x1, x1, x1, lsl #3
    4001093c:	8b010086 	add	x6, x4, x1
	pf->addr = addr;
    40010940:	f8216880 	str	x0, [x4, x1]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    40010944:	91400400 	add	x0, x0, #0x1, lsl #12
	pf->flags |= Z_PAGE_FRAME_MAPPED;
    40010948:	394020c3 	ldrb	w3, [x6, #8]
		pf->flags |= Z_PAGE_FRAME_PINNED;
    4001094c:	2a080061 	orr	w1, w3, w8
    40010950:	390020c1 	strb	w1, [x6, #8]
	VIRT_FOREACH(Z_KERNEL_VIRT_START, Z_KERNEL_VIRT_SIZE, addr)
    40010954:	17ffffea 	b	400108fc <z_mem_manage_init+0x38>
		if (z_page_frame_is_available(pf)) {
    40010958:	39402080 	ldrb	w0, [x4, #8]
    4001095c:	35000060 	cbnz	w0, 40010968 <z_mem_manage_init+0xa4>
			free_page_frame_list_put(pf);
    40010960:	aa0403e0 	mov	x0, x4
    40010964:	97ffff37 	bl	40010640 <free_page_frame_list_put>
	Z_PAGE_FRAME_FOREACH(phys, pf) {
    40010968:	914004c6 	add	x6, x6, #0x1, lsl #12
    4001096c:	91002484 	add	x4, x4, #0x9
    40010970:	eb0700df 	cmp	x6, x7
    40010974:	54ffff21 	b.ne	40010958 <z_mem_manage_init+0x94>  // b.any
    40010978:	92407ca5 	and	x5, x5, #0xffffffff
    4001097c:	d51b4225 	msr	daif, x5
	 * and the BSS pages can be brought into physical
	 * memory to be cleared.
	 */
	z_bss_zero();
#endif
}
    40010980:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40010984:	d65f03c0 	ret
{
    40010988:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    4001098c:	910003fd 	mov	x29, sp
    40010990:	17fffff4 	b	40010960 <z_mem_manage_init+0x9c>

0000000040010994 <z_mem_manage_boot_finish>:
	/* At the end of boot process, unpin the boot sections
	 * as they don't need to be in memory all the time anymore.
	 */
	mark_linker_section_pinned(lnkr_boot_start, lnkr_boot_end, false);
#endif
}
    40010994:	d65f03c0 	ret

0000000040010998 <add_event>:
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
}

static inline void add_event(sys_dlist_t *events, struct k_poll_event *event,
			     struct z_poller *poller)
{
    40010998:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    4001099c:	910003fd 	mov	x29, sp
    400109a0:	a90153f3 	stp	x19, x20, [sp, #16]
    400109a4:	aa0003f3 	mov	x19, x0
    400109a8:	aa0103f4 	mov	x20, x1
    400109ac:	a9025bf5 	stp	x21, x22, [sp, #32]
	return sys_dlist_is_empty(list) ? NULL : list->tail;
    400109b0:	f9400261 	ldr	x1, [x19]
    400109b4:	f9400400 	ldr	x0, [x0, #8]
    400109b8:	eb01027f 	cmp	x19, x1
    400109bc:	54000121 	b.ne	400109e0 <add_event+0x48>  // b.any
	sys_dnode_t *const tail = list->tail;
    400109c0:	f9400660 	ldr	x0, [x19, #8]
	node->prev = tail;
    400109c4:	a9000293 	stp	x19, x0, [x20]
	tail->next = node;
    400109c8:	f9000014 	str	x20, [x0]
	list->tail = node;
    400109cc:	f9000674 	str	x20, [x19, #8]
			return;
		}
	}

	sys_dlist_append(events, &event->_node);
}
    400109d0:	a94153f3 	ldp	x19, x20, [sp, #16]
    400109d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    400109d8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400109dc:	d65f03c0 	ret
	if ((pending == NULL) ||
    400109e0:	b4ffff00 	cbz	x0, 400109c0 <add_event+0x28>
		(z_sched_prio_cmp(poller_thread(pending->poller),
    400109e4:	f9400800 	ldr	x0, [x0, #16]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
    400109e8:	aa0203f6 	mov	x22, x2
    400109ec:	b4000040 	cbz	x0, 400109f4 <add_event+0x5c>
    400109f0:	d1032000 	sub	x0, x0, #0xc8
    400109f4:	b4000056 	cbz	x22, 400109fc <add_event+0x64>
    400109f8:	d10322d6 	sub	x22, x22, #0xc8
		(z_sched_prio_cmp(poller_thread(pending->poller),
    400109fc:	aa1603e1 	mov	x1, x22
    40010a00:	97fffa1c 	bl	4000f270 <z_sched_prio_cmp>
	if ((pending == NULL) ||
    40010a04:	7100001f 	cmp	w0, #0x0
    40010a08:	54fffdcc 	b.gt	400109c0 <add_event+0x28>
	return list->head == list;
    40010a0c:	f9400275 	ldr	x21, [x19]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    40010a10:	eb15027f 	cmp	x19, x21
    40010a14:	54fffd60 	b.eq	400109c0 <add_event+0x28>  // b.none
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
    40010a18:	b4fffd55 	cbz	x21, 400109c0 <add_event+0x28>
		if (z_sched_prio_cmp(poller_thread(poller),
    40010a1c:	f9400aa1 	ldr	x1, [x21, #16]
	return p ? CONTAINER_OF(p, struct k_thread, poller) : NULL;
    40010a20:	b4000041 	cbz	x1, 40010a28 <add_event+0x90>
    40010a24:	d1032021 	sub	x1, x1, #0xc8
		if (z_sched_prio_cmp(poller_thread(poller),
    40010a28:	aa1603e0 	mov	x0, x22
    40010a2c:	97fffa11 	bl	4000f270 <z_sched_prio_cmp>
    40010a30:	7100001f 	cmp	w0, #0x0
    40010a34:	540000cd 	b.le	40010a4c <add_event+0xb4>
	sys_dnode_t *const prev = successor->prev;
    40010a38:	f94006a0 	ldr	x0, [x21, #8]
	node->prev = prev;
    40010a3c:	a9000295 	stp	x21, x0, [x20]
	prev->next = node;
    40010a40:	f9000014 	str	x20, [x0]
	successor->prev = node;
    40010a44:	f90006b4 	str	x20, [x21, #8]
			return;
    40010a48:	17ffffe2 	b	400109d0 <add_event+0x38>
	return (node == list->tail) ? NULL : node->next;
    40010a4c:	f9400660 	ldr	x0, [x19, #8]
    40010a50:	eb15001f 	cmp	x0, x21
    40010a54:	54fffb60 	b.eq	400109c0 <add_event+0x28>  // b.none
    40010a58:	f94002b5 	ldr	x21, [x21]
    40010a5c:	17ffffef 	b	40010a18 <add_event+0x80>

0000000040010a60 <register_events>:

static inline int register_events(struct k_poll_event *events,
				  int num_events,
				  struct z_poller *poller,
				  bool just_check)
{
    40010a60:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40010a64:	910003fd 	mov	x29, sp
    40010a68:	a90153f3 	stp	x19, x20, [sp, #16]
    40010a6c:	aa0203f4 	mov	x20, x2
    40010a70:	aa0003f3 	mov	x19, x0
    40010a74:	a9025bf5 	stp	x21, x22, [sp, #32]
    40010a78:	2a0103f6 	mov	w22, w1
	int events_registered = 0;
    40010a7c:	52800015 	mov	w21, #0x0                   	// #0
{
    40010a80:	a90363f7 	stp	x23, x24, [sp, #48]
	switch (event->type) {
    40010a84:	90000038 	adrp	x24, 40014000 <CSWTCH.135+0x90>
    40010a88:	91052318 	add	x24, x24, #0x148
{
    40010a8c:	a9046bf9 	stp	x25, x26, [sp, #64]
	switch (event->type) {
    40010a90:	90000039 	adrp	x25, 40014000 <CSWTCH.135+0x90>
    40010a94:	91050339 	add	x25, x25, #0x140
{
    40010a98:	f9002bfb 	str	x27, [sp, #80]
    40010a9c:	12001c7b 	and	w27, w3, #0xff

	for (int ii = 0; ii < num_events; ii++) {
    40010aa0:	52800017 	mov	w23, #0x0                   	// #0
    40010aa4:	6b1602ff 	cmp	w23, w22
    40010aa8:	5400012b 	b.lt	40010acc <register_events+0x6c>  // b.tstop
		}
		k_spin_unlock(&lock, key);
	}

	return events_registered;
}
    40010aac:	2a1503e0 	mov	w0, w21
    40010ab0:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010ab4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010ab8:	a94363f7 	ldp	x23, x24, [sp, #48]
    40010abc:	a9446bf9 	ldp	x25, x26, [sp, #64]
    40010ac0:	f9402bfb 	ldr	x27, [sp, #80]
    40010ac4:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40010ac8:	d65f03c0 	ret
    40010acc:	d53b423a 	mrs	x26, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010ad0:	d50342df 	msr	daifset, #0x2
	switch (event->type) {
    40010ad4:	f9400e60 	ldr	x0, [x19, #24]
    40010ad8:	53083000 	ubfx	w0, w0, #8, #5
    40010adc:	51000400 	sub	w0, w0, #0x1
    40010ae0:	71001c1f 	cmp	w0, #0x7
    40010ae4:	540001a8 	b.hi	40010b18 <register_events+0xb8>  // b.pmore
    40010ae8:	38604b20 	ldrb	w0, [x25, w0, uxtw]
    40010aec:	10000061 	adr	x1, 40010af8 <register_events+0x98>
    40010af0:	8b208820 	add	x0, x1, w0, sxtb #2
    40010af4:	d61f0000 	br	x0
		if (k_sem_count_get(event->sem) > 0U) {
    40010af8:	f9401260 	ldr	x0, [x19, #32]
    40010afc:	b9401000 	ldr	w0, [x0, #16]
    40010b00:	340000c0 	cbz	w0, 40010b18 <register_events+0xb8>
			*state = K_POLL_STATE_SEM_AVAILABLE;
    40010b04:	52800040 	mov	w0, #0x2                   	// #2
    40010b08:	14000019 	b	40010b6c <register_events+0x10c>
		if (!k_queue_is_empty(event->queue)) {
    40010b0c:	f9401260 	ldr	x0, [x19, #32]
    40010b10:	f9400000 	ldr	x0, [x0]
    40010b14:	b5000460 	cbnz	x0, 40010ba0 <register_events+0x140>
		} else if (!just_check && poller->is_polling) {
    40010b18:	350003bb 	cbnz	w27, 40010b8c <register_events+0x12c>
    40010b1c:	39400280 	ldrb	w0, [x20]
    40010b20:	34000360 	cbz	w0, 40010b8c <register_events+0x12c>
	switch (event->type) {
    40010b24:	f9400e60 	ldr	x0, [x19, #24]
    40010b28:	53083000 	ubfx	w0, w0, #8, #5
    40010b2c:	51000400 	sub	w0, w0, #0x1
    40010b30:	71001c1f 	cmp	w0, #0x7
    40010b34:	54000448 	b.hi	40010bbc <register_events+0x15c>  // b.pmore
    40010b38:	38604b00 	ldrb	w0, [x24, w0, uxtw]
    40010b3c:	10000061 	adr	x1, 40010b48 <register_events+0xe8>
    40010b40:	8b208820 	add	x0, x1, w0, sxtb #2
    40010b44:	d61f0000 	br	x0
		if (event->signal->signaled != 0U) {
    40010b48:	f9401260 	ldr	x0, [x19, #32]
    40010b4c:	b9401000 	ldr	w0, [x0, #16]
    40010b50:	34fffe40 	cbz	w0, 40010b18 <register_events+0xb8>
			*state = K_POLL_STATE_SIGNALED;
    40010b54:	52800020 	mov	w0, #0x1                   	// #1
    40010b58:	14000005 	b	40010b6c <register_events+0x10c>
		if (event->msgq->used_msgs > 0) {
    40010b5c:	f9401260 	ldr	x0, [x19, #32]
    40010b60:	b9404000 	ldr	w0, [x0, #64]
    40010b64:	34fffda0 	cbz	w0, 40010b18 <register_events+0xb8>
			*state = K_POLL_STATE_MSGQ_DATA_AVAILABLE;
    40010b68:	52800200 	mov	w0, #0x10                  	// #16
	event->state |= state;
    40010b6c:	f9400e61 	ldr	x1, [x19, #24]
	event->poller = NULL;
    40010b70:	f9000a7f 	str	xzr, [x19, #16]
	event->state |= state;
    40010b74:	d34d4821 	ubfx	x1, x1, #13, #6
    40010b78:	2a010000 	orr	w0, w0, w1
    40010b7c:	b9401a61 	ldr	w1, [x19, #24]
    40010b80:	33131401 	bfi	w1, w0, #13, #6
    40010b84:	b9001a61 	str	w1, [x19, #24]
			poller->is_polling = false;
    40010b88:	3900029f 	strb	wzr, [x20]
MAKE_REG_HELPER(daif)
    40010b8c:	92407f5a 	and	x26, x26, #0xffffffff
    40010b90:	d51b423a 	msr	daif, x26
	for (int ii = 0; ii < num_events; ii++) {
    40010b94:	110006f7 	add	w23, w23, #0x1
    40010b98:	9100a273 	add	x19, x19, #0x28
    40010b9c:	17ffffc2 	b	40010aa4 <register_events+0x44>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
    40010ba0:	52800080 	mov	w0, #0x4                   	// #4
    40010ba4:	17fffff2 	b	40010b6c <register_events+0x10c>
		add_event(&event->sem->poll_events, event, poller);
    40010ba8:	f9401260 	ldr	x0, [x19, #32]
    40010bac:	aa1403e2 	mov	x2, x20
    40010bb0:	aa1303e1 	mov	x1, x19
    40010bb4:	91006000 	add	x0, x0, #0x18
		add_event(&event->msgq->poll_events, event, poller);
    40010bb8:	97ffff78 	bl	40010998 <add_event>
			events_registered += 1;
    40010bbc:	110006b5 	add	w21, w21, #0x1
	event->poller = poller;
    40010bc0:	f9000a74 	str	x20, [x19, #16]
			events_registered += 1;
    40010bc4:	17fffff2 	b	40010b8c <register_events+0x12c>
		add_event(&event->queue->poll_events, event, poller);
    40010bc8:	f9401260 	ldr	x0, [x19, #32]
    40010bcc:	aa1403e2 	mov	x2, x20
    40010bd0:	aa1303e1 	mov	x1, x19
    40010bd4:	91008000 	add	x0, x0, #0x20
    40010bd8:	17fffff8 	b	40010bb8 <register_events+0x158>
		add_event(&event->signal->poll_events, event, poller);
    40010bdc:	aa1403e2 	mov	x2, x20
    40010be0:	aa1303e1 	mov	x1, x19
    40010be4:	f9401260 	ldr	x0, [x19, #32]
    40010be8:	17fffff4 	b	40010bb8 <register_events+0x158>
		add_event(&event->msgq->poll_events, event, poller);
    40010bec:	f9401260 	ldr	x0, [x19, #32]
    40010bf0:	aa1403e2 	mov	x2, x20
    40010bf4:	aa1303e1 	mov	x1, x19
    40010bf8:	91012000 	add	x0, x0, #0x48
    40010bfc:	17ffffef 	b	40010bb8 <register_events+0x158>

0000000040010c00 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, uint32_t state)
{
    40010c00:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40010c04:	910003fd 	mov	x29, sp
    40010c08:	a90153f3 	stp	x19, x20, [sp, #16]
    40010c0c:	aa0003f4 	mov	x20, x0
	struct z_poller *poller = event->poller;
    40010c10:	f9400813 	ldr	x19, [x0, #16]
{
    40010c14:	a9025bf5 	stp	x21, x22, [sp, #32]
    40010c18:	2a0103f5 	mov	w21, w1
    40010c1c:	f9001bf7 	str	x23, [sp, #48]
	int retcode = 0;

	if (poller != NULL) {
    40010c20:	b4000113 	cbz	x19, 40010c40 <signal_poll_event+0x40>
		if (poller->mode == MODE_POLL) {
    40010c24:	39400660 	ldrb	w0, [x19, #1]
    40010c28:	7100041f 	cmp	w0, #0x1
    40010c2c:	540004c1 	b.ne	40010cc4 <signal_poll_event+0xc4>  // b.any
	if (!z_is_thread_pending(thread)) {
    40010c30:	38551260 	ldurb	w0, [x19, #-175]
	return (thread->base.thread_state & _THREAD_PENDING) != 0U;
    40010c34:	d1032276 	sub	x22, x19, #0xc8
    40010c38:	37080160 	tbnz	w0, #1, 40010c64 <signal_poll_event+0x64>
		} else {
			/* Poller is not poll or triggered mode. No action needed.*/
			;
		}

		poller->is_polling = false;
    40010c3c:	3900027f 	strb	wzr, [x19]
	event->state |= state;
    40010c40:	f9400e81 	ldr	x1, [x20, #24]
	event->poller = NULL;
    40010c44:	f9000a9f 	str	xzr, [x20, #16]
	event->state |= state;
    40010c48:	b9401a80 	ldr	w0, [x20, #24]
    40010c4c:	d34d4821 	ubfx	x1, x1, #13, #6
    40010c50:	2a0102b5 	orr	w21, w21, w1
    40010c54:	331316a0 	bfi	w0, w21, #13, #6
    40010c58:	b9001a80 	str	w0, [x20, #24]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
    40010c5c:	52800000 	mov	w0, #0x0                   	// #0
    40010c60:	14000006 	b	40010c78 <signal_poll_event+0x78>
	if (z_is_thread_timeout_expired(thread)) {
    40010c64:	f94022c0 	ldr	x0, [x22, #64]
    40010c68:	b100081f 	cmn	x0, #0x2
    40010c6c:	54000101 	b.ne	40010c8c <signal_poll_event+0x8c>  // b.any
		return -EAGAIN;
    40010c70:	12800140 	mov	w0, #0xfffffff5            	// #-11
		poller->is_polling = false;
    40010c74:	3900027f 	strb	wzr, [x19]
}
    40010c78:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010c7c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010c80:	f9401bf7 	ldr	x23, [sp, #48]
    40010c84:	a8c47bfd 	ldp	x29, x30, [sp], #64
    40010c88:	d65f03c0 	ret
	z_unpend_thread(thread);
    40010c8c:	aa1603e0 	mov	x0, x22
    40010c90:	97fff9f6 	bl	4000f468 <z_unpend_thread>
	arch_thread_return_value_set(thread,
    40010c94:	710022bf 	cmp	w21, #0x8
    40010c98:	12800060 	mov	w0, #0xfffffffc            	// #-4
    40010c9c:	1a9f0000 	csel	w0, w0, wzr, eq  // eq = none
    40010ca0:	b9013ac0 	str	w0, [x22, #312]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    40010ca4:	394066c0 	ldrb	w0, [x22, #25]
    40010ca8:	f240101f 	tst	x0, #0x1f
    40010cac:	54fffc81 	b.ne	40010c3c <signal_poll_event+0x3c>  // b.any
	if (!z_is_thread_ready(thread)) {
    40010cb0:	f8560260 	ldur	x0, [x19, #-160]
    40010cb4:	b5fffc40 	cbnz	x0, 40010c3c <signal_poll_event+0x3c>
	z_ready_thread(thread);
    40010cb8:	aa1603e0 	mov	x0, x22
    40010cbc:	97fffac5 	bl	4000f7d0 <z_ready_thread>
		poller->is_polling = false;
    40010cc0:	17ffffdf 	b	40010c3c <signal_poll_event+0x3c>
		} else if (poller->mode == MODE_TRIGGERED) {
    40010cc4:	7100081f 	cmp	w0, #0x2
    40010cc8:	54fffba1 	b.ne	40010c3c <signal_poll_event+0x3c>  // b.any
{
	struct z_poller *poller = event->poller;
	struct k_work_poll *twork =
		CONTAINER_OF(poller, struct k_work_poll, poller);

	if (poller->is_polling && twork->workq != NULL) {
    40010ccc:	39400260 	ldrb	w0, [x19]
    40010cd0:	34fffb80 	cbz	w0, 40010c40 <signal_poll_event+0x40>
    40010cd4:	f85f8277 	ldur	x23, [x19, #-8]
    40010cd8:	d100a276 	sub	x22, x19, #0x28
    40010cdc:	b4fffb17 	cbz	x23, 40010c3c <signal_poll_event+0x3c>
		struct k_work_q *work_q = twork->workq;

		z_abort_timeout(&twork->timeout);
    40010ce0:	91008260 	add	x0, x19, #0x20
    40010ce4:	97fffd4b 	bl	40010210 <z_abort_timeout>
		twork->poll_result = 0;
    40010ce8:	b900427f 	str	wzr, [x19, #64]
		k_work_submit_to_queue(work_q, &twork->work);
    40010cec:	aa1603e1 	mov	x1, x22
    40010cf0:	aa1703e0 	mov	x0, x23
    40010cf4:	9400017a 	bl	400112dc <k_work_submit_to_queue>
		poller->is_polling = false;
    40010cf8:	17ffffd1 	b	40010c3c <signal_poll_event+0x3c>

0000000040010cfc <clear_event_registrations>:
	while (num_events--) {
    40010cfc:	51000421 	sub	w1, w1, #0x1
		clear_event_registration(&events[num_events]);
    40010d00:	52800507 	mov	w7, #0x28                  	// #40
    40010d04:	d2800028 	mov	x8, #0x1                   	// #1
    40010d08:	d28022c9 	mov	x9, #0x116                 	// #278
	while (num_events--) {
    40010d0c:	3100043f 	cmn	w1, #0x1
    40010d10:	54000041 	b.ne	40010d18 <clear_event_registrations+0x1c>  // b.any
}
    40010d14:	d65f03c0 	ret
		clear_event_registration(&events[num_events]);
    40010d18:	9b277c25 	smull	x5, w1, w7
    40010d1c:	8b050003 	add	x3, x0, x5
	switch (event->type) {
    40010d20:	f9400c64 	ldr	x4, [x3, #24]
	event->poller = NULL;
    40010d24:	f900087f 	str	xzr, [x3, #16]
	switch (event->type) {
    40010d28:	d3483086 	ubfx	x6, x4, #8, #5
    40010d2c:	53083084 	ubfx	w4, w4, #8, #5
    40010d30:	7100209f 	cmp	w4, #0x8
    40010d34:	54000168 	b.hi	40010d60 <clear_event_registrations+0x64>  // b.pmore
    40010d38:	9ac62104 	lsl	x4, x8, x6
    40010d3c:	ea09009f 	tst	x4, x9
    40010d40:	54000100 	b.eq	40010d60 <clear_event_registrations+0x64>  // b.none
	return node->next != NULL;
    40010d44:	f8656804 	ldr	x4, [x0, x5]
	if (remove_event && sys_dnode_is_linked(&event->_node)) {
    40010d48:	b40000c4 	cbz	x4, 40010d60 <clear_event_registrations+0x64>
	sys_dnode_t *const prev = node->prev;
    40010d4c:	f9400466 	ldr	x6, [x3, #8]
	prev->next = next;
    40010d50:	f90000c4 	str	x4, [x6]
	next->prev = prev;
    40010d54:	f9000486 	str	x6, [x4, #8]
	node->next = NULL;
    40010d58:	f825681f 	str	xzr, [x0, x5]
	node->prev = NULL;
    40010d5c:	f900047f 	str	xzr, [x3, #8]
    40010d60:	2a0203e2 	mov	w2, w2
    40010d64:	d51b4222 	msr	daif, x2
    40010d68:	d53b4222 	mrs	x2, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010d6c:	d50342df 	msr	daifset, #0x2
    40010d70:	51000421 	sub	w1, w1, #0x1
    40010d74:	17ffffe6 	b	40010d0c <clear_event_registrations+0x10>

0000000040010d78 <k_poll_event_init>:
	event->type = type;
    40010d78:	53181021 	ubfiz	w1, w1, #8, #5
    40010d7c:	530d0042 	ubfiz	w2, w2, #19, #1
    40010d80:	2a010042 	orr	w2, w2, w1
    40010d84:	39406001 	ldrb	w1, [x0, #24]
	event->poller = NULL;
    40010d88:	f900081f 	str	xzr, [x0, #16]
	event->type = type;
    40010d8c:	2a010042 	orr	w2, w2, w1
    40010d90:	b9001802 	str	w2, [x0, #24]
	event->obj = obj;
    40010d94:	f9001003 	str	x3, [x0, #32]
}
    40010d98:	d65f03c0 	ret

0000000040010d9c <z_impl_k_poll>:
{
    40010d9c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	poller->is_polling = true;
    40010da0:	52802023 	mov	w3, #0x101                 	// #257
{
    40010da4:	910003fd 	mov	x29, sp
    40010da8:	a90153f3 	stp	x19, x20, [sp, #16]
    40010dac:	aa0203f3 	mov	x19, x2
	events_registered = register_events(events, num_events, poller,
    40010db0:	f100027f 	cmp	x19, #0x0
{
    40010db4:	a9025bf5 	stp	x21, x22, [sp, #32]
	struct z_poller *poller = &_current->poller;
    40010db8:	b0000082 	adrp	x2, 40021000 <k_sys_work_q+0x240>
    40010dbc:	f9438856 	ldr	x22, [x2, #1808]
{
    40010dc0:	aa0003f4 	mov	x20, x0
	poller->is_polling = true;
    40010dc4:	aa1603e2 	mov	x2, x22
    40010dc8:	780c8c43 	strh	w3, [x2, #200]!
	events_registered = register_events(events, num_events, poller,
    40010dcc:	1a9f17e3 	cset	w3, eq  // eq = none
    40010dd0:	97ffff24 	bl	40010a60 <register_events>
    40010dd4:	2a0003f5 	mov	w21, w0
MAKE_REG_HELPER(daif)
    40010dd8:	d53b422a 	mrs	x10, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010ddc:	d50342df 	msr	daifset, #0x2
	if (!poller->is_polling) {
    40010de0:	394322c0 	ldrb	w0, [x22, #200]
    40010de4:	350001a0 	cbnz	w0, 40010e18 <z_impl_k_poll+0x7c>
		clear_event_registrations(events, events_registered, key);
    40010de8:	2a0a03e2 	mov	w2, w10
    40010dec:	2a1503e1 	mov	w1, w21
    40010df0:	aa1403e0 	mov	x0, x20
MAKE_REG_HELPER(daif)
    40010df4:	92407d4a 	and	x10, x10, #0xffffffff
    40010df8:	97ffffc1 	bl	40010cfc <clear_event_registrations>
    40010dfc:	d51b422a 	msr	daif, x10
		return 0;
    40010e00:	5280000a 	mov	w10, #0x0                   	// #0
}
    40010e04:	2a0a03e0 	mov	w0, w10
    40010e08:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010e0c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40010e10:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40010e14:	d65f03c0 	ret
	poller->is_polling = false;
    40010e18:	390322df 	strb	wzr, [x22, #200]
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    40010e1c:	b50000b3 	cbnz	x19, 40010e30 <z_impl_k_poll+0x94>
    40010e20:	92407d4a 	and	x10, x10, #0xffffffff
    40010e24:	d51b422a 	msr	daif, x10
		return -EAGAIN;
    40010e28:	1280014a 	mov	w10, #0xfffffff5            	// #-11
    40010e2c:	17fffff6 	b	40010e04 <z_impl_k_poll+0x68>
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
    40010e30:	2a0a03e1 	mov	w1, w10
    40010e34:	aa1303e3 	mov	x3, x19
    40010e38:	f00002e2 	adrp	x2, 4006f000 <sys_work_q_stack+0xf20>
    40010e3c:	9126a042 	add	x2, x2, #0x9a8
    40010e40:	b00002c0 	adrp	x0, 40069000 <z_page_frames+0x47725>
    40010e44:	91236c00 	add	x0, x0, #0x8db
    40010e48:	97fffaef 	bl	4000fa04 <z_pend_curr>
    40010e4c:	2a0003ea 	mov	w10, w0
    40010e50:	d53b422b 	mrs	x11, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010e54:	d50342df 	msr	daifset, #0x2
	clear_event_registrations(events, events_registered, key);
    40010e58:	2a0b03e2 	mov	w2, w11
    40010e5c:	2a1503e1 	mov	w1, w21
    40010e60:	aa1403e0 	mov	x0, x20
MAKE_REG_HELPER(daif)
    40010e64:	92407d6b 	and	x11, x11, #0xffffffff
    40010e68:	97ffffa5 	bl	40010cfc <clear_event_registrations>
    40010e6c:	d51b422b 	msr	daif, x11
	return swap_rc;
    40010e70:	17ffffe5 	b	40010e04 <z_impl_k_poll+0x68>

0000000040010e74 <z_handle_obj_poll_events>:
{
    40010e74:	aa0003e2 	mov	x2, x0
	return list->head == list;
    40010e78:	f9400000 	ldr	x0, [x0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
    40010e7c:	eb00005f 	cmp	x2, x0
    40010e80:	540000c0 	b.eq	40010e98 <z_handle_obj_poll_events+0x24>  // b.none
	sys_dnode_t *const prev = node->prev;
    40010e84:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
    40010e88:	f9000062 	str	x2, [x3]
	next->prev = prev;
    40010e8c:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
    40010e90:	a9007c1f 	stp	xzr, xzr, [x0]
		(void) signal_poll_event(poll_event, state);
    40010e94:	17ffff5b 	b	40010c00 <signal_poll_event>
}
    40010e98:	d65f03c0 	ret

0000000040010e9c <z_impl_k_poll_signal_init>:
	list->tail = (sys_dnode_t *)list;
    40010e9c:	a9000000 	stp	x0, x0, [x0]
	sig->signaled = 0U;
    40010ea0:	b900101f 	str	wzr, [x0, #16]
}
    40010ea4:	d65f03c0 	ret

0000000040010ea8 <z_impl_k_poll_signal_reset>:
	sig->signaled = 0U;
    40010ea8:	b900101f 	str	wzr, [x0, #16]
}
    40010eac:	d65f03c0 	ret

0000000040010eb0 <z_impl_k_poll_signal_check>:
	*signaled = sig->signaled;
    40010eb0:	b9401003 	ldr	w3, [x0, #16]
    40010eb4:	b9000023 	str	w3, [x1]
	*result = sig->result;
    40010eb8:	b9401400 	ldr	w0, [x0, #20]
    40010ebc:	b9000040 	str	w0, [x2]
}
    40010ec0:	d65f03c0 	ret

0000000040010ec4 <z_impl_k_poll_signal_raise>:
{
    40010ec4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40010ec8:	aa0003e2 	mov	x2, x0
    40010ecc:	910003fd 	mov	x29, sp
    40010ed0:	a90153f3 	stp	x19, x20, [sp, #16]
    40010ed4:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    40010ed8:	d50342df 	msr	daifset, #0x2
	sig->result = result;
    40010edc:	b9001401 	str	w1, [x0, #20]
	sig->signaled = 1U;
    40010ee0:	52800021 	mov	w1, #0x1                   	// #1
    40010ee4:	b9001001 	str	w1, [x0, #16]
	return list->head == list;
    40010ee8:	f9400000 	ldr	x0, [x0]
	if (!sys_dlist_is_empty(list)) {
    40010eec:	eb00005f 	cmp	x2, x0
    40010ef0:	54000101 	b.ne	40010f10 <z_impl_k_poll_signal_raise+0x4c>  // b.any
MAKE_REG_HELPER(daif)
    40010ef4:	92407e94 	and	x20, x20, #0xffffffff
    40010ef8:	d51b4234 	msr	daif, x20
		return 0;
    40010efc:	52800013 	mov	w19, #0x0                   	// #0
}
    40010f00:	2a1303e0 	mov	w0, w19
    40010f04:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010f08:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40010f0c:	d65f03c0 	ret
	sys_dnode_t *const prev = node->prev;
    40010f10:	a9400c02 	ldp	x2, x3, [x0]
	prev->next = next;
    40010f14:	f9000062 	str	x2, [x3]
	next->prev = prev;
    40010f18:	f9000443 	str	x3, [x2, #8]
	node->prev = NULL;
    40010f1c:	a9007c1f 	stp	xzr, xzr, [x0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
    40010f20:	97ffff38 	bl	40010c00 <signal_poll_event>
    40010f24:	2a0003f3 	mov	w19, w0
	z_reschedule(&lock, key);
    40010f28:	2a1403e1 	mov	w1, w20
    40010f2c:	b00002c0 	adrp	x0, 40069000 <z_page_frames+0x47725>
    40010f30:	91236c00 	add	x0, x0, #0x8db
    40010f34:	97fff958 	bl	4000f494 <z_reschedule>
	return rc;
    40010f38:	17fffff2 	b	40010f00 <z_impl_k_poll_signal_raise+0x3c>

0000000040010f3c <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    40010f3c:	90000022 	adrp	x2, 40014000 <CSWTCH.135+0x90>
    40010f40:	911be442 	add	x2, x2, #0x6f9
    40010f44:	d0000021 	adrp	x1, 40016000 <CSWTCH.205+0x4c5>
    40010f48:	9104ec21 	add	x1, x1, #0x13b
    40010f4c:	d0000020 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    40010f50:	91052000 	add	x0, x0, #0x148
    40010f54:	17ffc0d4 	b	400012a4 <printk>

0000000040010f58 <k_heap_init>:
    40010f58:	91006004 	add	x4, x0, #0x18
	list->tail = (sys_dnode_t *)list;
    40010f5c:	a9019004 	stp	x4, x4, [x0, #24]
#include <linker/linker-defs.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
    40010f60:	17ffc153 	b	400014ac <sys_heap_init>

0000000040010f64 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
    40010f64:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40010f68:	910003fd 	mov	x29, sp
    40010f6c:	a90153f3 	stp	x19, x20, [sp, #16]
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
    40010f70:	f00002f3 	adrp	x19, 4006f000 <sys_work_q_stack+0xf20>
    40010f74:	91296273 	add	x19, x19, #0xa58
    40010f78:	f00002f4 	adrp	x20, 4006f000 <sys_work_q_stack+0xf20>
    40010f7c:	91296294 	add	x20, x20, #0xa58
    40010f80:	eb14027f 	cmp	x19, x20
    40010f84:	540000a3 	b.cc	40010f98 <statics_init+0x34>  // b.lo, b.ul, b.last
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
    40010f88:	52800000 	mov	w0, #0x0                   	// #0
    40010f8c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40010f90:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40010f94:	d65f03c0 	ret
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    40010f98:	a9408a61 	ldp	x1, x2, [x19, #8]
    40010f9c:	aa1303e0 	mov	x0, x19
	STRUCT_SECTION_FOREACH(k_heap, h) {
    40010fa0:	9100a273 	add	x19, x19, #0x28
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    40010fa4:	97ffffed 	bl	40010f58 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
    40010fa8:	17fffff6 	b	40010f80 <statics_init+0x1c>

0000000040010fac <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
    40010fac:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
    40010fb0:	d0000020 	adrp	x0, 40016000 <CSWTCH.205+0x4c5>
    40010fb4:	9105bc00 	add	x0, x0, #0x16f
{
    40010fb8:	910003fd 	mov	x29, sp
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
    40010fbc:	910043e4 	add	x4, sp, #0x10
    40010fc0:	12800003 	mov	w3, #0xffffffff            	// #-1
    40010fc4:	d2820002 	mov	x2, #0x1000                	// #4096
    40010fc8:	d00002e1 	adrp	x1, 4006e000 <z_interrupt_stacks+0xf20>
    40010fcc:	91038021 	add	x1, x1, #0xe0
	struct k_work_queue_config cfg = {
    40010fd0:	f9000be0 	str	x0, [sp, #16]
	k_work_queue_start(&k_sys_work_q,
    40010fd4:	90000080 	adrp	x0, 40020000 <logging_thread>
    40010fd8:	91370000 	add	x0, x0, #0xdc0
	struct k_work_queue_config cfg = {
    40010fdc:	390063ff 	strb	wzr, [sp, #24]
	k_work_queue_start(&k_sys_work_q,
    40010fe0:	940000d4 	bl	40011330 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
    40010fe4:	52800000 	mov	w0, #0x0                   	// #0
    40010fe8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40010fec:	d65f03c0 	ret

0000000040010ff0 <flag_test_and_clear>:
}

static inline bool flag_test(const uint32_t *flagp,
			     uint32_t bit)
{
	return (*flagp & BIT(bit)) != 0U;
    40010ff0:	b9400002 	ldr	w2, [x0]
	*flagp &= ~BIT(bit);
    40010ff4:	d2800023 	mov	x3, #0x1                   	// #1
    40010ff8:	9ac12063 	lsl	x3, x3, x1
    40010ffc:	0a230043 	bic	w3, w2, w3
	return (*flagp & BIT(bit)) != 0U;
    40011000:	2a0203e2 	mov	w2, w2
	*flagp &= ~BIT(bit);
    40011004:	b9000003 	str	w3, [x0]
	return (*flagp & BIT(bit)) != 0U;
    40011008:	9ac12440 	lsr	x0, x2, x1
	bool ret = flag_test(flagp, bit);

	flag_clear(flagp, bit);

	return ret;
}
    4001100c:	12000000 	and	w0, w0, #0x1
    40011010:	d65f03c0 	ret

0000000040011014 <notify_queue_locked.isra.0>:
 */
static inline bool notify_queue_locked(struct k_work_q *queue)
{
	bool rv = false;

	if (queue != NULL) {
    40011014:	b40000a0 	cbz	x0, 40011028 <notify_queue_locked.isra.0+0x14>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
    40011018:	910e0000 	add	x0, x0, #0x380
    4001101c:	d2800002 	mov	x2, #0x0                   	// #0
    40011020:	52800001 	mov	w1, #0x0                   	// #0
    40011024:	17fffbdc 	b	4000ff94 <z_sched_wake>
	}

	return rv;
}
    40011028:	d65f03c0 	ret

000000004001102c <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
    4001102c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    40011030:	910003fd 	mov	x29, sp
    40011034:	a90153f3 	stp	x19, x20, [sp, #16]
    40011038:	aa0003f4 	mov	x20, x0
    4001103c:	a9025bf5 	stp	x21, x22, [sp, #32]
	return list->head;
    40011040:	90000095 	adrp	x21, 40021000 <k_sys_work_q+0x240>
    40011044:	911de2b5 	add	x21, x21, #0x778
			 * the lock, and we didn't find work nor got asked to
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
    40011048:	900002d6 	adrp	x22, 40069000 <z_page_frames+0x47725>
    4001104c:	91236ed6 	add	x22, x22, #0x8db
{
    40011050:	a90363f7 	stp	x23, x24, [sp, #48]
    40011054:	f90023f9 	str	x25, [sp, #64]
    40011058:	d53b4237 	mrs	x23, daif
	__asm__ volatile ("msr DAIFSet, %0"
    4001105c:	d50342df 	msr	daifset, #0x2
    40011060:	f941ba93 	ldr	x19, [x20, #880]
    40011064:	91100280 	add	x0, x20, #0x400
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    40011068:	b50001b3 	cbnz	x19, 4001109c <work_queue_main+0x70>
		} else if (flag_test_and_clear(&queue->flags,
    4001106c:	910e8280 	add	x0, x20, #0x3a0
    40011070:	52800041 	mov	w1, #0x2                   	// #2
    40011074:	97ffffdf 	bl	40010ff0 <flag_test_and_clear>
    40011078:	72001c1f 	tst	w0, #0xff
    4001107c:	54000421 	b.ne	40011100 <work_queue_main+0xd4>  // b.any
			(void)z_sched_wait(&lock, key, &queue->notifyq,
    40011080:	910e0282 	add	x2, x20, #0x380
    40011084:	2a1703e1 	mov	w1, w23
    40011088:	aa1603e0 	mov	x0, x22
    4001108c:	d2800004 	mov	x4, #0x0                   	// #0
    40011090:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
    40011094:	97fffbd8 	bl	4000fff4 <z_sched_wait>
					   K_FOREVER, NULL);
			continue;
    40011098:	17fffff0 	b	40011058 <work_queue_main+0x2c>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    4001109c:	f8578002 	ldur	x2, [x0, #-136]
	return node->next;
    400110a0:	f9400261 	ldr	x1, [x19]
	list->head = node;
    400110a4:	f8170001 	stur	x1, [x0, #-144]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    400110a8:	eb02027f 	cmp	x19, x2
    400110ac:	54000041 	b.ne	400110b4 <work_queue_main+0x88>  // b.any
	list->tail = node;
    400110b0:	f8178001 	stur	x1, [x0, #-136]
	*flagp |= BIT(bit);
    400110b4:	b943a280 	ldr	w0, [x20, #928]
MAKE_REG_HELPER(daif)
    400110b8:	92407ef7 	and	x23, x23, #0xffffffff
			handler = work->handler;
    400110bc:	f9400661 	ldr	x1, [x19, #8]
	*flagp |= BIT(bit);
    400110c0:	321f0000 	orr	w0, w0, #0x2
    400110c4:	b903a280 	str	w0, [x20, #928]
	*flagp &= ~BIT(bit);
    400110c8:	b9401a62 	ldr	w2, [x19, #24]
    400110cc:	121d7842 	and	w2, w2, #0xfffffffb
    400110d0:	32000042 	orr	w2, w2, #0x1
    400110d4:	b9001a62 	str	w2, [x19, #24]
    400110d8:	d51b4237 	msr	daif, x23

		if (work != NULL) {
			bool yield;

			__ASSERT_NO_MSG(handler != NULL);
			handler(work);
    400110dc:	aa1303e0 	mov	x0, x19
    400110e0:	d63f0020 	blr	x1
    400110e4:	d53b4239 	mrs	x25, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400110e8:	d50342df 	msr	daifset, #0x2
	*flagp &= ~BIT(bit);
    400110ec:	b9401a61 	ldr	w1, [x19, #24]
    400110f0:	121f7820 	and	w0, w1, #0xfffffffe
			 * starving other threads.
			 */
			key = k_spin_lock(&lock);

			flag_clear(&work->flags, K_WORK_RUNNING_BIT);
			if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    400110f4:	37080161 	tbnz	w1, #1, 40011120 <work_queue_main+0xf4>
	*flagp &= ~BIT(bit);
    400110f8:	b9001a60 	str	w0, [x19, #24]
    400110fc:	1400000d 	b	40011130 <work_queue_main+0x104>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
    40011100:	910e4293 	add	x19, x20, #0x390
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
    40011104:	aa1303e0 	mov	x0, x19
    40011108:	d2800002 	mov	x2, #0x0                   	// #0
    4001110c:	52800021 	mov	w1, #0x1                   	// #1
    40011110:	97fffba1 	bl	4000ff94 <z_sched_wake>
    40011114:	72001c1f 	tst	w0, #0xff
    40011118:	54ffff61 	b.ne	40011104 <work_queue_main+0xd8>  // b.any
    4001111c:	17ffffd9 	b	40011080 <work_queue_main+0x54>
	return list->head;
    40011120:	f94002a0 	ldr	x0, [x21]
	*flagp &= ~BIT(bit);
    40011124:	121e7421 	and	w1, w1, #0xfffffffc
    40011128:	b9001a61 	str	w1, [x19, #24]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    4001112c:	b5000120 	cbnz	x0, 40011150 <work_queue_main+0x124>
	*flagp &= ~BIT(bit);
    40011130:	b943a280 	ldr	w0, [x20, #928]
MAKE_REG_HELPER(daif)
    40011134:	92407f39 	and	x25, x25, #0xffffffff
    40011138:	121e7800 	and	w0, w0, #0xfffffffd
    4001113c:	b903a280 	str	w0, [x20, #928]
    40011140:	d51b4239 	msr	daif, x25
			k_spin_unlock(&lock, key);

			/* Optionally yield to prevent the work queue from
			 * starving other threads.
			 */
			if (yield) {
    40011144:	3747f8a0 	tbnz	w0, #8, 40011058 <work_queue_main+0x2c>
	z_impl_k_yield();
    40011148:	97fffad5 	bl	4000fc9c <z_impl_k_yield>
}
    4001114c:	17ffffc3 	b	40011058 <work_queue_main+0x2c>
	return node->next;
    40011150:	f9400018 	ldr	x24, [x0]
    40011154:	d2800017 	mov	x23, #0x0                   	// #0
		if (wc->work == work) {
    40011158:	f9400402 	ldr	x2, [x0, #8]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
    4001115c:	aa0003e1 	mov	x1, x0
		if (wc->work == work) {
    40011160:	eb02027f 	cmp	x19, x2
    40011164:	54000161 	b.ne	40011190 <work_queue_main+0x164>  // b.any
    40011168:	f9400001 	ldr	x1, [x0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
    4001116c:	b50001d7 	cbnz	x23, 400111a4 <work_queue_main+0x178>
    40011170:	f94006a2 	ldr	x2, [x21, #8]
	list->head = node;
    40011174:	f90002a1 	str	x1, [x21]
Z_GENLIST_REMOVE(slist, snode)
    40011178:	eb02001f 	cmp	x0, x2
    4001117c:	54000041 	b.ne	40011184 <work_queue_main+0x158>  // b.any
	list->tail = node;
    40011180:	f90006a1 	str	x1, [x21, #8]
	parent->next = child;
    40011184:	f801041f 	str	xzr, [x0], #16
	z_impl_k_sem_give(sem);
    40011188:	97fff7ff 	bl	4000f184 <z_impl_k_sem_give>
}
    4001118c:	aa1703e1 	mov	x1, x23
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    40011190:	b4fffd18 	cbz	x24, 40011130 <work_queue_main+0x104>
	return node->next;
    40011194:	aa1803e0 	mov	x0, x24
    40011198:	aa0103f7 	mov	x23, x1
    4001119c:	f9400318 	ldr	x24, [x24]
    400111a0:	17ffffee 	b	40011158 <work_queue_main+0x12c>
	return list->tail;
    400111a4:	f94006a2 	ldr	x2, [x21, #8]
	parent->next = child;
    400111a8:	f90002e1 	str	x1, [x23]
Z_GENLIST_REMOVE(slist, snode)
    400111ac:	eb00005f 	cmp	x2, x0
    400111b0:	54fffea1 	b.ne	40011184 <work_queue_main+0x158>  // b.any
	list->tail = node;
    400111b4:	f90006b7 	str	x23, [x21, #8]
}
    400111b8:	17fffff3 	b	40011184 <work_queue_main+0x158>

00000000400111bc <submit_to_queue_locked>:
{
    400111bc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400111c0:	910003fd 	mov	x29, sp
    400111c4:	a90153f3 	stp	x19, x20, [sp, #16]
    400111c8:	aa0003f3 	mov	x19, x0
	return (*flagp & BIT(bit)) != 0U;
    400111cc:	b9401800 	ldr	w0, [x0, #24]
{
    400111d0:	a9025bf5 	stp	x21, x22, [sp, #32]
    400111d4:	aa0103f4 	mov	x20, x1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    400111d8:	37080700 	tbnz	w0, #1, 400112b8 <submit_to_queue_locked+0xfc>
    400111dc:	2a0003e1 	mov	w1, w0
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
    400111e0:	721e003f 	tst	w1, #0x4
    400111e4:	54000701 	b.ne	400112c4 <submit_to_queue_locked+0x108>  // b.any
		if (*queuep == NULL) {
    400111e8:	f9400281 	ldr	x1, [x20]
    400111ec:	b5000061 	cbnz	x1, 400111f8 <submit_to_queue_locked+0x3c>
			*queuep = work->queue;
    400111f0:	f9400a61 	ldr	x1, [x19, #16]
    400111f4:	f9000281 	str	x1, [x20]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
    400111f8:	36000520 	tbz	w0, #0, 4001129c <submit_to_queue_locked+0xe0>
			*queuep = work->queue;
    400111fc:	f9400a60 	ldr	x0, [x19, #16]
			ret = 2;
    40011200:	52800055 	mov	w21, #0x2                   	// #2
			*queuep = work->queue;
    40011204:	f9000280 	str	x0, [x20]
		int rc = queue_submit_locked(*queuep, work);
    40011208:	f9400296 	ldr	x22, [x20]
	if (queue == NULL) {
    4001120c:	b4000616 	cbz	x22, 400112cc <submit_to_queue_locked+0x110>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    40011210:	90000080 	adrp	x0, 40021000 <k_sys_work_q+0x240>
    40011214:	f9438800 	ldr	x0, [x0, #1808]
    40011218:	eb16001f 	cmp	x0, x22
    4001121c:	54000441 	b.ne	400112a4 <submit_to_queue_locked+0xe8>  // b.any
    40011220:	97fff59f 	bl	4000e89c <k_is_in_isr>
    40011224:	12001c00 	and	w0, w0, #0xff
    40011228:	52000000 	eor	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
    4001122c:	b943a2c2 	ldr	w2, [x22, #928]
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    40011230:	12000000 	and	w0, w0, #0x1
	return (*flagp & BIT(bit)) != 0U;
    40011234:	d3420841 	ubfx	x1, x2, #2, #1
    40011238:	d3430c43 	ubfx	x3, x2, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
    4001123c:	360004c2 	tbz	w2, #0, 400112d4 <submit_to_queue_locked+0x118>
	} else if (draining && !chained) {
    40011240:	52000000 	eor	w0, w0, #0x1
    40011244:	6a00003f 	tst	w1, w0
    40011248:	54000381 	b.ne	400112b8 <submit_to_queue_locked+0xfc>  // b.any
	} else if (plugged && !draining) {
    4001124c:	52000021 	eor	w1, w1, #0x1
    40011250:	6a01007f 	tst	w3, w1
    40011254:	54000321 	b.ne	400112b8 <submit_to_queue_locked+0xfc>  // b.any
	return list->tail;
    40011258:	f941bec1 	ldr	x1, [x22, #888]
	parent->next = child;
    4001125c:	f900027f 	str	xzr, [x19]
	return list->tail;
    40011260:	911002c0 	add	x0, x22, #0x400
Z_GENLIST_APPEND(slist, snode)
    40011264:	b5000241 	cbnz	x1, 400112ac <submit_to_queue_locked+0xf0>
	list->tail = node;
    40011268:	a9374c13 	stp	x19, x19, [x0, #-144]
		(void)notify_queue_locked(queue);
    4001126c:	aa1603e0 	mov	x0, x22
    40011270:	97ffff69 	bl	40011014 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
    40011274:	b9401a60 	ldr	w0, [x19, #24]
    40011278:	321e0000 	orr	w0, w0, #0x4
    4001127c:	b9001a60 	str	w0, [x19, #24]
			work->queue = *queuep;
    40011280:	f9400280 	ldr	x0, [x20]
    40011284:	f9000a60 	str	x0, [x19, #16]
}
    40011288:	2a1503e0 	mov	w0, w21
    4001128c:	a94153f3 	ldp	x19, x20, [sp, #16]
    40011290:	a9425bf5 	ldp	x21, x22, [sp, #32]
    40011294:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40011298:	d65f03c0 	ret
		ret = 1;
    4001129c:	52800035 	mov	w21, #0x1                   	// #1
    400112a0:	17ffffda 	b	40011208 <submit_to_queue_locked+0x4c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    400112a4:	52800000 	mov	w0, #0x0                   	// #0
    400112a8:	17ffffe1 	b	4001122c <submit_to_queue_locked+0x70>
	parent->next = child;
    400112ac:	f9000033 	str	x19, [x1]
	list->tail = node;
    400112b0:	f8178013 	stur	x19, [x0, #-136]
}
    400112b4:	17ffffee 	b	4001126c <submit_to_queue_locked+0xb0>
		ret = -EBUSY;
    400112b8:	128001f5 	mov	w21, #0xfffffff0            	// #-16
		*queuep = NULL;
    400112bc:	f900029f 	str	xzr, [x20]
	return ret;
    400112c0:	17fffff2 	b	40011288 <submit_to_queue_locked+0xcc>
	int ret = 0;
    400112c4:	52800015 	mov	w21, #0x0                   	// #0
    400112c8:	17fffffd 	b	400112bc <submit_to_queue_locked+0x100>
		return -EINVAL;
    400112cc:	128002b5 	mov	w21, #0xffffffea            	// #-22
    400112d0:	17fffffb 	b	400112bc <submit_to_queue_locked+0x100>
		ret = -ENODEV;
    400112d4:	12800255 	mov	w21, #0xffffffed            	// #-19
    400112d8:	17fffff9 	b	400112bc <submit_to_queue_locked+0x100>

00000000400112dc <k_work_submit_to_queue>:
{
    400112dc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400112e0:	910003fd 	mov	x29, sp
    400112e4:	a90153f3 	stp	x19, x20, [sp, #16]
    400112e8:	f90017e0 	str	x0, [sp, #40]
    400112ec:	aa0103e0 	mov	x0, x1
    400112f0:	d53b4234 	mrs	x20, daif
	__asm__ volatile ("msr DAIFSet, %0"
    400112f4:	d50342df 	msr	daifset, #0x2
	int ret = submit_to_queue_locked(work, &queue);
    400112f8:	9100a3e1 	add	x1, sp, #0x28
MAKE_REG_HELPER(daif)
    400112fc:	92407e94 	and	x20, x20, #0xffffffff
    40011300:	97ffffaf 	bl	400111bc <submit_to_queue_locked>
    40011304:	2a0003f3 	mov	w19, w0
    40011308:	d51b4234 	msr	daif, x20
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
    4001130c:	7100001f 	cmp	w0, #0x0
    40011310:	5400008d 	b.le	40011320 <k_work_submit_to_queue+0x44>
	return z_impl_k_is_preempt_thread();
    40011314:	97fffad6 	bl	4000fe6c <z_impl_k_is_preempt_thread>
    40011318:	34000040 	cbz	w0, 40011320 <k_work_submit_to_queue+0x44>
	z_impl_k_yield();
    4001131c:	97fffa60 	bl	4000fc9c <z_impl_k_yield>
}
    40011320:	2a1303e0 	mov	w0, w19
    40011324:	a94153f3 	ldp	x19, x20, [sp, #16]
    40011328:	a8c37bfd 	ldp	x29, x30, [sp], #48
    4001132c:	d65f03c0 	ret

0000000040011330 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
    40011330:	d100c3ff 	sub	sp, sp, #0x30
    40011334:	2a0303e7 	mov	w7, w3
    40011338:	910e0003 	add	x3, x0, #0x380
    4001133c:	a9017bfd 	stp	x29, x30, [sp, #16]
    40011340:	910043fd 	add	x29, sp, #0x10
    40011344:	a90253f3 	stp	x19, x20, [sp, #32]
    40011348:	aa0003f3 	mov	x19, x0
    4001134c:	910dc000 	add	x0, x0, #0x370
    40011350:	aa0403f4 	mov	x20, x4
    40011354:	a9007c1f 	stp	xzr, xzr, [x0]
    40011358:	a9010c03 	stp	x3, x3, [x0, #16]
    4001135c:	910e4263 	add	x3, x19, #0x390
	list->head = (sys_dnode_t *)list;
    40011360:	f901ca63 	str	x3, [x19, #912]
	list->tail = (sys_dnode_t *)list;
    40011364:	f901ce63 	str	x3, [x19, #920]

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
    40011368:	b4000344 	cbz	x4, 400113d0 <k_work_queue_start+0xa0>
    4001136c:	39402080 	ldrb	w0, [x4, #8]
		flags |= K_WORK_QUEUE_NO_YIELD;
    40011370:	7100001f 	cmp	w0, #0x0
    40011374:	52802020 	mov	w0, #0x101                 	// #257
    40011378:	1a9f1400 	csinc	w0, w0, wzr, ne  // ne = any
	*flagp = flags;
    4001137c:	b903a260 	str	w0, [x19, #928]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    40011380:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
    40011384:	b90003ff 	str	wzr, [sp]
    40011388:	f90007e0 	str	x0, [sp, #8]
    4001138c:	90000003 	adrp	x3, 40011000 <flag_test_and_clear+0x10>
    40011390:	9100b063 	add	x3, x3, #0x2c
    40011394:	aa1303e4 	mov	x4, x19
    40011398:	aa1303e0 	mov	x0, x19
    4001139c:	d2800006 	mov	x6, #0x0                   	// #0
    400113a0:	d2800005 	mov	x5, #0x0                   	// #0
    400113a4:	97fff5dd 	bl	4000eb18 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
    400113a8:	b40000b4 	cbz	x20, 400113bc <k_work_queue_start+0x8c>
    400113ac:	f9400281 	ldr	x1, [x20]
    400113b0:	b4000061 	cbz	x1, 400113bc <k_work_queue_start+0x8c>
	return z_impl_k_thread_name_set(thread, str);
    400113b4:	aa1303e0 	mov	x0, x19
    400113b8:	97fff553 	bl	4000e904 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
    400113bc:	aa1303e0 	mov	x0, x19
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
    400113c0:	a9417bfd 	ldp	x29, x30, [sp, #16]
    400113c4:	a94253f3 	ldp	x19, x20, [sp, #32]
    400113c8:	9100c3ff 	add	sp, sp, #0x30
    400113cc:	17fff58a 	b	4000e9f4 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
    400113d0:	52800020 	mov	w0, #0x1                   	// #1
    400113d4:	17ffffea 	b	4001137c <k_work_queue_start+0x4c>
	...
